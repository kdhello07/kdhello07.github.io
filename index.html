<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>侬的杂货铺</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="侬的杂货铺">
<meta property="og:url" content="https://kdhello07.github.io/index.html">
<meta property="og:site_name" content="侬的杂货铺">
<meta property="og:locale">
<meta property="article:author" content="Kevin he">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="侬的杂货铺" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">侬的杂货铺</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术、阅读、分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kdhello07.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/27/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-01-26T16:00:00.000Z" itemprop="datePublished">2024-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/">技术工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/27/hello-world/">Hexo使用技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy -g</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2024/01/27/hello-world/" data-id="clruzyip40008rlkugzlg3o78" data-title="Hexo使用技巧" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Mac使用技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/27/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2024-01-26T16:00:00.000Z" itemprop="datePublished">2024-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mac/">Mac</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/27/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Mac使用技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除mac启动台中的无用图标</span></span><br><span class="line">defaults write com.apple.dock ResetLaunchPad -bool <span class="literal">true</span> </span><br><span class="line">killall Dock</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2024/01/27/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" data-id="clrv2tqxa00014hku13vbdbca" data-title="Mac使用技巧" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java语言学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/27/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-12-26T16:00:00.000Z" itemprop="datePublished">2022-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/27/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Java语言学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java语言学习"><a href="#Java语言学习" class="headerlink" title="Java语言学习"></a>Java语言学习</h1><h2 id="1-IDEA快捷键使用"><a href="#1-IDEA快捷键使用" class="headerlink" title="1.IDEA快捷键使用"></a>1.IDEA快捷键使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.删除当前行 CTRL+D</span><br><span class="line">2.复制当前行 ALT+X</span><br><span class="line">3.补全代码 ALT+/</span><br><span class="line">4.格式化代码 SHIFT+CTRL+F</span><br><span class="line">5.生成构造器 ALT+InSERT </span><br><span class="line">6.查看一个类的层级关系 ctrl+SHIFT+ALT+U</span><br><span class="line">7.自动生成变量名，在后面加.var  如new Scanner(System.in).var</span><br></pre></td></tr></table></figure>

<h3 id="2-线程的创建"><a href="#2-线程的创建" class="headerlink" title="2.线程的创建"></a>2.线程的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#创建线程的两种方式</span><br><span class="line">    线程都获取到cpu的执行权，cpu执行到谁，就运行谁，在每一个时刻都只有一个程序在运行（多核除外）</span><br><span class="line">	<span class="number">1.</span>一个是将一个类声明为Thread的子类。 这个子类应该重写run类的方法Thread 。 然后可以分配并启动子类的实例。 例如，计算大于规定值的素数的线程可以写成如下：</span><br><span class="line">    <span class="number">2.</span>另一种方法来创建一个线程是声明实现类Runnable接口。 那个类然后实现了run方法。 然后可以分配类的实例，在创建Thread时作为参数传递，并启动。 这种其他风格的同一个例子如下所示：</span><br><span class="line">    </span><br><span class="line"><span class="comment">//***继承Thread类和实现Runnable接口的多线程两种方式的区别：</span></span><br><span class="line">  	实现方式的好处，避免了单继承的局限性，因为java语言只支持单继承</span><br><span class="line">    在定义线程时，建议使用实现方式</span><br><span class="line">  两种方式区别：</span><br><span class="line">    	继承Thread线程代码存放在Thread子类run()方法中</span><br><span class="line">    	实现Runnable，线程代码存放在接口的子类的run()方法中</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="number">1.</span>继承方法</span><br><span class="line">   	<span class="comment">//为什么要覆盖run方法呢？</span></span><br><span class="line">    Thread类用于描述线程，该类就定义了一个功能，用于存储线程要运行的代码，该存储功能就是run()方法。</span><br><span class="line">    </span><br><span class="line">	代码：</span><br><span class="line">	<span class="comment">//1.定义类：继承Thread类</span></span><br><span class="line">	<span class="comment">//2.类中重写run方法:</span></span><br><span class="line">    	目的：将自定义代码存储在run()方法中，让线程执行</span><br><span class="line">	<span class="comment">//3.在主线程中创建类对象，并启动start()方法,启动线程，在start方法里面主动调用run方法</span></span><br><span class="line">    	注意：如果不调用start()方法，而是调用run方法的话，这与一般的对象调用方法是一样的，不会有多线程，因此要开启多线程需要调用start方法</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">PrimeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">         <span class="type">long</span> minPrime;</span><br><span class="line">         PrimeThread(<span class="type">long</span> minPrime) &#123;</span><br><span class="line">             <span class="built_in">this</span>.minPrime = minPrime;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">              . . .</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span>&#123;</span><br><span class="line">     	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">     		<span class="comment">//</span></span><br><span class="line">     		<span class="type">PrimeThread</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimeThread</span>(<span class="number">143</span>); <span class="comment">//创建好一个线程</span></span><br><span class="line">     		p.start();<span class="comment">//启动线程，并在里面调用run方法，</span></span><br><span class="line">            <span class="comment">//p.start();  //注意一次只能调用一个start()方法</span></span><br><span class="line">            <span class="comment">//p.run();  //只是对象的调用方法，而与多线程没有关系</span></span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">	<span class="number">2.</span>实现方法</span><br><span class="line">    代码：</span><br><span class="line">        <span class="number">1.</span>定义类实现Runnable接口</span><br><span class="line">        <span class="number">2.</span>覆盖Runnable接口中的run()方法</span><br><span class="line">        	目的：将线程要运行的代码放在该run（）方法中</span><br><span class="line">        <span class="number">3.</span>通过Thread类建立线程对象</span><br><span class="line">        <span class="number">4.</span>将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数</span><br><span class="line">        	为什么要将Runnable接口对象的子类对象传递给Thread的构造函数</span><br><span class="line">        	因为：自定义的run()方法所属的对象是Runnable接口的子类对象</span><br><span class="line">        	所以要让线程去执行指定对象的run()方法，就必须明确该run()方法所属的对象</span><br><span class="line">        <span class="number">5.</span>调用Thread类的start()方法开启线程并调用Runnable接口子类的run()方法</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Demo3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;sale&quot;</span>+ticket--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Demo3 d3=<span class="keyword">new</span> <span class="title class_">Demo3</span>();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(d3);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(d3);</span><br><span class="line">        Thread t3=<span class="keyword">new</span> <span class="title class_">Thread</span>(d3);</span><br><span class="line">        Thread t4=<span class="keyword">new</span> <span class="title class_">Thread</span>(d3);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/12/27/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" data-id="clrv16wj60002z5ku5cijbtm3" data-title="Java语言学习" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java虚拟机学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-10-26T16:00:00.000Z" itemprop="datePublished">2022-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/">Java虚拟机学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java虚拟机学习"><a href="#Java虚拟机学习" class="headerlink" title="Java虚拟机学习"></a>Java虚拟机学习</h1><h2 id="1-JVM与Java体系结构"><a href="#1-JVM与Java体系结构" class="headerlink" title="1.JVM与Java体系结构"></a>1.JVM与Java体系结构</h2><p>1.虚拟机的执行：执行一个所谓的Java程序的时候，真正再执行的是一个叫做Java虚拟机的进程</p>
<p>2.HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li>通过计数器找到最具编译价值代码，除法即时编译或栈上替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。</li>
</ul>
<p>3.JRocket</p>
<p>4.IBM J9。 后面这三种虚拟机现在用的比较多。在jdk中用的还是hotspot这个。</p>
<h2 id="2-类加载子系统"><a href="#2-类加载子系统" class="headerlink" title="2.类加载子系统"></a>2.类加载子系统</h2><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_JVM架构-中.jpg" alt="第02章_JVM架构-中"  />

<h3 id="1-类加载器子系统概述"><a href="#1-类加载器子系统概述" class="headerlink" title="1. 类加载器子系统概述"></a>1. 类加载器子系统概述</h3><p>1.类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。</p>
<p>2.classloader只负责class文件的加载，至于它是否可以运行，则由Excution Engine决定。</p>
<p>3.加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>
<h3 id="2-类的加载过程"><a href="#2-类的加载过程" class="headerlink" title="2.类的加载过程"></a>2.类的加载过程</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_类的加载过程.jpg" alt="第02章_类的加载过程" style="zoom: 25%;" />

<p>总过程：加载 –》链接【验证  –》准备  –》 解析 】 –》 初始化 </p>
<blockquote>
<p>加载：</p>
<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>&#x3D;&#x3D;在内存中生成一个代表这个类的 java.lang.Class 对象&#x3D;&#x3D;，作为方法区这个类的各种数据的访问入口</li>
</ol>
</blockquote>
<blockquote>
<p>链接：</p>
<ol>
<li>验证（verify）<ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会损害虚拟机自身安全。</li>
</ul>
</li>
<li>准备(prepare)<ul>
<li>为类变量（static 变量）分配内存并且设置该类变量的默认初始值，即零值</li>
<li>&#x3D;&#x3D;这里不包含用final修饰的static，因为final在编译的时候就分配了，准备阶段会显式初始化&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;这里不会为实例变量分配初始化&#x3D;&#x3D;，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li>
</ul>
</li>
<li>解析(Resolve)<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。直接引用就是直接只想目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等，对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>初始化：</p>
<ol>
<li>初始化阶段就是执行类构造器方法<clinit>( )的过程</li>
<li>此方法不需要定义，是javac编译器自动收集类中的&#x3D;&#x3D;所有类变量的赋值操作和静态代码块中的语句合并而来&#x3D;&#x3D;。（如果类中没有类变量和静态代码块，编译后就不会有<clinit>( )方法）</li>
<li>构造器方法中指令按语句在源文件中出现的顺序hi行</li>
<li><clinit>( )不同于类的构造器。（关联：构造器是虚拟机视角下的<init>( )）</li>
<li>若该类具有父类，JVM会保证子类的<clinit>（ ）执行前，父类的<clinit>( )已经执行完毕</li>
<li>虚拟机必须保证一个类的<clinit>( )方法在多线程下被同步加锁</li>
</ol>
</blockquote>
<h3 id="3-类加载器的分类"><a href="#3-类加载器的分类" class="headerlink" title="3.类加载器的分类"></a>3.类加载器的分类</h3><p>1.JVM支持两种类型的类加载器，分别为引导类加载器（bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</p>
<p>2.所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</p>
<p>3.常见的有3个类加载器</p>
<p>4.虚拟机自带的加载器</p>
<ul>
<li>启动类加载器（引导类加载器）<ul>
<li>这个类加载使用c&#x2F;c++语言实现的，嵌套在类内部</li>
<li>用来加载Java的核心库，用于提供jvm自身需要的类</li>
<li>并不继承自Java.lang.ClassLoader,没有父加载器</li>
<li>&#x3D;&#x3D;加载扩展类和应用程序类加载器，并指定为他们的父类加载器&#x3D;&#x3D;</li>
<li>处于安全考虑，Bootstrap 启动类加载器只加载包名为&#x3D;&#x3D;java、javax、sun等开头的类&#x3D;&#x3D;</li>
</ul>
</li>
<li>扩展类加载器（Extension ClassLoader）<ul>
<li>java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从jdk的安装目录的jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
</li>
<li>应用程序类加载器（系统类加载器，AppClassLoader）<ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>&#x3D;&#x3D;该类加载是程序中默认的类加载器&#x3D;&#x3D;，一般说来，Java应用的类都是由它来加载完成</li>
<li>通过ClassLoader . getSystemClassLoader（）方法可以获取到该类加载器</li>
</ul>
</li>
</ul>
<p>5.用户自定义类加载器</p>
<ul>
<li>在Java的日常应用程序开发种，类的加载几乎都是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>为什么要自定义类加载器<ol>
<li>隔离加载类</li>
<li>修该类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ol>
</li>
</ul>
<h3 id="4-关于ClassLoader"><a href="#4-关于ClassLoader" class="headerlink" title="4.关于ClassLoader"></a>4.关于ClassLoader</h3><ul>
<li><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
</li>
<li><p>类中的方法有：</p>
<ul>
<li>getParent(): 返回该类加载器的超类加载器</li>
<li>loadClass(String name) : 加载名称为name的类，返回结果为java.lang.Class类的实例</li>
<li>findClass(String name):</li>
<li>findLoadedClass(String name)</li>
<li>defineClass(String name,byte[] b,int off,int len) : 把字节数组b中的内容转化为一个Java类，返回结果为java.lang.Class类的实例</li>
<li>resolveClass(Class&lt;?&gt; c): 连接指定的一个Java类</li>
</ul>
</li>
<li><p>获取ClassLoader的路径：</p>
<ul>
<li><p>获取当前类的ClassLoader</p>
<ul>
<li><p>clazz.getClassLoader() </p>
</li>
<li><pre><code class="java">ClassLoader stringLoader = String.class.getClassLoader();
//对于用户自定义类来说: 默认使用系统类加载器来进行加载
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取当前线程上下文的ClassLoader</span><br><span class="line"></span><br><span class="line">  - Thread.currentThread().getContextClassLoader()</span><br><span class="line"></span><br><span class="line">- 获取系统的ClassLoader</span><br><span class="line"></span><br><span class="line">  - ClassLoader.getClassLoader()</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    //获取系统类加载器   sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>获取调用者的ClassLoader</p>
<ul>
<li>DriverManager.getCallerClassLoader()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-双亲委派机制"><a href="#5-双亲委派机制" class="headerlink" title="5.双亲委派机制"></a>5.双亲委派机制</h3><blockquote>
<p>Java虚拟机对class文件采用的是&#x3D;&#x3D;按需加载的方式&#x3D;&#x3D;，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是&#x3D;&#x3D;双亲委派模式&#x3D;&#x3D;，即把请求交由父类加载器处理，它是一种任务委派模式。</p>
<p>工作原理：</p>
<ul>
<li><p>如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</p>
</li>
<li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</p>
</li>
<li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，自家在其才会尝试自己去加载，这就是双亲委派机制。</p>
<p>引导类（BootStrap ClassLoader）</p>
<p>​	^</p>
<p>扩展类（Extension ClassLoader）</p>
<p>​	^</p>
<p>系统类（Application ClassLoader）</p>
<p>​	^</p>
<p>自定义类加载器</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改。 因为核心API是由上层类加载器进行加载的。如java.lang.String是由启动类加载器进行加载的。</li>
</ul>
<p>沙箱安全机制：</p>
<ul>
<li>就是为了保护Java核心代码的机制。如防止自己定义使用java.lang.String这种形式的包名和类名</li>
</ul>
</blockquote>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h3><blockquote>
<p>在JVM中表示两个Class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同</li>
</ul>
</blockquote>
<blockquote>
<p>对类加载器的引用：</p>
<ul>
<li>JVM需知道一个类型是由启动类加载加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>类的主动使用和被动使用</strong></p>
<ul>
<li>主动使用（七种情况）：<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如Class.forName(“com.example.Test”)）</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>jdk7开始提供的动态语言支持：<ul>
<li>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化。</li>
</ul>
</li>
</ul>
</li>
<li>除了以上七种情况，其他使用Java类的方式都被看做是对&#x3D;&#x3D;类的被动使用，都不会导致对类的初始化。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h2 id="3-运行时数据区概述及线程"><a href="#3-运行时数据区概述及线程" class="headerlink" title="3.运行时数据区概述及线程"></a>3.运行时数据区概述及线程</h2><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_JVM架构-简图.jpg" alt="第02章_JVM架构-简图" style="zoom:50%;" />

<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><blockquote>
<p>JVM内存布局规定了Java在运行过程 中内存申请、分配、管理的策略，保证了jvm的高效稳定运行，&#x3D;&#x3D;不同的JVM对于内存的划分方式和管理机制存在了部分差异&#x3D;&#x3D;。</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220428110326650.png" alt="image-20220428110326650"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面红色部分：</span></span><br><span class="line">	方法区（metadata元空间，代码缓存（JIT即时编译的产物），堆外内存），堆这两个区域是多个线程共享的，随着虚拟机这个进程的创建而创建，销毁而销毁。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面灰色部分：</span></span><br><span class="line">	程序计数器，本地方法栈，虚拟机栈是单独线程私有的，与单个线程的生命周期是一样的。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>class Runtime</strong>:</p>
<ul>
<li><p>每个JVM只有一个Runtime实例，即为运行时环境，相当于内存结构中间的那个框架：运行时环境</p>
</li>
<li><p>static  Runtime getRuntime()  返回与当前Java应用程序关联的运行时对象。</p>
</li>
</ul>
</blockquote>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h3><blockquote>
<ul>
<li><p>线程是一个程序里的运行单元。JVM允许一个应用程序同时执行多个执行线程。</p>
</li>
<li><p>在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行中止以后，本地线程也会回收。</li>
</ul>
</li>
<li><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上，一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>JVM系统线程：</p>
<ul>
<li>这些后台线程不包括调用 public static void main(String[] agrs)的main线程以及所有这个main线程自己创建的线程。</li>
<li>这些主要的后台系统线程在HotSpot JVM里主要是这几个：<ul>
<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现 。这种线程的执行类型包括“stop-the-wrold”的垃圾收集，线程栈手机，线程挂起以及偏向锁撤销。</li>
<li>周期任务线程：这种线程是时间周期时间的体现（比如中断），他们一般用于周期性操作的调度执行</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li>
<li>编译线程：这种线程在运行时会将字节码编译成本地代码</li>
<li>信号调度线程：这种线程接收信号并发送给JVM,往它内部通过调用适当的方法进行处理</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="4-程序计数器（PC寄存器）"><a href="#4-程序计数器（PC寄存器）" class="headerlink" title="4.程序计数器（PC寄存器）"></a>4.程序计数器（PC寄存器）</h2><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220428114945803.png" alt="image-20220428114945803"></p>
<h3 id="1-PC-Register介绍"><a href="#1-PC-Register介绍" class="headerlink" title="1.PC Register介绍"></a>1.PC Register介绍</h3><blockquote>
<p>JVM中的程序计数寄存器，并非是广义上的物理寄存器，或许将其翻译为pc计数器（或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。&#x3D;&#x3D;JVM中的pc寄存器是对物理PC寄存器的一种抽象模拟&#x3D;&#x3D;</p>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_执行引擎的工作过程.jpg" alt="第12章_执行引擎的工作过程" style="zoom:33%;" />

<blockquote>
<p><strong>作用：</strong></p>
<ul>
<li>pc寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令</li>
</ul>
</blockquote>
<blockquote>
<p><strong>介绍：</strong></p>
<ul>
<li>很小的一块内存空间，也是运行速度最快的存储区域</li>
<li>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的&#x3D;&#x3D;当前方法&#x3D;&#x3D;，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，或者，如果是在执行native方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryEroor情况的区域。<ul>
<li>&#x3D;&#x3D;堆 和方法区有垃圾回收，PC寄存器也没有垃圾回收，栈区域有垃圾回收，&#x3D;&#x3D;</li>
<li>pc寄存器没有OutOfMemoryEroor（内存溢出），stack区域有，以及方法区和堆都有OutOfMemoryEroor。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-举例说明"><a href="#2-举例说明" class="headerlink" title="2.举例说明"></a>2.举例说明</h3><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220428130658431.png" alt="image-20220428130658431"></p>
<h3 id="3-两个常见问题"><a href="#3-两个常见问题" class="headerlink" title="3.两个常见问题"></a>3.两个常见问题</h3><blockquote>
<p><strong>Q1：使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢?</strong></p>
<p>A1：因为CPU需要不断的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</blockquote>
<blockquote>
<p><strong>Q2：PC寄存器为什么会被设定为线程私有？</strong></p>
<p>A2：都知道所谓的多线程在一个特定的时间段内只会执行其中一个线程的方法，&#x3D;&#x3D;CPU会不停地做任务切换，这样必然导致经常中断和恢复&#x3D;&#x3D;，如何保证分毫不差呢？为了能够准确的记录各个线程正在执行的当前字节码指令地址，&#x3D;&#x3D;最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。&#x3D;&#x3D; （每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响）</p>
</blockquote>
<blockquote>
<ul>
<li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li>
<li>在宏观上，我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li>
<li>但在微观上 ，由于只有一个CPU,一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</li>
</ul>
</blockquote>
<h2 id="5-虚拟机栈"><a href="#5-虚拟机栈" class="headerlink" title="&#x3D;&#x3D;5.虚拟机栈&#x3D;&#x3D;"></a>&#x3D;&#x3D;5.虚拟机栈&#x3D;&#x3D;</h2><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220429090223158.png" alt="image-20220429090223158"></p>
<h3 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1.虚拟机栈概述"></a>1.虚拟机栈概述</h3><blockquote>
<ul>
<li><p>由于跨平台性的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器的。</p>
</li>
<li><p>优点：</p>
<ul>
<li>跨平台，指令集小，编译器容易实现。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>性能下降，实现同样的功能需要更多的指令。</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;栈是运行时的单位，而堆是存储的单位。&#x3D;&#x3D;</p>
<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储问题，即数据怎么放，放在哪儿</li>
</ul>
</li>
<li><p>Java虚拟机栈，早期也叫Java栈，每个线程在创建时都会创建一个虚拟机栈，&#x3D;&#x3D;其内部保存一个个的栈帧，对应着一次次的Java方法调用&#x3D;&#x3D;。</p>
</li>
<li><p>Java虚拟机栈是线程私有的。</p>
</li>
<li><p>生命周期和线程一致</p>
</li>
<li><p><strong>作用：</strong></p>
<ul>
<li>主管Java程序的运行，它保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。</li>
<li>局部变量 VS 成员变量（属性）</li>
<li>基本数据变量 VS 引用类型变量（类、数组、接口）</li>
</ul>
</li>
<li><p><strong>栈的特点：</strong></p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li>
<li>JVM直接对Java栈的操作只有两个：<ul>
<li>每个方法执行，伴随着进栈（入栈，压栈）</li>
<li>执行结果后的出栈工作</li>
</ul>
</li>
<li>对于栈来说，不存在垃圾回收问题，但是有OOM (内存溢出)</li>
</ul>
</li>
<li><p>开发中遇到的异常有哪些？</p>
<ul>
<li>StackOverFlowError  (Java栈设置的大小固定，陷入死循环)</li>
<li>OutOfMemoryError （内存溢出，超出内存大小）</li>
</ul>
</li>
<li><p>可以设置栈内存大小，使用 -Xss1024k  或者-Xss256k来设置大小</p>
</li>
</ul>
</blockquote>
<h3 id="2-栈的存储单位"><a href="#2-栈的存储单位" class="headerlink" title="2.栈的存储单位"></a>2.栈的存储单位</h3><blockquote>
<ul>
<li>栈中的数据都是以栈帧的格式存在</li>
<li>&#x3D;&#x3D;在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）&#x3D;&#x3D;</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>栈运行原理：</strong></p>
<ul>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>&#x3D;&#x3D;Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令，另外一种是抛出异常，不管使用那种方式，都会导致栈帧被弹出。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第05章_栈桢内部结构.jpg" alt="第05章_栈桢内部结构" style="zoom: 33%;" />

<blockquote>
<p><strong>栈帧的内部结构：</strong></p>
<ul>
<li>&#x3D;&#x3D;局部变量表（Local variable）&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;操作数栈（Operand Stack）(或表达式栈)&#x3D;&#x3D;</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
</blockquote>
<h3 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3.局部变量表"></a>3.局部变量表</h3><blockquote>
<ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li>&#x3D;&#x3D;定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量&#x3D;&#x3D;，这些数据类型包括各类基本数据类型，对象引用（reference），以及returnAddress类型。</li>
<li>因为局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li>
<li>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li>&#x3D;&#x3D;方法嵌套调用的次数由栈的大小决定。&#x3D;&#x3D;一般说来，栈越大，方法嵌套调用次数越多，对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，进而函数调用就会占用更多的占空间，导致其嵌套调用次数就会减少。</li>
<li>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量完成参数值到参数列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></li>
</ul>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220429113920978.png" alt="image-20220429113920978"></p>
<blockquote>
<p><strong>关于Slot的理解：</strong></p>
<ul>
<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</li>
<li>局部变量表最基本的存储单元是Slot(变量槽)</li>
<li>在局部变量表里，32位以内的类型只占用一个Slot(包括returnAddress类型)，64位的类型（long 和double）占用两个Slot<ul>
<li>byte,short,char在存储前被转换位int，boolean也被转换位int,0表示false,1表示true</li>
<li>long和double则表示两个slot</li>
</ul>
</li>
<li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按&#x3D;&#x3D;照顺序被复制局部变量表中的每一个slot上&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可&#x3D;&#x3D;</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列</li>
</ul>
</blockquote>
<blockquote>
<p>slot的重复利用：</p>
<ul>
<li>栈帧之中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量的就很有可能会服用过期局部变量的槽位，从而达到节省资源的目的。</li>
</ul>
</blockquote>
<blockquote>
<p>静态变量与局部变量的对比：</p>
</blockquote>
<p>变量的分类： </p>
<ul>
<li>按照数据类型分为：<ol>
<li>基本数据类型 </li>
<li>引用数据类型</li>
</ol>
</li>
<li>按照在类中声明的位置分为: <ol>
<li>成员变量。在使用前都经历过默认初始化赋值</li>
<li>类变量：linking的prepare阶段：给类变量赋默认值 —》initial阶段：给类变量显式赋值（包括静态代码块）【所有类对象共享同一个区域】</li>
<li>实例变量（非static域）：随着对象的创建的，会在堆空间中分配实例变量空间，并进行默认赋值【每一个对象都有自己的一份】</li>
<li>局部变量。在使用前必须要显式赋值的，否则编译不通过。</li>
</ol>
</li>
</ul>
<blockquote>
<p>补充说明：</p>
<ul>
<li>在栈桢中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li>&#x3D;&#x3D;局部变量表中的变量也是重要的垃圾回收<strong>根节点</strong>，只要被局部变量表中直接或间接引用的对象都不会被回收。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4.操作数栈"></a>4.操作数栈</h3><blockquote>
<ul>
<li>每一个独立的栈帧中除了包含局部变量以外，还包含一个<strong>后进先出的操作数栈</strong>，也可以称之为表达式栈。</li>
<li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈或出栈，即入栈或出栈。</li>
<li>操作数栈，主要用于保存计算过程的中间结果 ，同时&#x3D;&#x3D;作为计算过程中变量临时的存储空间&#x3D;&#x3D;。</li>
<li>操作数栈就是jvm执行引擎的一个工作区，&#x3D;&#x3D;当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。&#x3D;&#x3D;</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度再编译器就定义好了，保存在方法的Code属性中，为max_stack的值。</li>
<li>栈中的任何一个元素都是可以任意的Java数据类型<ul>
<li>32bit的类型占用一个栈单位深度。</li>
<li>64bit的类型占用两个栈单位深度。</li>
</ul>
</li>
<li>&#x3D;&#x3D;操作数栈并非采用访问索引的方式来进行数据访问的&#x3D;&#x3D;，而是只能通过标准的入栈和出栈操作来完成一次数据访问。</li>
<li>&#x3D;&#x3D;如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中&#x3D;&#x3D;，并更新PC寄存器中下一条需要执行的字节码指令。</li>
<li>&#x3D;&#x3D;Java虚拟机的解释引擎是基于栈的执行引擎&#x3D;&#x3D;，其中的栈指的就是操作数栈。</li>
</ul>
</blockquote>
<h3 id="5-代码追踪"><a href="#5-代码追踪" class="headerlink" title="5.代码追踪"></a>5.代码追踪</h3><h3 id="6-栈顶缓存技术（Top-of-Stack-caching）"><a href="#6-栈顶缓存技术（Top-of-Stack-caching）" class="headerlink" title="6.栈顶缓存技术（Top-of-Stack-caching）"></a>6.栈顶缓存技术（Top-of-Stack-caching）</h3><blockquote>
<ul>
<li>基于栈式结构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派次数和内存读写次数。</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读写操作必然会影响速度，为了解决这个问题，HotSpot JVM的设计值们提出了&#x3D;&#x3D;栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="7-动态链接（或指向运行时常量池的方法引用）"><a href="#7-动态链接（或指向运行时常量池的方法引用）" class="headerlink" title="7.动态链接（或指向运行时常量池的方法引用）"></a>7.动态链接（或指向运行时常量池的方法引用）</h3><blockquote>
<ul>
<li>每一个栈帧内部都包含一个指向&#x3D;&#x3D;运行时常量池中该栈帧所属方法的引用&#x3D;&#x3D;，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在&#x3D;&#x3D;class文件的常量池里&#x3D;&#x3D;。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么&#x3D;&#x3D;动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Q: 为什么需要常量池呢？</li>
<li>A:常量池的作用就是为了提供一些符号和常量，便于指令的识别</li>
</ul>
</blockquote>
<h3 id="8-方法的调用：解析与分派（重点）"><a href="#8-方法的调用：解析与分派（重点）" class="headerlink" title="8.方法的调用：解析与分派（重点）"></a>8.方法的调用：解析与分派（重点）</h3><blockquote>
<ul>
<li>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。</li>
<li>&#x3D;&#x3D;静态链接：&#x3D;&#x3D;，当一个字节码文件被装载进 JVM内部时，如果&#x3D;&#x3D;被调用的目标方法在编译期可知，且运行期保持不变时&#x3D;&#x3D;，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li>
<li>&#x3D;&#x3D;动态链接：&#x3D;&#x3D;如果&#x3D;&#x3D;被调用的方法在编译器无法被确认下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用&#x3D;&#x3D;，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0 new #3 &lt;com/example/java/DynamicTest&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 invokespecial #4 &lt;com/example/java/DynamicTest.&lt;init&gt; : ()V&gt;    静态链接</span><br><span class="line"> 7 astore_1</span><br><span class="line"> 8 new #5 &lt;com/example/java/Animal&gt;</span><br><span class="line">11 dup</span><br><span class="line">12 invokespecial #6 &lt;com/example/java/Animal.&lt;init&gt; : ()V&gt;			静态链接</span><br><span class="line">15 astore_2</span><br><span class="line">16 aload_1</span><br><span class="line">17 aload_2</span><br><span class="line">18 invokevirtual #7 &lt;com/example/java/DynamicTest.print : (Lcom/example/java/Animal;)V&gt; 动态链接</span><br><span class="line">21 new #8 &lt;com/example/java/Cat&gt;</span><br><span class="line">24 dup</span><br><span class="line">25 invokespecial #9 &lt;com/example/java/Cat.&lt;init&gt; : ()V&gt;			静态链接</span><br><span class="line">28 astore_3</span><br><span class="line">29 aload_1</span><br><span class="line">30 aload_3</span><br><span class="line">31 invokevirtual #7 &lt;com/example/java/DynamicTest.print : (Lcom/example/java/Animal;)V&gt; 动态链接</span><br><span class="line">34 return</span><br></pre></td></tr></table></figure>



<blockquote>
<ul>
<li>对应的方法的绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</li>
<li>&#x3D;&#x3D;早期绑定：&#x3D;&#x3D;早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>&#x3D;&#x3D;晚期绑定：&#x3D;&#x3D;如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</li>
<li>Java中任何一个普通方法其实都具备虚函数的特征，如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>非虚方法：<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</li>
<li>其他方法都成为虚方法。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li>普通方法调用指令：<ul>
<li>&#x3D;&#x3D;invokestatic：调用静态方法，解析阶段确定唯一方法版本&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;invokespecial: 调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本&#x3D;&#x3D;</li>
<li>invokevirtual: 调用所有虚方法</li>
<li>invokeinterface:调用接口方法</li>
</ul>
</li>
<li>动态调用指令：<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
<li>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本，&#x3D;&#x3D;其中invokestatic 指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在Java7中增加了invokedynamic指令，这是Java为了实现动态类型语言支持而做的一种改进。</li>
<li>&#x3D;&#x3D;直到Java8的Lambda表达式的出现，invokedynamic指令的生成&#x3D;&#x3D;，在Java中才有了直接的生成方式。</li>
</ul>
<p>动态类型语言和静态类型语言：</p>
<ul>
<li>动态类型语言和静态类型于洋两者的区别就在于对类型的检查是在编译器还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。</li>
<li>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征，如JS,python这些的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此为了提高性能，JVM采用在类的方法区建立一个虚方法表（非虚方法不会出现在表中）来实现，使用索引表来代替查找。</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>Q: 那么虚方法表什么时候被创建呢？</li>
<li>A: 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕</li>
</ul>
</blockquote>
<h3 id="9-方法返回地址"><a href="#9-方法返回地址" class="headerlink" title="9.方法返回地址"></a>9.方法返回地址</h3><blockquote>
<ul>
<li>存放调用该方法的PC寄存器的值</li>
<li>一个方法的结束，有两种方式：<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置，&#x3D;&#x3D;方法正常退出时，调用者的PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址&#x3D;&#x3D;，而通过异常退出的，返回地址是要用过异常表来确定的，栈帧中一般不会保存这部分信息。</li>
<li>本质上，方法的退出就是房钱战阵出栈的过程，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入栈帧的操作数栈、设置PC寄存器等，让调用者方法继续执行下去</li>
<li>&#x3D;&#x3D;正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="10-一些附加信息"><a href="#10-一些附加信息" class="headerlink" title="10.一些附加信息"></a>10.一些附加信息</h3><blockquote>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息</p>
</blockquote>
<h3 id="11-栈的相关面试题"><a href="#11-栈的相关面试题" class="headerlink" title="11.栈的相关面试题"></a>11.栈的相关面试题</h3><blockquote>
<ul>
<li>举例栈溢出的情况？（StackOverFlow）<ul>
<li>通过-Xss设置栈的大小  OOM (内存溢出 OutOfMemory)</li>
</ul>
</li>
<li>调整栈大小，就能保证不出现溢出吗？<ul>
<li>不能保证，可能有内存溢出</li>
</ul>
</li>
<li>分配的虚拟机栈内存越大越好吗？<ul>
<li>因为计算机内存的大小是固定的，但是这样会导致总的线程数会变少。</li>
</ul>
</li>
<li>垃圾回收是否会涉及到虚拟机栈？<ul>
<li>不会，虚拟机栈不会涉及到垃圾回收，但是涉及到OOM.</li>
<li>本地方法栈与虚拟机栈一样</li>
<li>程序计数器垃圾回收，OOM都不存在</li>
<li>而方法区和堆两者都存在</li>
</ul>
</li>
<li>方法中定义的局部变量是否线程安全？<ul>
<li>具体问题具体分析</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="6-本地方法接口"><a href="#6-本地方法接口" class="headerlink" title="6.本地方法接口"></a>6.本地方法接口</h2><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220502161312269.png" alt="image-20220502161312269"  />

<blockquote>
<p>什么是本地方法？</p>
<ul>
<li>简单地讲，&#x3D;&#x3D;一个Native Method就是一个Java调用非Java代码的接口&#x3D;&#x3D;，一个Native Method是这样一个Java方法：该方法由非Java语言实现，比如C,这个特征并非Java所特有，很多其他的编程语言都有这一限制，比如在c++中，你可以用extern “C”告知C++编译器去调用一个C的函数。</li>
<li>在定义一个native method时，&#x3D;&#x3D;并不提供实现体&#x3D;&#x3D;（有些像定义一个Java interface）,因为其实现体是由非Java语言在外面实现的。</li>
<li>本地接口的作用是融合不同的编程语言为Java所用，他的初衷是融合c&#x2F;c++程序</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>native和abstract不能共用,</li>
</ul>
</blockquote>
<blockquote>
<p>为什么要使用Native Method?</p>
<ul>
<li>与Java环境外交互。<ul>
<li>有时Java应用需要与Java外面的环境进行交互，这是本地方法存在的主要原因。可以想象Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制，它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
</ul>
</li>
<li>与操作系统进行交互。<ul>
<li>jvm毕竟不是一个完整的系统，他经常依赖与一些底层系统的支持，这些底层系统通常是非常强大的操作系统，通过使用本地方法，我们得以用Java实现了jre与底层系统的交互，甚至jvm的一些部分就是用c写的。还有如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
</ul>
</li>
<li>sun’s Java<ul>
<li>sun的解释器是用c实现的，这使得它能像一些普通的c一样与外部交互，jre大部分使用Java实现的，他也通过一些本地方法与外界交互。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>现状：目前该方法使用的越来越少了，除非是与硬件有关的应用。</p>
</blockquote>
<h2 id="7-本地方法栈"><a href="#7-本地方法栈" class="headerlink" title="7.本地方法栈"></a>7.本地方法栈</h2><blockquote>
<ul>
<li><p>&#x3D;&#x3D;Java虚拟机用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。&#x3D;&#x3D;</p>
</li>
<li><p>本地方法栈也是线程私有的</p>
</li>
<li><p>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面与虚拟机栈是相同的）</p>
<ul>
<li>如果县城请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常</li>
</ul>
</li>
<li><p>本地方法是使用c语言实现的</p>
</li>
<li><p>&#x3D;&#x3D;它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库&#x3D;&#x3D;。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>&#x3D;&#x3D;当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限&#x3D;&#x3D;<ul>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li>
<li>它甚至可以直接使用本地处理其中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果jvm产品不打算支持本地native方法，也可以无需实现本地方法栈。</li>
<li>在HotSpot JVM中们直接将本地方法栈和虚拟机栈合二为一。</li>
</ul>
</blockquote>
<h2 id="8-堆"><a href="#8-堆" class="headerlink" title="&#x3D;&#x3D;8.堆&#x3D;&#x3D;"></a>&#x3D;&#x3D;8.堆&#x3D;&#x3D;</h2><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_JVM架构-简图.jpg" alt="第02章_JVM架构-简图" style="zoom: 50%;" />

<h3 id="1-堆的核心概述"><a href="#1-堆的核心概述" class="headerlink" title="1.堆的核心概述"></a>1.堆的核心概述</h3><blockquote>
<ul>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就被确定了。是JVM管理的最大一块内存空间。<ul>
<li>堆内存的大小的是可以调节的</li>
</ul>
</li>
<li>堆可以处于&#x3D;&#x3D;物理上不连续&#x3D;&#x3D;的内存空间中，但在&#x3D;&#x3D;逻辑上它应该被视为连续&#x3D;&#x3D;的。</li>
<li>所有线程共享Java堆，在这里还可以划分线程私有的缓冲区（TLAB）</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>所有的对象实例以及数组都应当在运行时分配到堆上。</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li>
<li>堆，是GC执行垃圾回收的重点区域  【频繁的进行GC操作，会影响用户线程的性能】</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_堆和方法区图.jpg" alt="第08章_堆和方法区图" style="zoom: 33%;" />

<blockquote>
<p>&#x3D;&#x3D;堆中内存细分：&#x3D;&#x3D;</p>
<ul>
<li>现代垃圾收集器大部分都是都基于分代收集理论设计，堆空间细分为：<ul>
<li>Java 7之前堆内存逻辑上分为三部分：新生区Young Generation space+养老区Tenure generation space+&#x3D;&#x3D;永久区(permanent space)&#x3D;&#x3D;<ul>
<li>新生区又分为Eden区和Survivor区,其中Survivor区又分为Survivor0区和Survivor1区（有时也叫做from区，to区，这两个区一般只能有一个区有用，另外一个区空闲）</li>
</ul>
</li>
<li>Java 8之前堆内存逻辑上分为三部分：新生区+养老区+&#x3D;&#x3D;元空间&#x3D;&#x3D;（meta space）<ul>
<li>新生区又分为Eden区和Survivor区</li>
</ul>
</li>
<li>约定：新生区 &#x3D;&#x3D; 新生代 &#x3D;&#x3D; 年轻代  ||  养老区 &#x3D;&#x3D; 老年区 &#x3D;&#x3D; 老年代  ||  永久区 &#x3D;&#x3D; 永久代</li>
<li>永久区或者元空间只是逻辑上在堆空间中，但是它不属于堆内存中的设置的HeapSize</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-设置堆内存大小与OOM"><a href="#2-设置堆内存大小与OOM" class="headerlink" title="2.设置堆内存大小与OOM"></a>2.设置堆内存大小与OOM</h3><blockquote>
<ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过-Xmx 和 -Xms来进行设置<ul>
<li>-Xms用于表示堆区的起始内存，等价于 -XX:InitialHeapSize  （这里面设置的空间只包含了新生区+养老区）</li>
<li>-Xmx则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
</ul>
</li>
<li>一旦堆区中的内存大小超过-Xmx所指定的最大内存的时候，将会抛出OutOfMemoryError异常</li>
</ul>
</blockquote>
<h3 id="3-年轻代（YoungGen）与老年代-OldGen"><a href="#3-年轻代（YoungGen）与老年代-OldGen" class="headerlink" title="3.年轻代（YoungGen）与老年代(OldGen)"></a>3.年轻代（YoungGen）与老年代(OldGen)</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_堆空间细节.jpg" alt="第08章_堆空间细节" style="zoom: 50%;" />

<blockquote>
<ul>
<li>存储在JVM中的Java对象可以被分为两类：<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
</li>
<li>配置新生代与老年代的比例：（开发过程中一般不会修改）<ul>
<li>&#x3D;&#x3D;默认&#x3D;&#x3D; -XX:NewRatio&#x3D;2,表示新生代占1，老年代占2</li>
<li>可以修改-XX:NewRatio&#x3D;4,表示新生代占1，老年代占4</li>
</ul>
</li>
<li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1</li>
<li>开发人员可以通过选项 -XX:SurvivorRatio调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8，&#x3D;&#x3D;默认值是8&#x3D;&#x3D;</li>
<li>-XX:-UseAdaptiveSizePolicy   关闭自适应的内存分配策略</li>
<li>&#x3D;&#x3D;几乎所有的&#x3D;&#x3D;Java对象都是在Eden区被new出来的。</li>
<li>绝大部分的Java对象的销毁都在新生代进行了</li>
<li>可以使用-Xmn设置新生代最大内存大小。<ul>
<li>这个参数一般使用默认值就可以</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4-图解对象分配过程"><a href="#4-图解对象分配过程" class="headerlink" title="4.图解对象分配过程"></a>4.图解对象分配过程</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_新生代对象分配与回收过程.jpg" alt="第08章_新生代对象分配与回收过程" style="zoom: 33%;" />

<blockquote>
<ol>
<li>new的对象先放Eden区（伊甸园区），此区有大小限制</li>
<li>当伊甸园的空间填满的时候，程序有需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收YGC（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象到放到Eden区</li>
<li>然后将Eden区中的剩余对象移动到幸存者0区（s0）</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，如果没有回收，接着再去幸存者1区。</li>
<li>啥时候能去养老区（Tenured&#x2F;Old）?可以设置次数。默认是15次。<ul>
<li>可以设置参数：-XX:MaxTenuringThreshold&#x3D;<N> 进行设置</li>
</ul>
</li>
<li>在养老区，相对悠闲，当养老区内存不足时，再次触发GC:Major GC,进行养老区的内存清理。</li>
<li>若养老区执行了FGC(Major GC)之后发现依然无法进行对象的保存，就会产生OOM异常<ul>
<li>java.lang.OutOfMemoryError：Java heap space</li>
</ul>
</li>
<li>总结：<ul>
<li>针对幸存者0区，幸存者1区的总结：复制之后有交换，谁空谁是to</li>
<li>s0或s1区满了并不会主动触发Minor GC。只有在Eden区满了的情况下才会去触发Eden区和s区的Minor GC</li>
<li>关于垃圾回收，频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>常用调优工具：</p>
<ul>
<li>JDK命令行</li>
<li>Jconsole</li>
<li>VisualVM</li>
<li>Jprofile</li>
<li>Java Flight Recoder</li>
<li>GCViewer</li>
<li>GC Easy</li>
</ul>
</blockquote>
<h3 id="5-Minor-GC、Major-GC、Full-GC"><a href="#5-Minor-GC、Major-GC、Full-GC" class="headerlink" title="5.Minor GC、Major GC、Full GC"></a>5.Minor GC、Major GC、Full GC</h3><blockquote>
<ul>
<li>JVM在进行GC时，并非每次都对上面三个内存区域（新生代、老年代；方法区（jdk 7里面是永久代，8里面是元空间））一起回收的，大部分时候回收的都是指新生代。</li>
<li>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC）,一种是整堆收集（Full GC）</li>
<li>部分收集：不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）:只是新生代的垃圾收集</li>
<li>老年代收集（Major GC&#x2F;Old GC）:只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li>&#x3D;&#x3D;注意,很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收&#x3D;&#x3D;</li>
</ul>
</li>
<li>混合收集（Mixed GC）:收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（Full GC）:收集整个java 堆和方法区的垃圾收集</li>
</ul>
</blockquote>
<blockquote>
<p>年轻代GC(Minor GC)触发机制：</p>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代指的是Eden代满，Survivor满不会触发GC.(每次Minor GC会清理年轻代的内存)</li>
<li>因为Java对象&#x3D;&#x3D;大多都具备朝生夕灭&#x3D;&#x3D;的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li>
<li>Minor GC会引发STW (Stop the world),暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
</blockquote>
<blockquote>
<p>老年代GC(Major GC&#x2F;Full GC)触发机制：</p>
<ul>
<li>指发生在老年代的GC,对象从老年代消失时，我们说“Major GC”或“Full GC”发生了</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM错误。</li>
</ul>
</blockquote>
<blockquote>
<p>Full GC触发机制：</p>
<ul>
<li>触发Full GC执行的情况有如下五种：<ul>
<li>调用System.gc()时，系统建议执行 Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区，survivor space0区（From区）向survivor space1区（To区）复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
</li>
<li>说明：full GC是开发或调优中尽量要避免的，这样暂停的时间会短一些。</li>
</ul>
</blockquote>
<blockquote>
<p>字符串常量池存在于堆空间中，以前存在于方法区。</p>
</blockquote>
<h3 id="6-堆空间分代思想"><a href="#6-堆空间分代思想" class="headerlink" title="6.堆空间分代思想"></a>6.堆空间分代思想</h3><blockquote>
<p>&#x3D;&#x3D;为什么需要把Java堆进行分代？不分代就不能正常工作了吗？&#x3D;&#x3D;</p>
<ul>
<li>经过研究得出，不同对象的生命周期不同，70%~99%的对象是临时对象。<ul>
<li>新生代：有Eden、两块大小相同的Survivor(又称为from&#x2F;to,s0&#x2F;s1)构成，to总为空</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象</li>
</ul>
</li>
<li>其实不分代完全可以，&#x3D;&#x3D;分代的唯一理由就是优化GC性能&#x3D;&#x3D;。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教师。GC的时候要找到哪些对象没用，这样&#x3D;&#x3D;就会对堆的所有区域进行扫描&#x3D;&#x3D;。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方法，当GC的时候先把这块存储朝生夕死对象的区域进行回收，这样就会腾出很大的空间出来。</li>
</ul>
</blockquote>
<h3 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7.内存分配策略"></a>7.内存分配策略</h3><blockquote>
<ul>
<li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1.对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM,每个GC都有所不同）时，就会被晋升到老年代中</li>
<li>对于晋升老年代的年龄阈值，可以通过选项-XX:MaxTenuringThreshold来设置</li>
</ul>
</blockquote>
<blockquote>
<p>内存分配策略(对象提升（promotion）策略)。针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄</li>
</ul>
</li>
<li>空间分配担保：<ul>
<li>-XX:HandlePromotionFailure</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="8-为对象分配内存：TLAB"><a href="#8-为对象分配内存：TLAB" class="headerlink" title="8.为对象分配内存：TLAB"></a>8.为对象分配内存：TLAB</h3><blockquote>
<p>&#x3D;&#x3D;为什么有TLAB(Thread Local Allocation Buffer)?&#x3D;&#x3D;</p>
<ul>
<li>堆区是线程共享区域，任何线程又可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;什么是TLAB?&#x3D;&#x3D;</p>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，&#x3D;&#x3D;JVM为每个线程分配了一个私有缓存区域&#x3D;&#x3D;，它包括在Eden空间内。</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为&#x3D;&#x3D;快速分配策略。&#x3D;&#x3D;</li>
<li>好像所有OpenJDK衍生出来的JVM都提供了TLAB的设计</li>
</ul>
</blockquote>
<blockquote>
<p>TLAB的再说明：</p>
<ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但&#x3D;&#x3D;JVM确实是将TLAB作为内存分配的首选&#x3D;&#x3D;。</li>
<li>开发人员可以通过选项“-XX:UserTLAB”设置是否开启TLAB空间。默认情况下是开启的</li>
<li>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</li>
</ul>
</blockquote>
<h3 id="9-小结堆空间的参数设置"><a href="#9-小结堆空间的参数设置" class="headerlink" title="9.小结堆空间的参数设置"></a>9.小结堆空间的参数设置</h3><blockquote>
<ul>
<li><p>-XX:+PrintFlagsInitial	查看所有的参数的默认初始值</p>
</li>
<li><p>-XX:+PrintFlagsFinal      查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>
<ul>
<li><p>具体查看某个参数的指令 cmd中操作： jps: 查看当前运行中的进程</p>
</li>
<li><p>​                                                                   jinfo -flag SurvivorRatio  进程id</p>
</li>
<li><p>-Xms:初始堆空间内存 （默认为物理内存的 1&#x2F;64）</p>
</li>
<li><p>-Xmx: 最大堆空间内存（默认为物理内存的1&#x2F;4）</p>
</li>
<li><p>-Xmn:设置新生代的大小。（初始值及最大值）</p>
</li>
<li><p>-XX:NewRatio:配置新生代与老年代在堆结构的占比</p>
</li>
<li><p>-XX:SurvivorRatio:设置新生代中Eden和s0&#x2F;s1空间的占比  8：1：1</p>
</li>
<li><p>-XX:MaxTenuringThreshold:设置新生代垃圾的最大年龄（阈值）</p>
</li>
<li><p>-XX:+PrintGCDetails:输出详细的GC处理日志</p>
</li>
<li><p>打印gc简要信息：① -XX:+PrintGC    ② -verbose:gc</p>
</li>
<li><p>-XX:HandlePromotionFailure:是否设置空间分配担保</p>
<ul>
<li>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC,否则将进行Full GC</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="10-堆是分配对象的唯一选择吗？"><a href="#10-堆是分配对象的唯一选择吗？" class="headerlink" title="10.堆是分配对象的唯一选择吗？"></a>10.堆是分配对象的唯一选择吗？</h3><blockquote>
<ul>
<li>随着JIT编译器的发展与&#x3D;&#x3D;逃逸分析技术&#x3D;&#x3D;逐渐成熟，&#x3D;&#x3D;栈上分配、标量替换优化技术&#x3D;&#x3D;将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了。</li>
<li>在Java虚拟机中，对象实在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，&#x3D;&#x3D;那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。&#x3D;&#x3D;这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术了。</li>
</ul>
</blockquote>
<blockquote>
<p>逃逸分析手段：</p>
<ul>
<li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li>
<li>通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>参数设置：</p>
<ul>
<li>在jdk6版本之后，HotSpot中默认就已经开启了逃逸分析。</li>
<li>如果使用的是较早的版本，开发人员则可以通过<ul>
<li>选项 -XX:+DoEscapeAnalysis显式开启逃逸分析</li>
<li>选项-XX:+PrintExcapeAnalysis查看逃逸分析的筛选结果</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;结论：开发中能使用局部变量的，就不要使用在方法外定义。&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>使用逃逸分析，编译器可以对代码做以下优化：</p>
<ul>
<li>栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。<ul>
<li>jdk8是默认开启的</li>
</ul>
</li>
<li>同步省略（锁消除）。如果一个对象被发现只能从一个线程北方问道，那么对于这个对象的操作可以不考虑同步。<ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来&#x3D;&#x3D;判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。&#x3D;&#x3D;这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，或者叫锁消除。</li>
<li>这个在看字节码文件时仍然存在锁，但是在运行的时候就把锁消除了。</li>
</ul>
</li>
<li>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。<ul>
<li>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li>
<li>相对的，哪些还可以分解的数据叫做聚合量，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li>
<li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程就是&#x3D;&#x3D;标量替换&#x3D;&#x3D;。</li>
<li>标量替换参数设置：<ul>
<li>参数 -XX:+EliminateAllocations  开启了标量替换（默认打开），允许将对象打散分配在栈上。</li>
</ul>
</li>
</ul>
</li>
<li>逃逸分析现在还不是很成熟，在Oracle HotSpot中并没有使用逃逸分析，但是使用了标量替换，所以优化后还是有性能提升的。所以总的来说，对象还是分配在堆上。</li>
</ul>
</blockquote>
<h2 id="9-方法区"><a href="#9-方法区" class="headerlink" title="&#x3D;&#x3D;9.方法区&#x3D;&#x3D;"></a>&#x3D;&#x3D;9.方法区&#x3D;&#x3D;</h2><h3 id="1-栈、堆、方法区-元空间-的交互关系"><a href="#1-栈、堆、方法区-元空间-的交互关系" class="headerlink" title="1.栈、堆、方法区(元空间)的交互关系"></a>1.栈、堆、方法区(元空间)的交互关系</h3><p>Person	person   &#x3D;  new  Person();</p>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_方式2：使用直接指针访问.jpg" alt="第10章_方式2：使用直接指针访问" style="zoom: 33%;" />

<h3 id="2-方法区的理解"><a href="#2-方法区的理解" class="headerlink" title="2.方法区的理解"></a>2.方法区的理解</h3><blockquote>
<ul>
<li>尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot VM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。所以，&#x3D;&#x3D;方法区看作是一块独立于Java堆的内存空间&#x3D;&#x3D;</li>
<li>方法区（method area）与Java堆一样，是各个线程共享的内存区域</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样，都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryEroor: PermGen space或者java.lang.OutOfMemoryError: Metaspace 【这是在JDK 8中】</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_堆和方法区图.jpg" alt="第08章_堆和方法区图" style="zoom: 33%;" />

<blockquote>
<ul>
<li>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。<ul>
<li>永久代和元空间都是方法区的逻辑实现</li>
</ul>
</li>
<li>本质上，方法区和永久代并不等价，仅是堆hotspot而言的。</li>
<li>元空间的本质和永久代类似，都是对JVM规范方法区的实现。不过元空间与永久代最大的区别在于：&#x3D;&#x3D;元空间不在虚拟机设置的内存中，而是使用本地内存&#x3D;&#x3D;</li>
<li>根据Java虚拟机规范的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</li>
</ul>
</blockquote>
<h3 id="3-设置方法区大小与OOM"><a href="#3-设置方法区大小与OOM" class="headerlink" title="3.设置方法区大小与OOM"></a>3.设置方法区大小与OOM</h3><blockquote>
<p>jdk8及以后：</p>
<ul>
<li>元数据区大小可以使用参数 -XX:MetaspaceSize和 -XX:MaxMetaspaceSize指定，替代上述原有的两个参数</li>
<li>默认值依赖于平台。windows下，-XX:MetaspaceSize 是21M,-XX:MaxMetaspaceSize的值是-1，即没有限制。</li>
<li>与永久代不同，如果不设置大小，默认情况下，虚拟机会耗尽所有的可用系统内存，如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_OOM.jpg" alt="第10章_OOM" style="zoom:50%;" />

<blockquote>
<p>OOM出现的两大原因：</p>
<ul>
<li>内存泄漏</li>
<li>内存溢出</li>
</ul>
</blockquote>
<h3 id="4-方法区的内部结构"><a href="#4-方法区的内部结构" class="headerlink" title="4.方法区的内部结构"></a>4.方法区的内部结构</h3><p><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第09章_方法区存储信息.jpg" alt="第09章_方法区存储信息"></p>
<blockquote>
<p>方法区存储内容如下：</p>
<ul>
<li>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存，域信息等。</li>
</ul>
</blockquote>
<blockquote>
<p>类型信息：</p>
<ul>
<li>对每个加载的类型（类class,接口interface,枚举enum,注解annotation），JVM必须在方法区中存储以下类型信息<ul>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object,都没有父类）</li>
<li>这个类型的修饰符（public，abstract,final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>域信息（成员变量）：</p>
<ul>
<li>JVM必须在方法区中保存类型的所有域相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称、域类型、域修饰符（public，private, protected, static, final, volatile, transient 的某个子集）</li>
</ul>
</blockquote>
<blockquote>
<p>方法信息：</p>
<ul>
<li>JVM必须保存所有方法的一下信息，同域信息一样包括声明顺序：<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符</li>
<li>方法的字节码、操作数栈、局部变量表及大小（abstract 和native方法除外）</li>
<li>异常表（abstract 和native方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>non-final的类变量：</p>
<ul>
<li><p>静态变量和类关联在一起，随着类的加载而加载，它们就成为类数据在逻辑上的一部分</p>
</li>
<li><p>类变量被类的所有实例共享，即使没有类实例也可以访问它</p>
</li>
<li><pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        Order order = null;
        order.hello();    //均不会报空指针异常
        sout(order.count);//均不会报空指针异常
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final常量：</span><br><span class="line"></span><br><span class="line">- 在编译时就已经被赋值，而无需等到后面的初始化阶段才赋值。</span><br><span class="line"></span><br><span class="line">运行时常量池 VS 常量池</span><br><span class="line"></span><br><span class="line">- 方法区，内部包含了运行时常量池</span><br><span class="line">- 字节码文件，内部包含了常量池</span><br><span class="line">- 要弄清楚方法区，需要理解清楚ClassFile,因为加载类的信息都在方法区</span><br><span class="line">- 要想弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池</span><br><span class="line"></span><br><span class="line">- 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是==常量池表（Constant Pool Table）,包含各种字面量和对类型、域和方法的符号引用==</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- Q:为什么需要常量池？</span><br><span class="line"></span><br><span class="line">- A;一个Java源文件的类、接口，编译后产生一个字节码文件，而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用，在==动态链接==的时候会用到运行时常量池。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 常量池中有什么？</span><br><span class="line"></span><br><span class="line">  - 数量值</span><br><span class="line">  - 字符串值</span><br><span class="line">  - 类引用</span><br><span class="line">  - 字段引用</span><br><span class="line">  - 方法引用</span><br><span class="line"></span><br><span class="line">- 小结：</span><br><span class="line"></span><br><span class="line">  - 常量池，可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</span><br><span class="line"></span><br><span class="line">运行时常量池：</span><br><span class="line"></span><br><span class="line">- ==运行时常量池（Runtime Constant Pool）是方法区的一部分==</span><br><span class="line">- 常量池表（Constant Pool Table）是Class文件的一部分，==用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。==</span><br><span class="line">- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池</span><br><span class="line">- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</span><br><span class="line">- 运行池常量池，相对于Class文件常量池的另一重要特征是：具备动态性</span><br><span class="line">- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OutOfMemoryError异常</span><br><span class="line"></span><br><span class="line">### 5.方法区使用举例</span><br><span class="line"></span><br><span class="line">### 6.方法区的演进细节</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_方法区的演进细节-hotspot.jpg&quot; alt=&quot;第08章_方法区的演进细节-hotspot&quot; style=&quot;zoom: 50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- 首先明确只有HotSpot中才有永久代</span><br><span class="line">- Hotspot中方法区的变化：</span><br><span class="line">  - 1.6及之前：有永久代，静态变量存放在永久代上</span><br><span class="line">  - 1.7：有永久代，但已经逐步去永久代，字符串常量池、静态变量移除，保存在堆中</span><br><span class="line">  - ==1.8及之后：无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆。==</span><br><span class="line">  - ==注意：==静态引用对应的对象实体 （如new出来的内容，new Person()）始终都存在堆空间。</span><br><span class="line">  - 而上面jdk6说的静态变量存在永久代，指的是Static Person person这个引用名在永久代。</span><br><span class="line"></span><br><span class="line">为什么永久代会被元空间进行替代？</span><br><span class="line"></span><br><span class="line">- 为永久代设置空间大小是很困难的</span><br><span class="line">  - 在某些场景下，如果动态加载类过多，容易产生Perm区的OOM,比如某个实际Web工程，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</span><br><span class="line">  - 而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此默认情况下，元空间的大小仅受本地限制。</span><br><span class="line">- 对永久代进行调优时很困难的</span><br><span class="line"></span><br><span class="line">- Q:String Table为什么要调整？【从永久代中移到了堆空间中】</span><br><span class="line"></span><br><span class="line">- A:因为永久代的回收效率很低，在full GC的时候才会触发。而full gc是老年代的空间不足、永久代不足时才触发。这就导致String Table回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">   static ObjectHolder staticObject = new ObjectHolder();</span><br><span class="line">   ObjectHolder instanceObject = new ObjectHolder();</span><br><span class="line">   void func() &#123;</span><br><span class="line">       ObjectHolder localObject = new ObjectHolder();</span><br><span class="line">       sout(localObject);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;staticObject随着Test的类型信息存放在方法区&#x3D;&#x3D;，instanceObject随着Test的对象实例存放在堆中，localObject则是存放在foo()方法栈帧的局部变量表中</p>
</li>
<li><p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围中，所以结论：&#x3D;&#x3D;只要是对象实例必然会在Java堆中分配。&#x3D;&#x3D;</p>
</li>
<li><p>jdk7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，存储于Java堆之中。</p>
</li>
</ul>
</blockquote>
<h3 id="7-方法区的垃圾回收"><a href="#7-方法区的垃圾回收" class="headerlink" title="7.方法区的垃圾回收"></a>7.方法区的垃圾回收</h3><blockquote>
<ul>
<li>一般来说方法区的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。</li>
<li>方法区的垃圾收集主要回收两部分内容：&#x3D;&#x3D;常量池中废弃的常量和不再使用的类型&#x3D;&#x3D;</li>
<li>方法区内常量池之中主要存放的两发类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如本文字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念。包括下面三种:<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li>Hotspot虚拟机对常量池的回收策略是很明确的，&#x3D;&#x3D;只要常量池中的常量没有被任何地方引用，就可以被回收。&#x3D;&#x3D;</li>
<li>回收废弃常量与回收堆中的对象非常类似</li>
<li>jdk11的zgc收集器就不支持类卸载</li>
</ul>
</blockquote>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第09章_小结.jpg" alt="第09章_小结"></p>
<h2 id="10-对象的实例化、内存布局与访问定位"><a href="#10-对象的实例化、内存布局与访问定位" class="headerlink" title="10.对象的实例化、内存布局与访问定位"></a>10.对象的实例化、内存布局与访问定位</h2><h3 id="0-大厂面试题"><a href="#0-大厂面试题" class="headerlink" title="0.大厂面试题"></a>0.大厂面试题</h3><blockquote>
<ul>
<li>对象在JVM中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
<li>Java对象头里面有什么</li>
</ul>
</blockquote>
<h3 id="1-对象的实例化"><a href="#1-对象的实例化" class="headerlink" title="1.对象的实例化"></a>1.对象的实例化</h3><blockquote>
<p>&#x3D;&#x3D;创建对象的方式：&#x3D;&#x3D;</p>
<ul>
<li>new</li>
<li>Class的newInstance( )方法 【反射的方式，只能调用空参的构造器，权限必须是public】</li>
<li>Constructor的newInstance(Xxx)方法 【反射的方式，可以调用空参和有参的方式，权限没有要求】</li>
<li>使用clone( )  【不调用任何构造器，当前类需要实现Cloneable接口，实现clone( )方法】</li>
<li>使用反序列化  【从文件中、网络中获取一个对象的二进制流】</li>
<li>第三方库Objenesis</li>
</ul>
</blockquote>
<blockquote>
<p>创建对象的步骤：</p>
<ol>
<li>判断对象对应的类是否加载、链接、初始化<ul>
<li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派机制的模式下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应的class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</li>
</ul>
</li>
<li>为对象分配内存 【首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量（类的属性&#x2F;域）是引用变量，仅分配引用变量空间即可，即4个字节大小。】<ol>
<li>如果内存规整  ——》指针碰撞  【对应的垃圾回收算法是标记压缩算法】<ul>
<li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。</li>
<li>意思是所有用过的内存在一边，空间的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时，使用指针碰撞。</li>
</ul>
</li>
<li>如果内存不规整      【对应的垃圾回收算法是标记清除算法 CMS】<ol>
<li>虚拟机需要维护一个列表</li>
<li>空闲列表分配<ul>
<li>如果内存不是规整的，已使用的内存和未使用的内存交互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存</li>
<li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表”</li>
</ul>
</li>
</ol>
</li>
<li>说明<ul>
<li>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>
</ul>
</li>
</ol>
</li>
<li>处理并发安全问题<ol>
<li>采用CAS配上失败重试保证更新的原子性</li>
<li>每个线程预先分配一块TLAB ——》通过-XX:+&#x2F;-UseTLAB参数来设定</li>
</ol>
</li>
<li>初始化分配到的空间  ——》所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用 【属性的默认初始化】</li>
<li>设置对象的对象头<ul>
<li>将对行的所属类（即类的元数据信息），对象的hashcode和对象的GC信息、锁信息等数据存储在对象的对象头中，这个过程的具体设置方式取决于JVM实现。</li>
</ul>
</li>
<li>执行init方法进行初始化 【属性的显式初始化，代码块中初始化，构造器中初始化】<ul>
<li>在Java程序的视角看来，初始化才正式开始，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的兑现那个才算完全创建出来。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_内存布局.jpg" alt="第10章_内存布局" style="zoom: 200%;" />

<blockquote>
<p>内存布局</p>
<ul>
<li><p>对象头（Header）：</p>
<ul>
<li>运行时元数据（Mark word）<ul>
<li>哈希值</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
</li>
<li>类型指针 ——》指向类元数据InstanceKlass,确定该对象所属的类型</li>
<li>说明：如果是数组，还需记录数组的长度</li>
</ul>
</li>
<li><p>实例数据（Instance Data）</p>
<ul>
<li>说明 ——》它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来和本身拥有的字段）</li>
<li>规则<ul>
<li>相同宽度的字段总是被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果CompactFields参数为true(默认为true):子类的窄变量可能插入到父类变量的空隙</li>
</ul>
</li>
</ul>
</li>
<li><p>对齐填充（Padding） ——》不是必须的，也没有特别含义，仅仅起到占位符的作用</p>
</li>
<li><p>小结：图示</p>
</li>
<li><pre><code class="java">class Account &#123;
    double money;
    double balance;
&#125;
  
class Customer &#123;
    int ID = 1001;
    String name;
    Account acct;
  
    &#123;
        name = &quot;匿名客户&quot;;
    &#125;
      
    public Customer() &#123;
        Account acct = new Account();
        this.acct = acct;
    &#125;
&#125;


public class ClassTest &#123;
    public static void main(String[] args) &#123;
        Customer cust = new Customer();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ![第10章_图示对象的内存布局](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_图示对象的内存布局.jpg)</span><br><span class="line"></span><br><span class="line">### 3.对象的访问定位</span><br><span class="line"></span><br><span class="line">- Q:JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢?</span><br><span class="line"></span><br><span class="line">- A:定位，通过栈上reference访问</span><br><span class="line"></span><br><span class="line">对象访问方式主要有两种：</span><br><span class="line"></span><br><span class="line">- 句柄访问</span><br><span class="line">  - 优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</span><br><span class="line">  - ![第10章_方式1：句柄访问](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_方式1：句柄访问.jpg)</span><br><span class="line">- 直接指针（HotSpot使用）</span><br><span class="line">  - 优点：不要单独开启空间来存储指针</span><br><span class="line">  - ![第10章_方式2：使用直接指针访问](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_方式2：使用直接指针访问.jpg)</span><br><span class="line"></span><br><span class="line">## 11.直接内存</span><br><span class="line"></span><br><span class="line">- 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</span><br><span class="line">- 直接内存是在Java堆外的，直接向系统申请的内存区间</span><br><span class="line">- 来源于NIO（non-blocking IO，非阻塞式IO）,通过存在堆中的DirectByteBuffer操作Native内存</span><br><span class="line">- 通常，访问直接内存的速度会优于Java堆。即读写性能高</span><br><span class="line">  - 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</span><br><span class="line">  - Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</span><br><span class="line"></span><br><span class="line">- 读写文件，需要与磁盘进行交互，需要由用户态切换到内核态，在内核态时，需要内存如右图所示。</span><br><span class="line"></span><br><span class="line">- 使用IO,这里需要两份内存存储重复数据，效率低。【JVM中的用户地址空间一份。OS中的内核地址空间一份】</span><br><span class="line">- 使用NIO时，操作系统直接划出的直接缓存区可以被Java代码直接访问，只有一份，NIO适合堆大文件的读写操作。</span><br><span class="line"></span><br><span class="line">- 也可能导致OutOfMemoryEroor异常</span><br><span class="line">- 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统给出的最大内存</span><br><span class="line">- 缺点：</span><br><span class="line">  - 分配回收成本较高</span><br><span class="line">  - 不受JVM内存回收管理</span><br><span class="line">- 直接内存大小可以通过MaxDirectMemorySize设置</span><br><span class="line">- 如果不指定，默认与堆的最大值-Xmx参数值一致</span><br><span class="line"></span><br><span class="line">- 方法区（元空间）放在堆外的本地内存中</span><br><span class="line">- 本地内存包括直接内存 和元数据区（元空间）</span><br><span class="line">- java process memory ~= java  heap  +  native  memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 12.执行引擎</span><br><span class="line"></span><br><span class="line">![第02章_JVM架构-中](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_JVM架构-中.jpg)</span><br><span class="line"></span><br><span class="line">### 1.执行引擎概述</span><br><span class="line"></span><br><span class="line">- 执行引擎时Java虚拟机核心的组成部分之一</span><br><span class="line">- 虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而==虚拟机的执行引擎则是由软件自行实现的==，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，==能够执行那些不被硬件直接支持的指令集格式。==</span><br><span class="line">- ==JVM的主要任务是负责装载字节码到其内部==，但字节码并不能直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表、以及其他辅助信息。</span><br><span class="line">- 那么，如果想要让一个Java程序运行起来，==执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以==。简单来说，JVM中的执行引擎充当了高级语言翻译为机器语言的翻译官。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_执行引擎的工作过程.jpg&quot; alt=&quot;第12章_执行引擎的工作过程&quot; style=&quot;zoom: 33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">执行引擎的工作过程：</span><br><span class="line"></span><br><span class="line">- 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器</span><br><span class="line">- 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址</span><br><span class="line">- 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到存储在元空间中的目标对象的类型信息。</span><br><span class="line">- 从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的；输入的是二进制流，处理过程是字节码解析执行的等效过程，输出的执行结果。</span><br><span class="line"></span><br><span class="line">### 2.Java代码编译和执行过程</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_程序执行过程.jpg&quot; alt=&quot;第12章_程序执行过程&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤。</span><br><span class="line"></span><br><span class="line">- 绿色对应的是解释过程</span><br><span class="line">- 蓝色对应的是JIT编译过程</span><br><span class="line"></span><br><span class="line">Q：什么是解释器，什么是JIT编译器</span><br><span class="line"></span><br><span class="line">A：解释器：当Java虚拟机启动的时候会根据预定义的规范==对字节码采用逐行解释的方式执行==，将每条字节码文件中的内容解释为对应平台的本地机器指令执行。	JIT编译器（just in time Compile）：就是虚拟机将源代码直接编译成本地机器平台相关的机器语言。</span><br><span class="line"></span><br><span class="line">Q：为什么说Java是半编译半解释型语言？</span><br><span class="line"></span><br><span class="line">A：JDK1.0时代，将Java语言定位为解释执行，还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器（这是后端编译。将.java文件编译成.class文件是前端编译）。现在JVM在执行代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</span><br><span class="line"></span><br><span class="line">![第12章_理解执行引擎](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_理解执行引擎.jpg)</span><br><span class="line"></span><br><span class="line">### 3.机器码、指令、汇编语言</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_机器语言、汇编、高级语言.jpg&quot; alt=&quot;第12章_机器语言、汇编、高级语言&quot; style=&quot;zoom: 50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">机器码：</span><br><span class="line"></span><br><span class="line">- 各种用二进制编码方式表示的指令，叫做机器指令码。开始人们就用它来编写程序，这就是机器语言</span><br><span class="line">- 用机器语言编写的程序，CPU可以直接读取运行，因此和其他语言编的程序相比，执行速度最快</span><br><span class="line">- 机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</span><br><span class="line"></span><br><span class="line">机器指令：</span><br><span class="line"></span><br><span class="line">- 由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</span><br><span class="line">- 指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文编写，如mov,inc等），可读性稍好</span><br><span class="line">- 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov）,对应的机器码也可能不同</span><br><span class="line"></span><br><span class="line">指令集：</span><br><span class="line"></span><br><span class="line">- 不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</span><br><span class="line">- 常见的：</span><br><span class="line">  - X86指令集，对应的是x86架构的平台</span><br><span class="line">  - ARM指令集，对应的是ARM架构的平台</span><br><span class="line"></span><br><span class="line">汇编语言：</span><br><span class="line"></span><br><span class="line">- 由于指令的可读性还是太差，于是人们发明了汇编语言</span><br><span class="line">- 汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址</span><br><span class="line">- 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</span><br><span class="line">  - 由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</span><br><span class="line"></span><br><span class="line">高级语言：</span><br><span class="line"></span><br><span class="line">- 为了更简单，后来就出现了各种高级语言，更接近人的语言</span><br><span class="line">- 当计算机执行高级语言执行的程序时，仍然需要把程序解释和编译成机器的指令码，完成这个过程的程序就叫做解释程序或编译程序。</span><br><span class="line"></span><br><span class="line">字节码：</span><br><span class="line"></span><br><span class="line">- 字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</span><br><span class="line">- 字节码主要为了实现特定软件运行和软件环境、==与硬件环境无关。==</span><br><span class="line">- 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</span><br><span class="line">  - 字节码的典型应用为Java bytecode</span><br><span class="line"></span><br><span class="line">### 4.解释器</span><br><span class="line"></span><br><span class="line">- JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法</span><br><span class="line">- 解释器工作机制：</span><br><span class="line">  - 真正意义上所承担的角色就是一个运行时解释者，将字节码文件中的内容翻译为对应平台的本地机器指令执行</span><br><span class="line">  - 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</span><br><span class="line">- 现状：</span><br><span class="line">  - 基于解释器执行已经沦落为低效的代名词，并且时常被一些c/c++程序员调侃。</span><br><span class="line">  - 为了解决这个问题，JVM平台支持一种叫做即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成机器码。每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</span><br><span class="line">  - 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</span><br><span class="line"></span><br><span class="line">### 5.JIT编译器</span><br><span class="line"></span><br><span class="line">- Hotspot VM是目前市面上高性能虚拟机的代表作之一。==它采用解释器与即时编译器并存的架构==。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</span><br><span class="line">- Q：既然Hotspot VM已经内置JIT编译器了，那么为什么还需要在使用解释器来拖累程序的执行性能呢？</span><br><span class="line">- A：当程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间，单边以为本地代码后，执行效率高。</span><br><span class="line"></span><br><span class="line">Hotspot VM的执行方式：</span><br><span class="line"></span><br><span class="line">- 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的代码编译为本地机器指令，以换取更高的程序执行效率。</span><br><span class="line"></span><br><span class="line">概念解释：</span><br><span class="line"></span><br><span class="line">- Java语言的编译器，其实是一段不确定的操作过程，因为它可能是指一个前端编译器（或叫编译器的前端）把.java文件转变成.class文件的过程。</span><br><span class="line">- 也可能是指虚拟机的后端运行期编译器（JIT编译器）把字节码转变成机器码的过程（这中间还经历了转换为汇编语言）</span><br><span class="line">- 还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compile）直接把.java文件编译成本地机器代码的过程</span><br><span class="line"></span><br><span class="line">热点代码及探测方式：</span><br><span class="line"></span><br><span class="line">- ==根据代码被调用执行的频率而定。那些需要被编译为本地代码的字节码也被称为热点代码==。JIT编译器在运行时会针对那些频繁被调用的热点代码作出深度优化，将其直接编译为对应平台的本地机器指令，以此来提升性能。</span><br><span class="line">- 热点代码都可以通过JIT编译器编译为本地机器指令，由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为==OSR(On Stack Replacement)编译==</span><br><span class="line">- 一个方法究竟需要被调用多少次，这里主要依靠热点探测功能。</span><br><span class="line">- ==目前Hotspot VM所采用的热点探测方式是基于计数器的热点探测。==</span><br><span class="line">- Hotspot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器和汇编计数器</span><br><span class="line">  - 方法调用计数器用于==统计方法的调用次数==</span><br><span class="line">  - 回边计数器则用于==统计循环体执行的循环次数==</span><br><span class="line"></span><br><span class="line">方法调用计数器：</span><br><span class="line"></span><br><span class="line">- 它的默认阈值在client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。（这个次数包括方法调用计数器与回边计数器值之和）</span><br><span class="line">- 这个阈值可以通过虚拟机参数 -XX:CompileThrehold来人为设定</span><br><span class="line">- 热度衰减：</span><br><span class="line">  - 如果不做任何设置，方法调用计数器统计的并不是方法被调用的次数，而是一个相对的执行效率，即一段时间内方法被调用的次数。即当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期</span><br><span class="line">  - 进行热度衰减的动作实在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCountDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译称本地代码。</span><br><span class="line">  - 另外，可以使用 -XX:CounterHalfLifeTime 参数设hi半衰周期的时间，单位是秒</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_方法调用计数器.jpg&quot; alt=&quot;第12章_方法调用计数器&quot; style=&quot;zoom: 33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">回边计数器：</span><br><span class="line"></span><br><span class="line">- 作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为回边。显然，建立回边计数器统计的目的就是为了触发OSR编译</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_回边计数器.jpg&quot; alt=&quot;第12章_回边计数器&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">Hotspot VM可以设置程序执行方式：</span><br><span class="line"></span><br><span class="line">- 默认情况下是采用解释器与即时编译器并存的架构。当然开发人员可以根据需要进行修改来指定运行时到底是完全采用解释器执行还是完全采用即时编译器执行。</span><br><span class="line">- -Xint : 完全采用解释器模式执行程序</span><br><span class="line">- -Xcomp: 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</span><br><span class="line">- -Xmixed:采用解释器、即时编译器混合模式来共同执行程序。</span><br><span class="line"></span><br><span class="line">Hotspot VM中的JIT分类：</span><br><span class="line"></span><br><span class="line">- 在Hotspot VM中内嵌有两个JIT编译器，分别为Client Compile和Server Compile，但大多数情况下我们简称为c1编译器和c2编译器。开发人员可以通过如下命令显示指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</span><br><span class="line">  - -client : 指定Java虚拟机运行在Client模式下，并使用c1编译器</span><br><span class="line">    - c1编译器会对字节码进行==简单和可靠的优化，耗时短==，以达到更快的编译速度</span><br><span class="line">  - -server: 指定Java虚拟机运行在Server模式下，并使用c2编译器</span><br><span class="line">    - c2编译器进行==耗时较长的优化，以及激进优化==，但优化的代码执行效率更高</span><br><span class="line"></span><br><span class="line">c1和c2编译器不同的优化策略：</span><br><span class="line"></span><br><span class="line">- 在不同的编译器上有不同的优化策略，c1上主要有方法内联，去虚拟化、冗余消除</span><br><span class="line">  - 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</span><br><span class="line">  - 去虚拟化：对唯一的实现类进行内联</span><br><span class="line">  - 冗余消除：在运行期间把一些不会执行的代码折叠掉</span><br><span class="line">- c2的优化主要在全局层面，逃逸分析是优化的基础。基于逃逸分析在c2上有如下几种优化：</span><br><span class="line">  - 标量替换：用标量值代替聚合对象的属性值</span><br><span class="line">  - 栈上分配：对于未逃逸的对象分配对象在栈而不是堆</span><br><span class="line">  - 同步消除：消除同步操作，通常指synchronized</span><br><span class="line"></span><br><span class="line">- 分层编译策略：程序解释执行（不开启性能监控）可以触发c1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，c2编译会根据性能监控信息进行激进优化。</span><br><span class="line"></span><br><span class="line">- 在-server模式下，默认将开启分层编译策略，由c1和c2编译器相互协作来完成</span><br><span class="line"></span><br><span class="line">总结来讲：</span><br><span class="line"></span><br><span class="line">- JIT编译出来的机器码性能比解释器高。</span><br><span class="line">- c2编译器启动时长比c1编译器慢，系统稳定执行以后，c2编译器执行速度远远快于c1编译器</span><br><span class="line"></span><br><span class="line">在JDK10之后，引入了全新即时编译器，Graal编译器（与c1,c2是并列关系，属于JIT里面），性能已经快赶上c2编译器了</span><br><span class="line"></span><br><span class="line">- AOT编译器（与JIT是并列的关系），静态提前编译器，在jdk9引入的，是与即时编译相对立的一个概念。即时编译是在==程序的运行过程中==，而AOT编译指的是，==在程序运行之前==，便将字节码转换为机器码的过程。</span><br><span class="line">- 最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行，不必等待即时编译器的预热，减少Java应用给人带来第一次运行慢的不良体验</span><br><span class="line">- 缺点:</span><br><span class="line">  - 破坏了Java一次编译到处运行，必须为每个不同硬件，oS编译对应的发行包</span><br><span class="line">  - 降低了Java连接过程的动态性，加载的代码在编译器就必须全部已知。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 13.String Table</span><br><span class="line"></span><br><span class="line">### 1.String 的基本特性</span><br><span class="line"></span><br><span class="line">- String的两种定义方式：</span><br><span class="line">  - String  str  =  &quot;anc&quot;;  //==字面量定义方式  &quot;abc&quot;存储在字符串常量池中==</span><br><span class="line">  - String  str  =  new  String(&quot;abc&quot;);  </span><br><span class="line">- String类被声明为final的，不可被继承</span><br><span class="line">- String实现了Serializable接口，表示字符串是支持序列化的，实现了Comparable接口，表示String可以比较大小</span><br><span class="line">- String在jdk 8及以前内部定义了final char[] value用于存储字符串数据。jdk9时改为byte[]。为了节约内存空间，char占两个byte,而大多数存储的内容都用一个byte就足够了，对于像中文这样的，需要两个字节的则使用encoding-flag field来进行标识。</span><br><span class="line">- String:代表不可变的特性，简称不可变性。即已经存在的字符串就不会再变化。</span><br><span class="line">- ==通过字面量的方式（区别于new的方式）给一个字符串赋值，此时的字符串声明在字符串常量池中==</span><br><span class="line">- ==字符串常量池中是不会存储相同内容的字符串的==</span><br><span class="line">- String的String pool是一个固定大小的Hashtable，使用数组+链表来进行实现。当里面字符串过多时，就会有hash冲突，导致链表会很长，而链表长了，直接会造成的影响就是当调用String,intern()时性能会大幅下降。这里不能够扩容</span><br><span class="line">- 使用 -XX:StringTableSize 可设置StringTable的长度。jdk6中默认的是1009. jdk7中默认是60013，jdk8开始设置的最小值是1009.</span><br><span class="line"></span><br><span class="line">### 2.String 的内存分配</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   String s1 = &quot;abc&quot;;</span><br><span class="line">   String s2 = &quot;abc&quot;;</span><br><span class="line">   System.out.println(s1.hashCode());  //96354</span><br><span class="line">   System.out.println(s2.hashCode());	//96354</span><br><span class="line">   System.out.println(s1 == s2);   //true</span><br><span class="line"></span><br><span class="line">   String s3 = new String(&quot;efg&quot;);</span><br><span class="line">   String s4 = new String(&quot;efg&quot;);</span><br><span class="line">   System.out.println(s3.hashCode());	//100326</span><br><span class="line">   System.out.println(s4.hashCode());	//100326</span><br><span class="line">   System.out.println(s3 == s4);   //false     虽然hashcode值相同，它们的地址仍然不同</span><br><span class="line"></span><br><span class="line">   String s5 = &quot;poi&quot;;</span><br><span class="line">   String s6 = new String(&quot;poi&quot;);</span><br><span class="line">   System.out.println(s5.hashCode());	//111178</span><br><span class="line">   System.out.println(s6.hashCode());	//111178</span><br><span class="line">   System.out.println(s5 == s6);   //false     虽然hashcode值相同，它们的地址仍然不同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li>
<li>常量池就类似一个Java系统级别提供的缓存，8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊，它的主要使用方法有两种。<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中，比如：String info &#x3D; “abc”;</li>
<li>如果不是双引号声明的String对象，可以使用String提供的intern( )方法，后面重点谈。</li>
</ul>
</li>
<li>Java 6及以前，字符串常量池存放在永久代</li>
<li>Java 7 中Oracle 的工程师对字符串池的逻辑做了很大的改变，&#x3D;&#x3D;即将字符串常量池的位置调整到Java堆中&#x3D;&#x3D;<ul>
<li>所有的字符串都保存在堆（heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够得理由让我们重新考虑在Java 7中使用String.intern( )。</li>
</ul>
</li>
<li>Java 8 元空间，字符串常量在堆中。</li>
<li>String Table(字符串常量池为什么要调整到堆中去)？<ul>
<li>永久代（方法区、元空间）默认大小比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-String的基本操作"><a href="#3-String的基本操作" class="headerlink" title="3.String的基本操作"></a>3.String的基本操作</h3><blockquote>
<p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列，并且必须是指向同一个String 类实例。</p>
</blockquote>
<h3 id="4-字符串拼接操作"><a href="#4-字符串拼接操作" class="headerlink" title="4.字符串拼接操作"></a>4.字符串拼接操作</h3><blockquote>
<ul>
<li>&#x3D;&#x3D;常量与常量&#x3D;&#x3D;的&#x3D;&#x3D;拼接结果在常量池&#x3D;&#x3D;，原理是编译器优化</li>
<li>常量池中不会存在相同内容的常量</li>
<li>&#x3D;&#x3D;只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder&#x3D;&#x3D;</li>
<li>如果拼接的结果调用intern( )方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
<li>字符串拼接操作不一定使用的是StringBuilder</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#第一个特点演示</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">#第三个特点演示</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;	<span class="comment">//编译器优化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;		<span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中 new String() 	</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 +s2;</span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s7);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s7);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s6 == s7);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//intern( )方法，会判断字符串常量池中是否有内容为s6的字符串，如果存在，则返回常量池中该常量值对应的地址，如果字符串常量池中不存在，则在常量池中加载一份该值对应的常量，并返回该值对应的地址。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">System.out.println(s3 == s8);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如下的 s1 + s2 的执行细节</span></span><br><span class="line"><span class="comment">        ①StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">        ②s.append(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">        ③s.append(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">        ④s.toString()  --》约等于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;	<span class="comment">//这里字节码文件反编译之后 String s4 = s1 + s2;</span></span><br><span class="line">    System.out.println(s3 == s4);  <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意与上面问题的差别：在变量前加 final</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;    <span class="comment">//区别</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;   <span class="comment">//这里字节码文件反编译之后 String s4 = &quot;ab&quot;</span></span><br><span class="line">    System.out.println(s3 == s4);  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译器优化，，即非StringBuilder的方式。</li>
<li>针对于final修饰类、方法、基本数据类型、引用数据类型的将量的结构时，能使用上final的时候建议使用上</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式<ul>
<li>StringBuilder  s  &#x3D;  new StringBuilder();   s.append(“a”); </li>
<li>String  str &#x3D; “”   str &#x3D;  str +  “a”;  &#x2F;&#x2F;这种方式每次执行都会去创建StringBuilder对象和一个String对象</li>
</ul>
</li>
<li>好处：<ul>
<li>使用StringBuilder的append()的方式，自始至终只创建过一个StringBuilder对象。使用String的字符串拼接方式，创建过多个StringBuilder和String的对象</li>
<li>使用StringBuilder的append()的方式，内存中由于创建了较多的StringBuilder和String的对象，内存占用更大，如果进行GC，需要花费额外的时间。</li>
</ul>
</li>
<li>改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器，StringBuilder s &#x3D; new  StringBuilder(highLevel) ;  &#x2F;&#x2F;底层使用 new char[highLevel];</li>
</ul>
</blockquote>
<h3 id="5-intern-的使用"><a href="#5-intern-的使用" class="headerlink" title="&#x3D;&#x3D;5.intern( )的使用&#x3D;&#x3D;"></a>&#x3D;&#x3D;5.intern( )的使用&#x3D;&#x3D;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>).intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;rty&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;rty&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果不是双引号声明的String对象，可以使用String提供的intern( )方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
<li>比如 String  myInfo  &#x3D;  new  String(“I love  atguigu”).intern();</li>
<li>也就是说，如果在任意字符串上调用String.intern( )方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true。<ul>
<li>（”a” + “b” + “c” &#x3D;&#x3D; “abc”） &#x2F;&#x2F;true</li>
</ul>
</li>
<li>通俗点讲，&#x3D;&#x3D;Interned  String就是确保字符串在内存里只有一份拷贝，这样就可以节约内存空间&#x3D;&#x3D;，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池。（String  Intern  pool）</li>
</ul>
</blockquote>
<blockquote>
<p>如何保证变量s指向的是字符串常量池中的数据呢？</p>
<ul>
<li>方式1：String  s &#x3D; “hello”;</li>
<li>方式2：String  s &#x3D; new  String(“hello”).intern();</li>
<li>String s &#x3D; new StringBuilder().toString().intern();</li>
</ul>
</blockquote>
<blockquote>
<p>intern( )的空间效率测试：空间使用上。</p>
<p>&#x3D;&#x3D;结论：&#x3D;&#x3D;对于程序中大量存在的字符串，尤其其中存在很多重复字符串时，使用intern( )可以节省内存空间。</p>
</blockquote>
<h3 id="6-String-Table的垃圾回收"><a href="#6-String-Table的垃圾回收" class="headerlink" title="6.String Table的垃圾回收"></a>6.String Table的垃圾回收</h3><blockquote>
<ul>
<li>与堆中回收方式相同，也是通过minor GC,major GC</li>
</ul>
</blockquote>
<h3 id="7-G1中的String-去重操作"><a href="#7-G1中的String-去重操作" class="headerlink" title="7.G1中的String 去重操作"></a>7.G1中的String 去重操作</h3><blockquote>
<p>这里说到的去重去的是堆上存在的重复的String对象。而不是堆中字符串常量池中的字符串对象去重</p>
</blockquote>
<h3 id="8-String中的面试题"><a href="#8-String中的面试题" class="headerlink" title="8.&#x3D;&#x3D;String中的面试题&#x3D;&#x3D;"></a>8.&#x3D;&#x3D;String中的面试题&#x3D;&#x3D;</h3><blockquote>
<ul>
<li><p>&#x3D;&#x3D;Q1&#x3D;&#x3D;：new String(“ab”)会创建几个对象？看字节码，就知道是两个</p>
</li>
<li><p>A1：两个，一个对象是，new 关键字在堆空间创建的，另一个对象是：字符串常量池中的对象，字节码指令 ldc</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;Q2&#x3D;&#x3D;：new String(“a”) + new String(“b”)会创建几个对象呢？</p>
</li>
<li><p>A2：</p>
<ul>
<li>对象1：new  StringBuilder()</li>
<li>对象2：new String(“a”)</li>
<li>对象3：常量池中的a</li>
<li>对象4：new String(“b”)</li>
<li>对象5：常量池中的b</li>
<li>深入剖析：StringBuilder的toString( );</li>
<li>对象6：new String(“ab”)。&#x3D;&#x3D;但值得注意的是，toString ( )的调用，在字符串常量池中没有生成”ab”&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;Q3的代码就是针对下面的代码：&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s.intern();  <span class="comment">//调用此方法之前</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s == s2);    <span class="comment">//jdk6中返回false, jdk7/8: false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">//此时s3变量记录的地址为：new String(&quot;11&quot;);</span></span><br><span class="line"><span class="comment">//执行完上一行代码以后，字符串常量池中不存在&quot;11&quot;</span></span><br><span class="line">s3.intern();   <span class="comment">//所以在字符串常量池中生成&quot;11&quot;。</span></span><br><span class="line"><span class="comment">// 如何理解s3.intern()：jdk6:创建了一个新的对象&quot;11&quot;，也就有了新的地址.jdk7：此时常量池中并没有创建&quot;11&quot;,而是创建了一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;   <span class="comment">//s4变量记录的地址，使用的是上一行代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">//jdk6: false，jdk7/8：true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q4是上面Q3的变体：代码如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">//此时s3变量记录的地址为：new String(&quot;11&quot;);</span></span><br><span class="line"><span class="comment">//执行完上一行代码以后，字符串常量池中不存在&quot;11&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;   <span class="comment">//在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">s3.intern();   </span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结String的intern()的使用：</p>
<ul>
<li>jdk1.6中，将这个字符串对象尝试放入串池。<ul>
<li>如果串池中有，则并不会放入，返回已有的串池中的对象的地址</li>
<li>如果没有，&#x3D;&#x3D;会把此对象复制一份&#x3D;&#x3D;，放入串池，并返回串池中的对象地址</li>
</ul>
</li>
<li>jdk1.7起，将这个字符串对象尝试放入串池。<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，&#x3D;&#x3D;则会把对象的引用地址复制一份&#x3D;&#x3D;，放入串池，并返回串池中的引用地址</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="14-垃圾回收概述"><a href="#14-垃圾回收概述" class="headerlink" title="14.垃圾回收概述"></a>14.垃圾回收概述</h2><h3 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1.什么是垃圾"></a>1.什么是垃圾</h3><blockquote>
<ul>
<li>关于垃圾回收有三个经典问题：<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率，也是面试的重点。</li>
<li>什么是垃圾呢？<ul>
<li>垃圾是指在&#x3D;&#x3D;运行程序过程中没有任何指针指向的对象&#x3D;&#x3D;，这个对象就是需要被回收的垃圾</li>
</ul>
</li>
<li>如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一致保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li>
</ul>
</blockquote>
<h3 id="2-为什么需要GC"><a href="#2-为什么需要GC" class="headerlink" title="2.为什么需要GC"></a>2.为什么需要GC</h3><blockquote>
<ul>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，&#x3D;&#x3D;内存迟早都会被消耗完&#x3D;&#x3D;，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾收集也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ul>
</blockquote>
<h3 id="3-早期垃圾回收"><a href="#3-早期垃圾回收" class="headerlink" title="3.早期垃圾回收"></a>3.早期垃圾回收</h3><blockquote>
<ul>
<li>在c&#x2F;c++中，垃圾回收基本上是手工进行地。开发人员可以使用new 关键字进行内存分配，并使用delete关键字进行内存释放。</li>
<li>这种方式灵活控制内存释放地时间，但是会给开发人员带来频繁申请和释放内存地管理负担。一般忘了，就会造成内存泄漏。垃圾对象永远无法清除，随着系统运行时间地增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</li>
</ul>
</blockquote>
<h3 id="4-Java垃圾回收机制"><a href="#4-Java垃圾回收机制" class="headerlink" title="4.Java垃圾回收机制"></a>4.Java垃圾回收机制</h3><blockquote>
<ul>
<li>自动内存管理，无需开发人员手动参与内存地分配与回收，这样&#x3D;&#x3D;降低内存泄漏和内存溢出的风险&#x3D;&#x3D;</li>
<li>如果过度依赖于自动管理，这对于程序员来说就是一个黑匣子，会严重的弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须&#x3D;&#x3D;对这些自动化技术实施必要的监控和调节。&#x3D;&#x3D;</li>
<li>GC的作用区域主要是在方法区（元空间）和堆</li>
<li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。其中，Java堆是垃圾收集器的工作重点。</li>
<li>从次数上将：<ul>
<li>频繁收集新生代</li>
<li>较少收集老年代</li>
<li>基本不动永久Perm代（方法区、元空间）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-大厂面试题"><a href="#5-大厂面试题" class="headerlink" title="5.大厂面试题"></a>5.大厂面试题</h3><blockquote>
<ul>
<li><p>有哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1</p>
</li>
<li><p>JVM GC算法有哪些，目前的JDK版本采用什么回收算法</p>
</li>
<li><p>G1回收器讲下回收过程</p>
</li>
<li><p>GC是什么？为什么要有GC</p>
</li>
<li><p>GC的两种判定方法？CMS收集器与G1收集器的特点</p>
</li>
<li><p>说一下GC算法，分代回收说下</p>
</li>
<li><p>垃圾收集策略和算法</p>
</li>
<li><p>垃圾回收算法的实现原理</p>
</li>
<li><p>什么情况下触发垃圾回收</p>
</li>
<li><p>如何选择合适的垃圾收集算法</p>
</li>
<li><p>JVM有哪三种垃圾回收器</p>
</li>
<li><p>system.gc()和runtime.gc()会做什么事情</p>
</li>
<li><p>CMS解决什么问题，说一下回收的过程</p>
</li>
<li><p>CMS回收停顿了几次，为什么要停顿两次</p>
</li>
</ul>
</blockquote>
<h2 id="15-垃圾回收相关算法"><a href="#15-垃圾回收相关算法" class="headerlink" title="15.垃圾回收相关算法"></a>15.垃圾回收相关算法</h2><h3 id="1-标记阶段：引用计数算法"><a href="#1-标记阶段：引用计数算法" class="headerlink" title="1.标记阶段：引用计数算法"></a>1.标记阶段：引用计数算法</h3><blockquote>
<p><strong>垃圾标记阶段：对象存活判断</strong></p>
<ul>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象引用时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：&#x3D;&#x3D;引用计数算法和可达性分析算法&#x3D;&#x3D;</li>
</ul>
</blockquote>
<blockquote>
<p><strong>方式一：引用计数算法</strong></p>
<ul>
<li>引用计数算法（Reference Counting）比较简单，对每个对象&#x3D;&#x3D;保存一个整型的引用计数器属性，用于记录对象被引用的情况。&#x3D;&#x3D;</li>
<li>对于一个对象A,只要有任何一个对象引用了A,则A的引用计数器就加一，当引用失效时，引用计数器就减一。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li>
<li>优点：<ul>
<li>实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性</li>
</ul>
</li>
<li>缺点：<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销</li>
<li>引用计数器有一个致命的问题，即&#x3D;&#x3D;无法处理循环引用&#x3D;&#x3D;的情况，。这是一条致命缺陷，导致在&#x3D;&#x3D;Java的垃圾回收器中没有使用这类算法&#x3D;&#x3D;。【如循环链表中就存在循环引用的情况，会导致内存泄漏，但是举例的时候不要用这个，因为Java中没有采用这种方式】</li>
</ul>
</li>
<li>小结：<ul>
<li>Java并没有选择引用计数，是因为其存在一个基本的半屉，也就是很难处理循环引用关系。</li>
<li>python如何解决循环引用：<ul>
<li>手动解除，很好理解，就是在合适的时机，解除引用关系</li>
<li>使用弱引用weakref,weakref是python提供的标准库，旨在解决循环引用</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//5MB</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceTest1</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceTest1</span>();</span><br><span class="line">        <span class="type">ReferenceTest1</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceTest1</span>();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为,如果是使用的引用计数，则即便进行显式调用gc算法，也不会进行回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-标记阶段：可达性分析算法"><a href="#2-标记阶段：可达性分析算法" class="headerlink" title="2.标记阶段：可达性分析算法"></a>2.标记阶段：可达性分析算法</h3><blockquote>
<p><strong>方式二：可达性分析</strong>（或跟搜索算法、追踪行垃圾收集）</p>
<ul>
<li>相对于引用计数而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以&#x3D;&#x3D;有效地解决在引用计数算法中地循环引用地问题，防止内存泄漏地发生。&#x3D;&#x3D;</li>
<li>相对于引用计数算法，这里地可达性分析就是Java、c#选择地。这种类型的垃圾收集通常也叫做追踪性垃圾收集（Tracing Garbage Collection）</li>
<li>所谓”GC  Roots”跟集合就是一组必须活跃的引用</li>
<li>基本思路：<ul>
<li>可达性分析算法是以跟对象集合（GC Roots）为起始点，按照从上至下的方式搜索&#x3D;&#x3D;被跟对象集合所连接的目标对象是否可达。&#x3D;&#x3D;</li>
<li>使用可达性分析算法后，内存中的存活对象都会被跟对象集合直接或间接连接着，搜索所走过的路径称为引用链（reference chain）</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</li>
<li>在可达性分析算法中，只有能够被跟对象集合直接或间接连接的对象才是存活对象。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>在Java语言中，&#x3D;&#x3D;GC  Roots（指向堆中对象）包括以下几类元素&#x3D;&#x3D;：【面试常考】</p>
<ul>
<li>虚拟机栈中引用的对象：<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈JNI （通常说的本地方法）引用的对象</li>
<li>方法区中常量引用的对象<ul>
<li>比如字符串常量池（String Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如NullPointerException、OutOfMemoryError），系统类加载器</li>
</ul>
</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI注册的回调、本地代码缓存</li>
<li>除了这些固定的GC  Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性的加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）<ul>
<li>如果只针对Java堆中的某一块区域进行垃圾回收(比如：典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
</li>
<li>小技巧：<ul>
<li>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</li>
</ul>
</li>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作就必须在一个能保障一致性的快照中进行，这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致GC进行时必须stop the world的一个重要原因。<ul>
<li>即便时号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-对象的finalization机制"><a href="#3-对象的finalization机制" class="headerlink" title="3.对象的finalization机制"></a>3.对象的finalization机制</h3><blockquote>
<ul>
<li><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供&#x3D;&#x3D;对象被销毁之前的自定义处理逻辑。&#x3D;&#x3D;</p>
</li>
<li><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize( )方法</p>
</li>
<li><p>&#x3D;&#x3D;finalize( )方法允许在子类中被重写，用于在对象被回收时进行资源回收&#x3D;&#x3D;。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
</li>
<li><p>永远不要主动调用某个对象的finalize( )方法，应该交给垃圾回收机制调用，理由包括下面三点：</p>
<ul>
<li>在finalize( )时可能会导致对象复活</li>
<li>finalize( )方法的执行时间是没有保障的，他完全由GC线程决定，极端情况下，若不发生GC,则finalize( )方法将没有执行机会</li>
<li>一个糟糕的finalize( )会严重影响GC的性能</li>
</ul>
</li>
<li><p>从功能上来说，finalize（）方法与c++中的析构函数相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize( )方法在本质上不同于c++中的析构函数</p>
</li>
<li><p>由于finalize( )方法的存在，&#x3D;&#x3D;虚拟机中的对象一般处于三种可能的状态：&#x3D;&#x3D;</p>
<ul>
<li>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了，一般说来，此对象需要被回收。但事实上，也并非是非死不可的，这时候它们暂时处于缓刑阶段。&#x3D;&#x3D;一个无法触及的对象有可能在某一个条件下复活自己&#x3D;&#x3D;，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态，如下：<ul>
<li>&#x3D;&#x3D;可触及的&#x3D;&#x3D;：从根节点开始，可以达到这个对象</li>
<li>&#x3D;&#x3D;可复活的&#x3D;&#x3D;：对象的所有引用都被释放，但是对象有可能在finalize( )中复活</li>
<li>&#x3D;&#x3D;不可触及的&#x3D;&#x3D;：对象的finalize( )被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能复活，因为&#x3D;&#x3D;finalize( )只会被调用一次。&#x3D;&#x3D;</li>
</ul>
</li>
<li>以上三种状态中，是由于finalize( )方法的存在，进行的区分，只有在对象不可触及时才可以被回收</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>具体过程:</p>
<ul>
<li>判断一个对象objA是否可回收，至少要经历两次标记过程：<ol>
<li>如果对象objA到GC Roots没有引用链，则进行第一次标记</li>
<li>进行筛选，判断此对象是否有必要执行finalize( )方法<ol>
<li>如果对象objA没有重写finalize( )方法，或者finalize( )方法已经被虚拟机调用过，则虚拟机视为“没有必要执行” ，objA被判定为不可触及的。</li>
<li>如果对象objA重写了finalize( )方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize( )方法执行</li>
<li>&#x3D;&#x3D;finalize( )方法是对象逃脱死亡的最后机会&#x3D;&#x3D;，稍后GC会对F-Queue队列中的对象进行第二次标记。&#x3D;&#x3D;如果objA在finalize( )方法中与引用链上的任何一个对象建立了联系&#x3D;&#x3D;，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况，&#x3D;&#x3D;在这个情况下，finalize方法不会被再次调用&#x3D;&#x3D;，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次【不管有没有在finalize( )中复活都是一样的】。</li>
</ol>
</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeTest obj;  <span class="comment">//类变量,属于GC Roots</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用房前类重写的finalize方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;  <span class="comment">//当前待回收的对象在finalize（）方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">FinalizeTest</span>();</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            System.out.println(<span class="string">&quot;第一次 GC&quot;</span>);</span><br><span class="line">            <span class="comment">//因为finalizer线程优先级很低，暂停两秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二次GC&quot;</span>);</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//下面这段代码与上面的完全相同，但是这次自救失败了</span></span><br><span class="line">            System.gc();</span><br><span class="line">             <span class="comment">//因为finalizer线程优先级很低，暂停两秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-MAT与JProfile的GC-Roots溯源"><a href="#4-MAT与JProfile的GC-Roots溯源" class="headerlink" title="4.MAT与JProfile的GC Roots溯源"></a>4.MAT与JProfile的GC Roots溯源</h3><blockquote>
<p>类变量也是GC Roots</p>
</blockquote>
<h3 id="5-清除阶段：标记-清除算法"><a href="#5-清除阶段：标记-清除算法" class="headerlink" title="5.清除阶段：标记-清除算法"></a>5.清除阶段：标记-清除算法</h3><blockquote>
<ul>
<li><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存</p>
</li>
<li><p>目前在JVM中比较常见的三种垃圾收集算法是标记-清除算法（Mark-Sweep）、复制算法（Coping）、标记-压缩算法（Mark-Compact）</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>标记清除算法是一种非常基础和常见的垃圾收集算法</p>
</li>
<li><p>执行过程：</p>
<ul>
<li>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</li>
<li>标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象</li>
<li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有被标记为可达对象，则将其回收。</li>
</ul>
</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第14章_标记-清除算法.jpg" alt="第14章_标记-清除算法" style="zoom: 33%;" />

<blockquote>
<p>缺点：</p>
<ul>
<li>效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表</li>
</ul>
<p>&#x3D;&#x3D;注意：何为清除&#x3D;&#x3D;</p>
<ul>
<li>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表。下次有新对象需要加载时，判断垃圾的位置空间是否足够，如果够，就存放。</li>
</ul>
</blockquote>
<h3 id="6-清除阶段：复制算法"><a href="#6-清除阶段：复制算法" class="headerlink" title="6.清除阶段：复制算法"></a>6.清除阶段：复制算法</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第14章_复制算法.jpg" alt="第14章_复制算法" style="zoom:33%;" />

<blockquote>
<p>背景：</p>
<ul>
<li>为了解决标记-清除算法在垃圾收集效率方面的缺陷</li>
</ul>
<p>核心思想：</p>
<ul>
<li>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>没有标记和清除阶段，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片问题”</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>此算法的缺点是明显的，就是需要两倍的内存空间</li>
<li>对于G1这种分拆成大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ul>
<p><strong>特别的：</strong></p>
<ul>
<li>如果系统中的垃圾对象很多，复制算法不会很理想，复制算法需要复制的存活对象数量并不会太大或者说非常低才行。</li>
</ul>
<p>应用场景:</p>
<ul>
<li>在新生代，对常规应用的垃圾回收，一次通常可以回收70% -  90%的内存空间，回收性价比很高。所以现在的商业虚拟机都适用这种收集算法回收新生代。</li>
</ul>
</blockquote>
<h3 id="7-清除阶段：标记-压缩算法"><a href="#7-清除阶段：标记-压缩算法" class="headerlink" title="7.清除阶段：标记-压缩算法"></a>7.清除阶段：标记-压缩算法</h3><blockquote>
<p>背景：</p>
<ul>
<li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，&#x3D;&#x3D;基于老年代垃圾回收的特性，需要使用其他的算法&#x3D;&#x3D;</li>
<li>虽然标记–清除算法可以应用在老年代，但是会产生内存碎片，所以在标记–清除的基础之上进行改进，标记–压缩算法由此诞生。</li>
</ul>
<p>执行过程：</p>
<ul>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放</li>
<li>之后，清理边界外所有空间。</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第14章_标记-压缩算法.jpg" alt="第14章_标记-压缩算法" style="zoom:33%;" />

<blockquote>
<ul>
<li>标记压缩算法的最终效果等同于标记–清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记–清除–压缩算法</li>
<li>二者的本质差异在于标记清除算法是一种非移动式的回收算法，标记压缩算法是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策</li>
<li>可以看到标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了很多开销。</li>
</ul>
<p>优点：</p>
<ul>
<li>消除了标记–清除算法当中，内存区域分散的特点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法房中，内存减半的高额代价</li>
</ul>
<p>缺点：</p>
<ul>
<li>从效率上来说，标记–压缩算法要低于复制算法</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动的过程中，需要全程暂停用户应用程序，即STW</li>
</ul>
</blockquote>
<h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h3><table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的两倍</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存</li>
<li>而为了尽量兼顾上面提到的三个指标，标记–整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记–清除多了一个整理内存的阶段</li>
</ul>
</blockquote>
<h3 id="9-分代收集算法"><a href="#9-分代收集算法" class="headerlink" title="9.分代收集算法"></a>9.分代收集算法</h3><blockquote>
<ul>
<li>前面所有这些算法中，它们都具有自己独特的优势和特点。分代收集算法应运而生。</li>
<li>分代收集算法，是基于这样一个事实，不同的对象的生命周期是不一样的。因此，&#x3D;&#x3D;不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。&#x3D;&#x3D;一般是把Java堆分为新生代和老年代，这样就可以根据哥哥年代的特点使用不同的回收算法，以提高垃圾回收效率。</li>
<li>&#x3D;&#x3D;目前几乎所有的GC都是采用分代收集（Generational Collection）算法执行垃圾回收的&#x3D;&#x3D;</li>
<li>在HotSpot中，基于分代的概念，GC所使用的内存回收算法，必须结合年轻代和老年代各自的特点。<ul>
<li>年轻代：<ul>
<li>特点：区域相对老年代较小，对象生命周期、存活率低、回收频繁。</li>
<li>这种情况复制算法的回收整理，速度是最快的，复制算法的效率只和当前存活对象有关，因此很适用于年轻代的回收，而复制算法内存利用率不高的问题，通过Hotspot中的两个survivor的设计得到缓解。</li>
</ul>
</li>
<li>老年代：<ul>
<li>特点：区域较大、对象生命周期长、存活率高，回收不及年轻代频繁。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除与标记整理（压缩）的混合实现<ul>
<li>Mark阶段的开销与存活对象的数量成正比</li>
<li>Sweep阶段的开销与所管理区域的大小成正比</li>
<li>Caompact阶段的开销与存活对象的数据成正比</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在Hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施;当内存回收不佳（碎片导致的Concurrent MOde Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理</li>
</ul>
</blockquote>
<h3 id="10-增量收集算法、分区算法"><a href="#10-增量收集算法、分区算法" class="headerlink" title="10.增量收集算法、分区算法"></a>10.增量收集算法、分区算法</h3><blockquote>
<p>增量收集算法：</p>
<ul>
<li>上述现有的算法，在垃圾回收的过程中，应用软件会处理一种stoop the world的状态，在stop the world的状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。&#x3D;&#x3D;如果 垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性&#x3D;&#x3D;。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集算法。</li>
<li>基本思想：<ul>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，&#x3D;&#x3D;垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。&#x3D;&#x3D;</li>
<li>总的来说，增量收集算法的基础仍然是标记清除算法和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</li>
</ul>
</li>
<li>缺点：<ul>
<li>使用这种方式，由于在垃圾回收过程中，间断性地还执行应用程序代码，所以能减少系统的停顿时间。但是，&#x3D;&#x3D;因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>分区算法：</p>
<ul>
<li>一般说来，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长，为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li>
<li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小空间</li>
<li>每一个小区间都独立使用，独立回收，这种算法的好处是可以控制一次回收多少个小区间</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>上面这些只是基本的算法思路，实际GC实现过程中要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</li>
</ul>
</blockquote>
<h2 id="16-垃圾回收相关概念"><a href="#16-垃圾回收相关概念" class="headerlink" title="16.垃圾回收相关概念"></a>16.垃圾回收相关概念</h2><h3 id="1-System-gc（）的理解"><a href="#1-System-gc（）的理解" class="headerlink" title="1.System.gc（）的理解"></a>1.System.gc（）的理解</h3><blockquote>
<ul>
<li><p>在默认情况下，通过System.gc( )或者Runtime.getRuntime( ).gc()的调用，&#x3D;&#x3D;会显式触发Full GC，&#x3D;&#x3D;同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
</li>
<li><p>然而System.gc（）调用附带一个免责声明，无法保证对垃圾收集器的调用。</p>
</li>
<li><p>JVM实现者可以通过System.gc( )调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无需手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之前调用System.gc( )</p>
</li>
</ul>
</blockquote>
<h3 id="2-内存溢出与内存泄漏"><a href="#2-内存溢出与内存泄漏" class="headerlink" title="2.内存溢出与内存泄漏"></a>2.内存溢出与内存泄漏</h3><blockquote>
<p>内存溢出：</p>
<ul>
<li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用</li>
<li>javadoc中对OutOfMemoryError的解释是，&#x3D;&#x3D;没有空闲内存，并且垃圾收集器也无法提供更多内存。&#x3D;&#x3D;</li>
<li>没有空闲内存的情况，说明Java虚拟机的堆内存不够，原因有二：<ul>
<li>Java虚拟机的堆内存设置不够：<ul>
<li>比如，可能存在内存泄漏问题，也很有可能就是堆的大小设置不合理，可以通过参过参数 -Xms,-Xmx来调整。</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>
</ul>
</li>
</ul>
</li>
<li>在抛出OOM之前，通常垃圾收集器会被触发，尽其所能去清理出空间<ul>
<li>例如，在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</li>
<li>在java.nio.Bits.reserveMemory( )方法中，我们能清楚的看到，System.gc( )会被调用，以清理空间</li>
</ul>
</li>
<li>当然，也不是在任何情况下垃圾收集器都会被触发<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题。所以直接抛出OOM.</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>内存泄漏：</p>
<ul>
<li>&#x3D;&#x3D;严格来说&#x3D;&#x3D;，只有对象不会再被程序用到了，但是GC又不能回收它们的情况，才叫内存泄漏</li>
<li>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM,也可以叫做&#x3D;&#x3D;宽泛意义上的内存泄漏。&#x3D;&#x3D;</li>
<li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OOM异常，导致程序崩溃</li>
<li>注意：这里的存储空间并不是指物理内存，而是指虚拟机内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li>
<li>举例：<ul>
<li>单例模式：单例的生命周期和应用程序一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生</li>
<li>一些提供close的资源未关闭导致内存泄漏<ul>
<li>数据库连接（datasource.getConnection）,网络连接（socket）和io连接必须手动close,否则是不能被回收的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-Stop-The-World"><a href="#3-Stop-The-World" class="headerlink" title="3.Stop The  World"></a>3.Stop The  World</h3><blockquote>
<ul>
<li>简称STW,指的是GC事件发生过程中，会产生应用程序的停顿，停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW.<ul>
<li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行程序停顿<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li>&#x3D;&#x3D;如果出现分析过程中对象引用关系还在不断发生变化，则分析结果的准确性无法保证&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</li>
<li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不断造成电影卡带一样，所以我们需要减少STW的发生。</li>
<li>STW事件和采用哪款GC无关，所有的GC都有这个实践</li>
<li>哪怕是G1收集器也不能完全避免STW情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间</li>
<li>STW是JVM在后台自动发起和自动完成地。在用户不可见地情况下，把用户正常地工作线程全部停掉。</li>
<li>开发中不要用System.gc( ),会导致Stop-the-world地发生</li>
</ul>
</blockquote>
<h3 id="4-垃圾回收的并行与并发"><a href="#4-垃圾回收的并行与并发" class="headerlink" title="4.垃圾回收的并行与并发"></a>4.垃圾回收的并行与并发</h3><blockquote>
<p>并发：</p>
<ul>
<li>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li>
<li>并发不是真正意义上地同时进行，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理地速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时运行。</li>
</ul>
</blockquote>
<blockquote>
<p>并行：</p>
<ul>
<li>当系统有一个以上CPU时，当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）</li>
<li>其实决定并行地因素并不是CPU地数量，而是CPU地核心数量，比如一个CPU多个核也可以并行。</li>
<li>适合科学计算，后台处理等弱交互场景</li>
</ul>
</blockquote>
<blockquote>
<p>二者对比：</p>
<ul>
<li><p>并发：指的是多个事情，在同一时间段内同时发生了</p>
</li>
<li><p>并行：指的是多个事情，在同一时间点上同时发生了</p>
</li>
<li><p>并发地多个任务之间是互相抢占资源的</p>
</li>
<li><p>并行地多个人物之间是不互相抢占资源地</p>
</li>
<li><p>只有在多CPU或者一个CPU多核地情况中，才会发生并行，否则看似同时发生地事情，其实都是并发执行的。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>垃圾回收的并发与并行：</p>
<ul>
<li>在讨论垃圾收集器的上下文语境中，它们可以解释为：</li>
<li>并行（Parallel）&#x3D;&#x3D;:指多条垃圾收集线程并行工作&#x3D;&#x3D;，但此时用户线程仍处于等待状态，<ul>
<li>如ParNew,Parallel Scavenge,Parallel Old</li>
</ul>
</li>
<li>串行（Serial）:<ul>
<li>相较于并行的概念，单线程执行</li>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
</li>
<li>并发（Concurrent）：<ul>
<li>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行<ul>
<li>用户程序再继续运行，而垃圾收集程序线程运行于另一个CPU上</li>
<li>如：CMS,G1</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-安全点与安全区域"><a href="#5-安全点与安全区域" class="headerlink" title="5.安全点与安全区域"></a>5.安全点与安全区域</h3><blockquote>
<p>安全点：</p>
<ul>
<li>程序执行时，并非所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC,这些位置称为“安全点（safepoint）”</li>
<li>safepoint的选择很重要，如果太少可能会导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“&#x3D;&#x3D;是否具有让程序长时间执行的特征为标准&#x3D;&#x3D;。”比如：&#x3D;&#x3D;选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<blockquote>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<ul>
<li>抢先式中断：（目前没有虚拟机采用了）<ul>
<li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点</li>
</ul>
</li>
<li>主动式中断：<ul>
<li>设置一个中断标志，各个线程运行到Safe  Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>安全区域(Safe region)：</p>
<ul>
<li><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序不执行的时候呢？例如线程处于Sleep状态或blocked状态，这时候线程无法响应JVM的中断请求，走到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域来解决。</p>
</li>
<li><p>&#x3D;&#x3D;安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的，&#x3D;&#x3D;我们可以把safe  region看作是被扩展了的Safepoint</p>
</li>
<li><p>实际执行时，</p>
<ul>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC,JVM会忽略标识为Safe Region状态的线程</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC,如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="6-再谈引用：强引用"><a href="#6-再谈引用：强引用" class="headerlink" title="6.再谈引用：强引用"></a>6.再谈引用：强引用</h3><blockquote>
<ul>
<li>我们希望能描述这样一类对象，当内存空间还足够的时候，则能保留在内存中，如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</li>
<li>&#x3D;&#x3D;偏门但热门的面试题：&#x3D;&#x3D;<ul>
<li>&#x3D;&#x3D;强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？&#x3D;&#x3D;</li>
</ul>
</li>
<li>在jdk1.2版本之后，Java对引用的的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种，这四种引用强度逐渐减弱</li>
<li>除强引用外，其他三种引用均可以在java.lang.ref包中找到它们的身影，下图显式了这三种引用类型对应的类，开发人员可以直接使用它们。</li>
<li><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220510091527332.png" alt="image-20220510091527332"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Reference子类中只有终结器引用（FinalReference）是包内可见的，其他三种引用类型均为public，可以在应用程序中直接使用。<ul>
<li>强引用：最传统的引用的定义，是指在程序代码中普遍存在的引用赋值，即类似Object obj &#x3D; new Object();这种引用关系，&#x3D;&#x3D;无论在何种情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象。&#x3D;&#x3D;</li>
<li>软引用：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。【内存就回收，够就不回收】【缓存中使用】</li>
<li>弱引用：被软引用关联的对象只能生存到下一次垃圾收集前，&#x3D;&#x3D;当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象&#x3D;&#x3D;【缓存中使用】</li>
<li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来获得一个对象的实例。&#x3D;&#x3D;为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知&#x3D;&#x3D;【用于对象被回收的跟踪】</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><font color='red'>强引用：</font></p>
<ul>
<li>Java程序中，最常见的引用类型就是强引用，也就是最常见的普通对象引用，也是默认的引用类型。</li>
<li>&#x3D;&#x3D;强引用的对象是可触及的，垃圾回收器就永远不会回收这个引用指向的对象&#x3D;&#x3D;</li>
<li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强)引用赋值为null,就是可以被当作垃圾被收集了，当然具体回收实际要看垃圾回收策略。</li>
<li>相对地，软引用、弱引用和虚引用的对象都是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的，所以，&#x3D;&#x3D;强引用是造成Java内存泄漏的主要原因之一。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="7-再谈引用：软引用"><a href="#7-再谈引用：软引用" class="headerlink" title="7.再谈引用：软引用"></a>7.再谈引用：软引用</h3><blockquote>
<ul>
<li><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
</li>
<li><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列。</p>
</li>
<li><p>类似弱引用，只不过Java虚拟机会尽量让软引用地存活时间长一些，迫不得已才清理。</p>
</li>
<li><p>内存不够时，不会回收软引用指向地对象。当内存不够时，会回收软引用地可达对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj); <span class="comment">//此时结束Object对象有一个强引用obj,和一个软引用sf</span></span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">//销毁强引用</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//上面的代码等价于下面代码</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">Objent</span>());</span><br><span class="line">  </span><br><span class="line"><span class="comment">//通过软引用获取对象</span></span><br><span class="line">sf.get();  <span class="comment">//可以获取到new Object()这个对象，如果在报OOM之前，就要回收软引用指向的对象  </span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-Xms30m -Xmx30m -XX:+PrintGCDetails  参数设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">int</span>[]&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>]); <span class="comment">//8M</span></span><br><span class="line">        sf.get()[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        System.out.println(sf.get());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//16M</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(sf.get());</span><br><span class="line">            System.out.println(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-再谈引用：弱引用"><a href="#8-再谈引用：弱引用" class="headerlink" title="8.再谈引用：弱引用"></a>8.再谈引用：弱引用</h3><blockquote>
<ul>
<li><p>弱引用也是用来描述那些非必需对象，&#x3D;&#x3D;只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。&#x3D;&#x3D;在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</p>
</li>
<li><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快的发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间</p>
</li>
<li><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
</li>
<li><p>&#x3D;&#x3D;弱引用、软引用都非常适合来保存那些可有可无的缓存数据。&#x3D;&#x3D;如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长时间，从而起到加速系统的作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj); <span class="comment">//此时结束Object对象有一个强引用obj,和一个弱引用wf</span></span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">//销毁强引用</span></span><br><span class="line"></span><br><span class="line">wf.get()  获取引用指向的对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用对象与软引用对象的最大不同就在于：当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收，弱引用对象更容易、更快被GC回收</p>
</li>
<li><p>面试题：你开发中使用过WeakHashMap</p>
</li>
</ul>
</blockquote>
<h3 id="9-再谈引用：虚引用"><a href="#9-再谈引用：虚引用" class="headerlink" title="9.再谈引用：虚引用"></a>9.再谈引用：虚引用</h3><blockquote>
<ul>
<li>虚引用（Phantom Reference）——对象回收跟踪</li>
<li>也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个</li>
<li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时可能被垃圾回收器回收</li>
<li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当时图通过虚引用的get()方法获取对象时，总是null。</li>
<li>&#x3D;&#x3D;为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;虚引用必须和引用队列一起使用&#x3D;&#x3D;。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，&#x3D;&#x3D;将这个虚引用加入引用队列，以通知应用程序对象的回收情况。&#x3D;&#x3D;</li>
<li>由于虚引用可以跟踪对象的回收时间，因此也可以将一些资源释放操作放置在虚引用中执行和记录。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomTest obj;</span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomTest&gt; phantomQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = ((PhantomReference) phantomQueue.remove());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程，PhantomTest实例被回收了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>); <span class="comment">//设置为守护线程，就是主线程不关闭，就也一直不关闭。当程序中没有非守护线程时，守护线程也就结束。垃圾回收线程也是守护线程</span></span><br><span class="line">        t.start(); <span class="comment">//开启守护线程</span></span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;PhantomTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomTest</span>();</span><br><span class="line">        <span class="comment">//构造了PhantomTest对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomTest&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj,phantomQueue);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可通过虚引用来获取引用指向的对象</span></span><br><span class="line">            System.out.println(phantomReference.get());</span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是可用的&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是可用的&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-再谈引用：终结器引用-了解即可"><a href="#10-再谈引用：终结器引用-了解即可" class="headerlink" title="10.再谈引用：终结器引用(了解即可)"></a>10.再谈引用：终结器引用(了解即可)</h3><blockquote>
<p>终结器引用：FinalReference</p>
<ul>
<li>它用以实现对象的finalize()方法，也可以称为终结器引用</li>
<li>无需手动编码，其内部配合引用队列使用</li>
<li>在GC时，终结器引用入队，由Finallizer线程通过终结器引用找到被引用对象并调用它的finalize( )方法，第二次GC时才能回收被引用对象。</li>
</ul>
</blockquote>
<h2 id="17-垃圾回收器"><a href="#17-垃圾回收器" class="headerlink" title="17.垃圾回收器"></a>17.垃圾回收器</h2><h3 id="1-GC分类与性能指标"><a href="#1-GC分类与性能指标" class="headerlink" title="1.GC分类与性能指标"></a>1.GC分类与性能指标</h3><blockquote>
<p><font color='red'>垃圾回收器概述：</font></p>
<ul>
<li>从不同角度分析垃圾收集器，可以将GC分为不同的类型<ul>
<li>按线程数（指的是执行垃圾回收的线程）<ul>
<li>串行回收</li>
<li>并行回收</li>
</ul>
</li>
<li>按照工作模式分<ul>
<li>并发式垃圾回收器<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li>
</ul>
</li>
<li>独占式垃圾回收器<ul>
<li>独占式垃圾回收器（stop the world）一旦运行,就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li>
</ul>
</li>
</ul>
</li>
<li>按碎片处理方式分：<ul>
<li>压缩式垃圾回收器<ul>
<li>在垃圾回收完成后，对存活对象进行压缩整理，清除回收后的碎片</li>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li>非压缩式垃圾回收器<ul>
<li>非压缩式的垃圾回收器不进行这步操作</li>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
</ul>
</li>
<li>按工作的内存区间分：<ul>
<li>年轻代垃圾回收器</li>
<li>老年代垃圾回收器</li>
</ul>
</li>
</ul>
</li>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>
<li>串行回收默认默认被应用在客户端的Client模式下的JVM中</li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li>
</ul>
</li>
<li>和串行回收相反。并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop the world”机制</li>
</ul>
<p><font color='red'>评估GC的性能指标：</font></p>
<ul>
<li>&#x3D;&#x3D;吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间&#x3D; 程序的运行时间 + 内存回收的时间）&#x3D;&#x3D;</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间占总运行时间的比例</li>
<li>&#x3D;&#x3D;暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间&#x3D;&#x3D;</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率</li>
<li>&#x3D;&#x3D;内存占用：Java堆区所占的内存大小&#x3D;&#x3D;</li>
<li>快速：一个对象从诞生到被回收所经历的时间</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>吞吐量、暂停时间、内存占用这三者共同构成一个不可能三角，三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项</p>
</li>
<li><p>在实际过程中，主要&#x3D;&#x3D;抓吞吐量、暂停时间这两点&#x3D;&#x3D;，因为内存占用随着硬件性能发展而能够有所改善</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>吞吐量：</p>
<ul>
<li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;(运行用户代码时间 + 垃圾收集时间)<ul>
<li>比如：虚拟机总共运行100分钟，其中垃圾收集花掉一分钟，那吞吐量就是99%</li>
</ul>
</li>
<li>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</li>
<li>吞吐量优先，意味着单位时间内，STW的时间最短</li>
</ul>
<p>暂停时间：</p>
<ul>
<li>暂停时间是指一个时间段内应用程序线程暂停，让GC线程执行的状态</li>
<li>暂停时间优先，意味着尽可能让单次STW的时间最短：</li>
</ul>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第17章_吞吐量与暂停时间.jpg" alt="第17章_吞吐量与暂停时间" style="zoom: 33%;" />

<ul>
<li>红色表示暂停时间或者垃圾回收时间，蓝色表示应用程序线程执行时间</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>&#x3D;&#x3D;高吞吐量&#x3D;&#x3D;较好因为这会让应用程序的最终用户感觉只有应用程序线程在做生产性工作，直觉上，吞吐量越高程序运行越快。</li>
<li>&#x3D;&#x3D;低暂停时间&#x3D;&#x3D;（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，&#x3D;&#x3D;有时候甚至短暂的200毫秒暂停都可能打断终端用户体验&#x3D;&#x3D;。因此，具有低的较大暂停时间是非常重要的，&#x3D;&#x3D;特别是对于一个交互式应用程序。&#x3D;&#x3D;</li>
<li>不幸的是高吞吐量和低暂停时间是一对相互竞争的目标（矛盾）<ul>
<li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
</li>
<li>一个GC算法只能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</li>
<li>现在的标准：&#x3D;&#x3D;在最大吞吐量优先的情况下，降低停顿时间。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="2-不同的垃圾回收器概述"><a href="#2-不同的垃圾回收器概述" class="headerlink" title="2.不同的垃圾回收器概述"></a>2.不同的垃圾回收器概述</h3><blockquote>
<p>&#x3D;&#x3D;面试题：Java常见的垃圾收集器有哪些？&#x3D;&#x3D;</p>
<ul>
<li>串行回收器：Serial&#x2F;Serial old  （这里地串行指地是单个垃圾收集线程）</li>
<li>并行回收器：ParNew，Parallel Scavenge，Parallel  Old  （并行指的是多个垃圾收集线程，如果有多个CPU或单个CPU多核话，就可以充分利用这些物理硬件地资源。如果是单核地话，则多个垃圾收集线程是并发执行，在执行过程中会发生任务切换，资源竞争）</li>
<li>并发回收器：CMS,G1（这里的并发是指在进行垃圾收集时，让垃圾收集线程与用户应用程序线程并发执行)</li>
</ul>
<p><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第17章_经典的7种GC.jpg" alt="第17章_经典的7种GC"></p>
</blockquote>
<blockquote>
<ul>
<li>新生代收集器：Serial、ParNew、Parallel  Scavenge</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS</li>
<li>整堆收集器：G1</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端、服务器，所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾回收性能。</li>
<li>虽然我们会对哥哥收集器进行比较，但是并非为了挑选一个最好的垃圾收集器出来，没有这样一个完美方案，所以&#x3D;&#x3D;我们选择的只是对具体应用场景最合适的收集器。&#x3D;&#x3D;</li>
</ul>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第17章_垃圾收集器组合.jpg" alt="第17章_垃圾收集器组合" style="zoom:33%;" />

<ul>
<li><p>虚线是在jdk 8之后被弃用的组合。</p>
</li>
<li><p>实线表示在在jdk8中还在使用的</p>
</li>
<li><p>在jdk8中,使用的是 Parallel Scavenge GC(parallel GC)与Parallel old  GC搭配</p>
</li>
<li><p>在jdk9中则使用的是G1GC</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><font color='red'>如何查看默认的垃圾收集器：</font></p>
<ul>
<li>-XX:+PrintCommandLineFlags:擦好看命令行相关参数（包含使用的垃圾收集器）</li>
<li>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</li>
</ul>
</blockquote>
<h3 id="3-Serial回收器：串行回收"><a href="#3-Serial回收器：串行回收" class="headerlink" title="3.Serial回收器：串行回收"></a>3.Serial回收器：串行回收</h3><blockquote>
<ul>
<li><p>Serial收集器作为Hotspot中client模式下的默认新生代垃圾收集器</p>
</li>
<li><p>&#x3D;&#x3D;Serial收集器采用复制算法，串行回收和Stop the world机制的方式执行内存回收&#x3D;&#x3D;</p>
</li>
<li><p>除了年轻代以外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。&#x3D;&#x3D;Serial Old收集器同样也采用了串行回收和stop the world机制，只不过内存回收算法使用的是标记压缩算法&#x3D;&#x3D;</p>
<ul>
<li>serial old是运行在client模式下默认的老年代的垃圾回收器</li>
<li>serial old在server模式下主要有两个用途，①与新生代的parallel scavenge 配合使用。②作为老年代CMS收集器的后背垃圾收集方案</li>
</ul>
</li>
<li><p>这个收集器是一个单线程的收集器，但它的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop the world）。</p>
</li>
<li><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在Client模式下的虚拟机是个不错的选择</li>
</ul>
</li>
<li><p>在HotSpot虚拟机中，使用 -XX:+UseSerialGC参数可以指定年轻代和老年代都适用串行收集器</p>
<ul>
<li>等价于 新生代使用 Serial GC，老年代使用 Serial Old GC</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>这种垃圾收集器了解即可，现在用的比较少，而且在限定单核cpu才可以用，现在都不是单核的了</li>
<li>对于交互较强的应用而言，这种垃圾收集器是不能接受的，一般在Java Web应用程序中是不会采用串行垃圾收集器的</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4-ParNew回收器：并行回收"><a href="#4-ParNew回收器：并行回收" class="headerlink" title="4.ParNew回收器：并行回收"></a>4.ParNew回收器：并行回收</h3><blockquote>
<ul>
<li>如果说Serial GC是年轻代 中的单线程垃圾收集器，那么在ParNew收集器则是Serial收集器的多线程版本<ul>
<li>Par是Parallel的缩写，New：只能处理的是新生代</li>
</ul>
</li>
<li>ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、“Stop the world”机制</li>
<li>ParNew是很多JVM运行在Server模式下新生代的默认垃圾回收器。</li>
<li>对于新生代，回收次数频繁，使用并行方式高效</li>
<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li>
<li>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的收集效率在任何场景下都会比Serial收集器高效呢？<ul>
<li>不一定，因为在单CPU的环境下，ParNew收集器不比Serial收集器更高效，虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生地一些额外开销。</li>
</ul>
</li>
<li>在程序中，开发人员可以通过选项 -XX:+UseParNewGC手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代</li>
<li>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同地线程数。</li>
</ul>
</blockquote>
<h3 id="5-Parallel回收器：吞吐量优先"><a href="#5-Parallel回收器：吞吐量优先" class="headerlink" title="5.Parallel回收器：吞吐量优先"></a>5.Parallel回收器：吞吐量优先</h3><blockquote>
<ul>
<li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了&#x3D;&#x3D;复制算法，并行回收和Stop the world机制&#x3D;&#x3D;</p>
</li>
<li><p>那么Parallel收集器的出现是否多此一举呢？</p>
<ul>
<li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个&#x3D;&#x3D;可控制的吞吐量&#x3D;&#x3D;（Throughput），它也被称为吞吐量优先的垃圾收集器</li>
<li>自适应调节策略也是Parallel Scavenge与ParNew的一个重要区别</li>
</ul>
</li>
<li><p>高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，&#x3D;&#x3D;主要适合在后台运算而不需要太多交互的任务&#x3D;&#x3D;。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>Parallel 收集器在jdk1.6时提供了用于执行老年代收集的Parallel Old收集器，用来代替老年代的Serial Old收集器</p>
</li>
<li><p>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和stop the world机制</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在程序吞吐量优先的场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错</li>
<li>在Java 8中，默认也是此垃圾收集器</li>
</ul>
<p><font color='red'>参数配置：</font></p>
<ul>
<li>-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务</li>
<li>-XX:+UseParallelOldGC 手动指定老年代都是使用并行回收收集器<ul>
<li>分别适用于新生代和老年代。默认jdk8是开启的</li>
<li>上面两个参数，默认开启一个，另一个也会被开启（互相激活）</li>
</ul>
</li>
<li>-XX:ParallelGCThreads:设置年轻代并行收集器的线程数，一般地，最好与CPU数量相等，以避免过多的线程数量影响垃圾收集性能<ul>
<li>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</li>
<li>当CPU数量大于8个时，ParallelGCThreads的值等于 （3+【5*CPU_count】&#x2F;8）</li>
</ul>
</li>
<li>-XX：MaxGCPauseMillis设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。<ul>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMillis以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好，但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制</li>
<li>该参数使用需谨慎。</li>
</ul>
</li>
<li>-XX:GCTimeRatio 垃圾收集时间占总时间的比例用于衡量吞吐量的大小<ul>
<li>取值范围（0，100）.默认值是99，也就是垃圾回收时间不超过1%</li>
<li>与前一个-XX:MaxGCPauseMills参数有一定矛盾性。暂停时间越长，Ratio参数就越容易超过设定的比例。</li>
</ul>
</li>
<li>-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节能力<ul>
<li>在这种模式下，年轻代的大小、Eden和survivor的比例、晋升老年代的对象年龄（阈值）等参数会被自动调整，以此来达到堆大小、吞吐量和停顿时间之间的平衡点</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="6-CMS回收器：低延迟"><a href="#6-CMS回收器：低延迟" class="headerlink" title="6.CMS回收器：低延迟"></a>6.CMS回收器：低延迟</h3><blockquote>
<ul>
<li><p>在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可以认为有划时代意义的垃圾收集器，CMS(Concurrent Mark Sweep)收集器，&#x3D;&#x3D;这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作&#x3D;&#x3D;</p>
</li>
<li><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li>目前很大一部分的Java应用集中在互联网网站或者B&#x2F;S系统的服务器上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验，CMS收集器就非常适合这类应用的需求。</li>
</ul>
</li>
<li><p>CMS的垃圾收集算法采用&#x3D;&#x3D;标记-清除&#x3D;&#x3D;算法，并且也会stop the world（只是尽可能地减短stw的时间）</p>
</li>
<li><p>CMS作为老年代的收集器，却无法与jdk1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在jdk1.5使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个</p>
</li>
<li><p>在G1（jdk9中开始成为默认的垃圾回收器）出现之前，CMS的使用还是比较广泛的（在jdk14中就被永久去除了）</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p>
<ul>
<li>初始标记阶段（Initial Mark）:在这个阶段中，程序中所有的工作线程都将会因为stop the world机制而出现短暂的暂停，这个阶段的主要任务&#x3D;&#x3D;仅仅只是标记出GC Roots能直接关联到的对象&#x3D;&#x3D;。一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里的速度比较快。</li>
<li>并发标记阶段（Concurrent Mark）：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要暂停用户线程，可以与垃圾手机线程一起并发执行。</li>
<li>重新标记阶段（Remark）:由于在&#x3D;&#x3D;并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或交叉运行（）&#x3D;&#x3D;，因此为了修正并发标记期间，因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>并发清除阶段：此阶段清理删掉标记阶段判断的已经死亡的对象，释放内存空间，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>尽管CMS收集器采用的是并发回收（非独占式），&#x3D;&#x3D;但是在其初始化标记和再次标记这两个阶段中仍然需要执行Stop the world机制&#x3D;&#x3D;暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop the world”,只是尽可能地缩短暂停时间</li>
<li>&#x3D;&#x3D;由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。&#x3D;&#x3D;</li>
<li>另外，由于在垃圾收集阶段用户线程没有中断，&#x3D;&#x3D;所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用&#x3D;&#x3D;。因此CMS收集器不能像其他收集器那样，等到老年代几乎完全被填满了再进行收集，而是&#x3D;&#x3D;当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行&#x3D;&#x3D;。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次Concurrent  Mode  Failure失败，这时虚拟机将启动后备预案，临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
<li>由于CMS垃圾收集器采用的&#x3D;&#x3D;是标记-清除算法&#x3D;&#x3D;，所以不可避免的&#x3D;&#x3D;会产生一些内存碎片&#x3D;&#x3D;。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞技术，而只能够选择空闲列表（Free List）执行内存分配。</li>
<li>有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？<ul>
<li>因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提是它运行的资源不受影响。Mark Compact更适合Stop the world这种场景下使用。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>CMS的优点：</p>
<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<p>CMS的弊端：</p>
<ul>
<li>会产生内存碎片。导致并发清除后，用户线程可用的空间不足，在无法分配大对象的情况下，不得不提前触发Full GC</li>
<li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低</li>
<li>CMS收集器无法处理浮动垃圾。可能出现Concurrent Mode Failure失败而导致另一次Full GC产生，在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在进行下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ul>
</blockquote>
<blockquote>
<p>CMS收集器可以设置的参数：</p>
<ul>
<li>-XX:+UseConcMarkSweepGC 手动指定使用CMS收集器执行内存回收任务<ul>
<li>开启该参数后会自动将 -XX:+UseParNewGC打开，&#x3D;&#x3D;即：ParNew(young区使用)+CMS(old区使用)+Serial Old （old区备用）的组合&#x3D;&#x3D;</li>
</ul>
</li>
<li>-XX:CMSInitiatingOccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。<ul>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。&#x3D;&#x3D;JDK6及以上版本默认值为92%&#x3D;&#x3D;</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序中内存使用率增长很快，则应该降低这个阈值，以避免频繁地触发老年代串行收集器，因此通过该选项便可以有效降低Full GC的执行次数</li>
</ul>
</li>
<li>-XX:+UseCMSCompactAtFullCollection 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并行执行，所带来的问题就是停顿时间更长了。</li>
<li>-XX:CMSFullGCsBeforeCompaction 设置在执行多少次Full GC后对内存空间进行压缩整理。</li>
<li>-XX:ParallelCMSThreads:设置CMS的线程数量<ul>
<li>CMS默认启动的线程数量是（ParallelGCThreads + 3）&#x2F;4</li>
<li>ParallelGCThreads 是年轻代并行执行收集器的线程数。当CPU资源比较紧张的时候，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>小结：</p>
<p>怎样进行选择这些垃圾回收器呢？</p>
<ul>
<li>如果想要最小化地使用内存和并行开销，则选Serial GC</li>
<li>如果想要最大化应用程序地吞吐量，请选择Parallel GC</li>
<li>如果你想要最小化GC的中断或停顿时间，请选CMS GC</li>
</ul>
<p>新特性：</p>
<ul>
<li>jdk 9新特性：CMS被标记为Deprecate了<ul>
<li>可以继续用，但是会有警告</li>
</ul>
</li>
<li>jdk14新特性：删除了CMS垃圾收集器<ul>
<li>会报警告信息，不能用会自动按照该版本下的GC来进行使用。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="7-G1回收器：区域化分代式"><a href="#7-G1回收器：区域化分代式" class="headerlink" title="7.G1回收器：区域化分代式"></a>7.G1回收器：区域化分代式</h3><blockquote>
<ul>
<li><p>问题：既然已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）GC?</p>
<ul>
<li>回答：应用程序所对应的业务越来越庞大，复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化，，于是就有了G1 GC。</li>
<li>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量</li>
<li>官方给G1设定的目标是在延迟可控的情况i下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</li>
</ul>
</li>
<li><p>为什么名字叫Garbage First（G1）呢？</p>
<ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）(物理上不连续)。使用不同的region来表示Eden、幸存者0区，幸存者1区，老年代等</li>
<li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，&#x3D;&#x3D;每次根据允许的收集时间，优先回收价值最大的region&#x3D;&#x3D;</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region）,所以我们给G1一个名字：垃圾优先（Garbage First）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>G1是一款面向服务端应用的垃圾回收器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时。还兼顾高吞吐量的性能特征</li>
<li>在JDK1.7版本正式启用，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel + Parallel Old组合组合，被Oracle官方称为全功能的垃圾收集器。与此同时，CMS已经在JDK9中被标记为废弃。</li>
<li>G1 GC在JDK8中还不是默认的垃圾回收器，需要使用 -XX:+UseG1GC来启用</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>与其他垃圾回收器相比，&#x3D;&#x3D;G1使用了全新的分区算法，其特点&#x3D;&#x3D;如下所示：<ul>
<li>&#x3D;&#x3D;并行与并发：&#x3D;&#x3D;<ul>
<li>并行性：G1在回收期间，可以有多个线程同时工作，有效利用多核计算能力，此时用户线程STW.</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作也可以和应用程序同时执行，因此，一般说来，不会在整个回收阶段发生完全阻塞应用程序的情况。</li>
</ul>
</li>
<li>&#x3D;&#x3D;分代收集：&#x3D;&#x3D;<ul>
<li>从分代上看，&#x3D;&#x3D;G1依然属于分代型垃圾收集器&#x3D;&#x3D;，它会区分年轻代和老年代，年轻代依然有Eden区和survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量</li>
<li>&#x3D;&#x3D;将堆空间分为若干个区域，这些区域包含了逻辑上的年轻代和老年代&#x3D;&#x3D;</li>
<li>和之前的各类收集器不同，它同时兼顾年轻代和老年代，对比其他回收器，或者工作在年轻代，或者工作在老年代</li>
</ul>
</li>
<li>&#x3D;&#x3D;空间整合：&#x3D;&#x3D;<ul>
<li>CMS：标记清除算法，内存碎片，若干次GC后进行一次碎片整理。</li>
<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看做是标记压缩算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC.尤其当Java堆非常大的时候，G1的优势就更加明显。</li>
</ul>
</li>
<li>&#x3D;&#x3D;可预测的停顿时间模型：&#x3D;&#x3D;（即：软实时soft real-time）<ul>
<li>G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个 长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N 毫秒</li>
<li>由于分区的原因，G1可以只选择部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），&#x3D;&#x3D;在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region.保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。&#x3D;&#x3D;</li>
<li>相对于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
</li>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负担都要比CMS要高</li>
<li>从经验上来看，在小内存应用上CMS的表现大概率会优于G1,而G1在大内存应用上则发挥其优势，平衡点在6—8G。</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收器的参数设置：</p>
<ul>
<li>-XX:+UseG1GC	手动指定使用G1回收器执行内存回收任务</li>
<li>-XX:+G1HeapRegionSize    设置每个region的大小，值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000</li>
<li>-XX:MaxGCPauseMillis    设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是200ms.</li>
<li>-XX:ParallelGCThreads    设置STW工作线程数的值，最多设置为8</li>
<li>-XX:ConcGCThreads    设置并发标记的线程数，将n设置为并行垃圾回收线程数（ParallelGCThreads）的1&#x2F;4</li>
<li>-XX:InitiatingHeapOccupancyPercent    设置触发并发GC周期的Java堆占用率阈值，超过此值，就触发GC.默认值是45</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收器的常见操作步骤：</p>
<ul>
<li>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优<ul>
<li>开启G1垃圾回收器</li>
<li>设置堆的最大内存</li>
<li>设置最大的停顿时间</li>
</ul>
</li>
<li>G1中提供了三种垃圾回收模式：&#x3D;&#x3D;YoungGC, Mixed GC, Full Gc,&#x3D;&#x3D;在不同的条件下触发。</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收器的适用场景：</p>
<ul>
<li>面向服务端应用，针对具有大内存，多处理器的机器（在普通大小的堆里表现并不惊喜）</li>
<li>最主要的应用是需要低延迟，并具有大堆的应用程序提供解决方案</li>
<li>用来替换掉JDK1.5中的CMS收集器。在下面的情况时，使用G1可能比CMS好。<ul>
<li>超过50%的Java堆被活动数据占用</li>
<li>对象分配频率或年代提升频率变化很大</li>
<li>GC停顿时间过长</li>
</ul>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用程序线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>
<li>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续)的集合。通过Region的动态分配方式实现逻辑上的连续。</li>
<li>一个Region有可能属于Eden、Survivor或者Old&#x2F;Tenured内存区域，但是一个region只能属于一个角色</li>
<li>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H 块，主要用于存储大对象，如果超过1.5个region，就放到H</li>
<li>设置H区的原因：<ul>
<li>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不进行Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收器垃圾回收过程：</p>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第17章_G1-GC垃圾回收过程.jpg" alt="第17章_G1-GC垃圾回收过程" style="zoom: 33%;" />

<ul>
<li>年轻代GC（Young  GC）</li>
<li>老年代并发标记过程（Concurrent  Marking）</li>
<li>混合回收（Mixed GC）</li>
<li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制）</li>
</ul>
<p>具体过程如下：</p>
<ul>
<li>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程：G1的年轻代收集过程是一个并行的独占式收集器。在年轻代回收期，G1  GC暂停所有应用程序线程，启动多线程执行年轻代回收，然后从年轻代区间存活对象到Survivor区间或老年区间，也有可能时两个区域都会设计</li>
<li>当堆内存使用达到一定值时（默认45%）,开始老年代并发标记过程。</li>
<li>标记完成，马上开始混合回收过程。对于一个混合回收期，G1  GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了，同时，这个老年代Region是和年轻代Region一起被回收的。</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;Remembered Set:&#x3D;&#x3D;</p>
<ul>
<li>一个对象被不同区域引用的问题</li>
<li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆，才能保证准确呢？</li>
<li>在其他的分代收集器，也存在这样的问题（G1更突出）</li>
<li>回收新生代也不得不同时扫描老年代</li>
<li>这样的话Minor  GC的效率就会降低</li>
</ul>
<p>解决办法：</p>
<ul>
<li>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</li>
<li>&#x3D;&#x3D;每个Region都有一个对应的Remembered Set&#x3D;&#x3D;</li>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set,就可以保证不进行全局扫描，也不会有遗漏。</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收过程一：年轻代GC</p>
<ul>
<li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li>
<li>&#x3D;&#x3D;年轻代垃圾回收只会回收Eden区和Survivor区&#x3D;&#x3D;</li>
<li>YGC时，首先停止应用程序的执行（Stop-The-World）,G1创建回收集（Collection  Set）,回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存片段。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>G1的初衷就是要避免Full  GC的出现，但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop–The–World）,使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</li>
<li>要避免Full  Gc的发生，一旦发生需要进行调整，什么时候会发生Full  GC呢？比如堆内存大小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full  GC，这种情况可以通过增大内存解决。</li>
</ul>
</blockquote>
<h3 id="8-垃圾回收器总结"><a href="#8-垃圾回收器总结" class="headerlink" title="8.垃圾回收器总结"></a>8.垃圾回收器总结</h3><table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>适用于单CPU单核环境下的client模式</td>
</tr>
<tr>
<td>parNew</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境Server模式下与CMS配合使用</td>
</tr>
<tr>
<td>Parallel</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>响应速度优先</td>
<td>适用于单CPU单核环境下的client模式</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>CMS</td>
<td>并发运行</td>
<td>作用于老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>适用于互联网或B&#x2F;S业务</td>
</tr>
<tr>
<td>G1</td>
<td>并发、并行运行</td>
<td>作用于新生代、老年代</td>
<td>标记压缩算法、复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用</td>
</tr>
</tbody></table>
<blockquote>
<p>怎么选择垃圾回收器？</p>
<ul>
<li><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择何时的垃圾收集器可以让JVM的性能有一个很大的提升。</p>
</li>
<li><p>怎么选择垃圾回收器？</p>
<ul>
<li><p>优先调整堆的大小让JVM自适应完成</p>
</li>
<li><p>如果内存小于100M，使用串行收集器</p>
</li>
<li><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p>
</li>
<li><p>如果是多CPU，需要高吞吐量，允许停顿时间超过1秒，选择并行或者JVM自己选择</p>
</li>
<li><p>如果是多CPU，追求停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</p>
<p>官方推荐G1,并能高，现在互联网的项目，基本都是使用G1</p>
</li>
<li><p>最后需要明确一个观点:</p>
<ul>
<li>没有最好的收集器，更没有万能的收集器</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>面试：</p>
<ul>
<li>垃圾收集算法有哪些？如何判断一个对象是否可以回收？</li>
<li>垃圾收集器工作的基本流程。</li>
<li>另外大家需要多关注垃圾回收器这一章的各种常用的参数</li>
</ul>
</blockquote>
<h3 id="9-GC日志分析"><a href="#9-GC日志分析" class="headerlink" title="9.GC日志分析"></a>9.GC日志分析</h3><blockquote>
<ul>
<li>通过阅读GC日志，我们可以了解JVM虚拟机内存分配与回收策略</li>
<li>内存分配与垃圾回收的参数列表：<ul>
<li>-XX:+PrintGC    输出GC日志，类似：-verbose:gc</li>
<li>-XX:+PrintGCDetails    输出GC的详细日志</li>
<li>-XX:+PrintGCTimeStamps    输出GC的时间戳（以基准时间的形式）</li>
<li>-XX:+PrintGCDataStamps    输出GC的时间戳（以日期的形式，如2013-05-04T21:53:59.234+0800）</li>
<li>-XX:+PrintHeapAtGC    在进行GC的前后打印出堆的信息</li>
<li>-Xloggc:..&#x2F;logs&#x2F;gc.log    日志文件的输出路径</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="10-垃圾回收器的新发展"><a href="#10-垃圾回收器的新发展" class="headerlink" title="10.垃圾回收器的新发展"></a>10.垃圾回收器的新发展</h3><blockquote>
<ul>
<li>shenandoah  GC的弱项：高运行负担下的吞吐量下降</li>
<li>shenandoah  GC的强项：低延迟时间</li>
<li>shenandoah  GC的工作过程大致分为九个阶段。</li>
</ul>
</blockquote>
<blockquote>
<p>令人震惊的革命性的ZGC:</p>
<ul>
<li>在尽可能对吞吐量影响不大的前提下，是现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在&#x3D;&#x3D;十毫秒以内的低延迟。&#x3D;&#x3D;</li>
<li>ZGC的工作过程可以分为4个阶段：并发标记-并发预备重分配-并发重分配-并发重映射</li>
<li>ZGC几乎在所有地方是并发执行的，除了初始标记是STW的。所以停顿时间几乎就好肥仔初始标记上，这部分的实际时间是非常少的。</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/" data-id="clrv16wj40001z5ku3i7s9ir1" data-title="Java虚拟机学习" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-10-26T16:00:00.000Z" itemprop="datePublished">2022-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/">LeetCode刷题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode笔记"><a href="#leetcode笔记" class="headerlink" title="leetcode笔记"></a>leetcode笔记</h1><h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h2><h4 id="1-字符串哈希（leetcode-686）"><a href="#1-字符串哈希（leetcode-686）" class="headerlink" title="1.字符串哈希（leetcode 686）"></a>1.字符串哈希（leetcode 686）</h4><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h2><h4 id="1-删除自身节点。（不能获取到头节点）"><a href="#1-删除自身节点。（不能获取到头节点）" class="headerlink" title="1.删除自身节点。（不能获取到头节点）"></a>1.删除自身节点。（不能获取到头节点）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode227题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="comment">//论如何获得永生:先将自己变成后面的节点，然后再杀死自己</span></span><br><span class="line">    ListNode last=node.next;</span><br><span class="line">    node.val= last.val;</span><br><span class="line">    node.next=last.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-树"><a href="#4-树" class="headerlink" title="4.树"></a>4.树</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代(即深度优先遍历二叉树)</span></span><br><span class="line"><span class="comment">     * 先序遍历二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) <span class="comment">//先压入右子树</span></span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) <span class="comment">//再压入左子树</span></span><br><span class="line">                stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代</span></span><br><span class="line"><span class="comment">     * 中序遍历二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">          List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span>  list;</span><br><span class="line">          Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">          <span class="keyword">while</span>(p != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">                  s.push(p);</span><br><span class="line">                  p = p.left;</span><br><span class="line">              &#125;</span><br><span class="line">              p = s.pop();</span><br><span class="line">              list.add(p.val);</span><br><span class="line">              p = p.right;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(list);</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序非递归遍历二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();    </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root, prev = root; <span class="comment">//pre记录上一个已经输出的结点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || stack.size() &gt; <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;    </span><br><span class="line">                stack.push(node);    </span><br><span class="line">                node = node.left;    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.peek().right; <span class="comment">//在出栈之前，先判断栈顶元素的右孩子结点</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span> || temp == prev) &#123; <span class="comment">//当前节点无右子树或右子树已经输出    </span></span><br><span class="line">                node = stack.pop();    </span><br><span class="line">                list.add(node.val);</span><br><span class="line">                prev = node; <span class="comment">//记录上一个已输出结点</span></span><br><span class="line">                node = <span class="literal">null</span>;    </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                node = temp; <span class="comment">//处理右子树</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-回溯"><a href="#5-回溯" class="headerlink" title="5.回溯"></a>5.回溯</h2><h2 id="6-贪心"><a href="#6-贪心" class="headerlink" title="6.贪心"></a>6.贪心</h2><h2 id="7-动态规划"><a href="#7-动态规划" class="headerlink" title="7.动态规划"></a>7.动态规划</h2><h4 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0-1背包问题</span></span><br><span class="line">	有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</span><br><span class="line">	---背包有是一维的情况</span><br><span class="line">	---背包也有多维的情况（如leetcode474）</span><br><span class="line">	//核心代码，注意滚动数组要从右往左，否则就成了完全背包了</span><br><span class="line">	for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">        for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">完全背包问题</span></span><br><span class="line">	有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</span><br><span class="line">	根据遍历物品与遍历背包的不同又会有求排列数和组合数的不同</span><br><span class="line">	---如果求组合数就是外层for循环遍历物品，内层for遍历背包。（1,5）和（5，1）是同一种情况（如leetcode518题）</span><br><span class="line">	//组合代码</span><br><span class="line">	public int change(int amount, int[] coins) &#123;</span><br><span class="line">        int[] dp=new int[amount+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for (int i = 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            for (int j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">	---如果求排列数就是外层for遍历背包，内层for循环遍历物品。（1,5）和（5，1）是两种情况（如leetcode377题）</span><br><span class="line">	//排列代码</span><br><span class="line">	public int combinationSum4(int[] nums, int target) &#123;</span><br><span class="line">        int[] dp=new int[target+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for (int i = 0; i &lt;= target; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class="line">                if(i&gt;=nums[j])&#123;</span><br><span class="line">                    dp[i]=dp[i]+dp[i-nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];        </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 先遍历物品，再遍历背包</span><br><span class="line">    for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">        for(int j = weight[i]; j &lt; bagWeight ; j++) &#123; // 遍历背包容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">爬楼梯问题</span></span><br><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    //简单动态规划的解法</span><br><span class="line">    // if(n&lt;=2)&#123;</span><br><span class="line">    //     return n;</span><br><span class="line">    // &#125;</span><br><span class="line">    // int a=1,b=2;</span><br><span class="line">    // for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">    //     int c=b;</span><br><span class="line">    //     b=a+b;</span><br><span class="line">    //     a=c;</span><br><span class="line">    // &#125;</span><br><span class="line">    // return b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将爬楼梯问题转化为完全背包的排列问题</span><br><span class="line">    //将代码中的2可以改为m,即一下子可以爬1到m阶楼梯，就相当于有1到m的面值的无限硬币个数，可以组成的总钱数为n的排列数有多少</span><br><span class="line">    int[] dp=new int[n+1];</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=2;j++)&#123;</span><br><span class="line">            if(i&gt;=j)&#123;</span><br><span class="line">            dp[i]=dp[i]+dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-打家劫舍问题"><a href="#2-打家劫舍问题" class="headerlink" title="2.打家劫舍问题"></a>2.打家劫舍问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>就是比较传统的一排街道，没有环，如果偷相邻的两个街道就会报警。</span><br><span class="line">	代码：</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态规划解法</span></span><br><span class="line"><span class="comment">         * dp[i]表示在前i个街区中不触碰警报能获取到的最大价值</span></span><br><span class="line"><span class="comment">         * 递推公式：如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</span></span><br><span class="line"><span class="comment">         *         如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）</span></span><br><span class="line"><span class="comment">         *      所以有：dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i])</span></span><br><span class="line"><span class="comment">         * 初始化：dp[0]=0,dp[1]=nums[0]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 因为我们每次只会用到i前面的dp[i-1]和dp[i-2]所以可以用滚动数组的解法</span></span><br><span class="line"><span class="comment">         * 用两个变量来进行记录</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c=Math.max(b,a+nums[i]);</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>还是一排街道，但是与第一种情况不同的是，这里面的首尾两个街道算是相邻的街道。所以需要做进一步思考。就是分情况讨论。</span><br><span class="line">    <span class="number">1</span>）.最终偷的结果首尾两个街道都不包括。即只考虑在除了首尾的中间的元素</span><br><span class="line">    <span class="number">2</span>）.最终偷的结果考虑首元素，但不考虑尾元素的情况</span><br><span class="line">    <span class="number">3</span>）.最终偷的结果考虑尾元素，但不考虑首元素的情况</span><br><span class="line">    综合得：<span class="number">2</span>、<span class="number">3</span>两种情况里面都包含了第一种情况，所以总得就只用分为<span class="number">2</span>，<span class="number">3</span>两种情况，在考虑<span class="number">2</span>、<span class="number">3</span>这两种情况得时候，这就是前面第一种打家劫舍类型去了，最后取这两者中得最大值。 </span><br><span class="line">    代码：</span><br><span class="line">    	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> r1=getAns(nums,l,r-<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> r2=getAns(nums,l+<span class="number">1</span>,r);</span><br><span class="line">            <span class="keyword">return</span> r1&gt;r2?r1:r2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAns</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">            <span class="type">int</span> n=r-l;</span><br><span class="line">            <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="type">int</span> c=Math.max(a+nums[i],b);</span><br><span class="line">                a=b;</span><br><span class="line">                b=c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-股票买卖问题"><a href="#3-股票买卖问题" class="headerlink" title="3.股票买卖问题"></a>3.股票买卖问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">leetcode 123题</span></span><br><span class="line">	- 分状态进行解决</span><br><span class="line">	每一天总共有5个状态</span><br><span class="line">		dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</span><br><span class="line">		0 不操作状态		相当手中现金为0  dp[i][0]=0</span><br><span class="line">	buy1	1 第一次买入		相当于是消耗了这一天的钱数  -prices[i]</span><br><span class="line">	sell1	2 第一次卖出		相当于是获得了这一天的钱数  +prices[i]</span><br><span class="line">	buy2	3 第二次买入		相当于是消耗了这一天的钱数  -prices[i]</span><br><span class="line">	sell2	4 第二次卖出		相当于是获得了这一天的钱数  +prices[i]</span><br><span class="line">	这一天可以不进行任何操作，或者在前一天的状态下进行其他四种状态的变化</span><br><span class="line">		在第i天，进行 	1 第一次买入  ：buy1=Math.max(buy1&#x27;,-prices[i])</span><br><span class="line">									:buy1&#x27;表示这一天不进行操作，-prices[i]表示这一天买入消耗这么多</span><br><span class="line">                        2 第一次卖出  :sell1=Math.max(sell1&#x27;,buy1+prices[i])</span><br><span class="line">                        3 第二次买入	 :buy2=Math.max(buy2&#x27;,sell1-prices[i])</span><br><span class="line">                        4 第二次卖出  :sell2=Math.max(sell2&#x27;,buy2+prices[i])</span><br><span class="line">                 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码演示</span></span><br><span class="line">	public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int buy1 = -prices[0], sell1 = 0;</span><br><span class="line">        int buy2 = -prices[0], sell2 = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">leetcode 188题</span></span><br><span class="line">这是在123题的基础上变为至多可以买卖k次,思想与123题类似</span><br><span class="line">    public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">        if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp=new int[k*2+1];</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        for (int i = 1; i &lt; k*2+1; i+=2) &#123;</span><br><span class="line">            dp[i]=-prices[0];</span><br><span class="line">            dp[i+1]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            for(int j=1;j&lt;k*2+1;j++)&#123;</span><br><span class="line">                if(j%2==1)&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-1]-prices[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-1]+prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[k*2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1eetcode309</span></span><br><span class="line">股票买卖问题，带手续费的</span><br><span class="line">	我们用 f[i]表示第 i 天结束之后的「累计最大收益」</span><br><span class="line">	该题分为以下几个状态（这里的状态是该天结束之后的状态）：</span><br><span class="line">		- 我们目前持有一支股票，对应的「累计最大收益」记为 f[i][0]；</span><br><span class="line">		- 我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]；</span><br><span class="line">		- 我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]。</span><br><span class="line">		这里的「处于冷冻期」指的是在第 i 天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	对于f[i][0]:我们可以是在这一天不进行任何操作，在之前就已经持有了一支股票，所以有f[i-1][0].或者是前一天不持有股票，然后今天买入，所以是必须在前一天处于非冷冻期中。因此为f[i][0]=f[i-1][2]-prices[i]</span><br><span class="line">	</span><br><span class="line">	对于f[i][1]:则是在前一天持有一支股票，然后在第i天卖出，所以处于冷冻期f[i][1]=f[i-1][0]+prices[i]</span><br><span class="line">	</span><br><span class="line">	对于f[i][2]:可以是当天不进行任何操作所以有f[i-1][2]，也可以是在前一天处于冷冻期，一天后就不是冷冻期了。所以有f[i][2]=f[i-1][1]</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">初始化</span></span><br><span class="line">		f[i][0]=-prices[0]</span><br><span class="line">		f[i][1]=0</span><br><span class="line">		f[i][2]=0</span><br><span class="line">		</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">代码：</span></span><br><span class="line">	public int maxProfit(int[] prices) &#123;</span><br><span class="line">        /*if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int[][] dp=new int[n][2];</span><br><span class="line">        dp[0][0]=-prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2]-prices[i]);</span><br><span class="line">            dp[i][1]=dp[i-1][0]+prices[i];</span><br><span class="line">            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[n-1][1],dp[n-1][2]);*/</span><br><span class="line"></span><br><span class="line">        //空间进行优化，因为第i天的状态只与第i-1天有关系</span><br><span class="line">        if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int a=-prices[0];</span><br><span class="line">        int b=0;</span><br><span class="line">        int c=0;</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            int d=Math.max(a,c-prices[i]);</span><br><span class="line">            int e=a+prices[i];</span><br><span class="line">            int f=Math.max(c,b);</span><br><span class="line">            a=d;</span><br><span class="line">            b=e;</span><br><span class="line">            c=f;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(b,c);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-最长子序列问题"><a href="#4-最长子序列问题" class="headerlink" title="4.最长子序列问题"></a>4.最长子序列问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如：leetcode1143。（leetcode1035）</span><br><span class="line">	值得注意的是这是一个二维的动态规划，既需要同时对两个数组进行动态分析。画出一个m*n的矩阵会便于进行分析</span><br></pre></td></tr></table></figure>



<h2 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h2><h2 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h2><h4 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有的位运算都是用补码进行运算</span></span><br><span class="line"></span><br><span class="line">	正数的原码，反码，补码都相同</span><br><span class="line">	负数的原码是除了第一个符号位为1外，其他位与正数原码相同，如-3的原码是 1000....0000011</span><br><span class="line">	负数的反码是在负数原码的基础上符号位不变，其他位取反    如-3的反码是  1111....1111100</span><br><span class="line">	负数的补码是在负数反码的基础上+1                    -3的反码是    1111....1111101</span><br></pre></td></tr></table></figure>

<h4 id="1-判断一个数是否是2的次幂"><a href="#1-判断一个数是否是2的次幂" class="headerlink" title="1.判断一个数是否是2的次幂"></a>1.判断一个数是否是2的次幂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> (sum&amp;(sum-<span class="number">1</span>))==<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="2-异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）"><a href="#2-异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）" class="headerlink" title="2.异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）"></a>2.异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如何才能做到线性时间复杂度和常数空间复杂度呢？</span><br><span class="line"></span><br><span class="line">答案是使用位运算。对于这道题，可使用异或运算 \oplus⊕。异或运算有以下三个性质。</span><br><span class="line"></span><br><span class="line">正数反码：与原码相同</span><br><span class="line"></span><br><span class="line">负数反码：符号位为“1”，数值位按位 取反。</span><br><span class="line">正数补码：与原码相同</span><br><span class="line">负数补码：求反加一</span><br><span class="line">记住：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有参与运算的都是以补码形式进行的 结果也是补码 因此也需要将补码转换成为原码的形式存在</span></span><br><span class="line"></span><br><span class="line">任何数和 0做异或运算，结果仍然是原来的数，即 a⊕0=a。</span><br><span class="line">任何数和其自身做异或运算，结果是 0，即 a⊕a=0。</span><br><span class="line">异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</span><br></pre></td></tr></table></figure>

<h4 id="3-与运算和或运算。（leetcode-318）"><a href="#3-与运算和或运算。（leetcode-318）" class="headerlink" title="3.与运算和或运算。（leetcode 318）"></a>3.与运算和或运算。（leetcode 318）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或运算  |   （1=1&amp;1 1=1|0 1=0|1 0=0|0） 注意这个没有短路的效果，有短路的是||和&amp;&amp;</span></span><br><span class="line">	常见的题目类型有：</span><br><span class="line">		1.看一个数的某一位是否为1或0.</span><br><span class="line">			如：   00000000</span><br><span class="line">				| 00000001</span><br><span class="line">                ————————————</span><br><span class="line">                  00000001</span><br><span class="line">     	2.看求某一个数的掩码</span><br><span class="line">     			a |= (1&lt;&lt;6)  (最终的效果就是a这个数的二进制数第六位数是1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">与运算  &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-移位运算"><a href="#4-移位运算" class="headerlink" title="4.移位运算"></a>4.移位运算</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> &lt;&lt;  左移运算</span>  </span><br><span class="line">	如 a= 1&lt;&lt;4  是将1变为二进制后往左移4位</span><br><span class="line">				00000001</span><br><span class="line">			 &lt;&lt; </span><br><span class="line">			 ____________</span><br><span class="line">			 a= 00010000=16</span><br><span class="line">	如 b= 3&lt;&lt;4  是将3转换为二进制后往左移4位，最终结果是48</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> &gt;&gt; 右移运算与左移运算则相反</span></span><br></pre></td></tr></table></figure>

<h4 id="5-非运算"><a href="#5-非运算" class="headerlink" title="5.非运算 ~"></a>5.非运算 ~</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意一点是所有位运算都是按照补码进行运算的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~运算是将要求的数的补码取反（包括符号位），得到补码，再由补码退出该数的原码，就是最终结果</span></span><br><span class="line">所以~10的求解过程是这样的</span><br><span class="line">	10的补码是 		                   0...00001010</span><br><span class="line">	所以~10的补码是上面10的补码所有位取反   1...11110101</span><br><span class="line">    就有了~10的原码就是					1...00001011  即~10等于 -11</span><br><span class="line">    </span><br><span class="line">    ~(-3)的求解过程是</span><br><span class="line">    -3的原码：1...00000011</span><br><span class="line">    -3的反码：1...11111100</span><br><span class="line">    -3的补码：1...11111101</span><br><span class="line">    </span><br><span class="line"> ~(-3)的补码：0...00000010</span><br><span class="line"> ~(-3)的反码：0...00000010</span><br><span class="line"> ~(-3)的原码：0...00000010   即 ~(-3)等于 2</span><br><span class="line"> </span><br><span class="line"> 结论：~(n) = -n-1  (无论n是正数还是负数)</span><br></pre></td></tr></table></figure>



<h4 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.剑指offer65题(利用位运算实现加法)</span><br></pre></td></tr></table></figure>



<h2 id="10-查找算法"><a href="#10-查找算法" class="headerlink" title="10.查找算法"></a>10.查找算法</h2><h4 id="1-二分查找算法"><a href="#1-二分查找算法" class="headerlink" title="1.二分查找算法"></a>1.二分查找算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.查找目标值的索引   如查找[5,7,8,10]的8位置，返回2，查找9，还是返回2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)&#123;</span><br><span class="line">                right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查找目标值索引的右边界  如查找[5,7,7,8,8,10]中8的右边界第一个值的索引即返回10对应的索引，查找7则返回第一个8的索引   (题目如剑指offer中53题，理解见图)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//与一般的二分查找区别在这里</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;=target)&#123;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-动态规划-二分查找"><a href="#2-动态规划-二分查找" class="headerlink" title="2.动态规划+二分查找"></a>2.动态规划+二分查找</h4><blockquote>
<p>见leetcode 300题</p>
</blockquote>
<h2 id="11-集合框架"><a href="#11-集合框架" class="headerlink" title="11.集合框架"></a>11.集合框架</h2><h4 id="1-List—ArrayList-LinkedList的使用"><a href="#1-List—ArrayList-LinkedList的使用" class="headerlink" title="1.List—ArrayList,LinkedList的使用"></a>1.List—ArrayList,LinkedList的使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是一个很重要的点</span></span><br><span class="line">1.当需要对集合中的数据进行频繁的随机访问的时候，建议使用ArrayList</span><br><span class="line">2.当需要对集合进行频繁的插入和删除数据时，建议使用LinkedList</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList的方法，add方法默认从末端添加元素</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList方法，add可以从开头或末尾添加元素</span><br></pre></td></tr></table></figure>

<h2 id="12-数学"><a href="#12-数学" class="headerlink" title="12.数学"></a>12.数学</h2><h4 id="1-求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）"><a href="#1-求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）" class="headerlink" title="1.求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）"></a>1.求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.方法1,暴力破解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.方法2.二分法</span></span><br><span class="line">如果num是完全平方数，就相当于是能从<span class="number">1</span>到num中间寻找一个数，这个数的平方等于num</span><br><span class="line">因此左边界是<span class="number">1</span>，右边界是num,然后进行二分查找。但是需要注意的是临时得到的中间数middle的平方可能会超出<span class="type">int</span>的范围，因此需要用<span class="type">long</span>类型来存储</span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="type">int</span> left=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> right=num;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">    <span class="type">int</span> middle=(right+left)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> square=(<span class="type">long</span>)middle*middle;</span><br><span class="line">    <span class="keyword">if</span>(square&gt;num)&#123;</span><br><span class="line">        right=middle-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(square&lt;num)&#123;</span><br><span class="line">        left=middle+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.方法3.数学。（利用一个完全平方数，能够由奇数相加得到）</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">4</span>=<span class="number">1</span>+<span class="number">3</span></span><br><span class="line"><span class="number">9</span>=<span class="number">1</span>+<span class="number">3</span>+<span class="number">5</span></span><br><span class="line"><span class="number">16</span>=<span class="number">1</span>+<span class="number">3</span>+<span class="number">5</span>+<span class="number">7</span></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">num -= x;</span><br><span class="line">x += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-矩阵快速幂（时间复杂度为O-logn-）解决斐波那契数列中使用（待看）"><a href="#2-矩阵快速幂（时间复杂度为O-logn-）解决斐波那契数列中使用（待看）" class="headerlink" title="2.矩阵快速幂（时间复杂度为O(logn)）解决斐波那契数列中使用（待看）"></a>2.矩阵快速幂（时间复杂度为O(logn)）解决斐波那契数列中使用（待看）</h4><h2 id="13-排序算法"><a href="#13-排序算法" class="headerlink" title="13.排序算法"></a>13.排序算法</h2><h4 id="1-内置的排序算法-比较器（Comparator）"><a href="#1-内置的排序算法-比较器（Comparator）" class="headerlink" title="1.内置的排序算法+比较器（Comparator）"></a>1.内置的排序算法+比较器（Comparator）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">java中的内置排序函数有Arrays和Collections类中的<span class="built_in">sort</span>函数，其中还可以自己定义排序的顺序，就是创建比较器对象，注意o1对象和o2对象比较顺序</span></span><br><span class="line">if(o1.get(i)&lt;o1.get(0))&#123;   //当这种情况发生时，如果想调整当前o1,o2的顺序，就返回正数，否则返回负数</span><br><span class="line">	return o1.get(0);  //将o1调整到o2之前</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	return -1;  //保持不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] nums=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Arrays.sort(nums, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1[<span class="number">0</span>]&gt;o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//因为要的是升序，但是o1大于o2所以应该调整顺序，所以返回正数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1[<span class="number">0</span>]&lt;o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//因为要的是升序，所以o1与o2已经是升序了，所以不变。o1，o2的顺序保持不变， </span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这是在第一维相等的情况下，比较第二维</span></span><br><span class="line">                <span class="keyword">if</span>(o1[<span class="number">1</span>]&gt;o2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1[<span class="number">1</span>]&lt;o2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(nums);</span><br><span class="line">    <span class="comment">//结果为：[1,2],[2,3],[2,6],[3,4],[5,2],[5,8],[6,1],[6,3]</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-快速排序-题目见剑指offer40"><a href="#2-快速排序-题目见剑指offer40" class="headerlink" title="2.快速排序(题目见剑指offer40)"></a>2.快速排序(题目见剑指offer40)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fastSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=i;</span><br><span class="line">    <span class="type">int</span> r=j;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[r]&gt;=arr[i])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[l]&lt;=arr[i])&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里其实判不判断l&lt;r都无所谓，只是进行了多一次交换，即便不满足，此时l==r，也不会有影响</span></span><br><span class="line">        <span class="type">int</span> temp=arr[r];</span><br><span class="line">        arr[r]=arr[l];</span><br><span class="line">        arr[l]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp=arr[i];</span><br><span class="line">    arr[i]=arr[l];</span><br><span class="line">    arr[l]=temp;</span><br><span class="line">    fastSort(arr,i,l-<span class="number">1</span>);</span><br><span class="line">    fastSort(arr,l+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优先队列（排序）"><a href="#3-优先队列（排序）" class="headerlink" title="3.优先队列（排序）"></a>3.优先队列（排序）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="comment">//                if(o1&gt;o2)&#123;</span></span><br><span class="line">        <span class="comment">//                    return o1-o2;</span></span><br><span class="line">        <span class="comment">//                &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//                    return o2-o1;</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//                if(o1&gt;o2)&#123;</span></span><br><span class="line">        <span class="comment">//                    //升序，因为o1是将要插入到优先队列中的元素，o2是队列中的头元素，</span></span><br><span class="line">        <span class="comment">//                    // 并且o1大于o2,所以返回1，直接放到后面</span></span><br><span class="line">        <span class="comment">//                    return 1;	   顺序变换    o1&gt;o2</span></span><br><span class="line">        <span class="comment">//                &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//                    return -1;  位置顺序不变  o1&lt;o2</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//                return o1-o2;  //升序</span></span><br><span class="line">        <span class="keyword">return</span> o2-o1;  <span class="comment">//降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] nums=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">			<span class="comment">//升序</span></span><br><span class="line">            <span class="keyword">if</span>(o1[<span class="number">0</span>]!=o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];  <span class="comment">//先根据第一维的数据进行排序，这是升序，如果换一下顺序就是降序</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pq.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size=pq.size();</span><br><span class="line">    <span class="comment">//注意在实际打印时的序列并不是有序的，而应该是依次取堆顶元素，这样取到的就是有序的</span></span><br><span class="line">    <span class="comment">//如果想让队列是有序的，可以先转化为数组再进行排序</span></span><br><span class="line">    <span class="comment">//Integer[] arr=new Integer[size];</span></span><br><span class="line">    <span class="comment">//Arrays.sort(pq.toArray(arr));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="type">int</span>[] arr=pq.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+arr[<span class="number">0</span>]+<span class="string">&quot; :&quot;</span>+arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(nums);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-归并排序-offer-51"><a href="#4-归并排序-offer-51" class="headerlink" title="4.归并排序(offer 51)"></a>4.归并排序(offer 51)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">利用对并排序求解逆序对（剑指offer 51题）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序的代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr=&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">67</span>,<span class="number">58</span>,<span class="number">12</span>,<span class="number">58</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Test</span>().mergeSort(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=arr.length-<span class="number">1</span>;</span><br><span class="line">    dfs(arr,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归划分</span></span><br><span class="line">    <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">    dfs(arr,l,m);</span><br><span class="line">    dfs(arr,m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//合并阶段</span></span><br><span class="line">    <span class="comment">//我们首先使用tmp数组存储要排序这一段数组</span></span><br><span class="line">    <span class="type">int</span>[] tmp=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= r; k++) &#123;</span><br><span class="line">        tmp[k]=arr[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再将左右有序的子树组合并为整个合起来有序的数组</span></span><br><span class="line">    <span class="comment">//用i,j来记录遍历左右子数组</span></span><br><span class="line">    <span class="type">int</span> i=l,j=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==m+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//代表左子数组已合并完，因此添加右子数组当前元素 tmp[j] ，并执行 j = j + 1；</span></span><br><span class="line">            arr[k]=tmp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==r+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//代表右子数组已合并完，因此添加左子数组当前元素tmp[i] ，并执行i=i+1；</span></span><br><span class="line">            arr[k]=tmp[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i]&gt;tmp[j])&#123;</span><br><span class="line">            <span class="comment">//当tmp[i&gt;tmp[j] 时： 添加右子数组当前元素tmp[j]，并执行j=j+1；</span></span><br><span class="line">            arr[k]=tmp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当tmp[i]≤tmp[j] 时： 添加左子数组当前元素tmp[i]，并执行i=i+1；</span></span><br><span class="line">            arr[k]=tmp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-堆排序（leetcode-215-解法见方法2）"><a href="#5-堆排序（leetcode-215-解法见方法2）" class="headerlink" title="5.堆排序（leetcode 215  解法见方法2）"></a>5.堆排序（leetcode 215  解法见方法2）</h4><blockquote>
<p>先按照顺序将数组元素组合成一个完全二叉树</p>
</blockquote>
<p><img src="https://assets.leetcode-cn.com/solution-static/215/1.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="comment">//建堆完毕后，nums【0】为最大元素。逐个删除堆顶元素，直到删除了k-1个。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//先将堆的最后一个元素与堆顶元素交换，由于此时堆的性质被破坏，需对此时的根节点进行向下调整操作。</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">//相当于删除堆顶元素，此时长度变为nums.length-2。即下次循环的i</span></span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="comment">//从最后一个父节点位置开始调整每一个节点的子树。数组长度为heasize，因此最后一个节点的位置为heapsize-1，所以父节点的位置为（heapsize-1-1)/2。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heapSize-<span class="number">2</span>)/ <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;      <span class="comment">//调整当前结点和子节点的顺序。</span></span><br><span class="line">        <span class="comment">//left和right表示当前父节点i的两个左右子节点。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, right = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="comment">//如果左子点在数组内，且比当前父节点大，则将最大值的指针指向左子点。</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; a[left] &gt; a[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果右子点在数组内，且比当前父节点大，则将最大值的指针指向右子点。</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最大值的指针不是父节点，则交换父节点和当前最大值指针指向的子节点。</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            <span class="comment">//由于交换了父节点和子节点，因此可能对子节点的子树造成影响，所以对子节点的子树进行调整。</span></span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-栈和队列"><a href="#14-栈和队列" class="headerlink" title="14.栈和队列"></a>14.栈和队列</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">剑指offer59_2</span></span><br></pre></td></tr></table></figure>

<h2 id="难题附录："><a href="#难题附录：" class="headerlink" title="难题附录："></a>难题附录：</h2><h3 id="1-lettcode-869-（关于回溯和预处理，重新排序看能否得到2次幂的数）"><a href="#1-lettcode-869-（关于回溯和预处理，重新排序看能否得到2次幂的数）" class="headerlink" title="1.lettcode 869.（关于回溯和预处理，重新排序看能否得到2次幂的数）"></a>1.lettcode 869.（关于回溯和预处理，重新排序看能否得到2次幂的数）</h3><h3 id="2-剑指Offer-35（复杂链表的复制）"><a href="#2-剑指Offer-35（复杂链表的复制）" class="headerlink" title="2.剑指Offer 35（复杂链表的复制）"></a>2.剑指Offer 35（复杂链表的复制）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意本题要求的是复制，因此原有的链表值和结构不能有改变</span></span><br><span class="line"><span class="comment">//本题的难点在于如果按照传统链表的方式进行遍历时，无法知道random指针指向的是哪里，</span></span><br><span class="line"><span class="comment">// 主要是不确定这个节点是否已经创建，因此需要先遍历一遍建立起已经创建的节点哈希表，再给构建的节点进行赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1 使用回溯+哈希表</span></span><br><span class="line">Map&lt;Node,Node&gt; hs=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node,Node&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!hs.containsKey(head))&#123;</span><br><span class="line">        Node cp=<span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        hs.put(head,cp);</span><br><span class="line">        cp.next=copyRandomList(head.next);</span><br><span class="line">        cp.random=copyRandomList(head.random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hs.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2 使用哈希表，但是是顺序遍历方式，这样比回溯方法好理解一点</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// 4. 构建新链表的 next 和 random 指向</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 返回新链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法3：使用拼接+拆分的方法</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">        tmp.next = cur.next;</span><br><span class="line">        cur.next = tmp;</span><br><span class="line">        cur = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.random != <span class="literal">null</span>)</span><br><span class="line">            cur.next.random = cur.random.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">    cur = head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="literal">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">    <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）"><a href="#3-leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）" class="headerlink" title="3.leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）"></a>3.leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">dp[i]表示的意思就是以arr[i]为结尾的子序列的长度。因此有j&lt;i&amp;&amp;arr[i]-arr[j]=d时，dp[i]=dp[j]+<span class="number">1</span></span><br><span class="line">为了方便，我们可以直接使用dp[i]就表示是以i为结尾的子序列的长度，此时就有dp[i]=dp[i-d]+<span class="number">1.</span></span><br><span class="line">#动态规划解决</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubsequence</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> difference)</span> &#123;</span><br><span class="line">    <span class="comment">//暴力破解超时</span></span><br><span class="line">    <span class="comment">/*int max=0;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length&amp;&amp;((arr.length-i-1)&gt;=max); i++) &#123;</span></span><br><span class="line"><span class="comment">            int count=1;</span></span><br><span class="line"><span class="comment">            int pre=arr[i];</span></span><br><span class="line"><span class="comment">            for (int j = i+1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">                if((arr[j]-pre)==difference)&#123;</span></span><br><span class="line"><span class="comment">                    count++;</span></span><br><span class="line"><span class="comment">                    pre=arr[j];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(count&gt;max)&#123;</span></span><br><span class="line"><span class="comment">                max=count;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return max;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划解决,该题如果不使用map来进行处理，而还是用数组的话，还是需要用两层循环，因此依旧会超时</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//使用变量记录最大值，可以减去后面遍历map，求解最大值</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> val:arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val-difference))&#123;</span><br><span class="line">            map.put(val,map.get(val-difference)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(val,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=Math.max(ans,map.get(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#数组解决办法</span><br><span class="line"><span class="comment">//该题也可以使用数组来取代hash表来进行解决，使得可以一次性就将结果查询出来</span></span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">40009</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubsequence2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        hash[i + M] = hash[i - d + M] + <span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans, hash[i + M]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）"><a href="#4-leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）" class="headerlink" title="4.leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）"></a>4.leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">1</span>背包问题的，其中背包的容量是二维的情况</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  动态规划</span></span><br><span class="line"><span class="comment"> 	*  这里dp[j][k]表示数组子集中累加的0和1的个数满足最大j个0和k个1时的子集中的字符串的最大个数</span></span><br><span class="line"><span class="comment">   	*  dp[5][3]=4就是表示子集中最多5个0和3个1的字符串个数为4</span></span><br><span class="line"><span class="comment">    *  这里我们使用滚动的二维数组来进行解决问题。</span></span><br><span class="line"><span class="comment">    *  当遍历到第i个字符串时，第i个字符串中有a=count[i][0]个0，有b=count[i][1]个1.就会出现两种情况：</span></span><br><span class="line"><span class="comment">  	*                      只有在j&gt;=a并且k&gt;=b时，才有可能出现第i个字符串是子集中的结果</span></span><br><span class="line"><span class="comment">  	*                   所以在前提条件j&gt;=a并且k&gt;=b被满足的情况下，才有下面两种情况的讨论，否则就不变</span></span><br><span class="line"><span class="comment">  	*                      第一种：子集中包括第i个字符串，dp[j][k]=dp[j-a][k-b]+1</span></span><br><span class="line"><span class="comment">  	*                      第二种：子集中不包括第i个字符串，dp[j][k]就保持不变</span></span><br><span class="line"><span class="comment">  	*  因此得到递推表达式是 dp[j][k]=Math.max(dp[j][k],dp[j-a][k-b]+1)</span></span><br><span class="line"><span class="comment">  	*  最终得到的结果就是dp[m][n]的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//注意在进行遍历的时候需要从右到左的顺序，否则会导致覆盖后的数据又被后面的数据覆盖了，导致结果数变大</span></span><br><span class="line"><span class="comment">//遍历物品，这里也是使用滚动数组的解法，只是和0-1背包问题不同的是，这里的价值是二维的，物品也是二维的</span></span><br><span class="line">    <span class="comment">//可以对空间进行优化，对于统计字符串的数组，可以在需要知道0和1的时候，用变量求解出来</span></span><br><span class="line">        <span class="comment">//可以对时间也进行优化，在j&lt;a或者k&lt;b时，dp[j][k]肯定就是保持不变的情况，可以提前结束for循环</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> strs.length;</span><br><span class="line"><span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//每个字符串都是一个物品，而m,n是一个背包，只不过是一个二维的背包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">//a、b表示strs中第i个字符串中 0和1 的个数</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:strs[i].toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;=a ; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n; k &gt;=b ; k--) &#123;</span><br><span class="line">            dp[j][k]=Math.max(dp[j-a][k-b]+<span class="number">1</span>,dp[j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-leetcode322题（该题的重点在于初始化）"><a href="#5-leetcode322题（该题的重点在于初始化）" class="headerlink" title="5.leetcode322题（该题的重点在于初始化）"></a>5.leetcode322题（该题的重点在于初始化）</h3><h3 id="6-leetcode138题（动态规划，注意这里递推公式是怎样写的）"><a href="#6-leetcode138题（动态规划，注意这里递推公式是怎样写的）" class="headerlink" title="6.leetcode138题（动态规划，注意这里递推公式是怎样写的）"></a>6.leetcode138题（动态规划，注意这里递推公式是怎样写的）</h3><h3 id="7-leetcode213题动态规划题（打家劫舍题）"><a href="#7-leetcode213题动态规划题（打家劫舍题）" class="headerlink" title="7.leetcode213题动态规划题（打家劫舍题）"></a>7.leetcode213题动态规划题（打家劫舍题）</h3><h3 id="8-leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）"><a href="#8-leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）" class="headerlink" title="8.***leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）"></a>8.***leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）</h3><h3 id="9-剑指offer36题（二叉搜索树）"><a href="#9-剑指offer36题（二叉搜索树）" class="headerlink" title="9.***剑指offer36题（二叉搜索树）"></a>9.***剑指offer36题（二叉搜索树）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二叉搜索树的性质：中序遍历是递增顺序的。</span><br></pre></td></tr></table></figure>

<h3 id="10-剑指offer的15天的题（三题都需要）需要重看一下（搜索-回溯的题）还有剑指offer68—II这道题"><a href="#10-剑指offer的15天的题（三题都需要）需要重看一下（搜索-回溯的题）还有剑指offer68—II这道题" class="headerlink" title="10.剑指offer的15天的题（三题都需要）需要重看一下（搜索+回溯的题）还有剑指offer68—II这道题"></a>10.剑指offer的15天的题（三题都需要）需要重看一下（搜索+回溯的题）还有剑指offer68—II这道题</h3><h3 id="11-剑指-Offer-64-求1-2-…-n-要求不能使用if-else-switch-A-B-C等结构"><a href="#11-剑指-Offer-64-求1-2-…-n-要求不能使用if-else-switch-A-B-C等结构" class="headerlink" title="11.剑指 Offer 64. 求1+2+…+n.要求不能使用if,else,switch,A?B:C等结构"></a>11.剑指 Offer 64. 求1+2+…+n.要求不能使用if,else,switch,A?B:C等结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重点掌握两种解决方法</span></span><br><span class="line">-位元算+快速乘法+高斯公式</span><br><span class="line">-位运算+递归解法</span><br></pre></td></tr></table></figure>

<h3 id="12-剑指offer16（求解数的整数次方）"><a href="#12-剑指offer16（求解数的整数次方）" class="headerlink" title="12.剑指offer16（求解数的整数次方）"></a>12.剑指offer16（求解数的整数次方）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重点掌握方法</span></span><br><span class="line">	-记忆化递归</span><br><span class="line">	-快速幂(重点掌握) 结合数的二进制来进行解决 </span><br></pre></td></tr></table></figure>

<h3 id="13-剑指Offer62-（求解圆圈中最后剩余的数字，约瑟夫环）"><a href="#13-剑指Offer62-（求解圆圈中最后剩余的数字，约瑟夫环）" class="headerlink" title="13.***剑指Offer62 （求解圆圈中最后剩余的数字，约瑟夫环）"></a>13.***剑指Offer62 （求解圆圈中最后剩余的数字，约瑟夫环）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该题的核心主要在于反推，主要题解见 https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</span> </span><br></pre></td></tr></table></figure>



<h3 id="14-leetcode677题"><a href="#14-leetcode677题" class="headerlink" title="14.leetcode677题"></a>14.leetcode677题</h3><h3 id="15-剑指offer20题待看，使用有限状态机进行解决"><a href="#15-剑指offer20题待看，使用有限状态机进行解决" class="headerlink" title="15.剑指offer20题待看，使用有限状态机进行解决"></a>15.剑指offer20题待看，使用有限状态机进行解决</h3><h3 id="16-leetcode423-学习这种解决问题的方法"><a href="#16-leetcode423-学习这种解决问题的方法" class="headerlink" title="16.leetcode423 学习这种解决问题的方法"></a>16.leetcode423 学习这种解决问题的方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">首先解决只存在一个未知数的方程求出这些方程中的未知数，再根据这些得到未知数的值代入到原来有多个未知数的方程中去，然后再依次进行求解。</span></span><br></pre></td></tr></table></figure>

<h3 id="17-剑指offer-38-回溯"><a href="#17-剑指offer-38-回溯" class="headerlink" title="17.剑指offer 38 回溯"></a>17.剑指offer 38 回溯</h3><h3 id="18-剑指offer-49-求解丑数"><a href="#18-剑指offer-49-求解丑数" class="headerlink" title="18.剑指offer 49 (求解丑数)"></a>18.剑指offer 49 (求解丑数)</h3><h3 id="19-剑指offer-60-（求解骰子的点数）"><a href="#19-剑指offer-60-（求解骰子的点数）" class="headerlink" title="19.剑指offer 60 （求解骰子的点数）"></a>19.剑指offer 60 （求解骰子的点数）</h3><h3 id="20-剑指offer-19-正则表达式匹配-动态规划"><a href="#20-剑指offer-19-正则表达式匹配-动态规划" class="headerlink" title="20.剑指offer 19 (正则表达式匹配 动态规划)"></a>20.剑指offer 19 (正则表达式匹配 动态规划)</h3><h3 id="21-剑指offer17-学会要掌握处理大数越界的问题"><a href="#21-剑指offer17-学会要掌握处理大数越界的问题" class="headerlink" title="21.剑指offer17 学会要掌握处理大数越界的问题"></a>21.剑指offer17 学会要掌握处理大数越界的问题</h3><h3 id="22-剑指offer-51-归并排序与逆序对"><a href="#22-剑指offer-51-归并排序与逆序对" class="headerlink" title="22.剑指offer 51 (归并排序与逆序对)"></a>22.剑指offer 51 (归并排序与逆序对)</h3><h3 id="23-剑指offer44题-（数字模拟）"><a href="#23-剑指offer44题-（数字模拟）" class="headerlink" title="23.剑指offer44题 （数字模拟）"></a>23.剑指offer44题 （数字模拟）</h3><h3 id="24-leetcode372（利用快速幂求解一个数的超级次方）"><a href="#24-leetcode372（利用快速幂求解一个数的超级次方）" class="headerlink" title="24.leetcode372（利用快速幂求解一个数的超级次方）"></a>24.leetcode372（利用快速幂求解一个数的超级次方）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以利用倒叙和正序的方法进行解题，正序的话就是使用秦九韶公式进行解决</span></span><br></pre></td></tr></table></figure>

<h3 id="25-leetcode1143-该题是典型的两维动态规划"><a href="#25-leetcode1143-该题是典型的两维动态规划" class="headerlink" title="25.leetcode1143	(该题是典型的两维动态规划)"></a>25.leetcode1143	(该题是典型的两维动态规划)</h3><h3 id="26-leetcode825-利用数学式子来进行解决问题-计数排序和排序"><a href="#26-leetcode825-利用数学式子来进行解决问题-计数排序和排序" class="headerlink" title="26.leetcode825(利用数学式子来进行解决问题)[计数排序和排序]"></a>26.leetcode825(利用数学式子来进行解决问题)[计数排序和排序]</h3><h3 id="27-leetcode394-（利用辅助栈来进行解决）"><a href="#27-leetcode394-（利用辅助栈来进行解决）" class="headerlink" title="27.leetcode394 （利用辅助栈来进行解决）"></a>27.leetcode394 （利用辅助栈来进行解决）</h3><h3 id="28-leetcode390-学习这种分析问题的做法，利用数学的方法进行解决"><a href="#28-leetcode390-学习这种分析问题的做法，利用数学的方法进行解决" class="headerlink" title="28.leetcode390(学习这种分析问题的做法，利用数学的方法进行解决)"></a>28.leetcode390(学习这种分析问题的做法，利用数学的方法进行解决)</h3><h3 id="29-leetcode-686题（上下界，字符串哈希的方法）"><a href="#29-leetcode-686题（上下界，字符串哈希的方法）" class="headerlink" title="29.leetcode 686题（上下界，字符串哈希的方法）"></a>29.leetcode 686题（上下界，字符串哈希的方法）</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/" data-id="clrv16wje000jz5ku41rm4ds7" data-title="LeetCode刷题" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/27/Linux%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-10-26T16:00:00.000Z" itemprop="datePublished">2022-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/27/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="导入："><a href="#导入：" class="headerlink" title="导入："></a>导入：</h2><h3 id="1-安装VM和centos"><a href="#1-安装VM和centos" class="headerlink" title="1.安装VM和centos"></a>1.安装VM和centos</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.基本说明</span><br><span class="line">	学习linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习</span><br><span class="line">1.先安装virtual machine 15.5</span><br><span class="line">2.再安装Linux（Centos 7.6/centos 8.1）</span><br></pre></td></tr></table></figure>

<h3 id="2-网络连接的三种方式"><a href="#2-网络连接的三种方式" class="headerlink" title="2.网络连接的三种方式"></a>2.网络连接的三种方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.桥接模式：虚拟系统可以和外部系统通讯，但是容易造成IP冲突</span><br><span class="line">2.NAT模式：网络地址转换模式，虚拟系统可以和外部系统通讯，不造成IP冲突</span><br><span class="line">3.主机模式：独立系统，不与外界发生练习</span><br></pre></td></tr></table></figure>

<h3 id="3-虚拟机克隆"><a href="#3-虚拟机克隆" class="headerlink" title="3.虚拟机克隆"></a>3.虚拟机克隆</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">克隆</span></span><br><span class="line">	1.如果你已经安装了一台linux操作系统，你还想更多的，没有必要再重新安装，只需要克隆就可以了</span><br><span class="line">	方式1:直接拷贝一份安装好的虚拟机文件</span><br><span class="line">	方式2：使用vmware的克隆操作。注意，克隆时，需要先关闭linux系统</span><br></pre></td></tr></table></figure>

<h3 id="4-虚拟机快照"><a href="#4-虚拟机快照" class="headerlink" title="4.虚拟机快照"></a>4.虚拟机快照</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建快照</span></span><br><span class="line">	1.如果你子啊使用虚拟机系统的时候（比如Linux）,你想回到原先的某一个状态，也就是说你担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，vmware也提供了这样的功能，就叫快照管理。打开快照管理器进行转到相应的快照状态。</span><br></pre></td></tr></table></figure>

<h3 id="5-虚拟机迁移和删除"><a href="#5-虚拟机迁移和删除" class="headerlink" title="5.虚拟机迁移和删除"></a>5.虚拟机迁移和删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">迁移</span></span><br><span class="line">	1.虚拟系统安装好了，它的本质就是文件（放在文件夹的），因此虚拟系统的迁移很方便，你可以把安装好的虚拟系统这个文件夹整体拷贝或者剪切到另外位置使用.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除</span></span><br><span class="line">	2.删除也很简单，用vmware进行移除，再点击菜单-》从磁盘删除即可，或者直接手动删除虚拟系统对应的文件夹即可。从vmware上移除，还是要在本地磁盘上进行删除。</span><br></pre></td></tr></table></figure>

<h3 id="6-安装vmtools"><a href="#6-安装vmtools" class="headerlink" title="6.安装vmtools"></a>6.安装vmtools</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">1.vmtools安装后，可以让我们在windows下更好的管理vm虚拟机</span><br><span class="line">2.可以设置windows和centos的共享文件夹</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意安装时，要用root账户身份进行管理</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装vmtools工具</span></span><br><span class="line">1.进入centos(root管理员身份进入)</span><br><span class="line">	1.弹出桌面上的centos光驱（如果有的话）</span><br><span class="line">2.点击vm外部菜单的虚拟机-》vmware tools安装</span><br><span class="line">3.centos会出现一个vm安装包，xx.tar.gz</span><br><span class="line">4.拷贝到/opt目录下  （这个先进入主文件夹，再点其他设备，再点本机就可以看到了）</span><br><span class="line">5.使用解压命令tar,得到一个安装文件</span><br><span class="line">	5.1.打开一个终端。  [root@study ~]# cd /opt   [进入到opt目录]（可以在开机主界面右键打开终端）</span><br><span class="line">	5.2.解压文件	   [root@study opt]# tar -zxvf VMwareTools-10.3.22-15902021.tar.gz</span><br><span class="line">6.进入该VM解压的目录。/opt目录下</span><br><span class="line">	[root@study opt]# cd vmware-tools-distrib/</span><br><span class="line">7.安装 ./vmware-install.pl</span><br><span class="line">    [root@study vmware-tools-distrib]# ls</span><br><span class="line">    bin  caf  doc  etc  FILES  INSTALL  installer  lib  vgauth  vmware-install.pl</span><br><span class="line">    [root@study vmware-tools-distrib]# ./vmware-install.pl</span><br><span class="line">    后面就一直回车，按默认设置即可，就可以安装成功</span><br><span class="line">8.注意：安装vmtools,需要有gcc</span><br><span class="line">	敲入gcc -v有提示信息就表示有(貌似没有也可以安装好使用)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置共享文件夹</span></span><br><span class="line">为了方便，我们可以设置一个共享文件夹，比如在，d:/test</span><br><span class="line"></span><br><span class="line">具体步骤：</span><br><span class="line">1.菜单-》VM(自己装的这个Linux)-》设置，如下图设置即可：设置为总是启用</span><br><span class="line">2.windows和centos就可以共享d:/test目录读写文件了</span><br><span class="line">3.共享文件夹在centos的 点完其他设备里面的计算机下面的 /mnt/hgfs/下了</span><br><span class="line"></span><br><span class="line">注意事项和细节说明：</span><br><span class="line">	1.windows和centos就可以共享文件了，但是在实际开发中，文件的上传和下载是需要使用 远程方式完成的</span><br><span class="line">	2.远程登陆方式，后面再讲</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211026175211469.png" alt="image-20211026175211469"></p>
<h3 id="7-目录结构"><a href="#7-目录结构" class="headerlink" title="7.目录结构"></a>7.目录结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录&quot;/&quot;,然后再次目录下再创建其他的目录。</span><br><span class="line">2.深刻理解linux树状文件目录式非常重要的。</span><br><span class="line">3.linux世界里，一切皆文件。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">具体的目录结构（不用背，知道即可）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin [常用] (/usr/bin,/usr/local/bin)是binary的缩写，这个目录存放着最经常使用的命令</span></span><br><span class="line"></span><br><span class="line">--- /sbin (/usr/bin,/usr/local/bin),s就是Super user的意思，这里存放的是系统管理员使用的系统管理程序</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/home [常用] 存放普通用户的主目录，在linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/root [常用] 该目录为系统管理员，也称作超级权限者的用户主目录</span></span><br><span class="line">--- /lib 系统开机所需要要的最基本的动态连接共享库，其作用类似于Windows里的DDL文件，几乎所有的应用程序都需要用到这些共享库</span><br><span class="line">--- /lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/etc [常用] 所有的系统管理所需要的配置文件和字目录，比如安装mysql教程 my.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/usr [常用] 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/boot [常用] 存放的是启动Linux时使用的一些核心文件，包括一些连接文件和镜像文件</span></span><br><span class="line"></span><br><span class="line">--- /proc 【不要动】这个目录是一个虚拟的目录，他是系统内存的映射，访问这个目录来获取系统信息</span><br><span class="line">--- /srv 【不要动】service缩写，该目录存放一些服务启动之后需要提取的数据</span><br><span class="line">--- /sys 【不要动】这是linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs</span><br><span class="line">--- /tmp 这个目录是用来存放一些临时文件的</span><br><span class="line">--- /dev 类似于windows的设备管理器，把所有的硬件用文件的形式存储</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/media [常用] Linux系统会自动识别一些设备，例如u盘，光驱等，当时别后，linux会把识别的设备挂载到这个目录</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/mnt [常用] 系统提供该目录是为了让用户临时挂载到别的文件系统，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了，如前面讲的共享文件夹 d:/test</span></span><br><span class="line"></span><br><span class="line">--- /opt 这是给主机额外安装软件所摆放的目录，如安装orcale数据库就可以放到该目录下，默认为空。前面在安装vmtools时就是在这里。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/local [常用] 这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/var [常用] 这个目录中存放着不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件</span></span><br><span class="line"></span><br><span class="line">--- /selinux [security-enhanced linux] SELinux 是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置</span><br></pre></td></tr></table></figure>

<h2 id="第一章：-linux实操篇：远程登录到linux服务器"><a href="#第一章：-linux实操篇：远程登录到linux服务器" class="headerlink" title="第一章：.linux实操篇：远程登录到linux服务器"></a>第一章：.linux实操篇：远程登录到linux服务器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么需要远程登陆linux</span></span><br><span class="line">1.linux服务器是开发小组程序</span><br><span class="line">2.正是上线的项目是运行在公网</span><br><span class="line">3.因此程序员需要远程登录到linux进行项目管理或者开发</span><br><span class="line">4.远程登陆客户端有XShell7,XFtp7,其他的工具大同小异。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：怎样获取vmware上虚拟的linux的主机ip地址</span></span><br><span class="line">使用ifconfig命令来获取inet的ip地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">XFtp7文件名乱码</span></span><br><span class="line">按照下图进行调试解决，设置编码，再进行连接</span><br></pre></td></tr></table></figure>

<h3 id="1-vi和vim文本编辑器（vim）"><a href="#1-vi和vim文本编辑器（vim）" class="headerlink" title="1.vi和vim文本编辑器（vim）"></a>1.vi和vim文本编辑器（vim）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">linux系统会内置vi文本编辑器</span><br><span class="line"></span><br><span class="line">vim编辑器具有程序编辑的能力，可以看作是VI的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计，代码补全，编译及错误跳转等方便编程的功能，特别丰富，在程序中被广泛使用。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vi和vim常用的三种模式</span></span><br><span class="line">1.正常模式【从终端命令行进入某个文件的编辑模式：输入vim hello.java [root@study ~]# vim hello.java】</span><br><span class="line">	以vim打开一个档案就直接进入一般模式了（这是默认的模式），在这个模式种，你可以使用【上下左右】按键来移动光标，你可以使用【删除字符】或【删除整行】来处理档案内容，也可以使用【复制、粘贴】来处理你的文件数据</span><br><span class="line">	</span><br><span class="line">2.插入模式 【从正常模式进到插入模式 输入i这个字母】</span><br><span class="line">	按下i,I,o,O,a,A,r,R等任何一个字母之后才会进行编辑模式，一般来说按i即可</span><br><span class="line"></span><br><span class="line">3.命令行模式【从插入模式进到命令行模式 先输入esc再输入 : 这个字符】【然后再输入wq就退回到终端，wq是指写入并退出，:q!强制退出  :wq是保存退出  :q是退出】</span><br><span class="line">	在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开Vim，显示行号等的动作则是在此模式中完成的。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">	在插入模式和命令行模式时，输入Esc就退回到一般模式</span><br><span class="line">	输入 i 进到插入模式</span><br><span class="line">	输入 : 进到命令行模式</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vi和vim快捷键</span></span><br><span class="line">快捷键练习：</span><br><span class="line">1.拷贝当前行 （输入 yy）, 拷贝当前行向下的5行 (输入 5yy ),并粘贴 （输入p），这个操作是将拷贝的内容放在光标所在行的后面插入  【注意这要在正常模式下输入】</span><br><span class="line">2.删除当前行 （输入dd）,删除当前行向下的5行 （输入5dd）【注意这要在正常模式下输入】</span><br><span class="line">3.在文件中查找某个单词（在命令行模式下 输入 /关键字，回车查找，输入n 就是查找下一个）</span><br><span class="line">4.设置文件的行号，取消文件的行号（在命令行模式下输入 :set nu 与 :set nonu）</span><br><span class="line">5.编辑/etc/profile文件，使用快捷键到该文档的最末行(输入G,即shift+g,和到最首行（输入gg）【在一般模式下使用】</span><br><span class="line">6.在一个文件中”hello“,然后又撤销这个动作 （输入u）【在一般模式下使用】</span><br><span class="line">7.编辑/etc/profile文件，并将光标移动到20行（输入 20 shift+g)【在一般模式下使用】</span><br><span class="line">8.更多的看</span><br></pre></td></tr></table></figure>

<h3 id="2-关机-重启命令-shutdown、reboot"><a href="#2-关机-重启命令-shutdown、reboot" class="headerlink" title="2.关机&amp;重启命令(shutdown、reboot)"></a>2.关机&amp;重启命令(shutdown、reboot)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">shutdown -h now   	立刻进行关机</span><br><span class="line">shutdown -h 1	  	&quot;hello,1分钟后会关机了&quot;</span><br><span class="line">shutdown -r now   	现在重新启动计算机</span><br><span class="line">halt				关机，作用和上面一样</span><br><span class="line">reboot				现在重新启动计算机</span><br><span class="line">sync				把内存的数据同步到磁盘</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意细节</span></span><br><span class="line">1.不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中</span><br><span class="line">2.目前的shutdown/sync/halt等命令均已经在关机前进行了sync</span><br></pre></td></tr></table></figure>

<h3 id="3-用户登录和注销-logout、exit"><a href="#3-用户登录和注销-logout、exit" class="headerlink" title="3.用户登录和注销(logout、exit)"></a>3.用户登录和注销(logout、exit)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.登录时尽量少用root账号登录，因为它是系统管理员，最大的权限，避免操作失误，可以利用普通用户登录，登陆后再用&quot;su - 用户名&quot; 命令来切换成系统管理员身份 （这里的用户名是指root）</span><br><span class="line">	如 [dmtsai@study ~]$ su - root</span><br><span class="line">	   密码：(输入root密码)</span><br><span class="line">       [root@study ~]#</span><br><span class="line"></span><br><span class="line">2.在提示符下输入logout即可注销用户 [在普通用户下使用su - root进到root管理员账户下，使用logout指令就退回到dmtsai普通用户下。如果在普通用户下再执行logout指令就退出这个系统了]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.logout注销指令（退出这个终端无效，从root用户退回到普通用户还是有效的）在图形运行级别(如在Vmware中)无效，在运行级别3（shell环境下，非图形化界面，如Xshell）下才有效</span><br><span class="line">2.运行级别这个概念，后面再讲</span><br></pre></td></tr></table></figure>

<h3 id="4-用户管理"><a href="#4-用户管理" class="headerlink" title="4.用户管理"></a>4.用户管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</span><br></pre></td></tr></table></figure>

<h4 id="1-添加账户-useradd"><a href="#1-添加账户-useradd" class="headerlink" title="1.添加账户(useradd)"></a>1.添加账户(useradd)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法：</span></span><br><span class="line">	useradd 用户名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例演示：</span></span><br><span class="line">	添加一个用户米兰，默认该用户的home目录在/home/milan</span><br><span class="line">	</span><br><span class="line">	[root@study home]# useradd milan</span><br><span class="line">    [root@study home]# ls</span><br><span class="line">    dmtsai  milan</span><br><span class="line">    [root@study home]# su - milan</span><br><span class="line">    [milan@study ~]$</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">细节说明：</span></span><br><span class="line">	1.当创建用户成功后，会自动的创建和用户同名的home目录</span><br><span class="line">	2.也可以通过 useradd -d 指定目录 新的用户名，给新创建的用户指定家目录</span><br><span class="line">		[milan@study ~]$ pwd    【pwd指令是输出当前用户所在的目录】</span><br><span class="line">		/home/milan</span><br><span class="line">		[milan@study ~]</span><br></pre></td></tr></table></figure>

<h4 id="2-指定-修改密码-passwd"><a href="#2-指定-修改密码-passwd" class="headerlink" title="2.指定&#x2F;修改密码(passwd)"></a>2.指定&#x2F;修改密码(passwd)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	passwd 用户名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应用案例：</span></span><br><span class="line">	给king指定密码</span><br><span class="line">	</span><br><span class="line">	[root@study ~]# passwd king</span><br><span class="line">    更改用户 king 的密码 。</span><br><span class="line">    新的 密码：</span><br><span class="line">    重新输入新的 密码：</span><br><span class="line">    passwd：所有的身份验证令牌已经成功更新。</span><br><span class="line">    [root@study ~]#</span><br></pre></td></tr></table></figure>

<h4 id="3-删除用户（userdel）"><a href="#3-删除用户（userdel）" class="headerlink" title="3.删除用户（userdel）"></a>3.删除用户（userdel）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	userdel 用户名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应用案例</span></span><br><span class="line">	1.删除用户milan，但是要保留家目录【userdel milan】</span><br><span class="line">		[root@study home]# ls</span><br><span class="line">        dmtsai  milan  test</span><br><span class="line">        [root@study home]# userdel milan</span><br><span class="line">        userdel: user milan is currently used by process 14066</span><br><span class="line">        [root@study home]# ls</span><br><span class="line">        dmtsai  milan  test</span><br><span class="line"></span><br><span class="line">	2.删除用户以及用户主目录【userdel -r tom】,这个操作要谨慎</span><br><span class="line">		[root@study home]# ls</span><br><span class="line">        dmtsai  milan  test  tom</span><br><span class="line">        [root@study home]# userdel -r tom</span><br><span class="line">        [root@study home]# ls</span><br><span class="line">        dmtsai  milan  test</span><br><span class="line">        [root@study home]#</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">细节说明：</span></span><br><span class="line">	是否保留家目录的讨论？</span><br><span class="line">	一般情况下，建议保留。</span><br></pre></td></tr></table></figure>

<h4 id="4-查询用户信息指令-id指令"><a href="#4-查询用户信息指令-id指令" class="headerlink" title="4.查询用户信息指令(id指令)"></a>4.查询用户信息指令(id指令)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	id 用户名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应用实例</span></span><br><span class="line">	请查询root信息</span><br><span class="line">	[root@study home]# id root</span><br><span class="line">    uid=0(root) gid=0(root) 组=0(root)</span><br><span class="line">    [root@study home]# id dmtsai</span><br><span class="line">    uid=1000(dmtsai) gid=1000(dmtsai) 组=1000(dmtsai),10(wheel)</span><br><span class="line">    [root@study home]# id king</span><br><span class="line">    uid=1002(king) gid=1002(king) 组=1002(king)</span><br><span class="line">    [root@study home]# id tom</span><br><span class="line">    id: tom: no such user</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">细节说明</span></span><br><span class="line">	当用户不存在时，返回无此用户</span><br></pre></td></tr></table></figure>

<h4 id="5-切换用户-su"><a href="#5-切换用户-su" class="headerlink" title="5.切换用户(su - )"></a>5.切换用户(su - )</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">	在操作Linux系统中，如果当前用户的权限不够，可以通过【su - 用户名】,切换到高权限用户，比如root</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	su - 用户名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">细节说明</span></span><br><span class="line">	1.从权限高的用户切换到权限低的用户，不需要输入密码，反之需要</span><br><span class="line">	2.当需要返回到原来用户时，使用exit/logout指令</span><br></pre></td></tr></table></figure>

<h4 id="6-查看当前用户-登录用户-whoami指令"><a href="#6-查看当前用户-登录用户-whoami指令" class="headerlink" title="6.查看当前用户&#x2F;登录用户(whoami指令)"></a>6.查看当前用户&#x2F;登录用户(whoami指令)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	whoami 或者 who am i</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应用实例</span></span><br><span class="line">	[root@study home]# who am i</span><br><span class="line">    root     pts/2        2021-10-26 20:51 (192.168.126.1)</span><br><span class="line">    [root@study home]# su - jack</span><br><span class="line">    su: user jack does not exist</span><br><span class="line">    [root@study home]# su dmtsai</span><br><span class="line">    [dmtsai@study home]$ whoami</span><br><span class="line">    dmtsai</span><br><span class="line">    [dmtsai@study home]$ who am i</span><br><span class="line">    root     pts/2        2021-10-26 20:51 (192.168.126.1)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">细节说明</span></span><br><span class="line">	当用户不存在时，返回无此用户</span><br></pre></td></tr></table></figure>

<h4 id="7-用户组（groupadd-useradd）"><a href="#7-用户组（groupadd-useradd）" class="headerlink" title="7.用户组（groupadd,useradd）"></a>7.用户组（groupadd,useradd）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">	类似于角色，系统可以对有共性的多个用户进行统一的管理</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新增组</span></span><br><span class="line">	groupadd 组名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除组</span></span><br><span class="line">	groupdel 组名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加用户时，直接加上组</span></span><br><span class="line">	useradd -g 用户组名 用户名</span><br><span class="line">	增加一个用户zwj,直接将他指定到wudang useradd -g wudang zwj</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改用户组</span></span><br><span class="line">	usermod -g 用户组 用户名</span><br><span class="line">	案例演示：将zwj（原本属于wudang这个组）放到mojiao</span><br><span class="line">		usermod -g mojiao zwj</span><br><span class="line">	</span><br><span class="line">	[root@study home]# groupadd wudang</span><br><span class="line">    [root@study home]# groupadd shaolin</span><br><span class="line">    [root@study home]# groupdel shaolin</span><br><span class="line">    [root@study home]# useradd -g wudang zwj</span><br><span class="line">    [root@study home]# su zwj</span><br><span class="line">    </span><br><span class="line">    [zwj@study home]$ id zwj</span><br><span class="line">    uid=1003(zwj) gid=1003(wudang) 组=1003(wudang)</span><br><span class="line">    </span><br><span class="line">    //创建用户时，如果没有设置组时，就会默认创建用户名这个组</span><br><span class="line">    [root@study home]# useradd yss</span><br><span class="line">    [root@study home]# id yss</span><br><span class="line">    uid=1004(yss) gid=1004(yss) 组=1004(yss)</span><br><span class="line">    [root@study home]# id root</span><br><span class="line">	uid=0(root) gid=0(root) 组=0(root)</span><br></pre></td></tr></table></figure>

<h4 id="8-用户和组相关文件"><a href="#8-用户和组相关文件" class="headerlink" title="8.用户和组相关文件"></a>8.用户和组相关文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/passwd 文件</span></span><br><span class="line">用户（user）的配置文件，记录用户的各种信息</span><br><span class="line">每行的含义：用户名:口令:用户标识号:组标识号:注释行描述:主目录:登录Shell</span><br><span class="line"></span><br><span class="line">如：bash就是一种shell,将输入的命令进行解释之后才能被linux内核知道（类似于语言的编译器，才能让机器明白）</span><br><span class="line">	root:x:0:0:root:/root:/bin/bash</span><br><span class="line">	dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">    milan:x:1001:1001::/home/milan:/bin/bash</span><br><span class="line">    king:x:1002:1002::/home/test:/bin/bash</span><br><span class="line">    zwj:x:1003:1005::/home/zwj:/bin/bash</span><br><span class="line">    yss:x:1004:1004::/home/yss:/bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/shadow 文件</span></span><br><span class="line">口令的配置文件</span><br><span class="line">每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">	root:$6$Yez.avR37mU/r4FL$4waY9vdxJR1rY.wnU9kon5asyABpDSn4Tq238ppg3nmpsLPrnkkON/Whi/clORaQ2pTZIM/02sa3CtMVElUQP0::0:99999:7:::</span><br><span class="line">dmtsai:$6$SLZCN44Q5SuUN6P3$K99BU40y6NYym6jOYxRbXF9QNJWAM0dL6BYDsJ.zS1qkrKCRjVJaFjD4s2lQLJSF8MeEl4svba45Y878AEvI..::0:99999:7:::</span><br><span class="line">yss:!!:18926:0:99999:7:::</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/group 文件</span></span><br><span class="line">组（group）的配置文件，记录Linux包含的组的信息</span><br><span class="line">每行的含义：组名:口令:组标识号:组内用户列表</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">    root:x:0:</span><br><span class="line">    dmtsai:x:1000:dmtsai</span><br><span class="line">    milan:x:1001:</span><br><span class="line">    king:x:1002:</span><br><span class="line">    wudang:x:1003:</span><br><span class="line">    yss:x:1004:</span><br><span class="line">    mojiao:x:1005:</span><br></pre></td></tr></table></figure>

<h2 id="第二章：linux-实操篇：常用指令"><a href="#第二章：linux-实操篇：常用指令" class="headerlink" title="第二章：linux:实操篇：常用指令"></a>第二章：linux:实操篇：常用指令</h2><h3 id="1-指定运行级别（systemctl指令）"><a href="#1-指定运行级别（systemctl指令）" class="headerlink" title="1.指定运行级别（systemctl指令）"></a>1.指定运行级别（systemctl指令）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行级别说明</span></span><br><span class="line">0:关机</span><br><span class="line">1:单用户【找回丢失密码】</span><br><span class="line">2:多用户状态没有网络服务</span><br><span class="line">3:多用户状态有网络服务</span><br><span class="line">4:系统未使用保留给用户</span><br><span class="line">5:图形界面</span><br><span class="line">6:系统重启</span><br><span class="line">常用运行级别是3和5，也可以指定默认运行级别，后面演示</span><br><span class="line"></span><br><span class="line">应用实例：</span><br><span class="line">	命令：init [0123456] 如：通过init来切换不同的运行级别，比如从5-3，然后关机</span><br><span class="line">	如在图形界面 输入 【init 5】就进入运行级别5.再输入【init 3】又可以回到图形界面</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">细节说明：</span></span><br><span class="line">multi-user.target:等同于就是运行级别3</span><br><span class="line">graphical.target:等同于就是运行级别5</span><br><span class="line"></span><br><span class="line">查看当前默认运行级别指令：</span><br><span class="line">[root@study ~]# systemctl get-default</span><br><span class="line">graphical.target</span><br><span class="line"></span><br><span class="line">设置当前默认运行级别指令：  //设置默认运行级别为multi-user.target，重启后，就使用这个级别</span><br><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>

<h3 id="2：找回root密码"><a href="#2：找回root密码" class="headerlink" title="2：找回root密码"></a>2：找回root密码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#面试题 如何找回root密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">课堂练习：</span><br><span class="line">	1.假设root密码忘记了，请问如何找回密码</span><br><span class="line">	2.设置密码级别，linux运行后，直接进到 命令行终端（即运行级别3）</span><br></pre></td></tr></table></figure>

<h3 id="3：帮助指令（man、help）"><a href="#3：帮助指令（man、help）" class="headerlink" title="3：帮助指令（man、help）"></a>3：帮助指令（man、help）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">man 获得帮助信息</span></span><br><span class="line">基本语法：man [命令或配置文件] （功能描述：获得帮助信息）</span><br><span class="line">案例：查看ls命令的帮助信息 man ls [选项] [文件名] </span><br><span class="line">	选项：（选项可以组合使用） 【ls -al】</span><br><span class="line">		-a 	列出所有文件，包括以 &quot;.&quot; 开头的隐含文件。</span><br><span class="line">		-1 	单列输出。</span><br><span class="line">	文件名：（指定输出当前目录的内容，不写的话就是默认当前工作目录） 【ls -a /root】</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">help</span>指令</span></span><br><span class="line">基本语法：help命令（功能描述：获得shell内置命令的帮助信息）</span><br><span class="line">案例：查看cd命令的帮助信息</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">百度帮助更靠谱</span></span><br></pre></td></tr></table></figure>

<h3 id="4：文件目录类-pwd-ls-cd-mkdir-rmdir-touch-cp-rm-mv-cat-more-less-echo-head-tail-ln-history"><a href="#4：文件目录类-pwd-ls-cd-mkdir-rmdir-touch-cp-rm-mv-cat-more-less-echo-head-tail-ln-history" class="headerlink" title="4：文件目录类[pwd,ls,cd,mkdir,rmdir,touch,cp,rm,mv,cat,more,less,echo,head,tail,&gt;,&gt;&gt;,ln,history]"></a>4：文件目录类[pwd,ls,cd,mkdir,rmdir,touch,cp,rm,mv,cat,more,less,echo,head,tail,&gt;,&gt;&gt;,ln,history]</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">pwd</span>指令</span></span><br><span class="line">    基本语法：pwd  (功能描述：显示当前工作目录的绝对路径)</span><br><span class="line">    案例：显示当前工作目录的绝对路径(从跟目录 / 开始的路径)</span><br><span class="line">        [root@study ~]# pwd</span><br><span class="line">        /root</span><br><span class="line">        [root@study ~]# cd /</span><br><span class="line">        [root@study /]# pwd</span><br><span class="line">        /</span><br><span class="line">        [root@study /]# cd home</span><br><span class="line">        [root@study home]# pwd</span><br><span class="line">        /home</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">ls</span>指令</span></span><br><span class="line">    基本语法：ls [选项] [目录或是文件]</span><br><span class="line">    常用选项：</span><br><span class="line">        -a 	列出所有文件，包括以 &quot;.&quot; 开头的隐含文件。</span><br><span class="line">        -1 	单列输出。</span><br><span class="line">    案例：查看当前目录的所有内容信息</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cd</span>指令</span></span><br><span class="line">    基本语法：cd [参数] （功能描述：切换到指定目录）</span><br><span class="line">    理解：绝对路径和相对路径</span><br><span class="line">    【cd ~】或者【cd】:回到自己的家目录</span><br><span class="line">    【cd ..】：回到当前目录的上一级目录</span><br><span class="line"></span><br><span class="line">        [root@study /]# cd home</span><br><span class="line">        [root@study home]# ls</span><br><span class="line">        dmtsai  milan  test  yss  zwj</span><br><span class="line">        [root@study home]# cd test</span><br><span class="line">        //依据相对路径来进行访问</span><br><span class="line">        [root@study test]# cd ../milan</span><br><span class="line">        //回到上一级目录</span><br><span class="line">        [root@study milan]# cd ..</span><br><span class="line">        [root@study home]# cd test</span><br><span class="line">        //依据绝对路径来进行访问</span><br><span class="line">        [root@study test]# cd /home/milan</span><br><span class="line">        //进入家目录</span><br><span class="line">        [root@study milan]# cd</span><br><span class="line">        [root@study ~]#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">mkdir</span>指令</span></span><br><span class="line">	mkdir指令用于创建目录</span><br><span class="line">	基本语法：mkdir [选项] 要创建的目录</span><br><span class="line">	常用选项</span><br><span class="line">		-p:创建多级目录  【即可以一下子创建好几级目录，否则的话只能创建一级目录】</span><br><span class="line">	案例：</span><br><span class="line">		1.创建一个目录 /tmp/test/dog</span><br><span class="line">		2.创建多级目录 /tmp/test/cat/smallcat </span><br><span class="line">	如：</span><br><span class="line">		[root@study test]# mkdir ./dog</span><br><span class="line">        [root@study test]# ls</span><br><span class="line">        dog</span><br><span class="line">        [root@study test]# mkdir ./cat/smallcat</span><br><span class="line">        mkdir: 无法创建目录&quot;./cat/smallcat&quot;: 没有那个文件或目录</span><br><span class="line">        [root@study test]# mkdir -p ./cat/smallcat</span><br><span class="line">        [root@study test]#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">rmdir</span>指令</span></span><br><span class="line">	rmdir指令删除空目录</span><br><span class="line">	基本语法：rmdir [选项] 要删除的空目录</span><br><span class="line">	案例：</span><br><span class="line">		删除一个目录 /tmp/test/dog</span><br><span class="line">	使用细节：</span><br><span class="line">		rmdir删除的是空目录，如果目录下有内容时无法删除的</span><br><span class="line">		提示：如果需要删除非空目录，需要使用 【rm -rf 要删除的目录】，这个动作需要小心谨慎</span><br><span class="line">	如：</span><br><span class="line">		[root@study tmp]# cd test</span><br><span class="line">        [root@study test]# rmdir dog</span><br><span class="line">        [root@study test]# rmdir cat</span><br><span class="line">        rmdir: 删除 &quot;cat&quot; 失败: 目录非空</span><br><span class="line">        [root@study test]# rm -rf cat</span><br><span class="line">        [root@study test]#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">touch</span>指令</span></span><br><span class="line">	touch指令创建空文件</span><br><span class="line">	基本语法：</span><br><span class="line">		touch 文件名称</span><br><span class="line">	应用实例：</span><br><span class="line">		创建一个空文件 hello.txt</span><br><span class="line">	如：</span><br><span class="line">		[root@study test]# touch hello.txt</span><br><span class="line">        [root@study test]# ls</span><br><span class="line">        hello.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cp</span>指令</span></span><br><span class="line">	cp指令拷贝文件到指定目录</span><br><span class="line">	基本语法</span><br><span class="line">		cp [选项] souce dest</span><br><span class="line">	常用选项：</span><br><span class="line">		-r:递归复制整个文件夹</span><br><span class="line">	案例：</span><br><span class="line">		1.将/tmp/test/hello.txt拷贝到/tmp/test/bbb目录下  (其中这个文件以及这个目录必须已经存在)</span><br><span class="line">		2.将递归复制整个文件夹，举例将/tmp/test/ddd这个文件夹递归复制到/tmp/temp/aaa这个目录内</span><br><span class="line">	使用细节：</span><br><span class="line">		当将一个文件夹整体复制到另外一个目录下面去时，存在同名的文件时，是否覆盖已有的文件，没有强制覆盖的话，就需要每次都进行一下确认。所以就有了强制覆盖不提示， \cp,如强制覆盖  \cp -r test/ddd temp/aaa</span><br><span class="line">	如：</span><br><span class="line">        [root@study tmp]# cp test/hello.txt test/ddd</span><br><span class="line">        [root@study tmp]# cd test</span><br><span class="line">        [root@study test]# ls</span><br><span class="line">        ddd  hello.txt</span><br><span class="line">        [root@study test]# cd ddd</span><br><span class="line">        [root@study ddd]# ls</span><br><span class="line">        hello.txt</span><br><span class="line">        [root@study ddd]#</span><br><span class="line">        </span><br><span class="line">        //案例2演示</span><br><span class="line">        [root@study tmp]# cp test/ddd temp/aaa</span><br><span class="line">        cp: 略过目录&quot;test/ddd&quot;</span><br><span class="line">        [root@study tmp]# cp -r test/ddd temp/aaa</span><br><span class="line">        [root@study tmp]# cd temp/aaa</span><br><span class="line">        [root@study aaa]# ls</span><br><span class="line">        ddd</span><br><span class="line">        [root@study aaa]#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">rm</span>指令</span></span><br><span class="line">	rm指令移除文件或者目录</span><br><span class="line">	基本语法：</span><br><span class="line">		rm [选项] 要删除的文件或目录</span><br><span class="line">	常用选项：</span><br><span class="line">		-r:递归删除整个文件夹</span><br><span class="line">		-f:强制删除不提示</span><br><span class="line">	案例：</span><br><span class="line">		1.将/tmt/test/hello.txt删除</span><br><span class="line">		2.递归删除整个文件夹/tmp/test/ddd</span><br><span class="line">	使用细节：</span><br><span class="line">		强制删除不提示的方法：带上-f参数即可</span><br><span class="line">	如：</span><br><span class="line">		[root@study tmp]# rm test/hello.txt   (如果不想要提示的话 rm -f test/hello.txt)</span><br><span class="line">		rm：是否删除普通空文件 &quot;test/hello.txt&quot;？y</span><br><span class="line">		[root@study tmp]# rm temp/aaa</span><br><span class="line">        rm: 无法删除&quot;temp/aaa&quot;: 是一个目录</span><br><span class="line">        [root@study tmp]# rm -r temp/aaa  (不想要提示就 -rf)</span><br><span class="line">        rm：是否进入目录&quot;temp/aaa&quot;? y</span><br><span class="line">        rm：是否进入目录&quot;temp/aaa/ddd&quot;? y</span><br><span class="line">        rm：是否删除普通空文件 &quot;temp/aaa/ddd/hello.txt&quot;？y</span><br><span class="line">        rm：是否删除目录 &quot;temp/aaa/ddd&quot;？y</span><br><span class="line">        rm：是否删除目录 &quot;temp/aaa&quot;？y</span><br><span class="line">        [root@study tmp]#</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">mv</span>指令</span></span><br><span class="line">	mv指令移动文件与目录或重命名</span><br><span class="line">	基本语法：</span><br><span class="line">		mv oldNameFile newNameFile (功能描述：重命名)</span><br><span class="line">		mv /temp/moveFile /targetFolder (功能描述：移动文件)</span><br><span class="line">	应用实例：</span><br><span class="line">		1.将/tmp/test/cat.txt文件重命名为pig.txt</span><br><span class="line">		2.将/tmp/test/pig.txt移动到/tmp/temp/aaa目录下  (如果移动并且重命名mv pig.txt ../temp/aaa/cat.txt)</span><br><span class="line">		3.将/tmp/test/aaa这个目录移动到/tmp/temp目录下</span><br><span class="line">	如：</span><br><span class="line">        [root@study test]# ls</span><br><span class="line">        cat.txt  ddd</span><br><span class="line">        [root@study test]# mv cat.txt pig.txt</span><br><span class="line">        [root@study test]# ls</span><br><span class="line">        ddd  pig.txt</span><br><span class="line">        //这是光移动文件不重命名</span><br><span class="line">        [root@study test]# mv pig.txt ../temp/aaa</span><br><span class="line">        [root@study test]# ls</span><br><span class="line">        ddd</span><br><span class="line">        [root@study test]# cd ../temp/aaa</span><br><span class="line">        [root@study aaa]# ls</span><br><span class="line">        pig.txt</span><br><span class="line">        </span><br><span class="line">        //这是将一个目录移动到另一个目录下</span><br><span class="line">        //3.将/tmp/test/aaa这个目录移动到/tmp/temp目录下</span><br><span class="line">        [root@study tmp]# mv test/ddd temp</span><br><span class="line">        [root@study tmp]# cd temp</span><br><span class="line">        [root@study temp]# ls</span><br><span class="line">        aaa  ddd</span><br><span class="line">        [root@study temp]#</span><br><span class="line"><span class="meta prompt_">		</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span>指令</span></span><br><span class="line">	cat指令查看文件内容。（vim也可以查看，但是cat是只能查看不能修改）</span><br><span class="line">	基本语法：</span><br><span class="line">		cat [选项] 要查看的文件</span><br><span class="line">	常用选项：</span><br><span class="line">		-n:显示行号</span><br><span class="line">	案例：</span><br><span class="line">		查看/etc/profile文件内容，并显示行号</span><br><span class="line">		[root@study temp]# cat -n  /etc/profile</span><br><span class="line">	使用细节：</span><br><span class="line">		cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令 |more</span><br><span class="line">		//相当于是将前面执行的命令交给more去处理，按回车键就多看一行，按空格键就翻页</span><br><span class="line">		[root@study temp]# cat -n  /etc/profile | more </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">more指令</span></span><br><span class="line">	more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容，more指令中内置了若干了快捷键（交互的指令），详见操作说明</span><br><span class="line">	基本语法：</span><br><span class="line">			more 要查看的文件</span><br><span class="line">	操作说明:</span><br><span class="line">            空格键（SPACE）： 代表向下翻一页</span><br><span class="line">            回车键（Enter）:代表向下翻一行</span><br><span class="line">            q 或 Q 或 INTERRUPT：代表立即退出.不再显示文件内容</span><br><span class="line">            CTRL+F:向下滚动一屏</span><br><span class="line">            CTRL+B:返回上一屏</span><br><span class="line">            =           ：显示当前行号.</span><br><span class="line">            :f          ：显示 当前文件名 和 行号.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">less指令</span></span><br><span class="line">	less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端，less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率（类似于动态加载）</span><br><span class="line">	基本语法：</span><br><span class="line">		less 要查看的文件</span><br><span class="line">	操作说明：</span><br><span class="line">		空格键：显示下一页</span><br><span class="line">		pageDown键：向下翻动一页</span><br><span class="line">		pageUp键：向上翻动一页</span><br><span class="line">		/字串：向下搜寻【字串】的功能：n:向下查找，N:向上查找</span><br><span class="line">		?字串：向上搜寻【字串】的功能：n:向上查找，N:向下查找</span><br><span class="line">		q:退出less这个文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span>指令</span></span><br><span class="line">	echo指令输出内容到控制台</span><br><span class="line">	基本语法：</span><br><span class="line">		echo [选项] [输出内容]</span><br><span class="line">	案例：</span><br><span class="line">		1.使用echo指令输出环境变量  </span><br><span class="line">		2.使用echo指令输出 hello,world!</span><br><span class="line">	如：</span><br><span class="line">		[root@study temp]# echo $PATH</span><br><span class="line">        /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">        [root@study temp]# echo $HOSTNAME</span><br><span class="line">        study.centos.vbird</span><br><span class="line">        [root@study temp]# echo hello,wrold!</span><br><span class="line">		hello,wrold!</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">head</span>指令</span></span><br><span class="line">	head指令用于显示文件的开头部分内容，默认情况下head指令显示文件的前十行内容</span><br><span class="line">	基本语法：</span><br><span class="line">		head 文件 （功能描述：查看文件头10行内容）</span><br><span class="line">		head -n 5 文件 （功能描述：查看文件头5行内容，5可以是任意行数）</span><br><span class="line">	案例：</span><br><span class="line">		查看/etc/profile的前5行内容</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">tail</span>指令</span></span><br><span class="line">	tail指令输出文件尾部的内容，默认是文件的最后10行内容</span><br><span class="line">	基本语法：</span><br><span class="line">		tail 文件 （功能描述：查看文件尾部的10行内容）</span><br><span class="line">		tail -n 5 文件 （功能描述：查看文件尾部5行内容，5可以是任意的行数）</span><br><span class="line">		tail -f 文件 (功能描述：实时追踪该文档的所有更新)</span><br><span class="line">	案例：</span><br><span class="line">		1.查看/etc/profile的最后5行内容</span><br><span class="line">		tail -n 5 /etc/profile</span><br><span class="line">		2.实时监控mydate.txt,看看文件有变化时，是否看到实时追加的日期</span><br><span class="line">		tail -f mydate.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt;指令和 &gt;&gt;指令</span></span><br><span class="line"><span class="meta prompt_">	&gt;</span><span class="language-bash">指令：输出重定向</span></span><br><span class="line"><span class="meta prompt_">	&gt;</span><span class="language-bash">&gt;指令：追加</span></span><br><span class="line">	基本语法：</span><br><span class="line">		ls -l &gt; 文件 （功能描述：将列表列出的内容写入文件a.txt中（覆盖写））</span><br><span class="line">		ls -al &gt;&gt; 文件 （功能描述：列表的内容追加到文件aa.txt的末尾）</span><br><span class="line">		cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2）</span><br><span class="line">		echo &quot;内容&quot; &gt;&gt; 文件 </span><br><span class="line">	案例：</span><br><span class="line">		1.将/home目录下的文件列表写入到/home/info.txt中 </span><br><span class="line">		ls -l /home &gt; /home/info.txt   //如果info.txt文件不存在，就会创建</span><br><span class="line">		2.将当前日历信息追加到/home/mycal.txt文件</span><br><span class="line">	如：</span><br><span class="line">        [root@study temp]# touch temp.txt</span><br><span class="line">        [root@study temp]# ls -l &gt; temp.txt</span><br><span class="line">        [root@study temp]# cat temp.txt</span><br><span class="line">        总用量 4</span><br><span class="line">        drwxr-xr-x. 2 root root  6 10月 27 18:06 aaa</span><br><span class="line">        drwxr-xr-x. 2 root root 23 10月 27 16:31 ddd</span><br><span class="line">        -rw-r--r--. 1 root root 26 10月 27 18:55 mydate.txt</span><br><span class="line">        -rw-r--r--. 1 root root  0 10月 27 19:05 temp.txt</span><br><span class="line">        [root@study temp]# ls</span><br><span class="line">        aaa  ddd  mydate.txt  temp.txt</span><br><span class="line">        [root@study temp]# cat temp.txt &gt;&gt; mydate.txt</span><br><span class="line">        [root@study temp]# cat mydate.txt</span><br><span class="line">        hdkjsfjdskfds</span><br><span class="line">        fksfksdfksd</span><br><span class="line">        总用量 4</span><br><span class="line">        drwxr-xr-x. 2 root root  6 10月 27 18:06 aaa</span><br><span class="line">        drwxr-xr-x. 2 root root 23 10月 27 16:31 ddd</span><br><span class="line">        -rw-r--r--. 1 root root 26 10月 27 18:55 mydate.txt</span><br><span class="line">        -rw-r--r--. 1 root root  0 10月 27 19:05 temp.txt</span><br><span class="line">        [root@study temp]# echo helloworld &gt; temp.txt</span><br><span class="line">        [root@study temp]# cat temp.txt</span><br><span class="line">        helloworld</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span>指令</span></span><br><span class="line">	软链接也成为符号链接，类似于windows里面的快捷方式，主要存放了链接其他文件的路径，是一个文件</span><br><span class="line">	基本语法：</span><br><span class="line">		ln -s [原文件或目录] [软链接名] （功能描述：给源文件创建一个软链接）</span><br><span class="line">	应用实例：</span><br><span class="line">		1.在/home目录下创建一个软链接myroot,连接到/root目录 </span><br><span class="line">		2.删除软链接myroot</span><br><span class="line">	细节说明：</span><br><span class="line">		当我们使用pwd指令查看目录时，仍然看到的时软链接所在目录</span><br><span class="line">	[root@study temp]# ln -s /root myroot</span><br><span class="line">    [root@study temp]# ls</span><br><span class="line">    aaa  ddd  mydate.txt  myroot  temp.txt</span><br><span class="line">    [root@study temp]# cd myroot</span><br><span class="line">    [root@study myroot]# pwd</span><br><span class="line">    /tmp/temp/myroot</span><br><span class="line">    [root@study temp]# ls</span><br><span class="line">    aaa  ddd  mydate.txt  myroot  temp.txt</span><br><span class="line">    [root@study temp]# cd myroot</span><br><span class="line">    [root@study myroot]# ls</span><br><span class="line">    anaconda-ks.cfg  crontab2  hello.java  initial-setup-ks.cfg  公共  模板  视频  图片  文档  下载  音乐  桌面</span><br><span class="line">    [root@study myroot]# rm ..</span><br><span class="line">    rm: 无法删除&quot;..&quot;: 是一个目录</span><br><span class="line">    [root@study myroot]# cd ..</span><br><span class="line">    //删除软链接</span><br><span class="line">    [root@study temp]# rm myroot</span><br><span class="line">    rm：是否删除符号链接 &quot;myroot&quot;？y</span><br><span class="line">    [root@study temp]#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">history</span>指令</span></span><br><span class="line">	查看已经执行过的历史指令，也可以执行历史指令</span><br><span class="line">	基本语法：</span><br><span class="line">		history (功能描述：查看已经执行过的历史命令)</span><br><span class="line">	应用实例：</span><br><span class="line">		1.显示所有的历史命令  </span><br><span class="line">			history</span><br><span class="line">		2.显示最近使用过的10条指令</span><br><span class="line">			history 10</span><br><span class="line">		3.执行历史编号为5的指令</span><br><span class="line">			!5</span><br></pre></td></tr></table></figure>

<h3 id="5-时间日期类-date、cal"><a href="#5-时间日期类-date、cal" class="headerlink" title="5.时间日期类(date、cal)"></a>5.时间日期类(date、cal)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">date</span>指令</span></span><br><span class="line">	显示当前日期</span><br><span class="line">	基本语法：</span><br><span class="line">		date (功能描述：显示当前时间)</span><br><span class="line">		date +%Y (功能描述：显示当前年份)</span><br><span class="line">		date +%m(功能描述：显示当前月份)</span><br><span class="line">		date +%d(功能描述：显示当前是哪一天)</span><br><span class="line">		date &quot;+%Y-%m-%d %H:%M:%S&quot;(功能描述：显示年月日时分秒)</span><br><span class="line">		</span><br><span class="line">	设置日期：</span><br><span class="line">    基本语法：</span><br><span class="line">    	date -s 字符串时间</span><br><span class="line">    比如设置系统当前时间为：2021-11-11 11:22:22</span><br><span class="line">    </span><br><span class="line">	案例：</span><br><span class="line">		1.显示当前时间信息</span><br><span class="line">		2.显示当前那时间年月日</span><br><span class="line">		3.显示当前时间年月日时分秒</span><br><span class="line">	如：</span><br><span class="line">		[root@study temp]# date</span><br><span class="line">        2021年 10月 27日 星期三 19:37:30 CST</span><br><span class="line">        [root@study temp]# date &quot;+%Y-%m-%d&quot;</span><br><span class="line">        2021-10-27</span><br><span class="line">        [root@study temp]# date &quot;+%Y %m %d&quot;</span><br><span class="line">        2021 10 27</span><br><span class="line">        [root@study temp]# date &quot;+%Y %m %d %H:%M:%S&quot;</span><br><span class="line">        2021 10 27 19:39:10</span><br><span class="line">        [root@study temp]# date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">        2021-10-27 19:39:20</span><br><span class="line">        [root@study temp]# date +%Y</span><br><span class="line">        2021</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cal指令</span></span><br><span class="line">	查看日历指令</span><br><span class="line">	基本语法：</span><br><span class="line">		cal [选项]  （功能描述：不加选项，显示本月日历）</span><br><span class="line">	案例：</span><br><span class="line">		1.显示本月日历</span><br><span class="line">		cal</span><br><span class="line">		2.显示2021年日历</span><br><span class="line">		cal 2021</span><br></pre></td></tr></table></figure>

<h3 id="6-搜索查找类-find-locate-which-grep"><a href="#6-搜索查找类-find-locate-which-grep" class="headerlink" title="6.搜索查找类(find,locate,which,grep)"></a>6.搜索查找类(find,locate,which,grep)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">find指令</span></span><br><span class="line">	find指令将从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端</span><br><span class="line">	基本语法：</span><br><span class="line">		find [搜索范围] [选项]</span><br><span class="line">	选项：</span><br><span class="line">		-name (查询方式)：按照指定的文件名查找模式查找文件</span><br><span class="line">		-user (用户名)：查找属于指定用户名所有文件</span><br><span class="line">		-size(文件大小)：按照指定的文件大小查找文件</span><br><span class="line">	案例：</span><br><span class="line">		1.按文件名：根据名称查找/home目录下的hello.txt文件</span><br><span class="line">		2.按拥有者：查找/home目录下，用户名称为zwj的文件/目录</span><br><span class="line">			find /home -user zwj</span><br><span class="line">		3.查找整个Linux系统下大于200M的文件（+n大于 -n小于 n等于）</span><br><span class="line">			find / -size +200M  (M,k,G)</span><br><span class="line">	如：</span><br><span class="line">		[root@study temp]# find /home -name hello.txt</span><br><span class="line">		[root@study home]# ls</span><br><span class="line">        dmtsai  milan  test  yss  zwj</span><br><span class="line">        [root@study home]# find /home -name test</span><br><span class="line">        /home/test</span><br><span class="line">        [root@study home]# touch hello.txt</span><br><span class="line">        [root@study home]# find /home -name hello.txt</span><br><span class="line">        /home/hello.txt</span><br><span class="line">        </span><br><span class="line">        [root@study home]# find /home -user zwj</span><br><span class="line">        /home/zwj</span><br><span class="line">        /home/zwj/.mozilla</span><br><span class="line">        /home/zwj/.mozilla/extensions</span><br><span class="line">        /home/zwj/.mozilla/plugins</span><br><span class="line">        /home/zwj/.bash_logout</span><br><span class="line">        /home/zwj/.bash_profile</span><br><span class="line">        /home/zwj/.bashrc</span><br><span class="line">        /home/zwj/.cache</span><br><span class="line">        /home/zwj/.cache/abrt</span><br><span class="line">        /home/zwj/.cache/abrt/lastnotification</span><br><span class="line">        /home/zwj/.config</span><br><span class="line">        /home/zwj/.config/abrt</span><br><span class="line">        /home/zwj/.bash_history</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">locate指令</span></span><br><span class="line">	locate指令可以快速定位文件路径，locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查询速度较快，为了保证查询结果的准确度，管理员必须定期更新locate时刻。</span><br><span class="line">	基本语法：</span><br><span class="line">		locate 指定文件</span><br><span class="line">	特别说明：</span><br><span class="line">		由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</span><br><span class="line">	案例：</span><br><span class="line">		请使用locate指令快速定位hello.txt文件所在目录</span><br><span class="line">	如：</span><br><span class="line">		[root@study /]# updatedb</span><br><span class="line">        [root@study /]# locate hello.txt</span><br><span class="line">        /home/hello.txt</span><br><span class="line">        [root@study /]# touch hello.txt</span><br><span class="line">        [root@study /]# locate hello.txt</span><br><span class="line">        /home/hello.txt</span><br><span class="line">        [root@study /]# updatedb</span><br><span class="line">        [root@study /]# locate hello.txt</span><br><span class="line">        /hello.txt</span><br><span class="line">        /home/hello.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">which</span>指令，可以查看某个指令在哪个目录下，比如 <span class="built_in">ls</span>指令</span></span><br><span class="line">	如：which ls</span><br><span class="line">		[root@study /]# which ls</span><br><span class="line">        alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">            /usr/bin/ls</span><br><span class="line">        [root@study /]# which reboot</span><br><span class="line">        /usr/sbin/reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">grep指令和管道符号 |</span></span><br><span class="line">	grep过滤查找</span><br><span class="line">	管道符&quot;|&quot;,表示将前一个命令的处理结果输出传递给后面的命令处理</span><br><span class="line">	</span><br><span class="line">	基本语法：</span><br><span class="line">		grep [选项] 查找内容 源文件</span><br><span class="line">	常用选项：</span><br><span class="line">		-n:显示匹配行及行号</span><br><span class="line">		-i:忽略字母大小写</span><br><span class="line">	案例：</span><br><span class="line">		请在hello.txt文件中，查找&quot;yes&quot;所在行，并且显示行号</span><br><span class="line">		写法1：cat /home/hello.txt | grep -ni &quot;yes&quot;</span><br><span class="line">		写法2：grep -ni &quot;yes&quot; /home/hello.txt</span><br><span class="line">		</span><br><span class="line">	如：</span><br><span class="line">		[root@study home]# grep -ni if /etc/profile</span><br><span class="line">        16:            if [ &quot;$2&quot; = &quot;after&quot; ] ; then</span><br><span class="line">        25:if [ -x /usr/bin/id ]; then</span><br><span class="line">        26:    if [ -z &quot;$EUID&quot; ]; then</span><br><span class="line">        37:if [ &quot;$EUID&quot; = &quot;0&quot; ]; then</span><br><span class="line">        47:if [ &quot;$HISTCONTROL&quot; = &quot;ignorespace&quot; ] ; then</span><br><span class="line">        59:if [ $UID -gt 199 ] &amp;&amp; [ &quot;`/usr/bin/id -gn`&quot; = &quot;`/usr/bin/id -un`&quot; ]; then</span><br><span class="line">        66:    if [ -r &quot;$i&quot; ]; then</span><br><span class="line">        67:        if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then</span><br><span class="line">        [root@study home]#</span><br></pre></td></tr></table></figure>

<h3 id="7-压缩和解压类（gzip-gunzip-zip-unzip-tar）"><a href="#7-压缩和解压类（gzip-gunzip-zip-unzip-tar）" class="headerlink" title="7.压缩和解压类（gzip&#x2F;gunzip,zip&#x2F;unzip,tar）"></a>7.压缩和解压类（gzip&#x2F;gunzip,zip&#x2F;unzip,tar）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gzip/gunzip指令</span></span><br><span class="line">	gzip用于压缩文件，gunzip用于解压文件</span><br><span class="line">	基本语法：</span><br><span class="line">		gzip 文件 (功能描述：压缩文件，只能将文件压缩为*.gz文件)</span><br><span class="line">        gunzip 文件.gz （功能描述：解压缩文件命令）</span><br><span class="line">   	案例：</span><br><span class="line">   		1.gzip压缩，将/home下的hello.txt文件进行压缩</span><br><span class="line">   		2.gunzip解压，将/home下的hello.txt.gz文件进行解压缩</span><br><span class="line">   	如：</span><br><span class="line">        [root@study home]# gzip hello.txt</span><br><span class="line">        [root@study home]# ls</span><br><span class="line">        dmtsai  dst.txt  hello.txt.gz  milan  test  yss  zwj</span><br><span class="line">        [root@study home]# gunzip hello.txt.gz</span><br><span class="line">        [root@study home]# ls</span><br><span class="line">        dmtsai  dst.txt  hello.txt  milan  test  yss  zwj</span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">zip/unzip指令</span></span><br><span class="line">	zip用于压缩文件，unzip用于解压的，这个在项目打包发布中很有用的</span><br><span class="line">	基本语法：</span><br><span class="line">		zip [选项] xxx.zip 将要压缩的内容  (功能描述：压缩文件和目录)</span><br><span class="line">		unzip [选项] xxx.zip  (功能描述：解压缩文件)</span><br><span class="line">	zip常用选项：</span><br><span class="line">		-r:递归压缩，即压缩目录</span><br><span class="line">	unzip常用选项：</span><br><span class="line">		-d &lt;目录&gt;：指定文件解压后存放的目录</span><br><span class="line">	</span><br><span class="line">	案例：</span><br><span class="line">		1.将/tmp/temp下的所有文件进行压缩成myhome.zip  （包括/temp本身）</span><br><span class="line">			[root@study tmp]# zip -r myhome.zip test</span><br><span class="line">            updating: test/ (stored 0%)</span><br><span class="line">            updating: test/cat.txt (deflated 15%) </span><br><span class="line">		2.将myhome.zip解压到/tmp/temp目录下</span><br><span class="line">			[root@study tmp]# unzip -d temp myhome.zip</span><br><span class="line">            Archive:  myhome.zip</span><br><span class="line">               creating: temp/test/</span><br><span class="line">              inflating: temp/test/cat.txt       </span><br><span class="line">            [root@study tmp]# cd temp</span><br><span class="line">            [root@study temp]# ls</span><br><span class="line">            aaa  ddd  mydate.txt  temp.txt  test</span><br><span class="line">            [root@study temp]# cd test</span><br><span class="line">            [root@study test]# ls</span><br><span class="line">            cat.txt</span><br><span class="line">            [root@study test]# cat cat.txt</span><br><span class="line">            fhdshfhfsjd:fkjsfkdfjksdjfjdsfds</span><br><span class="line"></span><br><span class="line">            fsii</span><br><span class="line">            hdsfjdskfjds</span><br><span class="line">            [root@study test]#</span><br><span class="line">            </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tar指令</span></span><br><span class="line">	tar指令是打包指令，最后打包后的文件是.tar.gz文件</span><br><span class="line">	基本语法:</span><br><span class="line">		tar [选项] xxx.tar.gz 要打包的内容 （功能描述：打包目录，压缩后的文件格式为tar.gz）</span><br><span class="line">	选项说明：</span><br><span class="line">		-c:产生.tar打包文件</span><br><span class="line">		-v:显示详细信息</span><br><span class="line">		-f:指定压缩后的文件名</span><br><span class="line">		-z:打包同时压缩</span><br><span class="line">		-x:解压打包的.tar文件</span><br><span class="line">	案例：</span><br><span class="line">		1.压缩多个文件，将/home/pig.txt和/home/cat.txt压缩成pc.tar.gz</span><br><span class="line">		2.将/home的文件夹压缩成myhome.tar.gz</span><br><span class="line">			tar -zcvf myhome.tar.gz /home</span><br><span class="line">		3.将pc.tar.gz解压到当前目录，切换到/opt/</span><br><span class="line">		4.将myhome.tar.gz解压到/home/tmp2目录下</span><br><span class="line">			tar -zxvf /home/myhome.tar.gz -C /home/home/tmp2</span><br><span class="line">		</span><br><span class="line">	如：</span><br><span class="line">		[root@study home]# tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt</span><br><span class="line">        tar: 从成员名中删除开头的“/”</span><br><span class="line">        /home/pig.txt</span><br><span class="line">        /home/cat.txt</span><br><span class="line">        [root@study home]# ls</span><br><span class="line">        cat.txt  dmtsai  dst.txt  hello.txt  milan  pc.tar.gz  pig.txt  test  yss  zwj</span><br><span class="line">        </span><br><span class="line">        [root@study home]# tar -zxvf pc.tar.gz</span><br><span class="line">        home/pig.txt</span><br><span class="line">        home/cat.txt</span><br></pre></td></tr></table></figure>

<h3 id="8-防火墙命令"><a href="#8-防火墙命令" class="headerlink" title="8.防火墙命令"></a>8.防火墙命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果出现未识别的命令firewall-cmd，可能是没有安装firewall。安装命令：</span><br><span class="line">	yum install firewalld </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">firewalld的基本使用</span></span><br><span class="line">启动： systemctl start firewalld</span><br><span class="line">关闭： systemctl stop firewalld</span><br><span class="line">查看状态： systemctl status firewalld</span><br><span class="line">开机禁用 ： systemctl disable firewalld</span><br><span class="line">开机启用 ： systemctl enable firewalld</span><br><span class="line">查看开放的端口：firewall-cmd --list-ports</span><br><span class="line">添加端口：firewall-cmd --add-port=8080/tcp --permanent （–permanent永久生效，没有此参数重启后失效）</span><br><span class="line">让修改的端口生效：firewall-cmd --reload</span><br><span class="line">查看当前这个端口是否开启成功：firewall-cmd --query-port=8080/tcp</span><br></pre></td></tr></table></figure>



<h2 id="第三章：linux实操篇：组管理和权限管理"><a href="#第三章：linux实操篇：组管理和权限管理" class="headerlink" title="第三章：linux实操篇：组管理和权限管理"></a>第三章：linux实操篇：组管理和权限管理</h2><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在linux中每个用户必须属于一个组，不能独立于组外，在linux中每个文件有所有者、所在组、其他组的概念。</span><br><span class="line"></span><br><span class="line">1.所有者</span><br><span class="line">2.所在组</span><br><span class="line">3.其他组</span><br><span class="line">3.改变所属的组</span><br></pre></td></tr></table></figure>

<h3 id="2-文件-目录所有者-查看和修改-chown"><a href="#2-文件-目录所有者-查看和修改-chown" class="headerlink" title="2.文件&#x2F;目录所有者(查看和修改)(chown)"></a>2.文件&#x2F;目录所有者(查看和修改)(chown)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一般为文件的创建者，就自然的成为该文件的所有者</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看文件的所有者</span></span><br><span class="line">	指令：ls -ahl</span><br><span class="line">	案例：[root@study home]# ls -ahl </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改文件所有者</span></span><br><span class="line">	指令：chown 用户名 文件名</span><br><span class="line">	案例：使用root创建一个apple.txt,然后将其所有者修改成tom</span><br><span class="line">		 [root@study home]# chown dmtsai apple.txt</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="3-组的创建-groupadd-useradd"><a href="#3-组的创建-groupadd-useradd" class="headerlink" title="3.组的创建(groupadd,useradd)"></a>3.组的创建(groupadd,useradd)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">组的创建：</span></span><br><span class="line">	基本指令：groupadd 组名</span><br><span class="line">	案例：</span><br><span class="line">		1.创建一个组 monster</span><br><span class="line">			groupadd monster</span><br><span class="line">		2.创建一个用户 fox,并放入到monster组中</span><br><span class="line">			useradd -g monster fox</span><br></pre></td></tr></table></figure>

<h3 id="4-文件-目录所在组（查看和修改）-ls-chgrp"><a href="#4-文件-目录所在组（查看和修改）-ls-chgrp" class="headerlink" title="4.文件&#x2F;目录所在组（查看和修改）(ls,chgrp)"></a>4.文件&#x2F;目录所在组（查看和修改）(ls,chgrp)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看文件/目录所在组：(就是上面所有者列旁边的那一列）</span></span><br><span class="line">	基本指令：ls -ahl （ll指令也可以）</span><br><span class="line">	案例：[root@study home]# ls -ahl</span><br><span class="line">		 [zwj@study ~]$ ls -ahl	</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改文件所在的组：</span></span><br><span class="line">	基本指令：</span><br><span class="line">		chgrp 组名 文件名/目录名</span><br><span class="line">	案例：</span><br><span class="line">		使用root用户创建文件orange.txt,看看当前这个文件属于哪个组，然后将这个文件所在组修改到fruit组中。</span><br><span class="line">		chgrp mojiao orange.txt</span><br></pre></td></tr></table></figure>

<h3 id="5-其他组和改变用户所在组-usermod"><a href="#5-其他组和改变用户所在组-usermod" class="headerlink" title="5.其他组和改变用户所在组(usermod)"></a>5.其他组和改变用户所在组(usermod)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其他组：除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改变用户所在组</span></span><br><span class="line">	在添加用户时，可以指定将该用户添加到哪个组，同样的用root的管理权限可以改变某个用户所在的组</span><br><span class="line">	基本指令：</span><br><span class="line">		1.usermod -g 组组名 用户名</span><br><span class="line">		2.usermod -d 目录名 用户名 改变用户登录的初始目录（家目录）,特别说明：用户需要有进入到新目录的权限。</span><br><span class="line">	案例：</span><br><span class="line">		将zwj这个用户从原来所在组（mojiao）,修改到wudang组</span><br><span class="line">	如：</span><br><span class="line">		[root@study home]# id zwj</span><br><span class="line">        uid=1003(zwj) gid=1005(mojiao) 组=1005(mojiao)</span><br><span class="line">        [root@study home]# usermod -g wudang zwj</span><br><span class="line">        [root@study home]# id zwj</span><br><span class="line">        uid=1003(zwj) gid=1003(wudang) 组=1003(wudang)</span><br><span class="line">        [root@study home]#</span><br><span class="line">        </span><br><span class="line">        [zwj@study ~]$ pwd</span><br><span class="line">		/home/zwj</span><br><span class="line">        [root@study home]# mkdir zwjmod</span><br><span class="line">        [root@study home]# ls</span><br><span class="line">        apple.txt  dmtsai  dst.txt  hello.txt  home  milan  myhome.tar.gz  orange.txt  pc2.tar.gz  pc.tar.gz  test  yss  zwj  zwjmod</span><br><span class="line">        [root@study home]# usermod -d /home/zwjmod zwj</span><br><span class="line">        [root@study home]# su - zwj</span><br><span class="line">        上一次登录：五 10月 29 19:14:01 CST 2021pts/0 上</span><br><span class="line">        -bash-4.2$ pwd</span><br><span class="line">        /home/zwjmod</span><br></pre></td></tr></table></figure>

<h3 id="6-权限管理和（rwx权限）"><a href="#6-权限管理和（rwx权限）" class="headerlink" title="6.权限管理和（rwx权限）"></a>6.权限管理和（rwx权限）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">ls</span> -l中显示的内容如下：</span></span><br><span class="line">-rw-r--r--.  1 root   root   333 10月 27 20:28 dst.txt</span><br><span class="line">lrwxrwxrwx.  1 root   root           5 10月 29 19:32 linkFile -&gt; /root</span><br><span class="line"></span><br><span class="line">0-9位说明：</span><br><span class="line">- 第0位确定文件类型（d、-、l、c、b） （l是小写的L）</span><br><span class="line">	-是一般的文件，如.txt</span><br><span class="line">	l是链接，相当于windows的快捷方式  （[root@study temp]# ln -s /root linkFile）</span><br><span class="line">	d是目录，相当于windows的文件夹</span><br><span class="line">	c是字符设备文件，鼠标，键盘</span><br><span class="line">	b是块设备</span><br><span class="line">	</span><br><span class="line">- 第1-3位确定所有者（该文件的所有者）拥有该文件的权限， ---User</span><br><span class="line">- 第4-6位确定所属组（同用户组的）拥有该文件的权限， ---Group</span><br><span class="line">- 第7-9位确定其他用户拥有该文件的权限， ---Other</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rwx权限详解（难点）</span></span><br><span class="line">1.rwx作用到文件（重要）</span><br><span class="line">	r:代表可读（read）：可以读取、查看</span><br><span class="line">	w:代表可写（write）:可以修改，但是不代表可以删除该文件，删除一个文件的前提是对该文件所在的目录有写权限，才能删除该文件</span><br><span class="line">	x:代表可执行（execute）：可以被执行</span><br><span class="line"></span><br><span class="line">2.rwx作用到目录(重要)</span><br><span class="line">	r:代表可读（read）：可以读取，ls查看目录内容</span><br><span class="line">	w:代表可写（write）:可以修改，对目录下创建+删除+重命名(文件/目录)</span><br><span class="line">	x:代表可执行（execute）：可以进入该目录</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可用数字表示为：r=4,w=4,x=1,因此rwx=4+2+1=7</span></span><br><span class="line">-rw-r--r--.  1 root   root   333 10月 27 20:28 dst.txt</span><br><span class="line"></span><br><span class="line">其他说明：</span><br><span class="line">	1				： 文件：硬连接数 或目录：子目录数</span><br><span class="line">	root			：文件/目录所有者</span><br><span class="line">	root			:文件/目录所在组</span><br><span class="line">    333				：文件大小（字节），如果是文件夹，显示4096字节</span><br><span class="line">    10月 27 20:28   	:最后修改日期</span><br><span class="line">    dst.txt			:文件名			</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="7-修改文件-目录权限-chmod"><a href="#7-修改文件-目录权限-chmod" class="headerlink" title="7.修改文件&#x2F;目录权限-chmod"></a>7.修改文件&#x2F;目录权限-chmod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本说明</span></span><br><span class="line">	通过chmod指令，可以修改文件或者目录的权限</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一种方式：+，-，=变更权限</span></span><br><span class="line">	u:所有者 g:所在组 o:其他用户 a:所有用户（u,g,o的总和）</span><br><span class="line">	1.chmod u=rwx,g=rx,o=x 文件/目录名</span><br><span class="line">	2.chmod o+w 文件/目录名</span><br><span class="line">	3.chmod a-x 文件/目录名</span><br><span class="line">	</span><br><span class="line">	案例演示：</span><br><span class="line">		1.给abc文件的所有者读写执行的权限，给所在组读执行权限，给其他组读执行权限</span><br><span class="line">			chmod u=rwx,g=rx,o=x abc</span><br><span class="line">        2.给abc文件的所有者去除执行的权限，增加所在组写的权限</span><br><span class="line">        	chmod u-x,g+w abc</span><br><span class="line">        3.给abc文件的所有用户添加读的权限</span><br><span class="line">			chmod a+r abc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第二种方式：通过数字变更的方式</span></span><br><span class="line">	r=4,w=2,x=1 rwx=4=2=1=7</span><br><span class="line">	chmod u=rwx,g=rx,o=x 文件/目录名</span><br><span class="line">	上面这条指令也相当于是：</span><br><span class="line">	chmod 751 文件/目录名</span><br><span class="line">	</span><br><span class="line">	案例演示：</span><br><span class="line">		1.将/home/abc.txt文件的权限修改成rwxr-xr-x,使用数字的方式变更</span><br><span class="line">			chmod 755 /home/abc.txt</span><br></pre></td></tr></table></figure>

<h3 id="8-修改文件所有者-chown"><a href="#8-修改文件所有者-chown" class="headerlink" title="8.修改文件所有者-chown"></a>8.修改文件所有者-chown</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">	chown newowner 文件/目录 改变所有者</span><br><span class="line">	chown newowner:newgroup 文件/目录 改变所有者和所在组</span><br><span class="line">		如：chown zwj:wudang apple.txt dmtsai（这里要求所有者和所在组相同）</span><br><span class="line">	-R 如果是目录，则使其下所偶子文件或目录递归生效</span><br><span class="line">	</span><br><span class="line">	案例演示：</span><br><span class="line">		1.请将/home/abc.txt文件的所有者修改成tom</span><br><span class="line">			chown tom /home/abc.tx root</span><br><span class="line">		2.请将/home/kkk目录下所有的文件和目录的所有者都修改成tom</span><br><span class="line">			chown -R tom /home/kkk root</span><br></pre></td></tr></table></figure>

<h3 id="9-修改文件-目录所在组-chgrp"><a href="#9-修改文件-目录所在组-chgrp" class="headerlink" title="9.修改文件&#x2F;目录所在组-chgrp"></a>9.修改文件&#x2F;目录所在组-chgrp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍：</span></span><br><span class="line">	chgrp newgroup 文件/目录</span><br><span class="line">	-R 如果是目录，则使其下所偶子文件或目录递归生效</span><br><span class="line">	案例演示：</span><br><span class="line">		1.请将/home/abc.txt文件的所在组修改成shaolin</span><br><span class="line">			chgrp shaolin /home/abc.txt</span><br><span class="line">		2.请将/home/kkk目录下所有的文件和目录的所在组都修改成shaolin</span><br><span class="line">			chgrp -R shaolin /home/kkk</span><br></pre></td></tr></table></figure>

<h3 id="10：注意事项"><a href="#10：注意事项" class="headerlink" title="10：注意事项"></a>10：注意事项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一个用户创建的目录下，在这个目录下又创建了一个文件。此时如果想让同一个组的另外一个用户也能读写这个文件，不仅要给这个文件的所在组的读写权限，同时还要给这个目录的所在组的执行权限，只有这样才能完成。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rwx权限详解（难点）</span></span><br><span class="line">1.rwx作用到文件（重要）</span><br><span class="line">	r:代表可读（read）：可以读取、查看</span><br><span class="line">	w:代表可写（write）:可以修改，但是不代表可以删除该文件，删除一个文件的前提是对该文件所在的目录有写权限，才能删除该文件</span><br><span class="line">	x:代表可执行（execute）：可以被执行</span><br><span class="line"></span><br><span class="line">2.rwx作用到目录(重要)</span><br><span class="line">	r:代表可读（read）：可以读取，ls查看目录内容</span><br><span class="line">	w:代表可写（write）:可以修改，对目录下创建+删除+重命名(文件/目录)</span><br><span class="line">	x:代表可执行（execute）：可以进入该目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第四章：linux实操篇：实时任务调度（B站视频到P52-P81待看，韩顺平老师）"><a href="#第四章：linux实操篇：实时任务调度（B站视频到P52-P81待看，韩顺平老师）" class="headerlink" title="第四章：linux实操篇：实时任务调度（B站视频到P52-P81待看，韩顺平老师）"></a>第四章：linux实操篇：实时任务调度（B站视频到P52-P81待看，韩顺平老师）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">crond 任务调度</span></span><br><span class="line">	crontab 进行定时任务的设置</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">概述</span></span><br></pre></td></tr></table></figure>

<h2 id="第五章：linux实操篇：进程管理"><a href="#第五章：linux实操篇：进程管理" class="headerlink" title="第五章：linux实操篇：进程管理"></a>第五章：linux实操篇：进程管理</h2><h2 id="第六章：rpm包的管理（P82）"><a href="#第六章：rpm包的管理（P82）" class="headerlink" title="第六章：rpm包的管理（P82）"></a>第六章：rpm包的管理（P82）</h2><h3 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">	rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版本中，它生成具有.RPM扩展名的文件，RPM是RedHat Package Manager(RedHat软件包管理工具)的缩写，类似windows的setup.exe,这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</span><br><span class="line">	Linux的分发版本中都有采用（suse,redhat,centos等等），可以算是行业标准了</span><br></pre></td></tr></table></figure>

<h3 id="2-RPM包的管理"><a href="#2-RPM包的管理" class="headerlink" title="2.RPM包的管理"></a>2.RPM包的管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm包的简单查询指令</span></span><br><span class="line">	查询已安装的rpm列表  rpm -qa | grep xx</span><br><span class="line">	举例：看看当前系统是否安装了Firefox，</span><br><span class="line">		rpm -qa | grep firefox</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm包名基本格式</span></span><br><span class="line">	一个rpm包名：firefox-68.5.0-2.el7.centos.x86_64</span><br><span class="line">	名称：firefox</span><br><span class="line">	版本号：68.5.0-2</span><br><span class="line">	适用操作系统：el7.centos.x86_64。表示centos7.x的64位系统</span><br><span class="line">	如果是i686,i386表示32位系统，noarch表示通用。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm包的其他查询指令</span></span><br><span class="line">	rpm -qa (查询所安装的所有rpm软件包)</span><br><span class="line">	rpm -qa | more</span><br><span class="line">	rpm -qa | grep xx (如rpm -qa | grep firefox)</span><br><span class="line">	</span><br><span class="line">	rpm -q 软件包名：查询软件包是否安装</span><br><span class="line">	案例：rpm -q firefox</span><br><span class="line">	</span><br><span class="line">	rpm -qi 软件包名 (查询软件包信息)</span><br><span class="line">	案例：rpm -qi firefox</span><br><span class="line">	rpm -ql 软件包名 (查询软件包中的文件)</span><br><span class="line">	案例：rpm -ql firefox</span><br><span class="line">	</span><br><span class="line">	rpm -qf 文件全路径名（查询文件所属的软件包）</span><br><span class="line">	案例：</span><br><span class="line">		rpm -qf /etc/passwd</span><br><span class="line">		rpm -qf /root/install.log</span><br></pre></td></tr></table></figure>

<h3 id="3-RPM包的卸载"><a href="#3-RPM包的卸载" class="headerlink" title="3.RPM包的卸载"></a>3.RPM包的卸载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载RPM包</span></span><br><span class="line">	基本语法：</span><br><span class="line">		rpm -e RPM包的名称</span><br><span class="line">	案例：</span><br><span class="line">		删除firefox软件包</span><br><span class="line">		rpm -e firefox</span><br><span class="line">	注意细节：</span><br><span class="line">		1.如果其他软件包依赖于你要卸载的软件包，卸载时就会产生错误信息</span><br><span class="line">			如 rpm -e foo</span><br><span class="line">		2.如果我们就是要删除foo这个rpm包，可以增加参数--nodes,就可以强制删除，但是一般不推荐这样，因为可能会导致依赖于该软件包的程序无法运行</span><br><span class="line">			如：rpm -e --nodes foo</span><br></pre></td></tr></table></figure>

<h3 id="4-RPM包的安装"><a href="#4-RPM包的安装" class="headerlink" title="4.RPM包的安装"></a>4.RPM包的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装rpm包</span></span><br><span class="line">	基本语法：</span><br><span class="line">		rpm -ivh RPM包全路径名称</span><br><span class="line">	参数说明：</span><br><span class="line">		i：install安装</span><br><span class="line">		v:verbose提示</span><br><span class="line">		h:hash进度条</span><br><span class="line">	应用案例：</span><br><span class="line">		演示卸载和安装firefox浏览器</span><br><span class="line">		卸载：直接rpm -e firefox卸载</span><br><span class="line">		安装：从桌面光驱中的packages中找到firefox的rpm包。（如果桌面没有光驱，就从虚拟机-&gt;可移动设备-&gt;cd/dvd那个打开），先将firefox的rpm包复制到一个目录下如/opt目录下，然后执行rpm -ivh /opt/firefox.rpm即可。</span><br></pre></td></tr></table></figure>

<h2 id="第七章：yum包"><a href="#第七章：yum包" class="headerlink" title="第七章：yum包"></a>第七章：yum包</h2><h3 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">	Yum是一个shell前端软件包处理工具，基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包(yum服务器有点类似于maven远程仓库)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">yum的基本指令</span></span><br><span class="line">	查询yum服务器是否有这需要安装的软件</span><br><span class="line">		yum list | grep xx软件列表</span><br><span class="line">	</span><br><span class="line">	安装指定的安装包：</span><br><span class="line">		yum install xxx (下载安装)</span><br><span class="line">	yum应用实例：</span><br><span class="line">		请使用yum的方式来安装firefox</span><br><span class="line">		[root@study temp]# rpm -e firefox</span><br><span class="line">		[root@study temp]# rpm -qi firefox</span><br><span class="line">        未安装软件包 firefox </span><br><span class="line">        [root@study temp]# yum list | grep firefox</span><br><span class="line">        firefox.i686                                91.2.0-4.el7.centos        updates  </span><br><span class="line">        firefox.x86_64                              91.2.0-4.el7.centos        updates  </span><br><span class="line">        [root@study temp]# yum install firefox</span><br></pre></td></tr></table></figure>

<h2 id="第八章：在Linux系统上搭建javaee开发环境"><a href="#第八章：在Linux系统上搭建javaee开发环境" class="headerlink" title="第八章：在Linux系统上搭建javaee开发环境"></a>第八章：在Linux系统上搭建javaee开发环境</h2><h3 id="1-安装jdk"><a href="#1-安装jdk" class="headerlink" title="1.安装jdk"></a>1.安装jdk</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装jdk</span></span><br><span class="line">	步骤：</span><br><span class="line">		1.mkdir /opt/jdk</span><br><span class="line">		2.通过xftp6上传到/opt/jdk下</span><br><span class="line">		3.cd /opt/jdk</span><br><span class="line">		4.解压 tar -zxvf jdk-8u261-linux-x64.tar.gz</span><br><span class="line">		5.mkdir /usr/local/java</span><br><span class="line">		6.mv /opt/jdk/jdk1.8.0_261 /usr/local/java</span><br><span class="line">		7.配置环境变量的配置文件 vim /etc/profile</span><br><span class="line">		8.export JAVA_HOME=/usr/local/java/jdk1.8.0_261</span><br><span class="line">		9.export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">		10.source /etc/profile  [这一步是为了让文件生效]</span><br><span class="line">	测试安装是否成功：</span><br><span class="line">		编写一个简单的Hello.java 输出”hello,world“</span><br><span class="line">		</span><br><span class="line">	命令演示：</span><br><span class="line">		[root@study jdk]# mkdir /opt/jdk</span><br><span class="line">		[root@study jdk]# cd /opt/jdk （使用xftp上传jdk-8u311-linux-x64.tar.gz到/opt/jdk目录下） </span><br><span class="line">		[root@study jdk]# tar -zxvf jdk-8u311-linux-x64.tar.gz</span><br><span class="line">		[root@study jdk]# ll</span><br><span class="line">        总用量 143360</span><br><span class="line">        drwxr-xr-x. 8 10143 10143       273 9月  27 20:29 jdk1.8.0_311</span><br><span class="line">        -rw-r--r--. 1 root  root  146799982 11月  3 16:15 jdk-8u311-linux-x64.tar.gz</span><br><span class="line">        [root@study jdk]# mkdir /usr/local/java  （习惯把环境放在/usr/local下面）</span><br><span class="line">		[root@study jdk]# mv jdk1.8.0_311/ /usr/local/java</span><br><span class="line">        [root@study jdk]# ll</span><br><span class="line">        总用量 143360</span><br><span class="line">        -rw-r--r--. 1 root root 146799982 11月  3 16:15 jdk-8u311-linux-x64.tar.gz</span><br><span class="line">        [root@study bin]# cd /usr/local/java</span><br><span class="line">		[root@study java]# vim /etc/profile </span><br><span class="line">		在/etc/profile文件中i插入： export JAVA_HOME=/usr/local/java/jdk1.8.0_311</span><br><span class="line">								export PATH=$JAVA_HOME/bin:$PATH，然后ESC :wq保存退出</span><br><span class="line">		[root@study java]# echo $PATH</span><br><span class="line">        /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">        [root@study java]# source /etc/profile  [让刚刚的修改环境变量生效，刷新环境变量]</span><br><span class="line">        [root@study java]# echo $PATH</span><br><span class="line">/usr/local/java/jdk1.8.0_311/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">		[root@study ~]# vim Hello.java</span><br><span class="line">		[root@study ~]# javac Hello.java  （编译）</span><br><span class="line">		[root@study ~]# java Hello  (运行)</span><br><span class="line">								</span><br><span class="line">   	输出当前环境变量：</span><br><span class="line">   		[root@study bin]# echo $PATH</span><br><span class="line">        /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<h3 id="2-安装tomcat"><a href="#2-安装tomcat" class="headerlink" title="2.安装tomcat"></a>2.安装tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装tomcat:</span></span><br><span class="line">	步骤：</span><br><span class="line">		1.上传安装文件，并解压缩到/opt/tomcat</span><br><span class="line">		2.进入解压目录/bin,启动tomcat, ./startup.sh</span><br><span class="line">		3.开放端口8080</span><br><span class="line">		</span><br><span class="line">		1.mkdir /opt/tomcat</span><br><span class="line">		2.通过xftp6上传到/opt/tomcat下</span><br><span class="line">		3.cd /opt/tomcat</span><br><span class="line">		4.解压 tar -zxvf apache-tomcat-9.0.54.tar.gz</span><br><span class="line">		5.cd /opt/tomcat/apache-tomcat-9.0.54/bin</span><br><span class="line">		6.开启tomcat, ./startup.sh</span><br><span class="line">		7.开启8080端口，firewall-cmd --permanent --add-port=8080/tcp</span><br><span class="line">		8.让开启的端口生效，firewall-cmd --reload</span><br><span class="line">		</span><br><span class="line">	测试是否安装成功：</span><br><span class="line">		在windows，linux下访问 http://linux的ip:8080</span><br><span class="line">		</span><br><span class="line">	命令演示：</span><br><span class="line">		[root@study ~]# mkdir /opt/tomcat</span><br><span class="line">        [root@study ~]# cd /opt/tomcat  （通过xftp6将.tar.gz文件上传到这个目录下）</span><br><span class="line">        [root@study tomcat]# ll</span><br><span class="line">        总用量 11308</span><br><span class="line">        -rw-r--r--. 1 root root 11576317 11月  3 16:53 apache-tomcat-9.0.54.tar.gz</span><br><span class="line">		[root@study tomcat]# tar -zxvf apache-tomcat-9.0.54.tar.gz</span><br><span class="line">		[root@study tomcat]# ll</span><br><span class="line">        总用量 11308</span><br><span class="line">        drwxr-xr-x. 9 root root      220 11月  3 16:55 apache-tomcat-9.0.54</span><br><span class="line">        -rw-r--r--. 1 root root 11576317 11月  3 16:53 apache-tomcat-9.0.54.tar.gz</span><br><span class="line">        [root@study tomcat]# cd /opt/tomcat/apache-tomcat-9.0.54/</span><br><span class="line">        [root@study apache-tomcat-9.0.54]# cd bin</span><br><span class="line">        [root@study bin]# ./startup.sh  [这里是因为没有配置tomcat的环境变量，所以要有bin目录下./]</span><br><span class="line">        Using CATALINA_BASE:   /opt/tomcat/apache-tomcat-9.0.54</span><br><span class="line">        Using CATALINA_HOME:   /opt/tomcat/apache-tomcat-9.0.54</span><br><span class="line">        Using CATALINA_TMPDIR: /opt/tomcat/apache-tomcat-9.0.54/temp</span><br><span class="line">        Using JRE_HOME:        /usr/local/java/jdk1.8.0_311</span><br><span class="line">        Using CLASSPATH:       /opt/tomcat/apache-tomcat-9.0.54/bin/bootstrap.jar:/opt/tomcat/apache-tomcat-9.0.54/bin/tomcat-juli.jar</span><br><span class="line">        Using CATALINA_OPTS:   </span><br><span class="line">        Tomcat started.</span><br><span class="line">        //开启端口后，让端口生效</span><br><span class="line">        [root@study bin]# firewall-cmd --reload</span><br><span class="line">        success</span><br><span class="line">        //查询开启的端口有哪些</span><br><span class="line">        [root@study bin]# firewall-cmd --list-ports</span><br><span class="line">        8080/tcp</span><br><span class="line">        //查询8080这个端口是否开启成功</span><br><span class="line">        [root@study bin]# firewall-cmd --query-port=8080/tcp</span><br><span class="line">        yes</span><br><span class="line">		//项目部署用的</span><br><span class="line">        [root@study apache-tomcat-9.0.54]# cd webapps/</span><br><span class="line">        [root@study webapps]# ls</span><br><span class="line">        docs  examples  host-manager  manager  ROOT</span><br><span class="line">        [root@study webapps]# cd ROOT</span><br><span class="line">        [root@study ROOT]# vim hello.html</span><br><span class="line">        [root@study ROOT]# ls</span><br><span class="line">        asf-logo-wide.svg  bg-button.png  bg-middle.png  bg-nav.png  bg-upper.png  favicon.ico  hello.html  index.jsp  RELEASE-NOTES.txt  tomcat.css  tomcat.svg  WEB-INF</span><br><span class="line">        [root@study ROOT]# cd ../</span><br><span class="line">        [root@study webapps]# ls</span><br><span class="line">        docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure>

<h3 id="3-安装idea"><a href="#3-安装idea" class="headerlink" title="3.安装idea"></a>3.安装idea</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">步骤</span></span><br><span class="line">	步骤：</span><br><span class="line">		1.上传安装文件，并解压缩到/opt/idea</span><br><span class="line">		2.进入解压目录/bin,启动idea, ./idea.sh,配置jdk</span><br><span class="line">		3.编写Hello world程序并测试</span><br><span class="line">		</span><br><span class="line">		1.mkdir /opt/idea</span><br><span class="line">		2.通过xftp6上传到/opt/idea下</span><br><span class="line">		3.cd /opt/idea</span><br><span class="line">		4.解压 tar -zxvf ideaIU-2021.2.3.tar.gz</span><br><span class="line">		5.cd /opt/idea/ideaIU-2021.2.3/bin</span><br><span class="line">		6.在有图形化界面的linux下开启idea, ./idea.sh</span><br></pre></td></tr></table></figure>

<h3 id="4-安装mysql5-7"><a href="#4-安装mysql5-7" class="headerlink" title="4.安装mysql5.7"></a>4.安装mysql5.7</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">步骤</span></span><br><span class="line">	mysql.tar安装包文件下载地址：https://dev.mysql.com/downloads/mysql/</span><br><span class="line">	</span><br><span class="line">	步骤：</span><br><span class="line">		1.上传安装文件，并解压缩到/opt/mysql</span><br><span class="line">    	2.进入解压目录/bin,启动mysql, ./startup.sh</span><br><span class="line">    	3.开放端口8080</span><br><span class="line">   	</span><br><span class="line">   		1.mkdir /opt/mysql</span><br><span class="line">		2.通过xftp6将安装包上传到/opt/mysql下</span><br><span class="line">		</span><br><span class="line">			ps:centos7.x自带的类mysql数据库是mariadb,会跟mysql冲突，要先删除</span><br><span class="line">		3.cd /opt/mysql</span><br><span class="line">		4.解压 tar -xvf mysql-5.7.36-1.el7.x86_64.rpm-bundle.tar  (注意不需要带上选项z mysql-community-server-5.7.37-1.el7.x86_64.rpm这个包更小一点)</span><br><span class="line">		5.删除mariadb.可以先使用rpm -qa | grep mariadb查询看有没有，如果有使用rpm -e --nodeps mariadb-libs卸载还有rpm -e --nodeps marisa</span><br><span class="line">		5.然后真正安装mysql,依次运行以下几条</span><br><span class="line">			rpm -ivh mysql-community-common-5.7.36-1.el7.x86_64.rpm</span><br><span class="line">            rpm -ivh mysql-community-libs-5.7.36-1.el7.x86_64.rpm</span><br><span class="line">    		rpm -ivh mysql-community-client-5.7.36-1.el7.x86_64.rpm</span><br><span class="line">            rpm -ivh mysql-community-server-5.7.36-1.el7.x86_64.rpm	</span><br><span class="line">		6.运行 systemctl start mysqld.service 启动mysql</span><br><span class="line">		7.然后开始设置root用户密码</span><br><span class="line">			mysql自动给root设置随机密码，运行grep &quot;password&quot; /var/log/mysqld.log可看到当前密码</span><br><span class="line">		8.运行mysql -u root -p,用root用户登录，提示输入密码可用上述的，可以成功登录进入mysql命令行</span><br><span class="line">		9.设置root密码，对于个人开发环境，如果要设比较简单的密码（生产环境设置复杂的），可以运行</span><br><span class="line">			set global validate_password_policy=0;  提示密码设置策略</span><br><span class="line">			（validate_password_policy默认值为1）</span><br><span class="line">		10.set password for &#x27;root&#x27;@&#x27;localhost&#x27;=password(&#x27;1997...slr1126&#x27;);</span><br><span class="line">		11.运行flush privileges; 使密码生效</span><br><span class="line">		11-2.创建用户 </span><br><span class="line">		12.设置远程连接mysql的新账户密码.linux装好mysql后，设定远程访问的账户和密码,user或者user表示新设置的mysql账户，%表示开启远程权限，testPassword为自己的设的新账户密码</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;1997...slr1126&#x27;</span> WITH GRANT OPTION;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt;</span><span class="language-bash">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;1997...slr1126&#x27;</span> WITH GRANT OPTION;</span></span><br><span class="line">		13.防火墙开启3306端口</span><br><span class="line">			1.查看防火墙</span><br><span class="line">				systemctl status firewalld</span><br><span class="line">			2、查看3306端口状态</span><br><span class="line">				firewall-cmd --zone=public --query-port=3306/tcp</span><br><span class="line">			3、如果是no，表示关闭，打开3306端口</span><br><span class="line">				firewall-cmd --zone=public --add-port=3306/tcp --permanent </span><br><span class="line">			4、防火墙重载</span><br><span class="line">				firewall-cmd --reload</span><br><span class="line">			5、再次查看3306状态</span><br><span class="line">				firewall-cmd --zone=public --query-port=3306/tcp</span><br><span class="line">			6、应该是yes，说明端口已经打开，去navicat测试连接，输入ip和新的Mysql账户密码，即可成功！</span><br><span class="line">   	命令演示：</span><br><span class="line">   		[root@study ~]# mkdir /opt/mysql</span><br><span class="line">        [root@study ~]# cd /opt/mysql</span><br><span class="line">        [root@study mysql]# tar -xvf mysql-5.7.36-1.el7.x86_64.rpm-bundle.tar</span><br><span class="line">        [root@study mysql]# rpm -qa | grep mariadb</span><br><span class="line">        mariadb-libs-5.5.65-1.el7.x86_64</span><br><span class="line">        [root@study mysql]# rpm -e --nodeps mariadb-libs</span><br><span class="line">        [root@study mysql]# rpm -e --nodeps marisa</span><br><span class="line">        [root@study mysql]# rpm -ivh mysql-community-common-5.7.36-1.el7.x86_64.rpm</span><br><span class="line">        [root@study mysql]# rpm -ivh mysql-community-libs-5.7.36-1.el7.x86_64.rpm</span><br><span class="line">    	[root@study mysql]# rpm -ivh mysql-community-client-5.7.36-1.el7.x86_64.rpm</span><br><span class="line">    	[root@study mysql]# rpm -ivh mysql-community-server-5.7.36-1.el7.x86_64.rpm</span><br><span class="line">    	</span><br><span class="line">    	[root@study mysql]# systemctl start mysqld.service</span><br><span class="line">    	[root@study mysql]# grep &quot;password&quot; /var/log/mysqld.log  【临时密码为BDtcWeToB2(x】</span><br><span class="line">    	2021-11-03T11:21:19.822004Z 1 [Note] A temporary password is generated for root@localhost: BDtcWeToB2(x</span><br><span class="line">    	[root@study mysql]# mysql -u root -p</span><br><span class="line">		Enter password:    （输入上面的内容）</span><br><span class="line"><span class="meta prompt_">		mysql&gt; </span><span class="language-bash"><span class="built_in">set</span> global validate_password_policy=0;</span></span><br><span class="line">        Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">        mysql&gt; set global validate_password_length=4;  #设置密码长度可以为4</span><br><span class="line">        Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">        mysql&gt; set password for &#x27;root&#x27;@&#x27;localhost&#x27;=password(&#x27;1997...slr1126&#x27;);  #重设密码可设为root</span><br><span class="line">        Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line">        mysql&gt; create user &#x27;xxxx&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;;  #创建用户</span><br><span class="line">    	Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">    	mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;xxxx&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;		#给用户进行授权</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line">        mysql&gt; flush privileges;</span><br><span class="line">		Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_">		mysql&gt; </span><span class="language-bash">show databases;  (成功)</span></span><br></pre></td></tr></table></figure>

<h3 id="5-通过RPM方式安装mysql"><a href="#5-通过RPM方式安装mysql" class="headerlink" title="5.通过RPM方式安装mysql"></a>5.通过RPM方式安装mysql</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">步骤</span></span><br><span class="line">	rpm包下载地址： http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">	</span><br><span class="line">	步骤：</span><br><span class="line">		1.上传安装文件到/opt/mysql，并进入该目录</span><br><span class="line">		2.然后执行yum命令来下载安装源</span><br><span class="line">		3.然后执行yum命令来下载mysql-community-server</span><br><span class="line">		4.运行 systemctl start mysqld.service 启动mysql，后面的步骤与上面从第六步开始是一样的</span><br><span class="line">		</span><br><span class="line">	命令演示：</span><br><span class="line">		[root@dmtsai ~]# cd /opt/mysql/</span><br><span class="line">        [root@dmtsai mysql]# yum -y install mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">        [root@dmtsai mysql]# yum -y install mysql-community-server</span><br><span class="line">        [root@study mysql]# systemctl start mysqld.service</span><br></pre></td></tr></table></figure>



<h2 id="第九章：Linux之大数据定制篇-shell编程"><a href="#第九章：Linux之大数据定制篇-shell编程" class="headerlink" title="第九章：Linux之大数据定制篇-shell编程"></a>第九章：Linux之大数据定制篇-shell编程</h2><h3 id="1-基本介绍-3"><a href="#1-基本介绍-3" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么要学习Shell编程</span></span><br><span class="line">	1.Linux运维工程师在进行服务器集群管理时，需要编写Shell程序来进行服务器管理</span><br><span class="line">	2.对于javaEE和python程序员来说，工作的需要，你的老大会要求你编写一些shell脚本进行程序或者是服务器的维护，比如编写一个定时备份数据库的脚本</span><br><span class="line">	3.对于大数据程序员来说，需要编写Shell程序来管理集群</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">shell是什么</span></span><br><span class="line">	shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动，挂起，停止甚至是编写一些程序</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">shell脚本的注释</span></span><br><span class="line">单行注释是 </span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">注释的内容</span></span><br><span class="line">多行注释的方式 :&lt;&lt;!开头单独起一行  ! 结尾单独起一行   </span><br><span class="line">	:&lt;&lt;!</span><br><span class="line">	注释的内容</span><br><span class="line">	注释的内容</span><br><span class="line">	!</span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="2-shell脚本的执行方式"><a href="#2-shell脚本的执行方式" class="headerlink" title="2.shell脚本的执行方式"></a>2.shell脚本的执行方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">脚本格式要求</span></span><br><span class="line">    1.脚本以#!/bin/bash开头</span><br><span class="line">    2.脚本需要有可执行权限</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写第一个Shell脚本</span></span><br><span class="line">	需求说明:创建一个Shell脚本，输出Hello,world!</span><br><span class="line">	[root@study ~]# mkdir /root/shcode</span><br><span class="line">    [root@study ~]# cd /root/shcode</span><br><span class="line">    [root@study shcode]# ls</span><br><span class="line">    [root@study shcode]# vim hello.sh</span><br><span class="line">    [root@study shcode]# ll</span><br><span class="line">    总用量 4</span><br><span class="line">    -rw-r--r--. 1 root root 31 11月  3 20:53 hello.sh</span><br><span class="line">    [root@study shcode]# ./hello.sh</span><br><span class="line">    -bash: ./hello.sh: 权限不够</span><br><span class="line">    [root@study shcode]# chmod u+x hello.sh</span><br><span class="line">    [root@study shcode]# ll</span><br><span class="line">    总用量 4</span><br><span class="line">    -rwxr--r--. 1 root root 31 11月  3 20:53 hello.sh</span><br><span class="line">    [root@study shcode]# ./hello.sh</span><br><span class="line">    hello,world</span><br><span class="line">    [root@study shcode]# /root/shcode/hello.sh </span><br><span class="line">    [root@study shcode]# chmod u-x hello.sh</span><br><span class="line">    [root@study shcode]# ll</span><br><span class="line">    总用量 4</span><br><span class="line">    -rw-r--r--. 1 root root 31 11月  3 20:53 hello.sh</span><br><span class="line">    [root@study shcode]# ./hello.sh</span><br><span class="line">    -bash: ./hello.sh: 权限不够</span><br><span class="line">    [root@study shcode]# sh hello.sh</span><br><span class="line">    hello,world</span><br><span class="line">    </span><br><span class="line">    其中hello.sh内容为：</span><br><span class="line">    	#!/bin/bash</span><br><span class="line">    	echo &quot;hello,world&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">脚本的常用执行方式</span></span><br><span class="line">	方式1：(输入脚本的绝对路径或相对路径)首先要赋予helloworld.sh脚本的+x权限，再执行脚本</span><br><span class="line">		[root@study shcode]# ./hello.sh</span><br><span class="line">        [root@study shcode]# /root/shcode/hello.sh</span><br><span class="line">	方式2：（sh 脚本）不用赋予脚本+x权限，直接执行即可</span><br><span class="line">		如：[root@study shcode]# sh hello.sh</span><br></pre></td></tr></table></figure>

<h3 id="3-shell的变量"><a href="#3-shell的变量" class="headerlink" title="3.shell的变量"></a>3.shell的变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">shell变量介绍</span></span><br><span class="line">	1.Linux Shell中的变量分为，系统变量和用户自定义变量</span><br><span class="line">	2.系统变量：$HOME,$PWD,$SHELL,$USER，$PATH等等，比如：echo $HOME等等</span><br><span class="line">	3.显示当前shell中所有变量：set</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">shell变量的定义：</span></span><br><span class="line">	基本语法：</span><br><span class="line">		1.定义变量：变量名=值</span><br><span class="line">		2.撤销变量：unset 变量</span><br><span class="line">		3.声明静态变量：readonly 变量，注意：不能unset</span><br><span class="line">	快速入门：</span><br><span class="line">		案例1：定义变量A </span><br><span class="line">		案例2：撤销变量A</span><br><span class="line">		案例3：声明静态的变量B=2,不能unset</span><br><span class="line">		案例4：可把变量提升为全局环境变量，可供其他shell程序使用（后面讲）</span><br><span class="line">		</span><br><span class="line">	代码演示：（var.sh中的内容）</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line">    #案例1：定义变量A</span><br><span class="line">    A=100</span><br><span class="line">    #输出变量时别忘了$符</span><br><span class="line">    echo $A</span><br><span class="line">    echo A=$A</span><br><span class="line">    echo &quot;A=$A&quot;</span><br><span class="line">    #案例2：撤销变量A</span><br><span class="line">    unset A</span><br><span class="line">    echo $A</span><br><span class="line">    echo A=$A</span><br><span class="line">    echo &quot;A=$A&quot;</span><br><span class="line">    #案例3：声明静态的变量B=2,不能unset</span><br><span class="line">    readonly B=2</span><br><span class="line">    echo $B</span><br><span class="line">    echo B=$B</span><br><span class="line">    echo &quot;B=$B&quot;</span><br><span class="line">    unset B</span><br><span class="line">    </span><br><span class="line">    //执行var.sh的结果</span><br><span class="line">    [root@study shcode]# chmod u+x var.sh</span><br><span class="line">    [root@study shcode]# ./var.sh</span><br><span class="line">    100</span><br><span class="line">    A=100</span><br><span class="line">    A=100</span><br><span class="line"></span><br><span class="line">    A=</span><br><span class="line">    A=</span><br><span class="line">    2</span><br><span class="line">    B=2</span><br><span class="line">    B=2</span><br><span class="line">    ./var.sh: 第 18 行:unset: B: 无法反设定: 只读 variable</span><br><span class="line">    [root@study shcode]# ./var.sh</span><br></pre></td></tr></table></figure>

<h3 id="4-shell变量定义的规则"><a href="#4-shell变量定义的规则" class="headerlink" title="4.shell变量定义的规则"></a>4.shell变量定义的规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">规则</span></span><br><span class="line">	1.变量名称可以由字母，数字和下划线，但是不能以数字开头</span><br><span class="line">	2.等号两侧不能有空格</span><br><span class="line">	3.变量名称一般习惯为大写。这是一个规范</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将命令的返回值赋给变量</span></span><br><span class="line">	1.A=`date`  反引号，运行里面的命令，并把结果返回给变量A</span><br><span class="line">	2.A=$(date) $()等价于反引号</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令演示</span></span><br><span class="line">	C=`date`</span><br><span class="line">	D=$(date)</span><br><span class="line">	echo $C</span><br><span class="line">	echo $D</span><br><span class="line">	输出结果为</span><br><span class="line">	2021年 11月 03日 星期三 21:31:38 CST</span><br><span class="line">	2021年 11月 03日 星期三 21:31:38 CST</span><br></pre></td></tr></table></figure>

<h3 id="5-设置环境变量-全局变量"><a href="#5-设置环境变量-全局变量" class="headerlink" title="5.设置环境变量&#x2F;全局变量"></a>5.设置环境变量&#x2F;全局变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	1.export 变量名=变量值 （功能描述：将shell变量输出为环境变量）</span><br><span class="line">	2.source 配置文件      （功能描述：让修改后的配置信息立即生效）</span><br><span class="line">	3.echo $变量名         （功能描述：查询环境变量的值）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">快速入门</span></span><br><span class="line">	1.在/etc/profile文件中定义TOMCAT_HOME环境变量</span><br><span class="line">	2.查看环境变量TOMCAT_HOME的值</span><br><span class="line">	3.在另外一个shell程序中使用TOMCAT_HOME</span><br><span class="line">	</span><br><span class="line">	注意：在输出TOMCAT_HOME环境变量前，需要让其生效</span><br><span class="line">	source /etc/profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码演示：在/etc/profile中添加的内容是 <span class="built_in">export</span> TOMCAT_HOME=/opt/tomcat</span></span><br><span class="line">[root@study tomcat]# vim /etc/profile   </span><br><span class="line">[root@study tomcat]# echo $TOMCAT_HOME</span><br><span class="line"></span><br><span class="line">[root@study tomcat]# source /etc/profile</span><br><span class="line">[root@study tomcat]# echo $TOMCAT_HOME</span><br><span class="line">/opt/tomcat</span><br></pre></td></tr></table></figure>

<h3 id="6-位置参数变量"><a href="#6-位置参数变量" class="headerlink" title="6.位置参数变量"></a>6.位置参数变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">	当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量</span><br><span class="line">	比如： ./myshell.sh 100 200,这个就是一个执行shell的命令行，可以在myshell脚本中获取到参数信息</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">n (功能描述：n为数字，<span class="variable">$0</span>代表命令本身，<span class="variable">$1</span>-<span class="variable">$9</span>代表第一到第九个参数，第十个以上的参数需要用大括号包含，如<span class="variable">$&#123;10&#125;</span>)</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">* (功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体)</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">@ (功能描述：这个变量也代表命令行中所有的参数，不过<span class="variable">$@</span>把每个参数区别看待)</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash"><span class="comment"># (功能描述：这个变量代表命令行中所有参数的个数)</span></span></span><br><span class="line"></span><br><span class="line">位置参数变量</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例</span></span><br><span class="line">	编写一个shell脚本，position.sh,在脚本中获取到命令行的各个参数信息</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码演示 position.sh内容</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">    #获取第一个参数</span><br><span class="line">    echo &quot;第0个参数=$0&quot; </span><br><span class="line">    echo &quot;第1个参数=$1&quot; </span><br><span class="line">    echo &quot;第2个参数=$2&quot;</span><br><span class="line">    echo &quot;所有的参数=$*&quot;</span><br><span class="line">    echo &quot;参数个数=$#&quot;</span><br><span class="line">    </span><br><span class="line">    执行和输出</span><br><span class="line">    [root@study shcode]# chmod u+x position.sh</span><br><span class="line">    [root@study shcode]# ./position.sh 100 200 300</span><br><span class="line">    第0个参数=./position.sh</span><br><span class="line">    第1个参数=100</span><br><span class="line">    第2个参数=200</span><br><span class="line">    所有的参数=100 200 300</span><br><span class="line">    参数个数=3</span><br></pre></td></tr></table></figure>

<h3 id="7-预定义变量"><a href="#7-预定义变量" class="headerlink" title="7.预定义变量"></a>7.预定义变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">	就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">$ (功能描述：当前进程的进程号PID)</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">! (功能描述：后台运行的最后一个进程的进程号PID)</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">? (功能描述：最后一次执行的命令的返回状态，如果这个变量为0，证明上一个命令正确执行；如果这个变量为非0（具体哪个数，由命令来决定），则证明上一个命令执行不正确)</span></span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例</span></span><br><span class="line">	在一个shell脚本中简单使用以下预定义变量 preVar.sh</span><br></pre></td></tr></table></figure>

<h3 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8.运算符"></a>8.运算符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">	学习如何在shell中进行各种运算操作</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	1.$((运算式))或$[运算式]或者expr m + n  （expression）【推荐使用 $[]这种方式 】</span><br><span class="line">	2.注意expr运算符（如+）间要有空格，如果希望将expr后的结果赋给某个变量，使用反引号``引起来</span><br><span class="line">	3.expr m-n</span><br><span class="line">	4.expr \*,/,%, 乘、除、取余</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例</span></span><br><span class="line">	1.计算(2+3)*4的值</span><br><span class="line">	2.请求出命令行的两个参数【整数】的和</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码演示expr.sh内容如下</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">1.计算(2+3)*4的值</span></span><br><span class="line">    RES1=$(((2+3)*4))</span><br><span class="line">    echo &quot;RES1=$RES1&quot;</span><br><span class="line"></span><br><span class="line">    RES2=$[(2+3)*4]</span><br><span class="line">    echo &quot;RES2=$RES2&quot;</span><br><span class="line"></span><br><span class="line">    TEMP=`expr 2 + 3`</span><br><span class="line">    RES3=`expr $TEMP \* 4`</span><br><span class="line">    echo &quot;TEMP=$TEMP&quot;</span><br><span class="line">    echo &quot;RES3=$RES3&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #2.请求出命令行的两个参数【整数】的和</span><br><span class="line">    RES4=$[$1+$2]</span><br><span class="line">    echo &quot;RES4=$RES4&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行和结果输出如下</span></span><br><span class="line">	[root@study shcode]# chmod u+x expr.sh</span><br><span class="line">	[root@study shcode]# ./expr.sh</span><br><span class="line">	RES1=20</span><br><span class="line">    RES2=20</span><br><span class="line">    TEMP=5</span><br><span class="line">    RES3=20</span><br><span class="line">    RES4=300</span><br></pre></td></tr></table></figure>

<h3 id="9-条件判断"><a href="#9-条件判断" class="headerlink" title="9.条件判断"></a>9.条件判断</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断语句</span></span><br><span class="line">	基本语法：</span><br><span class="line">		[ condition ] (注意condition前后要有空格)</span><br><span class="line">        #非空返回true，可使用$?验证（0为true,&gt;1为false）</span><br><span class="line">    案例：</span><br><span class="line">    	[ hspEdu ]  返回true</span><br><span class="line">    	[  ]  为空返回false，即便为空，两端也要有空格</span><br><span class="line">    	[ condition ] &amp;&amp; echo</span><br><span class="line">   	代码演示：</span><br><span class="line">   		#!/bin/bash</span><br><span class="line">   		#案例1：判断&quot;ok&quot;是否等于&quot;ok&quot;,使用=</span><br><span class="line">   		if [ &quot;ok&quot; = &quot;ok&quot; ]</span><br><span class="line">   		then</span><br><span class="line">   			echo &quot;equal&quot;</span><br><span class="line">   		fi</span><br><span class="line">   		#案例2：判断23是否大于等于22</span><br><span class="line">   		if [ 23 -ge 22 ]</span><br><span class="line">   		then</span><br><span class="line">   			echo &quot;大于&quot;</span><br><span class="line">   		fi</span><br><span class="line">   		#案例3：判断/root/shcode/aaa.txt 目录中的文件是否存在</span><br><span class="line">   		if [ -f /root/shcode/aaa.txt ]</span><br><span class="line">   		then</span><br><span class="line">   			echo &quot;存在&quot;</span><br><span class="line">   		fi</span><br></pre></td></tr></table></figure>

<h3 id="10-流程控制"><a href="#10-流程控制" class="headerlink" title="10.流程控制"></a>10.流程控制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span>判断</span></span><br><span class="line">	基本语法 单分支</span><br><span class="line">		if [ 条件判断式 ]</span><br><span class="line">		then</span><br><span class="line">			代码</span><br><span class="line">		fi</span><br><span class="line">		或者 多分支</span><br><span class="line">		if [ 条件判断式 ]</span><br><span class="line">		then</span><br><span class="line">			代码</span><br><span class="line">		elif [ 条件判断式 ]</span><br><span class="line">		then</span><br><span class="line">        	代码</span><br><span class="line">        fi</span><br><span class="line">        或者</span><br><span class="line">        if [ 条件判断式 ]</span><br><span class="line">		then</span><br><span class="line">			代码</span><br><span class="line">		else</span><br><span class="line">        	代码</span><br><span class="line">        fi</span><br><span class="line"> 	注意事项：</span><br><span class="line"> 		[ 条件判断式 ] ，中括号和条件判断式之间必须有空格</span><br><span class="line"> 	代码演示：ifTest.sh</span><br><span class="line"><span class="meta prompt_"> 		#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">        if [ $1 -ge 60 ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;及格了&quot;</span><br><span class="line">        elif [ $1 -lt 60 ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;不及格&quot;</span><br><span class="line">        fi</span><br><span class="line"> 	执行输出</span><br><span class="line"> 		[root@study shcode]# chmod u+x ifTest.sh</span><br><span class="line">		[root@study shcode]# ./ifTest.sh 70</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">case</span>判断</span></span><br><span class="line">	基本语法：</span><br><span class="line">		case $变量名 in</span><br><span class="line">		&quot;值1&quot; )</span><br><span class="line">		如果变量的值等于值1，则执行程序1</span><br><span class="line">		::</span><br><span class="line">		&quot;值2&quot; ）</span><br><span class="line">		如果变量的值等于值2，则执行程序2</span><br><span class="line">		...</span><br><span class="line">		* )</span><br><span class="line">		如果变量的值都不是以上的值，则执行该程序</span><br><span class="line">		::</span><br><span class="line">		esac</span><br><span class="line">	代码演示：case.sh</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">        case $1 in</span><br><span class="line">        &quot;1&quot; )</span><br><span class="line">        echo &quot;周一&quot;</span><br><span class="line">        ;;</span><br><span class="line">        &quot;2&quot;)</span><br><span class="line">        echo &quot;周二&quot;</span><br><span class="line">        ;;</span><br><span class="line">        &quot;3&quot;)</span><br><span class="line">        echo &quot;周三&quot;</span><br><span class="line">        ;;</span><br><span class="line">        * )</span><br><span class="line">        echo &quot;other&quot;</span><br><span class="line">        ;;</span><br><span class="line">        esac</span><br><span class="line">  	执行和输出</span><br><span class="line">  		vim caseTest.sh</span><br><span class="line">        [root@study shcode]# chmod u+x caseTest.sh</span><br><span class="line">        [root@study shcode]# ./caseTest.sh </span><br><span class="line">        other</span><br><span class="line">        [root@study shcode]# ./caseTest.sh 1</span><br><span class="line">       	周一</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">for</span>循环</span></span><br><span class="line">	基本语法1</span><br><span class="line">		for 变量 in 值1 值2 值3</span><br><span class="line">		do</span><br><span class="line">		程序/代码</span><br><span class="line">		done</span><br><span class="line">	基本语法2</span><br><span class="line">		for ((初始值;循环控制条件;变量变化))</span><br><span class="line">		do</span><br><span class="line">		程序</span><br><span class="line">		done</span><br><span class="line">	代码演示（forTest.sh）</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">        #案例1：打印命令行输入的值【这里可以看出$@和$*的区别】</span><br><span class="line">        #$*是把参数当作一个整体</span><br><span class="line">        for i in &quot;$*&quot;</span><br><span class="line">        do</span><br><span class="line">        echo &quot;number is $i&quot;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        for i in &quot;$@&quot;</span><br><span class="line">        do</span><br><span class="line">        echo &quot;number is $i&quot;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        #案例2：求1到100的和</span><br><span class="line">        SUM=0</span><br><span class="line">        for((i=1; i&lt;=100; i++ ))</span><br><span class="line">        do</span><br><span class="line">        SUM=$[($SUM+$i)]</span><br><span class="line">        done</span><br><span class="line">        echo &quot;sum=$SUM&quot;</span><br><span class="line">  	执行和输出代码</span><br><span class="line">  		[root@study shcode]# chmod u+x forTest.sh </span><br><span class="line">        [root@study shcode]# ./forTest.sh 100 200 300</span><br><span class="line">        number is 100 200 300</span><br><span class="line">        number is 100</span><br><span class="line">        number is 200</span><br><span class="line">        number is 300</span><br><span class="line">        sum=5050</span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">while</span>循环</span></span><br><span class="line">	基本语法：</span><br><span class="line">		while [ 条件判断式 ]</span><br><span class="line">		do</span><br><span class="line">		程序</span><br><span class="line">		done</span><br><span class="line">	注意：while和[有空格，条件判断式和[ ]也有空格</span><br><span class="line">	代码演示</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">        SUM=0</span><br><span class="line">        i=0</span><br><span class="line">        while [ $i -le $1 ]</span><br><span class="line">        do</span><br><span class="line">        SUM=$[$SUM+$i]</span><br><span class="line">        i=$[$i+1]</span><br><span class="line">        done</span><br><span class="line">        echo &quot;Sum=$SUM&quot;</span><br><span class="line"> 	执行和输出</span><br><span class="line"> 		[root@study shcode]# chmod u+x whileTest.sh </span><br><span class="line">		[root@study shcode]# ./whileTest.sh 100</span><br><span class="line">		SUM=5050</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="11-read读取控制台输入"><a href="#11-read读取控制台输入" class="headerlink" title="11.read读取控制台输入"></a>11.read读取控制台输入</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	read(选项)(参数)</span><br><span class="line">	选项：</span><br><span class="line">		-p:指定读取值时的提示符</span><br><span class="line">		-t:指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了</span><br><span class="line">	参数：</span><br><span class="line">		变量：指定读取值的变量名</span><br><span class="line">	案例：</span><br><span class="line">		1.读取控制台输入一个NUM1值</span><br><span class="line">		2.读取控制台输入一个NUM2值，在10秒内输入</span><br><span class="line">	代码演示：</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">        #案例：</span><br><span class="line">        #               1.读取控制台输入一个NUM1值</span><br><span class="line">        read -p &quot;输入一个NUM1值&quot; NUM1</span><br><span class="line">        echo &quot;输入一个NUM1值=$NUM1&quot;</span><br><span class="line">        #               2.读取控制台输入一个NUM2值，在10秒内输入</span><br><span class="line">        read -t 10 -p &quot;输入一个NUM2值&quot; NUM2</span><br><span class="line">        echo &quot;输入一个NUM2值=$NUM2&quot;</span><br><span class="line">	执行和输出。会等待控制台输出</span><br><span class="line">		[root@study shcode]# chmod u+x readTest.sh </span><br><span class="line">        [root@study shcode]# ./readTest.sh </span><br><span class="line">        输入一个NUM1值100  </span><br><span class="line">        输入一个NUM1值=100</span><br><span class="line">        输入一个NUM2值200</span><br><span class="line">        输入一个NUM2值=200</span><br></pre></td></tr></table></figure>

<h3 id="12-函数"><a href="#12-函数" class="headerlink" title="12.函数"></a>12.函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">函数介绍</span></span><br><span class="line">	shell编程和其他编程语言一样，有系统函数，也可以自定义函数，系统函数中，我们这里就介绍两个</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">系统函数</span></span><br><span class="line">	basename基本语法</span><br><span class="line">		功能：返回完整路径最后/的部分，常用于获取文件名</span><br><span class="line">	basename [pathname] [suffix]</span><br><span class="line">	basename [string] [suffix] （功能描述：basename命令会删掉所有的前缀包括最后一个‘/’字符，然后将字符串显示出来）</span><br><span class="line">	选项</span><br><span class="line">		suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</span><br><span class="line">	案例：</span><br><span class="line">		请返回/home/aaa/test.txt的&quot;test.txt&quot;</span><br><span class="line">	执行：</span><br><span class="line">		[root@study shcode]# basename /home/aaa/test.txt</span><br><span class="line">		test.txt</span><br><span class="line">		[root@study shcode]# basename /home/aaa/test.txt .txt</span><br><span class="line">		test</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	dirname基本语法</span><br><span class="line">		功能：返回完整路径最后/的前面的部分，常用于返回路径部分</span><br><span class="line">		dirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录），然后返回剩下的路径（目录部分））</span><br><span class="line">		案例：</span><br><span class="line">			请返回/home/aaa/test/txt的/home/aaa</span><br><span class="line">		执行：</span><br><span class="line">			[root@study shcode]# dirname /home/aaa/test.txt</span><br><span class="line">			/home/aaa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">自定义函数</span></span><br><span class="line">	基本语法：</span><br><span class="line">		[ function ] funname[()]</span><br><span class="line">		&#123;</span><br><span class="line">			Action;</span><br><span class="line">			[return int;]</span><br><span class="line">		&#125;</span><br><span class="line">		调用直接写函数名：funname [值]</span><br><span class="line">	案例：</span><br><span class="line">		计算输入两个参数的和（动态的获取），getSum</span><br><span class="line">	代码演示：</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">        #定义函数</span><br><span class="line">        function getSum()&#123;</span><br><span class="line">        SUM=$[$n1+$n2]</span><br><span class="line">        echo &quot;sum=$SUM&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        #输入两个值</span><br><span class="line">        read -p &quot;输入一个值n1：&quot; n1</span><br><span class="line">        read -p &quot;输入一个值n2：&quot; n2</span><br><span class="line">        #调用自定义函数</span><br><span class="line">        getSum $n1 $n2</span><br><span class="line">  	执行和输出</span><br><span class="line">  		[root@study shcode]# chmod u+x funcTest.sh </span><br><span class="line">        [root@study shcode]# ./funcTest.sh </span><br><span class="line">        输入一个值n1：100</span><br><span class="line">        输入一个值n2：200</span><br><span class="line">        sum=300</span><br></pre></td></tr></table></figure>

<h3 id="13-Shell编程综合案例"><a href="#13-Shell编程综合案例" class="headerlink" title="13.Shell编程综合案例"></a>13.Shell编程综合案例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求分析</span></span><br><span class="line">	1.每天凌晨2：30备份数据库 ssm 到 /data/backup/db</span><br><span class="line">	2.备份开始和备份结束能够给出相应的提示信息</span><br><span class="line">	3.备份后的文件要求以备份时间为文件名，并打包成.tar.gz的形式，比如：2021-03-12_230201.tar.gz</span><br><span class="line">	4.在备份的同时，检查是否有10天前备份的数据库文件，如果有就将其删除</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/10/27/Linux%E5%AD%A6%E4%B9%A0/" data-id="clrv2tqxg00044hku7zuv7v52" data-title="Linux学习" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redis笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/27/Redis%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-10-26T16:00:00.000Z" itemprop="datePublished">2022-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/27/Redis%E7%AC%94%E8%AE%B0/">Redis学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis笔记"><a href="#Redis笔记" class="headerlink" title="Redis笔记"></a>Redis笔记</h1><h2 id="0-学习资料"><a href="#0-学习资料" class="headerlink" title="0. 学习资料"></a>0. 学习资料</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.redis官网：redis.io</span><br><span class="line">2.redis中文网：www.redis.cn</span><br><span class="line">3.在官网上下载Redis</span><br></pre></td></tr></table></figure>

<p>centos下安装python3和pip3：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1693084">https://cloud.tencent.com/developer/article/1693084</a></p>
<p>pip3不可用的解决情况：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42185136/article/details/90636750">https://blog.csdn.net/weixin_42185136/article/details/90636750</a></p>
<p>linux与python3安装redis：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1592173">https://cloud.tencent.com/developer/article/1592173</a></p>
<h2 id="1-Nosql概述"><a href="#1-Nosql概述" class="headerlink" title="1. Nosql概述"></a>1. Nosql概述</h2><h3 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1. 基础介绍"></a>1. 基础介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么要用Nosql</span></span><br><span class="line">	用户的个人信息，社交网络，地理位置，用户自己产生的数据，用户日志等等爆发式增长，这时候我们就需要使用Nosql数据库，Nosql可以很好的处理这些情况	</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">什么是Nosql （Not Only sql）</span></span><br><span class="line">	泛指非关系型数据库，数据的存储没有固定的格式，不需要特别的操作就可以横向扩展，使用键值对来进行控制</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Nosql特点</span></span><br><span class="line">	1.方便扩展（数据之间没有关系，很好扩展）</span><br><span class="line">	2.大数据量高性能（Redis一秒写8万次，读取11万次，Nosql缓存记录级，是一种细粒度的缓存，性能会比较高）</span><br><span class="line">	3.数据类型是多样型的（不需要事先设计数据库，随取随用）</span><br><span class="line">	4.传统的数据库和Nosql区别</span><br><span class="line">		传统的RBBMS:</span><br><span class="line">			- 结构化组织</span><br><span class="line">			- SQL</span><br><span class="line">			- 数据和关系都存在单独的表中</span><br><span class="line">			- 数据操作 数据定义语言</span><br><span class="line">			- 严格一致性</span><br><span class="line">			- 基础的事务</span><br><span class="line">		Nosql:</span><br><span class="line">			- 不仅仅是数据</span><br><span class="line">			- 没有固定的查询语言</span><br><span class="line">			- 键值对查询，列查询，文档存储，图形数据库（社交关系）</span><br><span class="line">			- 最终一致性</span><br><span class="line">			- CAP原理和BASE原理</span><br><span class="line">			- 高性能，高可用，高扩展性</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h3 id="2-nosql的四大分类"><a href="#2-nosql的四大分类" class="headerlink" title="2. nosql的四大分类"></a>2. nosql的四大分类</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.KV键值对：</span><br><span class="line">	新浪：Redis</span><br><span class="line">	美团：Redis+Tair</span><br><span class="line">	阿里、百度：Redis+memecache</span><br><span class="line">2.文档型数据库(bson格式和json一样)</span><br><span class="line">	MongoDB:是一个基于分布式文件存储的数据库，c++编写，主要用来处理大量的文档</span><br><span class="line">	MongoDB是一个介于关系型数据库和非关系型数据库中间的产品，是非关系型数据库中功能最丰富的，最像关系型数据库的</span><br><span class="line">3.列存储数据库</span><br><span class="line">	HBase</span><br><span class="line">	分布式文件系统</span><br><span class="line">4.图关系数据库</span><br><span class="line">	他不是存图形，放的是关系，比如朋友圈社交网络，广告推荐</span><br><span class="line">	Neo4j,InfoGrid</span><br></pre></td></tr></table></figure>

<h2 id="2-Redis入门"><a href="#2-Redis入门" class="headerlink" title="2. Redis入门"></a>2. Redis入门</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Redis是什么</span></span><br><span class="line">	Redis(==Remote Dictionary Server)即远程字典服务。免费和开源，最热门的Nosql技术之一</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Redis能干嘛</span></span><br><span class="line">	1.内存存储，持久化，内存中是断电即失，所以说持久化很重要（rdb,aof）</span><br><span class="line">	2.效率高，可以用于告诉缓存</span><br><span class="line">	3.发布订阅系统</span><br><span class="line">	4.地图信息分析</span><br><span class="line">	5.计时器，计数器（浏览量）</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Redis特性：</span></span><br><span class="line">	1.多样的数据类型</span><br><span class="line">	2.持久化</span><br><span class="line">	3.集群</span><br><span class="line">	4.事务</span><br></pre></td></tr></table></figure>

<h3 id="2-windows安装"><a href="#2-windows安装" class="headerlink" title="2. windows安装"></a>2. windows安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.下载安装包</span><br><span class="line">2.解压</span><br><span class="line">3.打开服务端，不要关闭</span><br><span class="line">4.打开客户端</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211201193620995.png" alt="image-20211201193620995"></p>
<h3 id="3-Linux安装"><a href="#3-Linux安装" class="headerlink" title="3. Linux安装"></a>3. Linux安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.下载安装包 redis-6.2.6.tar.gz</span><br><span class="line">2.在/opt目录下新建文件夹Redis</span><br><span class="line">3.将安装包放到Redis目录下</span><br><span class="line">4.解压安装包：   &gt;&gt;&gt;# tar -zxvf redis-6.2.6.tar.gz</span><br><span class="line">5.进入解压后的目录redis-6.2.6，我们可以看到一个redis.conf文件</span><br><span class="line">6.安装gcc环境：  &gt;&gt;&gt;# yum install gcc-c++</span><br><span class="line">7.使用make命令： &gt;&gt;&gt;# make</span><br><span class="line">8.redis的默认安装路径 /usr/local/bin</span><br><span class="line">9.进入到/usr/local目录 &gt;&gt;&gt;# cd /usr/local</span><br><span class="line">10.将redis.conf配置文件拷贝到当前local目录下的bin &gt;&gt;&gt;# cp /opt/Redis/redis-6.2.6/redis.conf bin</span><br><span class="line">11.redis默认不是后台启动的，修改配置文件 &gt;&gt;&gt;# vim redis.conf</span><br><span class="line">12.将daemonize属性修改为yes,输入:wq保存退出</span><br><span class="line">13.启动redis服务 [root@study bin]# redis-server redis.conf     #通过指定的配置文件启动</span><br><span class="line">14.开启客户端[root@study bin]# redis-cli</span><br><span class="line">15.测试是否开启成功</span><br><span class="line">    127.0.0.1:6379&gt; ping</span><br><span class="line">    PONG</span><br><span class="line">    127.0.0.1:6379&gt; set msg hello    （设置值）</span><br><span class="line">    OK</span><br><span class="line">    127.0.0.1:6379&gt; get msg        	  （获取值）</span><br><span class="line">    &quot;hello&quot;</span><br><span class="line">    127.0.0.1:6379&gt; keys *             （查看所有的key）</span><br><span class="line">	1) &quot;msg&quot;</span><br><span class="line">16.查看redis进程是否开启</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">新开一个端口来</span></span><br><span class="line">    [root@study bin]# ps -ef|grep redis</span><br><span class="line">    root      15432      1  0 20:17 ?        00:00:02 redis-server 127.0.0.1:6379</span><br><span class="line">    root      15486  10405  0 20:22 pts/1    00:00:00 redis-cli</span><br><span class="line">    root      15838  15763  0 20:24 pts/3    00:00:00 grep --color=auto redis</span><br><span class="line">17.如何关闭Redis服务呢？shutdown</span><br><span class="line">	127.0.0.1:6379&gt; shutdown  #关闭redis服务器</span><br><span class="line">	not connected&gt; exit       #退出</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211201200451105.png" alt="image-20211201200451105"></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211201200714760.png" alt="image-20211201200714760"></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211201201519607.png" alt="image-20211201201519607"></p>
<h3 id="4-测试性能"><a href="#4-测试性能" class="headerlink" title="4. 测试性能"></a>4. 测试性能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark是一个压力测试工具。官方自带的性能测试工具</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;<span class="comment"># redis-benchmark -h localhost -p 6379 -c 100 -n 10000</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-基础的知识和命令"><a href="#5-基础的知识和命令" class="headerlink" title="5. 基础的知识和命令"></a>5. 基础的知识和命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用<span class="keyword">select</span>切换数据库</span></span><br><span class="line">	redis有16个数据库,默认的使用第0个数据库</span><br><span class="line">    可以使用select进行切换</span><br><span class="line">        127.0.0.1:6379&gt; select 3</span><br><span class="line">        OK</span><br><span class="line">        127.0.0.1:6379[3]&gt; DBSIZE</span><br><span class="line">        (integer) 0</span><br><span class="line">        127.0.0.1:6379[3]&gt; select 0</span><br><span class="line">        OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用DBSIZE查看数据库大小</span></span><br><span class="line">	127.0.0.1:6379&gt; DBSIZE</span><br><span class="line">   	(integer) 5</span><br><span class="line">   	</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用keys *查看所有键</span></span><br><span class="line">	127.0.0.1:6379&gt; select 3</span><br><span class="line">    OK</span><br><span class="line">    127.0.0.1:6379[3]&gt; DBSIZE</span><br><span class="line">    (integer) 0</span><br><span class="line">    127.0.0.1:6379[3]&gt; set msg hello</span><br><span class="line">    OK</span><br><span class="line">    127.0.0.1:6379[3]&gt; DBSIZE</span><br><span class="line">    (integer) 1</span><br><span class="line">    127.0.0.1:6379[3]&gt; set name xiaoming</span><br><span class="line">    OK</span><br><span class="line">    127.0.0.1:6379[3]&gt; DBSIZE</span><br><span class="line">    (integer) 2</span><br><span class="line">    127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">    1) &quot;name&quot;</span><br><span class="line">    2) &quot;msg&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清空当前数据库 FLUSHDB</span></span><br><span class="line">	127.0.0.1:6379[3]&gt; FLUSHDB</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清空所有数据库 FLUSHDB</span></span><br><span class="line">	127.0.0.1:6379[3]&gt; FLUSHALL</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Redis是单线程的</span></span><br><span class="line">	Redis是基于内存操作的，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用了单线程。</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Redis使用单线程为什么还这么快</span></span><br><span class="line">    redis是c语言写的</span><br><span class="line">	误区1：高性能的服务器一定是多线程的</span><br><span class="line">	误区2：多线程（cpu上下文切换需要资源）一定比单线程块</span><br><span class="line">	先去cpu &gt; 内存 &gt; 硬盘的速度</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">核心：redis是将所有的数据放在内存中的，所以说使用单线程去操作效率是最高的，多线程（cpu上下文切换是一个耗时的操作！！！），对于内存系统来说，没有上下文切换效率就是最快的，多次读写都是在一个cpu上，在内存情况下，这个就是最佳的</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Redis五大数据类型"><a href="#3-Redis五大数据类型" class="headerlink" title="3.Redis五大数据类型"></a>3.Redis五大数据类型</h2><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</span><br></pre></td></tr></table></figure>

<h3 id="2-Redis-key-含基本命令"><a href="#2-Redis-key-含基本命令" class="headerlink" title="2. Redis-key(含基本命令)"></a>2. Redis-key(含基本命令)</h3><blockquote>
<p>有keys *、EXISTS key、move key db、EXPIRE key seconds、ttl key、type key</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">keys *		[查看所有key]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> key value	[设置值]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; set name xiaoming</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; set age 19</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">EXISTS key		[判断当前key是否存在]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; EXISTS name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; EXISTS nameone</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">move key db [将该键对应的键值对移到另外一个数据库中去]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; move name 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">EXPIRE key seconds [设置该键的过期时间]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; EXPIRE age 5</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ttl key	[查看当前key的剩余时间]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; ttl age</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379[3]&gt; set name xiaoming</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">type</span> key	[查看当前key的类型]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; type name</span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<h3 id="3-String（字符串）"><a href="#3-String（字符串）" class="headerlink" title="3. String（字符串）"></a>3. String（字符串）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> key value</span></span><br><span class="line">127.0.0.1:6379[3]&gt; set key1 val1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; set key2 val2</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">append key value	[在原有key对应的值后面附加值]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; APPEND key1 hello</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379[3]&gt; get key1</span><br><span class="line">&quot;val1hello&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; append key1 hello</span><br><span class="line">(integer) 14</span><br><span class="line">127.0.0.1:6379[3]&gt; append key1 hello&quot;</span><br><span class="line">Invalid argument(s)</span><br><span class="line">127.0.0.1:6379[3]&gt; append key1 &quot;hello&quot;</span><br><span class="line">(integer) 19</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">strlen key		[查看当前key对应的值的长度]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; strlen key1</span><br><span class="line">(integer) 19</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里注意 中文字占3个字节</span></span><br><span class="line">127.0.0.1:6379[3]&gt; append key1 &quot;我&quot;</span><br><span class="line">(integer) 22</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line">127.0.0.1:6379[3]&gt; set views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; get views</span><br><span class="line">&quot;0&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">incr key		[将当前键对应的<span class="built_in">integer</span>值进行加1]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; incr views</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; incr views</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379[3]&gt; get views</span><br><span class="line">&quot;2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">decr key 		[将当前键对应的<span class="built_in">integer</span>值进行减1]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; decr views</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; decr views</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">incrby key increment  [设置步长 将当前键对应的<span class="built_in">integer</span>值进行加incrment大小]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; INCRBY views 5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379[3]&gt; INCRBY views 5</span><br><span class="line">(integer) 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">decrby key decrment	[将当前键对应的<span class="built_in">integer</span>值进行减decrment大小]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; DECRBY views 5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379[3]&gt; DECRBY views 5</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line">127.0.0.1:6379[3]&gt; set name &quot;helloworld&quot;</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getrange key start end  [截取字符串下标从start开始，到end中间的子串，包括首尾的内容]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; GETRANGE name 0 3</span><br><span class="line">&quot;hell&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getrange key 0 -1		[获取整个字符串，-1表示到最后一个]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; GETRANGE name 0 -1</span><br><span class="line">&quot;helloworld&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379[3]&gt; set str abcdefg</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SETRANGE key offset value		[将value的值放到原来的value中，会根据大小进行一个覆盖]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; SETRANGE str 2 hello</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379[3]&gt; get str</span><br><span class="line">&quot;abhello&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意即便之前存在有这个键，也不会报错，只是将原来的内容进行一个覆盖</span></span><br><span class="line">127.0.0.1:6379[3]&gt; set str abcdefg</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; get str</span><br><span class="line">&quot;abcdefg&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; SETRANGE str 2 he</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379[3]&gt; get str</span><br><span class="line">&quot;abheefg&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; set str abcdefg</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; SETRANGE str 2 hehhhhhhhhh</span><br><span class="line">(integer) 13</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line">设置值时添加过期时间</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setex key seconds value   [在设置该键值对时并设置过期时间]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; setex name 10 xiaoming</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setnx key value   [这个会在分布式锁中常用。只有在该键不存在的情况下才能设置成功，返回1，否则失败，返回0]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; setnx stu neu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; get stu</span><br><span class="line">&quot;neu&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; setnx stu pku</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[3]&gt; get stu</span><br><span class="line">&quot;neu&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">MSET key value [key value...]		[设置多个键值对]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) &quot;k2&quot;</span><br><span class="line">2) &quot;k3&quot;</span><br><span class="line">3) &quot;k1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mget key [key...] 					[获取多个键的值]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; mget k1 k2 k3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">msetnx key value [key value...]     [用法同setnx。这是一个原子性的操作，要不全部成功，要不全部失败]</span></span><br><span class="line">127.0.0.1:6379[3]&gt; MSETNX k1 v1 k4 v4</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line">设置对象</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置一个user:1对象，值为json对象</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里的key是一个巧妙的设计，user:&#123;<span class="built_in">id</span>&#125;:&#123;filed&#125;,如此设计在redis中是可以的</span></span><br><span class="line">127.0.0.1:6379&gt; set user:1 &#123;name:hello,age:19&#125;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">&quot;&#123;name:hello,age:19&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt; set stu &#123;name:hello,age:19&#125;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get stu</span><br><span class="line">&quot;&#123;name:hello,age:19&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt; set user:2 &#123;name:haha,age:20&#125;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get user:2</span><br><span class="line">&quot;&#123;name:haha,age:20&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也可以这样进行操作</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name hello user:1:age 21</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">&quot;&#123;name:hello,age:19&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;21&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################</span></span></span><br><span class="line">getset命令</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getset key value		[如果该key之前不存在就返回nil,若存在就返回该键对应的值，并且将该键对应的值进行修改为后面的这个value值]</span></span><br><span class="line">127.0.0.1:6379&gt; getset db redis</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;mongodb&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量</li>
<li>粉丝数</li>
<li>对象缓存存储</li>
</ul>
</blockquote>
<h3 id="4-List（列表）"><a href="#4-List（列表）" class="headerlink" title="4. List（列表）"></a>4. List（列表）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在redis里面，我们可以把list实现栈、队列、阻塞队列</span></span><br><span class="line">注意所有的list命令都是用L(l)开头的。redis不区分大小写命令</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">插入值</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lpush key element [element...]  在头部依次插入多个值，有点类似于栈</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list 0 1 2 3</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 3</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpush list 4</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;0&quot;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpush key element [element...]   在尾部依次插入多个值，有点类似于队列</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list2 0 1 2 3 4</span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lrange key start stop		[通过指定区间获取值，包括start和stop两端的值]</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;4&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">移除值</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lpop key [count]		[从头部开始移除元素，默认是移除一个，也可以指定移除count个]</span></span><br><span class="line">127.0.0.1:6379&gt; lpop list 1</span><br><span class="line">1) &quot;8&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line"> 1) &quot;7&quot;</span><br><span class="line"> 2) &quot;6&quot;</span><br><span class="line"> 3) &quot;5&quot;</span><br><span class="line"> 4) &quot;4&quot;</span><br><span class="line"> 5) &quot;3&quot;</span><br><span class="line"> 6) &quot;2&quot;</span><br><span class="line"> 7) &quot;1&quot;</span><br><span class="line"> 8) &quot;0&quot;</span><br><span class="line"> 9) &quot;9&quot;</span><br><span class="line">10) &quot;10&quot;</span><br><span class="line">11) &quot;11&quot;</span><br><span class="line">12) &quot;12&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list 3</span><br><span class="line">1) &quot;7&quot;</span><br><span class="line">2) &quot;6&quot;</span><br><span class="line">3) &quot;5&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;0&quot;</span><br><span class="line">6) &quot;9&quot;</span><br><span class="line">7) &quot;10&quot;</span><br><span class="line">8) &quot;11&quot;</span><br><span class="line">9) &quot;12&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpop key [count]		[从尾部开始移除元素，默认是移除一个，也可以指定移除count个]</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list 3</span><br><span class="line">1) &quot;12&quot;</span><br><span class="line">2) &quot;11&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">根据下标获取值</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;0&quot;</span><br><span class="line">6) &quot;9&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lindex key index		[根据下标获取值，index从0开始]</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 2</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 4</span><br><span class="line">&quot;0&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">获取list中的长度</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">llen key</span></span><br><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(integer) 6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">移除list中指定的元素</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;1&quot;</span><br><span class="line">6) &quot;0&quot;</span><br><span class="line">7) &quot;9&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lrem key count element [从头部开始查找，移除指定的元素值，count指定要移除掉多少个]</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 4</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;0&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">ltrim 修建，将list进行截断，类似于取子串</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpush list &quot;hello&quot; hello1 hello2 hello3</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;hello3&quot;</span><br><span class="line">2) &quot;hello2&quot;</span><br><span class="line">3) &quot;hello1&quot;</span><br><span class="line">4) &quot;hello&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ltrim key start stop		[截取下标从start开始，到stop结束的元素赋给key]</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim list 1 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;hello2&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">从尾部移除一个元素，并添加到一个list的头部</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;hello5&quot;</span><br><span class="line">2) &quot;hello4&quot;</span><br><span class="line">3) &quot;hello3&quot;</span><br><span class="line">4) &quot;hello2&quot;</span><br><span class="line">5) &quot;hello1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpoplpush <span class="built_in">source</span> destination		[指从<span class="built_in">source</span>列表的尾部移除一个元素，并将该元素插入到destination的头部，注意<span class="built_in">source</span>和destination可以是同一个]</span></span><br><span class="line">127.0.0.1:6379&gt; rpoplpush list mylist</span><br><span class="line">&quot;hello1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello1&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush list list</span><br><span class="line">&quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;hello2&quot;</span><br><span class="line">2) &quot;hello5&quot;</span><br><span class="line">3) &quot;hello4&quot;</span><br><span class="line">4) &quot;hello3&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">lset设置值，类似于更新操作</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用exists来查询该列表是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS list</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lset key index element		[更新list中指定下标的值，如果该list不存在会报错]</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 hello</span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list val1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">在list中pviot元素的前面或者后面插入value值</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpush list world china chain</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">linsert BEFORE|AFTER pviot value		[在list中pviot元素的前面或者后面插入value值，注意如果有多个的话，只插入从头部开始遇到的第一个pviot元素值]</span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT list before world japan</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;chain&quot;</span><br><span class="line">2) &quot;china&quot;</span><br><span class="line">3) &quot;japan&quot;</span><br><span class="line">4) &quot;world&quot;</span><br><span class="line">5) &quot;hello&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################</span></span></span><br><span class="line">只有在list存在时，lpushx才能插入成功</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; FLUSHALL</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lpushx list 1 2 3 4 5</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; lpushx list 1 2 3 4 5 6 7 8 </span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; lpush list 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpushx list 4 5 6</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
<ul>
<li>它实际上是一个链表，可以从头插入，也可以从尾部插入</li>
<li>如果key不存在，就创建新的列表</li>
<li>如果key存在，就新增内容</li>
<li>如果移除了所有值，就是一个空列表，也代表不存在，此时就又需要重新创建列表了</li>
<li>在两边插入或者改动值，效率最高，中间元素，相对来说效率会低一点</li>
</ul>
</blockquote>
<h3 id="5-set-集合"><a href="#5-set-集合" class="headerlink" title="5. set (集合)"></a>5. set (集合)</h3><blockquote>
<p>set中的值是不能重复的，无序的集合</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sadd key member [member...]    [往<span class="built_in">set</span>集合中添加一个或多个元素]</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset world adele typora</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">smembers key		[查看<span class="built_in">set</span>集合中的所有元素]</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;typora&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;adele&quot;</span><br><span class="line">4) &quot;world&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sismember key member		[判断某一个值是不是在<span class="built_in">set</span>集合中]</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset helllotwo</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scard key			[获取<span class="built_in">set</span>集合中的内容元素个数]</span></span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">srem key member [member...]	[移除<span class="built_in">set</span>集合中的一个或多个元素]</span></span><br><span class="line">127.0.0.1:6379&gt; SREM myset hello world</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">srandmember key count		[随机获取到<span class="built_in">set</span>集合中的count个元素]</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 1</span><br><span class="line">1) &quot;haha&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 1</span><br><span class="line">1) &quot;xixi&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 1</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class="line">1) &quot;typora&quot;</span><br><span class="line">2) &quot;xixi&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hehe&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################################</span></span></span><br><span class="line">随机删除元素</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">spop key count		[随即删除<span class="built_in">set</span>集合中指定个数的元素]</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset 1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">smove <span class="built_in">source</span> destination member	[将<span class="built_in">source</span>集合中指定的元素member移到目标集合中去]</span></span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 adele</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################################################################</span></span></span><br><span class="line">求解集合之间的差集、交集、并集</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd set1 a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd set2 b c d</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sdiff key1 [key2...]   [求解差集。key1-key2.即只有key1集合中有，其他集合中没有的元素]</span>   </span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sinter key [key]		[求解交集]</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER set1 set2</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sunion key [key]		[求解并集]</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION set1 set2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">4) &quot;c&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>set集合的应用<ul>
<li>共同关注</li>
</ul>
</li>
</ul>
<p>	</p>
</blockquote>
<h3 id="6-Hash-哈希"><a href="#6-Hash-哈希" class="headerlink" title="6. Hash(哈希)"></a>6. Hash(哈希)</h3><p>Map集合，key  Map 这时候这个value值是一个map集合。本质和string没有太多区别</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hset key field value [field value...]		[往<span class="built_in">hash</span>中设置一个或多个值]</span></span><br><span class="line">127.0.0.1:6379&gt; HSET myhash name xiaoming age 19</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HSET myhash name zhangsan  age 20</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hkeys key		[获取该<span class="built_in">hash</span>中所有的字段]</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hget key field		[获取该<span class="built_in">hash</span>中该字段对应的值]</span></span><br><span class="line">127.0.0.1:6379&gt; hget myhash name</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hmset key field value [field value...]		[往<span class="built_in">hash</span>中设置一个或多个值]</span></span><br><span class="line">127.0.0.1:6379&gt; HMSET myhash city beijing  country China</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hgetall key		[获取该<span class="built_in">hash</span>中所有字段与字段值]</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;city&quot;</span><br><span class="line">6) &quot;beijing&quot;</span><br><span class="line">7) &quot;country&quot;</span><br><span class="line">8) &quot;China&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hdel key field [field...]		[删除<span class="built_in">hash</span>中指定的字段，删除后字段对应的值就也没有了]</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash name city</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hlen key		[获取<span class="built_in">hash</span>中有多少个field]</span></span><br><span class="line">127.0.0.1:6379&gt; HLEN myhash</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hexists key field		[判断<span class="built_in">hash</span>中某个字段是否存在]</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash age</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash name</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;country&quot;</span><br><span class="line">4) &quot;China&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hkeys key			[获取<span class="built_in">hash</span>中所有的field]</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;country&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hvals key			[获取<span class="built_in">hash</span>中所有的value]</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;China&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hsetnx key field value		[如果该字段不存在就设置该字段和值，否则就不允许设置]</span></span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash age 20</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash age 20</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash age 2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hincreby key field incrment	[将<span class="built_in">hash</span>中指定字段的值按照指定的步长进行自增]</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash age 3</span><br><span class="line">(integer) 23</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash age 3</span><br><span class="line">(integer) 26</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>hash变更的应用。尤其是用户信息的保存,经常变动的数据。hset user name xxx age xx</li>
<li>hash更适合于对象的存储，String更加适合于字符串存储</li>
</ul>
</blockquote>
<h3 id="7-Zset-有序集合"><a href="#7-Zset-有序集合" class="headerlink" title="7. Zset(有序集合)"></a>7. Zset(有序集合)</h3><p>在set的基础上，增加了一个值，set k1 v1 	zset k1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">zadd key score member [score member...]		[往集合中添加一个元素或多个元素]</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZADD myset 3 three 2 two</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取集合中指定范围的元素</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">降序</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 withscores</span><br><span class="line">1) &quot;xiaoming&quot;</span><br><span class="line">2) &quot;5000&quot;</span><br><span class="line">3) &quot;xiaoyang&quot;</span><br><span class="line">4) &quot;500&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line">排序如何实现</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">往zset中添加多个元素</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaohong 5000 xiaoming 500 xiaoyang</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">zrangebyscore key min max [withscores]		[获取zset中score值在min到max之间的元素，升序排列]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-inf表示最小值，+inf表示最大值</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEbyscore salary -inf +inf</span><br><span class="line">1) &quot;xiaoyang&quot;</span><br><span class="line">2) &quot;xiaohong&quot;</span><br><span class="line">3) &quot;xiaoming&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">withcores 是指在输出时也输出scores的值</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEbyscore salary -inf +inf withscores</span><br><span class="line">1) &quot;xiaoyang&quot;</span><br><span class="line">2) &quot;500&quot;</span><br><span class="line">3) &quot;xiaohong&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">5) &quot;xiaoming&quot;</span><br><span class="line">6) &quot;5000&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEbyscore salary 300 1000</span><br><span class="line">1) &quot;xiaoyang&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这表示输出score值在 300&lt;=score&lt;=500之间的元素</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEbyscore salary 300 500</span><br><span class="line">1) &quot;xiaoyang&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这表示输出score值在 300&lt;=score&lt;500之间的元素</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEbyscore salary 300 (500</span><br><span class="line">(empty array)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEbyscore salary -inf +inf withscores limit 1 2</span><br><span class="line">1) &quot;xiaohong&quot;</span><br><span class="line">2) &quot;2500&quot;</span><br><span class="line">3) &quot;xiaoming&quot;</span><br><span class="line">4) &quot;5000&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ZREVRANGEBYSCORE这是降序排列</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line">删除zset中指定的元素</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">zrem key member [member...]		[删除zset中指定的一个或多个元素]</span></span><br><span class="line">127.0.0.1:6379&gt; ZREM salary xiaohong</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line">获取有序集合中的个数</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">zcard key		[获取有序集合中的个数]</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 withscores</span><br><span class="line">1) &quot;xiaoming&quot;</span><br><span class="line">2) &quot;5000&quot;</span><br><span class="line">3) &quot;xiaobai&quot;</span><br><span class="line">4) &quot;2000&quot;</span><br><span class="line">5) &quot;xiaoliu&quot;</span><br><span class="line">6) &quot;1000&quot;</span><br><span class="line">7) &quot;xiaoyang&quot;</span><br><span class="line">8) &quot;500&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">zcount key min max			[获取指定区间的个数]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1000&lt;=score&lt;=2000</span></span><br><span class="line">127.0.0.1:6379&gt; zcount salary 1000 2000</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1000&lt;=score&lt;2000</span></span><br><span class="line">127.0.0.1:6379&gt; zcount salary 1000 (2000</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############################################################################</span></span></span><br><span class="line">按照zset集合中member的字典来进行排序</span><br><span class="line">127.0.0.1:6379&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1</span><br><span class="line">(integer) 12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">zrangebylex key min max [LIMIT offset count]</span> </span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX zset - +</span><br><span class="line"> 1) &quot;a&quot;</span><br><span class="line"> 2) &quot;aa&quot;</span><br><span class="line"> 3) &quot;abc&quot;</span><br><span class="line"> 4) &quot;apple&quot;</span><br><span class="line"> 5) &quot;b&quot;</span><br><span class="line"> 6) &quot;c&quot;</span><br><span class="line"> 7) &quot;d&quot;</span><br><span class="line"> 8) &quot;d1&quot;</span><br><span class="line"> 9) &quot;dd&quot;</span><br><span class="line">10) &quot;dobble&quot;</span><br><span class="line">11) &quot;z&quot;</span><br><span class="line">12) &quot;z1&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>zset的应用场景：存储班级成绩，工资表排序，带权重进行判断，排行榜，取top n方法</li>
</ul>
</blockquote>
<h2 id="4-三种特殊数据类型"><a href="#4-三种特殊数据类型" class="headerlink" title="4.三种特殊数据类型"></a>4.三种特殊数据类型</h2><h3 id="1-geospatial-地理位置"><a href="#1-geospatial-地理位置" class="headerlink" title="1.  geospatial(地理位置)"></a>1.  geospatial(地理位置)</h3><p>微信的定位，附近的人，打车距离计算</p>
<p>Redis中的geo，这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GEOADD key longitude latitude member [longitude latitude member ...]</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有效的经度从-180度到180度。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有效的纬度从-85.05112878度到85.05112878度。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing 121.47 31.23 shanghai</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 114.05 29.53 shenzhen</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################################################################</span></span></span><br><span class="line">获得当前定位</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GEOPOS key member [member ...]		[获取指定城市的经度和维度]</span></span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing shanghai shenzhen</span><br><span class="line">1) 1) &quot;116.39999896287918091&quot;</span><br><span class="line">   2) &quot;39.90000009167092543&quot;</span><br><span class="line">2) 1) &quot;121.47000163793563843&quot;</span><br><span class="line">   2) &quot;31.22999903975783553&quot;</span><br><span class="line">3) 1) &quot;114.04999762773513794&quot;</span><br><span class="line">   2) &quot;29.52999957900659211&quot;</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################################################################</span></span></span><br><span class="line">返回两个位置之间的距离</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GEODIST key member1 member2 [unit]</span></span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai m</span><br><span class="line">&quot;1067378.7564&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km</span><br><span class="line">&quot;1067.3788&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################################################################</span></span></span><br><span class="line">搜索附近的人，以给定的经纬度为中心，半径为radius内的人</span><br><span class="line">前提是所有的数据已经录入</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km </span><br><span class="line">1) &quot;chongqing&quot;</span><br><span class="line">2) &quot;shenzhen&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</span></span><br><span class="line">以给定的位置为中心，找出半径为radius内的位置或人</span><br><span class="line">前提是所有的数据已经录入</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1100 km</span><br><span class="line">1) &quot;beijing&quot;</span><br><span class="line">2) &quot;shanghai&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################################################################</span></span></span><br><span class="line">返回对应位置的geohash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GEOHASH key member [member ...]</span></span><br><span class="line">127.0.0.1:6379&gt; GEOHASH china:city beijing shanghai shenzhen</span><br><span class="line">1) &quot;wx4fbxxfke0&quot;</span><br><span class="line">2) &quot;wtw3sj5zbj0&quot;</span><br><span class="line">3) &quot;wt1pgrb8tw0&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>geo底层的实现的原理是zset,因此可以使用操作zset的方式来操作geo中的key</font></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对上面geo中的数据进行操作</span></span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) &quot;chongqing&quot;</span><br><span class="line">2) &quot;shenzhen&quot;</span><br><span class="line">3) &quot;hangzhou&quot;</span><br><span class="line">4) &quot;shanghai&quot;</span><br><span class="line">5) &quot;beijing&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除其中一个元素</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h3 id="2-hyperloglog"><a href="#2-hyperloglog" class="headerlink" title="2. hyperloglog"></a>2. hyperloglog</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">基数统计</span><br><span class="line">（1，3，5，7，8，7）</span><br><span class="line">（1，3，5，7，8）</span><br><span class="line">基数——就是不重复的元素，上面这两个集合的基数就为5，可以接受误差</span><br><span class="line">Redis2.8.9就推出了Hyperloglog数据结构</span><br><span class="line">Redis Hyperloglog 基数统计算法</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">优点：占用的内存是固定，2^64不同的元素的统计，只需要12KB内存，如果从内存角度来进行比较的话，hyperloglog是首选。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">缺点：会有一定的错误率（0.81%），可忽略不计</span></span><br><span class="line">网页的UV(一个人访问一个网站多次，但是还是算作一个人)</span><br><span class="line">传统的方式是使用set来保存用户的id,然后进行统计</span><br><span class="line">这个方式如果保存大量的用户id,就会比较麻烦，目的是为了计数，而不是保存用户id.</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将指定的元素添加到hyperloglog中</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pfadd key element [element...]</span></span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e f g h</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e f g</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">统计指定的hyperloglog中元素的基数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当参数为一个key时,返回存储在HyperLogLog结构体的该变量的近似基数，如果该变量不存在,则返回0.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当参数为多个key时，返回这些HyperLogLog并集的近似基数，这个值是将所给定的所有key的HyperLoglog结构合并到一个临时的HyperLogLog结构中计算而得到的.</span></span><br><span class="line">pfcount key [key...]</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey1 a b c d e f g w a a a </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey1</span><br><span class="line">(integer) 8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PFMERGE destkey sourcekey [sourcekey ...]  [合并任意组的基数中的hyperloglog到一个新的里面去统计]</span></span><br><span class="line">127.0.0.1:6379&gt; pfmerge myset2 mykey mykey1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount myset2</span><br><span class="line">(integer) 9</span><br></pre></td></tr></table></figure>

<h3 id="3-Bitmaps"><a href="#3-Bitmaps" class="headerlink" title="3. Bitmaps"></a>3. Bitmaps</h3><p><font color='red'>模式：使用 bitmap 实现用户上线次数统计</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">位存储</span></span><br><span class="line">统计用户信息，活跃，不活跃，登录，未登录，打卡!两个状态的，都可以使用Bitmaps!</span><br><span class="line"></span><br><span class="line">Bitmaps位图，数据结构！都是操作二进制位来进行记录，就只有0和1两种状态</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置值</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SETBIT key offset value</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 0</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取值，查看某一天是否打卡</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GETBIT key offset</span></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">统计操作，统计打卡的天数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">BITCOUNT sign [start stop]</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT sign</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h2><blockquote>
<p><font color='red'>redis单条命令保证原子性，但是事务不保证原子性</font></p>
</blockquote>
<blockquote>
<p>redis事务的本质：一组命令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行，一次性，顺序性，排他性。执行一系列的命令</p>
</blockquote>
<blockquote>
<p>redis事务中没有隔离级别的概念</p>
<p>所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行！Exec</p>
</blockquote>
<blockquote>
<ul>
<li>redis的事务：<ol>
<li>开启事务（multi）</li>
<li>命令入队（）</li>
<li>执行事务（exec）</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; set key1 val1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set key2 val2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get key1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get key2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) &quot;val1&quot;</span><br><span class="line">4) &quot;val2&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>放弃事务（discard）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; set key1 val1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set key2 val2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">放弃事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; discard</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">则进队的那些命令都没有执行</span></span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译型异常（代码有问题！命令有错），事务中所有的命令都不会被执行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译型异常</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; getsetss k3</span><br><span class="line">(error) ERR unknown command `getsetss`, with args beginning with: `k3`, </span><br><span class="line">127.0.0.1:6379(TX)&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行时异常（如1&#x2F;0）,如果事务队列中存在语法性错误，那么其他命令是可以正常执行的，错误命令抛出异常</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行型异常，虽然第一条命令运行异常，但是其他命令正常执行</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) (error) ERR value is not an integer or out of range</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) &quot;v2&quot;</span><br><span class="line">5) &quot;v3&quot;</span><br><span class="line">6) &quot;v1&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>&#x3D;&#x3D;<font color='red'>监控：watch</font>&#x3D;&#x3D; （面试常问）<ul>
<li>悲观锁：<ul>
<li>很悲观，认为任务什么时候都会出问题，无论做什么都会加锁</li>
</ul>
</li>
<li>乐观锁：<ul>
<li>很乐观，认为什么时候都会出问题，无论做什么都不会加锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>Redis监控测试：</p>
</blockquote>
<p>正常执行成功的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 0</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">watch key [key...]		[对一些key进行监视]</span></span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试多线程修改值，使用watch可以当做redis的乐观锁操作！</p>
</blockquote>
<p><font color='red'>#这是在A客户端操作</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec	#在执行之前，另外一个线程修改了我们的值，就会导致事务执行失败</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line">&quot;1000&quot;</span><br></pre></td></tr></table></figure>

<p><font color='red'>#这是在B客户端操作</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line">&quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; get out</span><br><span class="line">&quot;0&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在A客户端执行<span class="built_in">exec</span>之前，执行下面的命令，就会出现这种情况</span></span><br><span class="line">127.0.0.1:6379&gt; set money 1000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line">&quot;1000&quot;</span><br></pre></td></tr></table></figure>

<p>处理上面问题的方式：就是解锁后再执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">unwatch	[如果发现事务执行失败，就先解锁，再监视，之后再执行]</span></span><br><span class="line">127.0.0.1:6379&gt; unwatch    </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) (integer) 980</span><br><span class="line">2) (integer) 20</span><br></pre></td></tr></table></figure>

<h2 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6. Jedis"></a>6. Jedis</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们要使用java来操作redis,就需要用到</span></span><br><span class="line">是Redis官方推荐的Java连接开发工具，使用Java操作redis中间件，需要对jedis非常熟悉</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试</p>
</blockquote>
<ol>
<li><p>创建maven项目，导入对应的依赖包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入jedis包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--导入fastjson--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.78<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编码测试</p>
<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1.new Jedis对象即可</span></span><br><span class="line">    Jedis jedis=<span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//jedis所有的命令就是我们之前学习的所有指令，每一个指令都是以方法来进行操作</span></span><br><span class="line">    System.out.println(jedis.ping());  <span class="comment">//输出PONG表示没有问题</span></span><br><span class="line">    Set&lt;String&gt; res=jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String str:res)&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Springboot整合（待看主要是视频的P26、P27）"><a href="#7-Springboot整合（待看主要是视频的P26、P27）" class="headerlink" title="7.Springboot整合（待看主要是视频的P26、P27）"></a>7.Springboot整合（待看主要是视频的P26、P27）</h2><h2 id="8-Redis-conf详解"><a href="#8-Redis-conf详解" class="headerlink" title="8.Redis.conf详解"></a>8.Redis.conf详解</h2><p>启动的时候就通过配置文件来启动</p>
<blockquote>
<p>配置文件 unit单位：对于大小写不敏感</p>
</blockquote>
<blockquote>
<p>包含：相当于导入其他的配置文件</p>
<p>如：include &#x2F;path&#x2F;to&#x2F;local.conf</p>
<p>​		include &#x2F;path&#x2F;to&#x2F;other.conf</p>
</blockquote>
<blockquote>
<ul>
<li>网络<ol>
<li>绑定</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>快照<ul>
<li>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件，rdb.aof.redis是内存数据库，如果没有持久化，那么数据断电即失。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果3600秒内，如果至少有一个 key进行了修改，我们即失进行持久化操作</span></span><br><span class="line">save 3600 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果300秒内，如果至少100个key进行了修改，我们就及时进行持久化操作</span></span><br><span class="line">save 300 100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果60秒内，如果至少10000个key进行了修改，我们就及时进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们之后学习完持久化，可以进行自己设置</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes		#持久化如果出错，是否需要继续工作</span><br><span class="line"></span><br><span class="line">rdbcompression yes					#是否压缩rdb文件，需要消耗一些cpu资源</span><br><span class="line"></span><br><span class="line">rdbchecksum yes						#保存rdb文件的时候，进行错误的检查校验</span><br><span class="line"></span><br><span class="line">dir ./								#指定rdb文件保存的目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>REPLICATION复制，后面讲解主从复制的时候会讲解</p>
</blockquote>
<blockquote>
<p>SECURITY安全</p>
</blockquote>
<p>可以再这里设置redis的密码，默认是没有密码</p>
<blockquote>
<p>客户端限制</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000					#设置能连接的最大客户端数量</span><br><span class="line"></span><br><span class="line">maxmemory &lt;bytes&gt;					#redis配置最大的内存容量</span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction			#内存满了之后的处置策略</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>APPEND ONLY 模式，aof配置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly no						#默认是不开启aof模式的，默认时使用rdb方式持久化的，在大部分所有的的情况下，rdb完全够用</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;		#持久化文件的名字</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">appendfsync always				<span class="comment">#每次修改丢回sync,消耗性能</span></span></span><br><span class="line">appendfsync everysec				#每秒执行一次sync,可能会丢失这一秒的数据</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">appendfsync no					<span class="comment">#不执行sync,这个时候操作系统自己同步数据，速度最快</span></span></span><br></pre></td></tr></table></figure>

<h2 id="9-Redis持久化"><a href="#9-Redis持久化" class="headerlink" title="9.Redis持久化"></a>9.Redis持久化</h2><p>面试和工作，持久化是重点。Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以Redis提供了持久化功能。</p>
<h3 id="1-RDB-Redis-DataBase"><a href="#1-RDB-Redis-DataBase" class="headerlink" title="1.RDB(Redis DataBase)"></a>1.RDB(Redis DataBase)</h3><blockquote>
<ul>
<li><p>工作原理：</p>
<p>在指定的时间间隔内，将内存中的数据集快照写入磁盘，也就是行话讲的快照（snapshot）,它恢复时是将快照文件直接读到内存中。</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主进程是不进行任何I&#x2F;O操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效，RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般请开给你下不需要修改这个配置。</p>
<p><font color='red'>rdb保存的文件是dump.rdb</font>，都是在redis.conf文件中配置的<font color='red'>【在生产环境中我们需要对dump.rdb进行备份，防止丢失】</font></p>
</li>
</ul>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211205162549921.png" alt="image-20211205162549921"></p>
<blockquote>
<ul>
<li><font color='red'>触发机制：</font><ol>
<li>save的规则满足的情况下，会自动触发rdb操作</li>
<li>执行flushall命令，也会触发我们的rdb规则</li>
<li>退出redis（如执行shutdown命令的时候）,也会产生rdb文件</li>
</ol>
</li>
</ul>
</blockquote>
<p>备份就自动生成一个dump.rdb文件</p>
<blockquote>
<ul>
<li><p>如何恢复rdb文件</p>
<ol>
<li><p>只需要将rdb文件放在我们的redis启动目录下（在我本机里面是&#x2F;usr&#x2F;local&#x2F;bin目录下）就可以，redis启动的时候会自动检查dump.rdb文件中的数据</p>
</li>
<li><p>查看需要存在的位置</p>
<p>​	127.0.0.1:6379&gt; config get dir</p>
<p>​	1）”dir”</p>
<p>​	2）”&#x2F;usr&#x2F;local&#x2F;bin”		#如果在这个目录下存在dump.rdb文件，启动就自动会恢复其中的文件</p>
</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p>几乎使用它默认的配置就够用了</p>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>RDB优点：</font><ol>
<li>适合大规模的数据恢复！dump.rdb</li>
<li>对数据完整性要求不高</li>
</ol>
</li>
<li><font color='red'>RDB缺点：</font><ol>
<li>需要一定的时间间隔进程才操作！如果redis意外宕机了，这个最后一次修改的数据就没有了</li>
<li>fork进程的时候，会需要一定的内存空间</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2.AOF(Append Only File)"></a>2.AOF(Append Only File)</h3><p>将我们所有的命令都记录下来，history,恢复的时候就把这个文件全部执行一遍</p>
<blockquote>
<ul>
<li><p>AOF是什么：</p>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（该操作不记录），只许追加文件但不可以改写文件，reds启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
</li>
</ul>
</blockquote>
<p><font color='red'>Aof保存的是appendonly.aof文件</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly no				#默认是不开启的</span><br></pre></td></tr></table></figure>

<p>默认是不开启的，我们需要手动进行配置，我们只需要将appendonly改为yes就开启了aof</p>
<p>重启之后，redis就可以生效了</p>
<p>如果这个Aof文件有错误，这时候redis是启动不起来的，我们需要修复这个aof文件，redis给我们提供了这样一个工具，redis-check-aof –fix</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是在aof文件有错误的情况下启动redis失败的情况</span></span><br><span class="line">[root@study bin]# redis-server redis.conf</span><br><span class="line">[root@study bin]# redis-cli</span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################################################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们可以通过redis-check-aof文件来修复appendonly.aof文件，再重新启动redis</span></span><br><span class="line">[root@study bin]# redis-check-aof --fix appendonly.aof </span><br><span class="line">0x              3c: Expected \r\n, got: 6b66</span><br><span class="line">AOF analyzed: size=97, ok_up_to=52, ok_up_to_line=15, diff=45</span><br><span class="line">This will shrink the AOF from 97 bytes, with 45 bytes, to 52 bytes</span><br><span class="line">Continue? [y/N]: y</span><br><span class="line">Successfully truncated AOF</span><br></pre></td></tr></table></figure>

<blockquote>
<p>APPEND ONLY 模式，aof配置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">appendonly no						#默认是不开启aof模式的，默认时使用rdb方式持久化的，在大部分所有的的情况下，rdb完全够用</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;		#持久化文件的名字</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">appendfsync always				<span class="comment">#每次修改丢回sync,消耗性能</span></span></span><br><span class="line">appendfsync everysec				#每秒执行一次sync,可能会丢失这一秒的数据</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">appendfsync no					<span class="comment">#不执行sync,这个时候操作系统自己同步数据，速度最快</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rewrite	重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重写规则的说明：如果aof文件大于64mb,太大了，就会fork一个新的进程来将我们的文件进行重写</p>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>AOF优点：</font><ol>
<li>每一次修改都同步，文件的完整性会更加好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高的</li>
</ol>
</li>
<li><font color='red'>AOF缺点：</font><ol>
<li>相对于数据文件来说，aof文件远远大于rdb,修复的速度也比rdb慢</li>
<li>aof运行效率也比rdb慢，</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="10-Redis发布订阅"><a href="#10-Redis发布订阅" class="headerlink" title="10.Redis发布订阅"></a>10.Redis发布订阅</h2><blockquote>
<p>Redis发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收信息。</p>
<p>Redis客户端可以订阅任意数量的频道。（发送者和订阅者都是客户端，服务器端作为队列存储转发信息）</p>
</blockquote>
<blockquote>
<p>测试</p>
</blockquote>
<p><strong>订阅端</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE neu				#订阅一个频道</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;neu&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;neu&quot;</span><br><span class="line">3) &quot;hello&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;neu&quot;</span><br><span class="line">3) &quot;world&quot;</span><br></pre></td></tr></table></figure>

<p><strong>发送端：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH neu hello			#向一个频道内发送信息</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH neu world			#向一个频道内发送信息</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>原理：<ul>
<li>Pub&#x2F;Sub从字面上理解就是发布（publish）与订阅（Subscribe）,在Redis中，你可以设定对某一个key值（就是一个channel）进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的信息，这一功能最明显的做法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>使用场景：</p>
<ol>
<li>实时消息系统</li>
<li>实时聊天（频道当作聊天室，将消息回显给所有人）</li>
<li>订阅关注系统</li>
</ol>
</li>
<li><p>稍微复杂的我们使用消息中间件来做：如Kafka，rabbitMQ</p>
</li>
</ul>
</blockquote>
<h2 id="11-Redis主从复制"><a href="#11-Redis主从复制" class="headerlink" title="11.Redis主从复制"></a>11.Redis主从复制</h2><blockquote>
<ul>
<li><p>概念：</p>
<ul>
<li><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master&#x2F;leader）,后者称为从节点（slave&#x2F;follower）;数据的复制是单向的，只能由主节点到从节点。Master以写为主，salve以读为主。<font color='red'>（这里面的主节点和从节点都是属于Redis-server）</font></p>
</li>
<li><p><font color='red'>默认情况下，每台Redis服务器都是主节点</font>，且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点</p>
</li>
</ul>
</li>
<li><p>主从复制，读写分离！80%的情况都是在进行读操作，减缓服务器的压力架构中经常使用。一主二从</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>主从复制的作用：</font><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载，尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量</li>
<li>高可用（集群）的基础：除了上述作用外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础</li>
</ol>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>一般在工程项目中，不要只使用一台Redis（会宕机），原因如下：<ol>
<li>结构上，单个服务器会发生单点故障，并且一台服务器处理所有请求负载，压力过大</li>
<li>从容量上，单个Redis服务器内存容量有限，最好单个Redis服务器最大内存使用量不要超过20G</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p><font color='red'>环境配置</font></p>
</blockquote>
<p>只用配置从库，不用配置主库，因为默认是主库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@study bin]# redis-cli	</span><br><span class="line">127.0.0.1:6379&gt; INFO replication			#查看当前服务器的主/从复制信息</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master			#角色 master</span><br><span class="line">connected_slaves:0	#没有从机</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:d6b714e78248b3e0ff79ad463b49eb5a301243fa</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>步骤（一主二从）：（这是属于单机多集群，因为server都一样，只是配置文件不同，端口不同）</font></p>
<ol>
<li>复制3个配置文件（redis.conf） <ol>
<li>[root@study bin]#  cp redis.conf redis79.conf</li>
<li>[root@study bin]#  cp redis.conf redis80.conf</li>
<li>[root@study bin]#  cp redis.conf redis81.conf</li>
</ol>
</li>
<li>然后修改对应的配置信息：<ol>
<li>端口号：port	&#x3D;&#x3D;6379&#x3D;&#x3D;</li>
<li>修改pid名字：pid_file_name：pidfile &#x2F;var&#x2F;run&#x2F;&#x3D;&#x3D;redis_6381.pid&#x3D;&#x3D;</li>
<li>log文件名字：logfile &#x3D;&#x3D;”6381.log”&#x3D;&#x3D; </li>
<li>备份文件名字：dbfilename &#x3D;&#x3D;dump6381.rdb&#x3D;&#x3D;</li>
</ol>
</li>
<li>修改完毕之后，启动我们的3个redis服务器，可以通过进程信息查询<ol>
<li>[root@study bin]# redis-server redis79.conf</li>
<li>[root@study bin]# redis-server redis80.conf</li>
<li>[root@study bin]# redis-server redis81.conf</li>
<li>[root@study bin]# ps -ef |grep redis<br>root       5244      1  0 20:09 ?        00:00:12 redis-server 127.0.0.1:6379<br>root       5648      1  0 20:36 ?        00:00:00 redis-server 127.0.0.1:6380<br>root       5656      1  1 20:36 ?        00:00:00 redis-server 127.0.0.1:6381<br>root       5662   4080  0 20:36 pts&#x2F;2    00:00:00 grep –color&#x3D;auto redis</li>
</ol>
</li>
<li>在不配置的情况下，每台服务器都是主服务器，开三个端口作为客户端进入<ol>
<li>[root@study bin]# redis-cli -p 6379<br>127.0.0.1:6379&gt;</li>
<li>[root@study bin]# redis-cli -p 6380<br>127.0.0.1:6380&gt; </li>
<li>[root@study bin]# redis-cli -p 6381<br>127.0.0.1:6381&gt;</li>
</ol>
</li>
<li>通过info replication查看会发现每个服务器都是主机，所以一般情况下只用配置从机就可以了。现在准备配置一主（6379）二从（6380，6381）.核心就是从机来认主机<ol>
<li>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379<br>OK</li>
<li>127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379<br>OK</li>
</ol>
</li>
</ol>
</blockquote>
<p><font color='red'>#查看配置完从机后的主机主从复制信息：</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master		#角色	master</span><br><span class="line">connected_slaves:2		#从机的个数</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=84,lag=1	#从机的相关信息</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=84,lag=1	#从机的相关信息</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:61e4b33ab2f9baa6be68cf635919f485289ce44c</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:98</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:98</span><br></pre></td></tr></table></figure>

<p><font color='red'>#查看配置完从机后的从机主从复制信息：</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave		#角色	slave</span><br><span class="line">master_host:127.0.0.1	#主机的ip</span><br><span class="line">master_port:6379		#主机的端口号</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:9</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:42</span><br><span class="line">slave_repl_offset:42</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:61e4b33ab2f9baa6be68cf635919f485289ce44c</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:42</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:29</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></table></figure>

<p>但应该注意的是真正的主从配置应该在配置文件中（redis.conf）配置，这样的话就是永久的，我们这里使用的是命令，暂时的。</p>
<blockquote>
<p><font color='red'>细节：</font></p>
<ol>
<li>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存。</li>
<li>当主机宕机后，如果对应的的rdb文件（dump6379.rdb）被移除掉，则主机中的原有数据就都丢失了，没有重新连接的话，从机中原有的数据仍然可用且存在。这时如果再重新连接后，则从机中原有的那部分数据也会丢失（从机中的数据都是来源于主机，所以连接后，只会和主机中的数据一样多）</li>
<li>在主机可用的情况下，如果从机宕机了，这个从机就又变回主机了，所以如果没有重新配置从机（6380这个，即让6380成为6379的从机），此时6380的机子就只有宕机前6379主机的数据，之后主机写入的内容从机（6380）是没有的，但是如果6380经过命令或者配置文件成为6379的从机后，就又拥有了主机6379的全部数据了。</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">主机6379</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; shutdown		#主机宕机后，从机仍然可用，即可以读数据</span><br><span class="line">not connected&gt; exit</span><br><span class="line"></span><br><span class="line">[root@study bin]# redis-server redis79.conf		#主机重新连接回来后，从机就又可以从主机中获取到信息</span><br><span class="line">[root@study bin]# redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=14,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=14,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:c80ec71109519c7d9313d32f3f6e39dec8b99b9f</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:14</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:14</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从机6380</span></span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从机6381</span></span><br><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">127.0.0.1:6381&gt; set k2 v2</span><br><span class="line">(error) READONLY You can&#x27;t write against a read only replica.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复制原理：</p>
<ul>
<li>slave启动成功连接到master后会发送一个sync同步命令，</li>
<li>master接到命令，启动后台的存盘进程，同时收集所有接受到的用于修改数据的命令，在后台进程执行完毕之后，<font color='red'>master将传送整个数据文件到slave，并完成一次完全同步</font></li>
<li><font color='red'>全量复制</font>：而slave服务器在接受到数据库文件数据后，将其存盘并加载到内存中</li>
<li><font color='red'>增量复制</font>：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接到master,一次完全同步（全量复制）将会自动执行</li>
</ul>
</blockquote>
<blockquote>
<p>注意：这里面从机作为另一个从机形式上的主机（说是形式上，是因为这个从机仍然不能进行写数据），所以它的角色仍然是从节点（slave）</p>
<p>如6379是主机，连接一个从机6380，这个从机又连接另一个从机6381.。这种方式也可以完成主从复制。</p>
</blockquote>
<blockquote>
<ul>
<li><p>如果主机宕机了，从机可以通过执行命令成为主机.其他节点就可以手动连接到这个新主机了（手动的，哨兵模式是自主的）</p>
<ul>
<li><p>127.0.0.1:6380&gt; slaveof no one</p>
<p>OK</p>
</li>
</ul>
</li>
<li><p>如果这个时候原有的主机重新回来了，也只能重新配置主从机才可以。</p>
</li>
</ul>
</blockquote>
<h2 id="12-哨兵模式"><a href="#12-哨兵模式" class="headerlink" title="12. 哨兵模式"></a>12. 哨兵模式</h2><p>(自主选举老大(主机)的模式)</p>
<blockquote>
<p>概述:</p>
<ul>
<li>主从切换技术的方法是:当主服务器宕机后,需要手动把一台从服务器切换为主服务器,这就需要人工干预,费时费力,还会造成一段时间内服务不可用,这不是一种推荐的方式,更多时候,我们优先考虑哨兵模式,Redis从2.8开始正式提供了Sentinel(哨兵)架构来解决这个问题</li>
<li>前面手动切换的自动版,能够后台自主监控主机是否故障,如果故障了根据投票数自动将从库转为主库</li>
<li><font color='red'>哨兵模式是一种特殊的模式,首先Redis提供了哨兵的命令,哨兵是一个单独的进程,作为进程,它会独立运行,其原理是哨兵通过发送命令,等待Redis服务器响应,从而监控运行的多个Redis实例</font></li>
<li>哨兵进程需要单独开启,就是redis-sentinel,一般情况下,也会配置多个哨兵,防止一个哨兵宕机了导致不可用.</li>
<li>假设主服务器宕机,哨兵1先检测到这个结果,系统并不会马上进行failover过程,仅仅是哨兵1主观的认为主服务器不可用,,这个现象称为<font color='red'>主观下线</font>,当后面的哨兵也检测到主服务器不可用的时候,并且数量达到一定值时,那么哨兵之间就会进行一次投票(这里的投票是指哨兵赞成某一从服务器转化为主服务器,就给他投票),投票的结果由一个哨兵发起,进行<font color='red'>failover故障转移操作</font>,切换成功后,就会通过发布订阅模式,让各个哨兵把自己监控的从服务器实现切换主机,这个过程称为<font color='red'>客观下线</font>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>测试:(目前的状态是一主二从)<ol>
<li>新建并配置一个哨兵配置文件<ol>
<li>[root@study bin]# vim sentinel.conf</li>
<li>配置文件中的内容:      sentinel monitor myredis 127.0.0.1 6379 1</li>
</ol>
</li>
<li>启动哨兵<ol>
<li>[root@study bin]# redis-sentinel sentinel.conf</li>
</ol>
</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sentinel monitor 被监控的名称 host port 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后面这个数字1,代表主机挂了,slave投票看让谁接替成为主机,投票最多的,就会成为主机</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果Master节点断开了，这个时候就会从从机中随机选择一个服务器进行投票！（这里面有一个投票算法）</p>
<ul>
<li>当主机宕机或者断开后，选出一个从机成为主机后，原来其他的从机就也会选择这个新主机成为主机，并且宕机或者断开的那个主机也是会被配置为这个新主机的从机</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>哨兵模式优点：</p>
<ol>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有。</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加高级</li>
</ol>
</li>
<li><p>哨兵模式缺点：</p>
<ol>
<li>Redis不好在线扩容的，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="13-Redis缓存穿透和雪崩（面试高频，工作常用）"><a href="#13-Redis缓存穿透和雪崩（面试高频，工作常用）" class="headerlink" title="13.Redis缓存穿透和雪崩（面试高频，工作常用）"></a>13.Redis缓存穿透和雪崩（面试高频，工作常用）</h2><blockquote>
<p>这三个都涉及到服务的高可用问题</p>
</blockquote>
<h3 id="1-缓存穿透-根源-是因为查不到"><a href="#1-缓存穿透-根源-是因为查不到" class="headerlink" title="1.缓存穿透(根源:是因为查不到)"></a>1.缓存穿透(根源:是因为查不到)</h3><blockquote>
<ul>
<li><p>概念：</p>
<p>缓存穿透的概念很简单，用户想要查询一个数据，发现Redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库（如MySql）查询，发现也没有，于是本次查询失败，当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<ul>
<li><p>解决方案：</p>
<p><font color='red'>布隆过滤器</font>：布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力</p>
<p><font color='red'>缓存空对象</font>：当存储层不命中后，即使返回的是空对象也将其缓存起来，同时设置一个过期时间，之后再访问这个数据的时候就会从缓存中获取，保护了后端数据源.但是这个方法存在两个问题:</p>
<ol>
<li>如果空值能够被存储起来,这就意味着需要更多的空间存储更多的键,因为这当中可能会有很多的空值的键</li>
<li>即使对空值设置了过期时间,还是会存在缓存层和存储层的数据会有一段时间窗口的不一致,这对于需要保持一致性的业务会有影响.</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>						</p>
</blockquote>
<h3 id="2-缓存击穿-根源-是因为查询过多-缓存过期"><a href="#2-缓存击穿-根源-是因为查询过多-缓存过期" class="headerlink" title="2.缓存击穿(根源:是因为查询过多,缓存过期)"></a>2.缓存击穿(根源:是因为查询过多,缓存过期)</h3><blockquote>
<ul>
<li><p>概念:</p>
<p>这里需要注意和缓存击穿的区别,缓存击穿,是指一个key非常热点,在不停的扛着高并发,大并发集中对这一个点进行访问,当这个key在失效的瞬间,持续的大并发就穿透缓存,就像在一个屏幕上凿开了一个洞.</p>
<p>当某个key在过期的瞬间,有大量的请求并发访问,这类数据一般是热点数据,由于缓存过期,会同时访问数据库来查询最新数据,并且同时回写缓存,会导致数据库瞬间压力过大.</p>
</li>
<li><p>解决方案:</p>
<ul>
<li><p><font color='red'>设置热点数据永不过期,</font>从缓存层面来看,没有设置过期时间,所以不会出现热点key过期后产生的问题</p>
</li>
<li><p><font color='red'>加互斥锁</font>.分布式锁,使用分布式锁,保证对于每个key同时只有一个线程去查询后端服务,其他线程没有获得分布式锁的权限,因此只需要等待即可,这种方式将高并发的压力转移到了分布式锁,因此对分布式锁的考研很大.</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h3><blockquote>
<ul>
<li><p>概念:</p>
<p>缓存雪崩,是指在某一个时间段,缓存集中过期失效&#x2F;Redis宕机</p>
<p>产生雪崩的原因之一,比如在写文本的时候,马上就要到双十二零点,很快就会迎来一波抢购,这波商品时间比较集中的放入了缓存,假设缓存了一个小时,那么到了凌晨一点的时候,这批商品的缓存就都过期了,而对这批商品的访问查询,都落到了数据库上,对于数据库而言,就会产生周期性的压力波峰,于是所有的请求都会到达存储层,存储层的调用量会暴增,造成存储层也会挂掉的情况</p>
<p>其实集中过期,倒不是非常致命,比较致命的缓存雪崩是由于缓存服务器某个节点宕机或断网,因为自然形成的缓存雪崩,一定是在某个事件段集中创建缓存,这个时候,数据库也是可以顶住压力的,无非是对数据库产生周期性的压力而已.而缓存服务器节点的宕机,对数据库服务器造成的压力是不可预知的,很有可能瞬间就把数据库压垮.</p>
</li>
<li><p>解决方案:</p>
<ul>
<li>redis高可用:这个思想的含义就是,既然一台redis有可能断掉,那我多增设几台redis,这样一台挂掉之后其他的还可以继续工作,其实就是搭建的集群(异地多活.)</li>
<li>限流降级:思想就是在缓存失效后,通过加锁或者队列来控制数据库写缓存的线程数量,比如对某个key,只允许一个线程查询数据和写缓存,其他线程等待.</li>
<li>数据预热:数据加热的含义就是在正式部署之前,我先把可能的数据预先访问一遍,这样部分可能大量访问的数据就会加载到缓存中,在即将发生大并发访问前手动触发加载不同的key,设置不同的过期时间,让缓存失效的时间尽量均匀.</li>
</ul>
</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/10/27/Redis%E7%AC%94%E8%AE%B0/" data-id="clrv2tqxj00094hku0vh2cmi8" data-title="Redis学习" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java编程思想笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/27/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-08-26T16:00:00.000Z" itemprop="datePublished">2022-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/27/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/">Java编程思想</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java编程思想笔记"><a href="#Java编程思想笔记" class="headerlink" title="Java编程思想笔记"></a>Java编程思想笔记</h1><h2 id="第一章：对象导论"><a href="#第一章：对象导论" class="headerlink" title="第一章：对象导论"></a>第一章：对象导论</h2><h3 id="1-2-每个对象都有一个接口"><a href="#1-2-每个对象都有一个接口" class="headerlink" title="1.2 每个对象都有一个接口"></a>1.2 每个对象都有一个接口</h3><blockquote>
<ul>
<li>类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类就是一个数据类型。如所有浮点型数字具有相同的特性和行为集合。而程序员是通过定义类来适应问题，如定义Person类。</li>
<li>每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。接口包含了一些操作请求（方法），接口确定了对某一特定对象所能发出的请求</li>
</ul>
</blockquote>
<h3 id="1-4-被隐藏的具体实现"><a href="#1-4-被隐藏的具体实现" class="headerlink" title="1.4 被隐藏的具体实现"></a>1.4 被隐藏的具体实现</h3><blockquote>
<ul>
<li>访问控制的存在原因：<ol>
<li>让客户端程序员无法触及他们不应该触及的内容</li>
<li>允许类库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="1-5-复用具体实现"><a href="#1-5-复用具体实现" class="headerlink" title="1.5 复用具体实现"></a>1.5 复用具体实现</h3><blockquote>
<ul>
<li>&#x3D;&#x3D;组合（has a）&#x3D;&#x3D;：使用现有的类合成新类，如果组合是动态发生的，那么它通常被称为聚合。组合经常被视为“has a”(拥有)关系，如汽车拥有引擎一样</li>
</ul>
<p>注意：在创建新类时，应该首先考虑组合</p>
</blockquote>
<h3 id="1-6-继承（is-a）"><a href="#1-6-继承（is-a）" class="headerlink" title="1.6 继承（is a）"></a>1.6 继承（is a）</h3><blockquote>
<ul>
<li>虽然继承有时意味着在子类中添加新方法（Java中以extends表示继承），但并非总是如此，其中有一种使父类（基类、超类）和子类（导出类）之间产生差异的重要方式就是改变现有父类的方法的行为，这被称之为覆盖（overriding）</li>
<li>&#x3D;&#x3D;继承（is a）&#x3D;&#x3D;:如圆形是一个几何图形。经理是一个员工</li>
</ul>
</blockquote>
<h3 id="1-7-伴随多态的可互换对象"><a href="#1-7-伴随多态的可互换对象" class="headerlink" title="1.7 伴随多态的可互换对象"></a>1.7 伴随多态的可互换对象</h3><blockquote>
<ul>
<li>在Java中，使用动态绑定，不需要添加额外的关键字来实现多态。面向对象语言是采用<strong>后期绑定</strong>，被调用的代码只有直到运行的时候才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查，但是并不知道被执行的确切代码。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape类中有基类方法erase(),draw()</span></span><br><span class="line"><span class="comment">//Circle类，Square类继承了Shape类，并且重写了erase(),draw()方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape erase &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape erase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;circle erase &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle erase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square draw &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Square erase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Shape shape=<span class="keyword">new</span> <span class="title class_">Shape</span>();</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        Test t=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">//编译器在进行编译的时候，会判断传入的类型是否是Shape类或者是Shape类的子类,如果不是会直接报错</span></span><br><span class="line">        t.doSomething(shape);</span><br><span class="line">        <span class="comment">//运行的时候会判断该子类中是否复写了该方法，如果有就执行子类中的方法，如果没有就执行父类中的该方法</span></span><br><span class="line">        t.doSomething(circle);</span><br><span class="line">        t.doSomething(square);</span><br><span class="line">        <span class="comment">//注意：运行的时候，虽然执行的是子类中的方法，但是doSomething中的a仍然是使用的父类中的a</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">        <span class="comment">//编译器在这里会判断Shape类中是否有这样的方法，如果没有直接编译失败。</span></span><br><span class="line">        <span class="comment">//这里并不用确定这里要执行的具体代码是什么。运行时看子类中是否有这个方法，如果有就执行子类的</span></span><br><span class="line">        shape.erase();</span><br><span class="line">        shape.draw();</span><br><span class="line">        <span class="comment">//编译器会检查Shape类中是否有这样的字段,运行的时候看的就是父类中该字段</span></span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething &quot;</span>+shape.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Shape erase <span class="number">10</span></span><br><span class="line">Shape erase</span><br><span class="line">Shape draw</span><br><span class="line">doSomething <span class="number">10</span></span><br><span class="line">circle erase <span class="number">5</span></span><br><span class="line">Circle erase</span><br><span class="line">Circle draw</span><br><span class="line">doSomething <span class="number">10</span></span><br><span class="line">Square draw <span class="number">20</span></span><br><span class="line">Square erase</span><br><span class="line">Square draw</span><br><span class="line">doSomething <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8单根继承结构"><a href="#1-8单根继承结构" class="headerlink" title="1.8单根继承结构"></a>1.8单根继承结构</h3><blockquote>
<p>Java中所有的对象都继承自Object类。这样可以使垃圾回收器的实现变得容易得多，并且异常处理时也会容易很多。</p>
</blockquote>
<h3 id="1-9-容器"><a href="#1-9-容器" class="headerlink" title="1.9 容器"></a>1.9 容器</h3><blockquote>
<ul>
<li><p>容器：</p>
<ol>
<li>List</li>
<li>Set</li>
<li>Map</li>
<li>队列、栈、树等</li>
</ol>
</li>
<li><p><strong>参数化类型机制</strong>：在创建容器时，知道自己所保存的对象的类型，从而不需要向下转型以及消除错误的可能。</p>
</li>
<li><p>参数化类型就是一个编译器可以自动定制作用于特定类型上的类。</p>
</li>
<li><p>在Java中这个成为泛型。一对尖括号，中间包含类型的信息。如 ArrayList<Integer></p>
</li>
</ul>
</blockquote>
<h3 id="1-10-对象的创建和生命期"><a href="#1-10-对象的创建和生命期" class="headerlink" title="1.10 对象的创建和生命期"></a>1.10 对象的创建和生命期</h3><blockquote>
<ul>
<li>Java采用了<strong>动态内存</strong>分配。这样牺牲了一定的执行速度，但是带来了更大的灵活性。是在被称为<strong>堆</strong>的内存池中动态创建对象。对对象的声明周期一无所知，但是Java的垃圾回收机制可以自动发现不使用的对象并进行销毁。</li>
<li>c++是采用了在堆栈或静态存储期中创建对象。可以确定对象存活的时间，并且程序员自己可以去销毁它。但可能因为不正确处理带来内存泄漏。</li>
</ul>
</blockquote>
<h2 id="第二章：一切都是对象"><a href="#第二章：一切都是对象" class="headerlink" title="第二章：一切都是对象"></a>第二章：一切都是对象</h2><h3 id="2-1-用引用操作对象"><a href="#2-1-用引用操作对象" class="headerlink" title="2.1 用引用操作对象"></a>2.1 用引用操作对象</h3><blockquote>
<ul>
<li><p>引用：操作对象的标识符。可以拥有一个引用而不一定需要有一个对象与它关联。如String s;</p>
<p>其中s就是一个引用，而没有一个对象来与它关联。</p>
</li>
</ul>
</blockquote>
<h3 id="2-2-必须由你创建所有对象"><a href="#2-2-必须由你创建所有对象" class="headerlink" title="2.2 必须由你创建所有对象"></a>2.2 必须由你创建所有对象</h3><blockquote>
<p>程序运行时，对象是怎样进行放置安排的？特别是内存怎样分配的呢？</p>
<ul>
<li>寄存器：这是最快的存储区，不同于其他的存储区所在的位置，它位于存储器内部。寄存器数量有限。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（c++和c允许向变量一起建议寄存器的分配方式）</li>
<li>堆栈：位于通用RAM(随机访问存储器)中，但通过堆栈指针可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存，若向上移动，则释放那些内存。这是一种快速有效的分配存储的方法，仅次于寄存器。创建程序时，<strong>Java必须知道存储在堆栈内所有项的确切生命周期，以便上下移动指针</strong>。这限制了程序的灵活性。所以虽然<strong>某些Java数据存储于堆栈中——特别是对象引用，但是Java对象并不存于其中</strong>。</li>
<li>堆：<strong>一种通用的内存池（也位于RAM区），用于存放所有的Java对象</strong>。堆不同于堆栈的<strong>好处是：编译器不需要知道存储的数据在堆里存活多长时间</strong>。因此在堆里分配存储具有很大的灵活性。但同时也要付出一定的代价：用堆进行存储分配和清理可能要比用堆栈进行存储分配需要更多的时间。</li>
<li>常量存储：常量值通常直接存放在程序代码内部，有时在嵌入式系统中，常量本身会和其他部分隔离开，所以可以选择将其放在ROM（只读存储器）中。<strong>其中一个例子就是字符串池</strong>。所有字面常量字符串和具有字符串值得常量表达式都自动是内存限定得，并且会置于特殊得静态存储区中。</li>
<li>非RAM存储：<strong>如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子就是流对象和持久化对象。</strong>流对象中，对象被转化成字节流，通常发送给另一台机器。持久化对象中，对象存储与磁盘上。这种存储方式得技巧在于：把对象转化成可以存放在其他媒介上得事物，在需要时，可恢复成常规的，基于RAM的对象。Java提供了对轻量级持久化的支持，而诸如JDBC和Hibernate这样的机制提供了更加复杂的堆在数据库中存储和读取对象信息的支持。</li>
<li><strong>特例</strong>：基本类型。因为new是将对象存储在“堆”。<strong>对于基本类型，Java不用new来创建边练，而是创建一个并非是引用的“自动变量”。这个变量直接存储值，存储于堆栈中。</strong></li>
<li><strong>基本类型具有的包装器，使得可以在<font color='red'>堆中</font>创建一个非基本对象，用来表示对应的基本类型</strong>。</li>
<li>BigInteger和BigDecimal是两个高精度计算的类，没有对应的基本类型。</li>
</ul>
</blockquote>
<h3 id="2-4-创建新的数据类型：类"><a href="#2-4-创建新的数据类型：类" class="headerlink" title="2.4 创建新的数据类型：类"></a>2.4 创建新的数据类型：类</h3><blockquote>
<ul>
<li>类中可以设置两种类型的元素：字段（有时被称作数据成员）和方法（有时被称作成员函数）</li>
<li>类中的数据成员即使没有进行初始化，Java也会确保它获得一个默认值，即默认初始化。</li>
<li>但是如果是方法中的某个局部变量（即并非某个类的字段），并不会进行默认初始化，因此在使用前必须及进行初始化。（使用的话，会编译出错）</li>
</ul>
</blockquote>
<h3 id="2-5-方法、参数和返回值"><a href="#2-5-方法、参数和返回值" class="headerlink" title="2.5 方法、参数和返回值"></a>2.5 方法、参数和返回值</h3><blockquote>
<ul>
<li>int x&#x3D;a.f();    解释：调用方法的行为通常被称为发送消息给对象。在上面的例子中，消息是f(),对象是a。面向对象的程序设计通常简单地归纳为“向对象发送信息”</li>
<li>Java中任何传递对象的场合一样，传递的实际上也是引用，尽管传递的是对象，实际上传递的是对象的引用。</li>
</ul>
</blockquote>
<h3 id="2-6-构建一个Java程序"><a href="#2-6-构建一个Java程序" class="headerlink" title="2.6 构建一个Java程序"></a>2.6 构建一个Java程序</h3><blockquote>
<ul>
<li><font color='red'>static：使用的两种情形</font><ol>
<li>只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任和对象。</li>
<li>希望某个方法不与包含它的类的任何对象关联在一起。即即使没有创建对象，也能够调用这个方法。</li>
</ol>
</li>
<li>当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象关联在一起。所以**<font color='red'>即使从未创建某个类的任何对象，也可以调用其非static方法或者访问其static域。</font>**</li>
<li>通常，必须创建一个对象，并用它来访问数据或方法。因为非static域和方阿飞必须知道他们一起运作的特定对象。</li>
<li><strong>由于在用static 方法前不需要创建任何对象，所以对于static方法，不能简单的通过调用其他非static域或方法而没有指定某个命名对象，来直接访问非static域或方法（因为非static域或方法必须与某一特定对象关联）</strong></li>
<li>访问静态成员两种方式：<ol>
<li>通过类名来进行访问（这对于非静态成员就不行）</li>
<li>通过对象名来进行访问</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTest</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在即使创建了两个StaticTest对象，StaticTest.i也只有一份存储空间，这两个对象共享同一个i.非静态成员则是对每个对象有一个存储空间</span></span><br></pre></td></tr></table></figure>

<h2 id="第三章：操作符"><a href="#第三章：操作符" class="headerlink" title="第三章：操作符"></a>第三章：操作符</h2><h2 id="第四章：控制执行流程"><a href="#第四章：控制执行流程" class="headerlink" title="第四章：控制执行流程"></a>第四章：控制执行流程</h2><blockquote>
<p><font color='red'>switch用法</font></p>
<p>当switch后面的括号中如果是浮点数的话：会报错</p>
<p>Incompatible types. Found: ‘double’, required: ‘<font color='red'>char, byte, short, int, Character, Byte, Short, Integer, String, or an enum’</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (a)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当a为4时输出结果</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//当a为2时输出结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="第五章：初始化与清理"><a href="#第五章：初始化与清理" class="headerlink" title="第五章：初始化与清理"></a>第五章：初始化与清理</h2><h3 id="5-2-方法重载"><a href="#5-2-方法重载" class="headerlink" title="5.2 方法重载"></a>5.2 方法重载</h3><blockquote>
<ul>
<li>方法重载：这个针对的是在一个类里面，对具有相同方法名的方法，但是参数类型或个数不同的重载。（构造器也是，类名相同，里面的形式参数不同），值得注意的是参数的顺序不同也可以是一种重载</li>
<li>方法重写：是指在子类继承父类时，对父类中的方法进行重写。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>设计到基本数据类型的重载的时候<ol>
<li>如常数5作为int值传入的时候，如果有某个重载的方法接受int型参数，它就会被调用。</li>
<li>至于其他情况，如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。如int类型的实际参数类型，就会被提升至long,float,double。<font color='red'>byte类型就会被提升为short,int,long。</font></li>
<li>char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升为int型，long,float,double.</li>
<li>如果传入的实际参数大于重载方法的形式参数的话，就必须通过一个类型转换进行强转，否则编译器会报错。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="5-4-this关键字"><a href="#5-4-this关键字" class="headerlink" title="5.4 this关键字"></a>5.4 this关键字</h3><blockquote>
<ul>
<li>当希望在方法的内部获得对当前对象的引用，就可以使用this关键字。</li>
<li><font color='red'>this关键字</font>：只能在方法的内部使用，<font color='red'>表示对“调用方法的那个对象”的引用</font>。<ul>
<li>this关键字对于将当前对象传递给其他方法也很有用</li>
<li>在构造器中调用构造器（在一个构造器中调用另一个构造器），以避免重复代码<ul>
<li>一般情况下，this都是指这个对象或者当前对象。如果为this添加了参数列表，就有了不同的含义，这将产生对符合此参数列表的某个构造器的明确调用。如this(6,”hello”)。</li>
<li><font color='red'>在使用this调用构造器的时候，不能调用两次，并且调用的时候，必须将构造器调用置于最起始处（第一行），这也证实了this调用构造器语句必须在第一行，否则编译器会报错。</font></li>
<li>值得注意的是，只能在构造器方法体里面才能够调用另外一个构造器方法。在任何方法之外调用都会报错。Call to ‘this()’ must be first statement <font color='red'>in constructor body</font></li>
</ul>
</li>
<li>也可以使用this.s&#x3D;s来代表数据成员，避免与方法或者构造器中的变量产生歧义。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>static关键字</font>：static（静态）方法就是没有this的方法。在static方法的内部不能调用非静态方法，反过来是可以的（即在非静态方法中可以调用静态方法），在static方法内部，可以调用static域和static方法。static方法有时候又被称为<font color='red'>类方法</font>。</li>
</ul>
</blockquote>
<h3 id="5-5-清理：终结处理和垃圾回收"><a href="#5-5-清理：终结处理和垃圾回收" class="headerlink" title="5.5 清理：终结处理和垃圾回收"></a>5.5 清理：终结处理和垃圾回收</h3><blockquote>
<ul>
<li>Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：<font color='red'>假定你的对象（并非使用new）获得了一块特殊的内存区域。因为垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块特殊内存</font>。因此，为了应对这种情况，Java允许在类中定义一个finalize（）方法。</li>
<li><font color='red'>finalize()的工作原理</font>：<font color='red'>一旦垃圾回收器准备好释放占用的存储空间，将首先调用其finalize()方法</font>，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存</li>
<li>应该注意的以下几点：<ol>
<li>对象可能不被垃圾回收</li>
<li>垃圾回收并不等于“析构”</li>
<li>垃圾回收至于内存有关（使用垃圾回收器的唯一原因是为了回收程序不再使用的内存）</li>
</ol>
</li>
<li><font color='red'>finalize()函数的用途：</font><ul>
<li>注意：无论对象是如何创建的，垃圾回收器都会负责释放对象占据所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。（这种特殊情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式，本地方法目前只支持c和c++,如在非Java代码中，也许会调用到C的malloc()函数系列来分配存储空间，而且除了使用free()函数，否则存储空间永远将得不到释放，从而造成内存泄漏，free()是c和c++中的函数，所以需要在finalize()中用本地方法调用它）。但是要尽量避免使用finalize()函数</li>
<li>finalize()函数还可以作为终结条件验证</li>
</ul>
</li>
<li>特别注意的是：<font color='red'>无论是“垃圾回收”还是“终结（finalize）”,都不保证一定会发生，如果Java虚拟机并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以回复内存的。</font>因为finalize函数是发生在要进行垃圾回收之前执行。而垃圾回收是只有在内存濒临消耗完或者退出程序的时候才会被调用，所以也有可能不会执行。</li>
<li>System.gc()函数：用于强制进行垃圾回收和终结动作。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: initialization/TerminationCondition.java</span></span><br><span class="line"><span class="comment">// Using finalize() to detect an object that</span></span><br><span class="line"><span class="comment">// hasn&#x27;t been properly cleaned up.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">checkedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  Book(<span class="type">boolean</span> checkOut) &#123;</span><br><span class="line">    checkedOut = checkOut;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">checkIn</span><span class="params">()</span> &#123;</span><br><span class="line">    checkedOut = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//对于对终结条件的验证</span></span><br><span class="line">    <span class="keyword">if</span>(checkedOut)</span><br><span class="line">      System.out.println(<span class="string">&quot;Error: checked out&quot;</span>);</span><br><span class="line">    <span class="comment">// Normally, you&#x27;ll also do this:</span></span><br><span class="line">    <span class="comment">// super.finalize(); // Call the base-class version</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminationCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">novel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// Proper cleanup:</span></span><br><span class="line">    novel.checkIn();</span><br><span class="line">    <span class="comment">// Drop the reference, forget to clean up:</span></span><br><span class="line">    <span class="comment">//只有在没有具体声明对象的引用的时候，执行Sytem.gc()才会执行finalize()里面的方法</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// Force garbage collection &amp; finalization:</span></span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Error: checked out</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>垃圾回收机制的工作原理：<ul>
<li>其他系统中是采用引用计数的方式（计数值变为0时就释放对象）</li>
<li>在Java中是采用是更快的模式，依据这样的思想：对任何“活的对象”，一定能够追溯到其存活在堆栈或静态存储区之中的引用。由此，先在堆栈或静态存储区遍历引用，对于发现的每个引用，追踪它所引用的对象，然后是此对象的所有引用，如此反复就解决了对象自引用的问题。</li>
<li>Java虚拟机采用自适应的方式。找到活的对象的方式基于不同的虚拟机有不同方式：<ol>
<li>停止-复制。这个对于需要清理的对象（垃圾）很少的时候，就很浪费，因为复制式回收器仍然会将内存从一处复制到另一处。</li>
<li>标记-清扫。这里面不会发生复制动作，会先给对象进行标记，没有标记的对象就会被清理掉。适用于垃圾较少的情况。</li>
<li>上面这两种方式都会暂停运行程序。</li>
<li>Java虚拟机会进行监视，从而在上面这两种方式之间进行一个切换，所以称之为自适应技术。</li>
</ol>
</li>
<li>Java中还有很多附加技术用以提升速度。如即时编译器(JIT——just in time)，将程序全部或部分翻译成本地机器码，提高程序运行速度。<ol>
<li>一种方式是让即时编译器编译所有代码。存在的问题是这种加载动作会散落在整个程序生命周期，比较耗时，同时会增加可执行代码的长度（字节码文件要比即时编译器展开后的本地机器码小很多）。</li>
<li>一种方式是惰性评估。即时编译器只有在必要的时候才编译代码。从不会执行的代码压根不会被JIT所编译，其中Java HotSpot技术就采用了类似方法。代码每次被执行的时侯都会做一些优化，执行的次数越多速度也越快。</li>
</ol>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-7-构造器初始化"><a href="#5-7-构造器初始化" class="headerlink" title="5.7 构造器初始化"></a>5.7 构造器初始化</h3><blockquote>
<p>可以用构造器来进行初始化，但是这无法组织自动初始化（默认初始化）的进行，这个将在构造器被调用之前就发生了。如下面的内容，i首先会被置为0，再然后变成7.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    Test()&#123;i=<span class="number">7</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>初始化顺序</font><font color='red'>:</font></p>
<ul>
<li>在类的内部，成员变量的先后顺序决定了初始化的顺序。即使变量定义散布于成员方法之间，他们仍旧会在任何方法（包括构造器,也包括静态static方法）被调用之前得到初始化。</li>
<li>静态数据的初始化：<font color='red'>静态数据都只占用一份内存区域，static关键字不能应用于局部变量、类上，因此它只能作用于成员变量或成员方法</font>。</li>
<li><font color='red'>静态初始化只有在必要时刻才会进行</font>。如下面的如果不创建Table对象，也不引用Table.b1或Table.b2，那么静态的Bowl b1和b2用于都不会创建。<font color='red'>只有第一个Table对象创建（或者第一次访问静态数据）的时候，它们才会被初始化。此后静态对象不会再次被初始化</font>。而<font color='red'>非静态成员变量，每创建一个对象就都会被初始化一次</font>。如Cupboard类中的Bowl成员变量，每次new Cupboard()时，都会进行一次初始化。</li>
<li>初始化的顺序是<font color='red'>先静态对象</font>（前提是他们尚未因前面的对象创建而被初始化），<font color='red'>而后是非静态对象</font>。即便是在含有静态的main（）方法的类中也是如此。</li>
<li>其实构造器方法在某种意义上可以看成是静态方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bowl</span> &#123;</span><br><span class="line">  Bowl(<span class="type">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">&quot;Bowl(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">1</span>);</span><br><span class="line">  Table() &#123;</span><br><span class="line">    print(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">    bowl2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cupboard</span> &#123;</span><br><span class="line">  <span class="type">Bowl</span> <span class="variable">bowl3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">4</span>);</span><br><span class="line">  Cupboard() &#123;</span><br><span class="line">    print(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">    bowl4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInitialization</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Cupboard</span> <span class="variable">cupboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Bowl(1)</span></span><br><span class="line"><span class="comment">Bowl(2)</span></span><br><span class="line"><span class="comment">Table()</span></span><br><span class="line"><span class="comment">f1(1)</span></span><br><span class="line"><span class="comment">Bowl(4)</span></span><br><span class="line"><span class="comment">Bowl(5)</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">f2(1)</span></span><br><span class="line"><span class="comment">f3(1)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>显式的静态初始化：</font></p>
<ul>
<li>Java允许将多个静态初始化动作组织成一个特殊的“静态子句”（有时也叫静态代码块），这与其他静态初始化动作一样，这段代码只执行一次：当首次生成这个类的对象的时候，或者首次访问属于那个类的静态数据成员时（即便从未生成那个类的对象）</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spoon</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i=<span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cup</span> &#123;</span><br><span class="line">    Cup(<span class="type">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cup(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cups</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Cup cup1=<span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">        cup1 = <span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">1</span>);</span><br><span class="line">        cup2 = <span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">2</span>);  <span class="comment">//这个不会出现异常</span></span><br><span class="line">        <span class="comment">//下面这个会引起非法向前引用的编译异常</span></span><br><span class="line"><span class="comment">//        System.out.println(cup2);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Cup cup2=<span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">4</span>);</span><br><span class="line">    Cups() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cups()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExplicitStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        Cups.cup1.f(<span class="number">99</span>);  <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//static Cups cups1 = new Cups();  // (2)</span></span><br><span class="line">    <span class="comment">// static Cups cups2 = new Cups();  // (2)</span></span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Inside main()</span></span><br><span class="line"><span class="comment">Cup(3)</span></span><br><span class="line"><span class="comment">静态代码块</span></span><br><span class="line"><span class="comment">Cup(1)</span></span><br><span class="line"><span class="comment">Cup(2)</span></span><br><span class="line"><span class="comment">Cup(4)</span></span><br><span class="line"><span class="comment">f(99)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>非静态实例初始化：</p>
<ul>
<li>实例初始化子句是在构造器函数执行之前进行的。</li>
</ul>
</blockquote>
<h3 id="5-8-数组初始化"><a href="#5-8-数组初始化" class="headerlink" title="5.8 数组初始化"></a>5.8 数组初始化</h3><blockquote>
<p>如果是基本类型数组，在创建数组的时候，基本数据类型值会自动初始化成空值。</p>
<p>如：int[] arr&#x3D;new int[20];</p>
<p>​		System.out.print(arr);	&#x2F;&#x2F;输出0</p>
</blockquote>
<blockquote>
<p>如果创建了一个非基本类型的数组，那么你就创建了一个引用数组。但是这还没有完成初始化的工作。必须直到创建新的Integer对象，并把对象赋值给引用，初始化进程才算结束。</p>
<p>如：Integer[] arr&#x3D;new Integer[20];</p>
<p>​		System.out.print(arr[0]);	&#x2F;&#x2F;输出null</p>
<p>​		arr[0]&#x3D;12;     &#x2F;&#x2F;通过自动包装机制创建的</p>
</blockquote>
<h3 id="5-9-枚举类型（enum）"><a href="#5-9-枚举类型（enum）" class="headerlink" title="5.9 枚举类型（enum）"></a>5.9 枚举类型（enum）</h3><blockquote>
<p>如下面适用的形式一样：</p>
<p>在创建enum时，编译器会自动添加一些有用的特性。如</p>
<ol>
<li>创建toString()方法：方便显示某个enum实例的名字</li>
<li>创建ordinal()方法：用来表示某个特定变量的声明顺序</li>
<li>创建了static values()方法：用来按照enum常量的声明顺序，产生由这些常量值构成的数组</li>
</ol>
<ul>
<li>特别值得注意的是，enum有个特别实用的特性，即它可以在switch语句内使用</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Spiciness</span> &#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleEnumUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       	<span class="comment">//注意声明的方式</span></span><br><span class="line">        <span class="type">Spiciness</span> <span class="variable">howHot</span> <span class="operator">=</span> Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">MEDIUM</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Spiciness s : Spiciness.values())</span><br><span class="line">            System.out.println(s + <span class="string">&quot;, ordinal &quot;</span> + s.ordinal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">NOT, ordinal 0</span></span><br><span class="line"><span class="comment">MILD, ordinal 1</span></span><br><span class="line"><span class="comment">MEDIUM, ordinal 2</span></span><br><span class="line"><span class="comment">HOT, ordinal 3</span></span><br><span class="line"><span class="comment">FLAMING, ordinal 4</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在switch语句中使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Burrito</span> &#123;</span><br><span class="line">  Spiciness degree;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Burrito</span><span class="params">(Spiciness degree)</span> &#123; <span class="built_in">this</span>.degree = degree;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">      <span class="keyword">case</span> NOT:    System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> MILD:</span><br><span class="line">      <span class="keyword">case</span> MEDIUM: System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> HOT:</span><br><span class="line">      <span class="keyword">case</span> FLAMING:</span><br><span class="line">      <span class="keyword">default</span>:     System.out.println(<span class="string">&quot;maybe too hot.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Burrito</span></span><br><span class="line">      <span class="variable">plain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.NOT),</span><br><span class="line">      greenChile = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.MEDIUM),</span><br><span class="line">      jalapeno = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.HOT);</span><br><span class="line">    plain.describe();</span><br><span class="line">    greenChile.describe();</span><br><span class="line">    jalapeno.describe();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">This burrito is a little hot.</span></span><br><span class="line"><span class="comment">This burrito is maybe too hot.</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第六章：访问权限控制"><a href="#第六章：访问权限控制" class="headerlink" title="第六章：访问权限控制"></a>第六章：访问权限控制</h2><blockquote>
<ul>
<li><p>访问权限的控制的等级依次为：public、protected、包访问权限（没有关键词）、private</p>
</li>
<li><p>package关键字：将构建类库捆绑到一个内聚的类库单元中。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>控制对成员的访问权限的原因</font>:<ol>
<li>安全,让用户不要触碰到那些他们不应该触碰的部分,简化他们的理解</li>
<li>让类库设计者可以更改类的内部工作方式,而不必担心会对客户端程序员产生重大的影响.接口与实现分离</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="6-1-包：库单元"><a href="#6-1-包：库单元" class="headerlink" title="6.1 包：库单元"></a>6.1 包：库单元</h3><blockquote>
<p>当编写一个Java源代码文件的时候，此文件通常被称为编译单元（或者叫转译单元），每个编译单元都必须有一个后缀名.java。在编译单元内，只允许有一个public类。编译单元中的其他类（指的是没有修饰符的类）主要为主public类提供支持。</p>
<ul>
<li><font color='red'>细节1</font>：类只能被public，或者没有修饰符来修饰。如：<ol>
<li>public class A{}</li>
<li>class B{}</li>
</ol>
</li>
<li><font color='red'>细节2</font>：在对一个编译单元（.java文件）进行编译的时候，<font color='red'>在.java文件中的每一个类都会有一个.class文件</font>。名称都与类名称相同，只是后缀名变为.class文件</li>
</ul>
</blockquote>
<blockquote>
<p>类库实际上是一组类文件，每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字package。</p>
<ul>
<li><font color='red'>细节：如果使用package语句，它必须是文件中除注释以外的第一句程序代码</font>。在文件起始处写。如：<ul>
<li>package access;</li>
</ul>
</li>
</ul>
<p>任何想要使用某个包中的某个类时，有两种选择，即指定全类名或者结合import将该类导入。如：</p>
<ul>
<li>第一种方式：java.util.ArrayList list&#x3D;new java.util.ArrayList();</li>
<li>第二种方式：import java.util.ArrayList;        ArrayList list&#x3D;new ArrayList();</li>
</ul>
</blockquote>
<h3 id="6-2-Java访问权限修饰词"><a href="#6-2-Java访问权限修饰词" class="headerlink" title="6.2 Java访问权限修饰词"></a>6.2 Java访问权限修饰词</h3><h4 id="1-包访问权限"><a href="#1-包访问权限" class="headerlink" title="1. 包访问权限"></a>1. 包访问权限</h4><blockquote>
<ul>
<li><font color='red'>包访问权限可以修饰类，成员变量（域），成员方法，局部变量</font></li>
</ul>
<p>当前包中的所有其他类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。</p>
</blockquote>
<h4 id="2-public：接口访问权限"><a href="#2-public：接口访问权限" class="headerlink" title="2. public：接口访问权限"></a>2. public：接口访问权限</h4><blockquote>
<ul>
<li><font color='red'>public可以修饰类，成员变量，成员方法</font></li>
</ul>
</blockquote>
<h4 id="3-private-你无法访问"><a href="#3-private-你无法访问" class="headerlink" title="3. private:你无法访问"></a>3. private:你无法访问</h4><blockquote>
<ul>
<li>private可以修饰成员变量,成员方法,<font color='red'>注意不能修饰类</font></li>
<li>其中有一个用法就是单例设计模式</li>
<li>还有一个用法是,将成员变量进行私有化,通过提供共有的get&#x2F;set方法来进行修改和获取.</li>
<li><font color='red'>细节:如果基类中只有一个private修饰的构造器方法,那么该类就不允许被其他类继承</font></li>
</ul>
</blockquote>
<h4 id="4-protected-继承访问权限-包含了包访问权限"><a href="#4-protected-继承访问权限-包含了包访问权限" class="headerlink" title="4. protected:继承访问权限(包含了包访问权限)"></a>4. protected:继承访问权限(包含了包访问权限)</h4><blockquote>
<ul>
<li>protected可以修饰成员变量,成员方法,<font color='red'>注意不能修饰类</font></li>
<li>有时,基类的创建者会希望有某个特定成员,把对它的访问权限赋予派生类而不是所有类,这就需要protected来进行完成.</li>
<li><font color='red'>细节:前提是在子类与父类不在一个包中</font>,在派生类(子类)中,可以在子类的构造器方法中通过super()的方式来访问父类中用protected修饰的构造器方法.也可以通过子类的引用(实例对象)来访问父类中用protected修饰的成员变量和成员方法.但是值得注意的是,在子类中,<font color='red'>通过父类的引用</font>(实例对象并不能访问父类中的protected修饰的成员变量和成员方法.但是也不能直接使用父类的protected构造器方法,而是需要用super关键字</li>
<li>细节:如果子类和父类都在一个包中,则可以直接使用父类的protected构造器方法,也可以通过父类的引用访问父类的成员方法和成员变量</li>
</ul>
</blockquote>
<h3 id="6-3-接口和实现"><a href="#6-3-接口和实现" class="headerlink" title="6.3 接口和实现"></a>6.3 接口和实现</h3><blockquote>
<p>访问权限的控制被称为是具体实现的隐藏.把数据和方法包装进类中,以及具体实现的隐藏,常共同被称作是<font color='red'>封装,</font>其结果是一个同时带有特征和行为的数据类型.</p>
</blockquote>
<h3 id="6-4-类的访问权限"><a href="#6-4-类的访问权限" class="headerlink" title="6.4 类的访问权限"></a>6.4 类的访问权限</h3><blockquote>
<p>一个编译单元(.java文件)最多允许有一个主public类,如果有那么这个文件名就必须该主类名.如果没有主public类,都是包访问权限,那么该文件名就可以随意.</p>
</blockquote>
<p>细节:在正常情况下,类只能由public或者包访问权限修饰.但是事实上,内部类可以是由protected或者private进行修饰,这是一个特例.</p>
<blockquote>
<p>如果我们将一个类的构造器方法添加了private修饰符,那么其他类就无法创建该类的对象,但是现在别人可以该怎样使用它呢?</p>
</blockquote>
<p>方式一:通过一个公有方法返回该类的引用,该种方式允许创建多个该类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Soup1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Soup1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//通过一个公有方法返回该类的引用,该种方式允许创建多个该类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Soup1 <span class="title function_">makeSoup</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Soup1</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;方式二:单例设计模式&#x3D;&#x3D;  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Soup2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Soup2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//这里应该注意到的是,其他类只能通过类名调用下面公有的access方法才能获取到对象实例,并不能通过类名调用ps1成员变量来进行访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Soup2 ps1=<span class="keyword">new</span> <span class="title class_">Soup2</span>();</span><br><span class="line">   	<span class="comment">//这里通过提供一个共有方法返回一个私有的静态成员变量,每次调用该方法时,返回的都是同一个实例,因为该实例是一个静态成员,所以共享一份内存空间.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Soup2 <span class="title function_">access</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ps1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第七章：复用类"><a href="#第七章：复用类" class="headerlink" title="第七章：复用类"></a>第七章：复用类</h2><blockquote>
<ul>
<li>组合和继承：<ul>
<li>组合：是在一个新类中把另一个类的对象作为它的数据成员</li>
<li>继承：是新类按照现有的类的类型来进行创建，并添加自己的新代码</li>
<li>这两种方式的混用</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="7-2-继承语法"><a href="#7-2-继承语法" class="headerlink" title="7.2 继承语法"></a>7.2 继承语法</h3><blockquote>
<p>在一个编译单元（.java文件）中，可以有至多一个主public类中，可以有任意个类（包访问权限），并且<font color='red'>每个类中可以有主main方法</font>。所有一个文件中可以有多个main方法。并且这些main（）都可以作为程序主入口，看你选择哪个。即使有多个main(),在进行编译的时候也只有命令行所调用的那个类的main()方法会被调用。其他main()方法可以在被调用的main方法中被调用</p>
</blockquote>
<blockquote>
<p><font color='red'>在子类中，如果对父类中的方法进行了覆盖（overriding），那么要想在子类中访问父类中的这个方法时可以通过super关键字来进行访问，而不能通过子类的引用来进行访问</font>。当然这里也可以直接通过父类的引用来进行调用。Java用super表示超类的意思，当前类就是从超类继承来的。如super.test();</p>
</blockquote>
<blockquote>
<ul>
<li>&#x3D;&#x3D;重点关注&#x3D;&#x3D;：<ol>
<li>在一般情况下，对成员变量的初始化要先与该类中的方法（包括构造器方法）调用，所以这也是为什么先输出第一个示例先输出B(),再输出A()</li>
<li><font color='red'>在继承的情况下，创建子类对象时，会先进行执行子类构造器中的第一行，即调用基类构造器，执行完基类构造器后，再对子类中的成员变量进行初始化，再是子类构造器后面的语句了。</font></li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">###################################################################################</span><br><span class="line">一般情况下（没有继承） :注意输出顺序</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E05_SimpleInheritance</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br><span class="line"></span><br><span class="line">#####################################################################################</span><br><span class="line">在有继承的情况下：注意输出顺序</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="built_in">super</span>();</span><br><span class="line">     System.out.println(<span class="string">&quot;hello C()&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E05_SimpleInheritance</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">hello C()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在子类构造器中，必须要显式或者隐式的调用父类的构造器方法。<ol>
<li>当是显式的时候，就直接使用super()进行调用即可。可以同时传参</li>
<li><font color='red'>当是隐式的时候，则默认就会执行super()去调用父类中的无参构造函数</font>，所以此时父类中必须要有无参构造器，若没有就会报错。</li>
</ol>
</li>
<li>&#x3D;&#x3D;细节：&#x3D;&#x3D;对父类构造器的调用语句（使用super()的方式）只能写在第一行，并且只能调用一次（侧面证实了该语句只能写在第一行）。应该注意到的是，<font color='red'>即便使用了new 父类类名（）的方式，在子类中仍然还是需要使用super的方式进行调用。 </font></li>
</ul>
</blockquote>
<h3 id="7-3-代理（没太弄明白）"><a href="#7-3-代理（没太弄明白）" class="headerlink" title="7.3 代理（没太弄明白）"></a>7.3 代理（没太弄明白）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过不用继承的方式，让代理对象去操作要继承的对象</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;不用代理模式的代码：&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShipControls</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">turboBoost</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShip</span> <span class="keyword">extends</span> <span class="title class_">SpaceShipControls</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SpaceShip</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpaceShip</span> <span class="variable">protector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpaceShip</span>(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;使用代理模式的代码：&#x3D;&#x3D;</p>
<p>​	上面不使用代理模式的问题在于，SpaceshipControls的所有方法在Spaceship中都暴露了出来。而代理模式中就通过代理对象来对SpaceshipControls中的方法进行管理，所以Spaceship就不用对SpaceshipControls进行继承了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShipDelegation</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">SpaceShipControls</span> <span class="variable">controls</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SpaceShipControls</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SpaceShipDelegation</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Delegated methods:</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.back(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.down(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.forward(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.left(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.right(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turboBoost</span><span class="params">()</span> &#123;</span><br><span class="line">    controls.turboBoost();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.up(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpaceShipDelegation</span> <span class="variable">protector</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SpaceShipDelegation</span>(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<h3 id="7-7-向上转型"><a href="#7-7-向上转型" class="headerlink" title="7.7 向上转型"></a>7.7 向上转型</h3><blockquote>
<ul>
<li><font color='red'>将子类的引用转化为父类的引用我们称之为向上转型</font></li>
<li>值得注意的是：向上转型后的父类引用在进行调用方法的时候，编译的时候会先看父类中是否有该方法，如果有则编译通过，如果没有就编译失败。在运行的时候，会判断在子类中是否对该方法进行了覆盖，如果进行了覆盖，则调用的就是子类中的方法，如果子类中没有则就直接调用父类中的该方法。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Amphibian</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(Amphibian amphibian)</span>&#123;</span><br><span class="line">        System.out.println(amphibian+<span class="string">&quot;能游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;陆生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;水生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Frog</span> <span class="keyword">extends</span> <span class="title class_">Amphibian</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里通过将一个子类的引用传给父类的引用实现了向上转型</span></span><br><span class="line">        Amphibian amphibian=<span class="keyword">new</span> <span class="title class_">Frog</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//值得注意的是：向上转型后的父类引用在进行调用方法的时候，编译的时候会先看父类中是否有该方法（并且要求该方法能够被该子类继承，即如果是父类中的私有方法也不可以），如果有则编译通过，如果没有就编译失败。在运行的时候，会判断在子类中是否对该方法进行了覆盖，如果进行了覆盖，则调用的就是子类中的方法，如果子类中没有则就直接调用父类中的该方法。</span></span><br><span class="line">        amphibian.a();</span><br><span class="line">        amphibian.b();</span><br><span class="line">        Frog frog=<span class="keyword">new</span> <span class="title class_">Frog</span>();</span><br><span class="line">        swim(frog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙陆生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙水生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(Amphibian amphibian)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙能游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-8-final关键字"><a href="#7-8-final关键字" class="headerlink" title="7.8 final关键字"></a>7.8 final关键字</h3><blockquote>
<p>根据上下文环境，final关键字的含义存在细微差别，但通常都是无法改变的。一般final可以作用于数据，方法和类</p>
</blockquote>
<h4 id="1-final数据"><a href="#1-final数据" class="headerlink" title="1. final数据"></a>1. final数据</h4><blockquote>
<ul>
<li><p>基本数据类型：</p>
<ul>
<li><p>对于final修饰基本类型数据，表明这个数据是一个常量</p>
</li>
<li><p>而用static和final共同修饰得数据，表明这个数据也是一个常量，只是所有对象共享一份存储空间。</p>
</li>
</ul>
</li>
<li><p>对象引用数据：</p>
<ul>
<li>final修饰得对象引用只是表明不能再被指向另一个新的对象。但是该对象引用的值仍然可以进行改变。</li>
<li>例如：一个final修饰的数据对象引用。这个数组里面的值仍然是可以改变的，只是不能再被指向另外一个新的数组对象。</li>
</ul>
</li>
<li><p>对于final修饰的域（数据成员），必须在域的定义处或者每个构造器中用表达式对final进行赋值（显式的），这正是final域在使用前总是被初始化的原因。</p>
</li>
<li><p>final参数：Java允许在参数列表中以声明的方式将参数指明为final,这就意味着你无法在方法中更改参数的类型。可以读final参数，但是无法修改，这一特性主要用来向匿名内部类传递数据。</p>
</li>
</ul>
</blockquote>
<h4 id="2-final方法"><a href="#2-final方法" class="headerlink" title="2. final方法"></a>2. final方法</h4><blockquote>
<p>使用final修饰方法，主要是将方法进行锁定，以防任何继承类修改它的含义。<font color='red'>所以final修饰的方法不可以被覆盖，确保了方法的行为不会发生改变。</font></p>
<ul>
<li>细节：final和private关键字<ul>
<li>类中所有的private方法都隐式地指定为final的。因为无法取用private方法，所以也就无法覆盖它了。可以对private方法添加final关键字。</li>
<li>如果父类中有一个private方法，而子类中以相同的名称生成一个public、protected或包访问权限的方法，此时并没有覆盖父类中该方法，仅是生成了一个新的方法。（这里面在向上转型调用该方法时会报错，说父类与子类该方法并不匹配）</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-final类"><a href="#3-final类" class="headerlink" title="3. final类"></a>3. final类</h4><blockquote>
<ul>
<li>当用final修饰类时，表明该类不能被继承，即不希望该类有子类。</li>
<li>final类的域（成员）可以根据需要确定是否定义为final,不论类是否定义为final,相同的规则都适用域定义为final的域。然而final类禁止被继承，所以final类中的所有方法都隐式指定为final的，因为无法覆盖他们。</li>
</ul>
</blockquote>
<h3 id="7-9-继承与初始化"><a href="#7-9-继承与初始化" class="headerlink" title="7.9 继承与初始化"></a>7.9 继承与初始化</h3><blockquote>
<ol>
<li>在运行一个类文件时，加载器会去加载该类，在加载的过程中，编译器会注意它有基类，于是就对它进行继续加载，这里不管是否打算产生一个该基类的对象，这都要发生。所以&#x3D;&#x3D;根基类中的static初始化&#x3D;&#x3D;即会被执行（在本例中是Insect类），再然后就是下一个导出类，依此类推。</li>
<li>至此，必要的类加载完毕，在这里应该注意的一点是如果调用的静态方法，则会先执行静态方法中的方法体内容，再进行本类中成员对象的创建，对象就可以创建了，首先对象中所有的基本数据类型都会被设为默认值，对象引用置为null。</li>
<li>然后，基类的构造器方法就会被调用，在本例中是被自动调用的，但也可以用super来指定对构造器的调用。基类构造器和导出类的构造器一样，以相同的顺序经历相同的过程。</li>
<li>&#x3D;&#x3D;在基类构造器完成之后，实例变量（即非static成员）按其次序被初始化。&#x3D;&#x3D;<font color='red'>在每一个类中，静态成员或者静态代码块先执行，再是实例变量，再是构造器方法。</font></li>
<li>&#x3D;&#x3D;最后构造器的其余部分被执行。&#x3D;&#x3D;</li>
</ol>
</blockquote>
<blockquote>
<p><font color='red'>加载类的动作仅发生一次（所以这也是为什么静态代码块只被执行一次）</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Insect</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> j;</span><br><span class="line">  Insect() &#123;</span><br><span class="line">    print(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    j = <span class="number">39</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span></span><br><span class="line">    printInit(<span class="string">&quot;static Insect.x1 initialized&quot;</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">printInit</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    print(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beetle</span> <span class="keyword">extends</span> <span class="title class_">Insect</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> printInit(<span class="string">&quot;Beetle.k initialized&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Beetle</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;k = &quot;</span> + k);</span><br><span class="line">    print(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span></span><br><span class="line">    printInit(<span class="string">&quot;static Beetle.x2 initialized&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Beetle constructor&quot;</span>);</span><br><span class="line">    <span class="type">Beetle</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Beetle</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">static Insect.x1 initialized</span></span><br><span class="line"><span class="comment">static Beetle.x2 initialized</span></span><br><span class="line"><span class="comment">Beetle constructor</span></span><br><span class="line"><span class="comment">i = 9, j = 0</span></span><br><span class="line"><span class="comment">Beetle.k initialized</span></span><br><span class="line"><span class="comment">k = 47</span></span><br><span class="line"><span class="comment">j = 39</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第八章：多态"><a href="#第八章：多态" class="headerlink" title="第八章：多态"></a>第八章：多态</h2><blockquote>
<ul>
<li><p>多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要他们是从同一种基类到处而来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。</p>
</li>
<li><p>多态（也称作动态绑定，后期绑定或运行时绑定）</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;Instrument play&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Piano</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;Piano play&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wind</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;Wind play&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(Instrument instrument)</span>&#123;</span><br><span class="line">        instrument.play();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        play(<span class="keyword">new</span> <span class="title class_">Instrument</span>);  <span class="comment">//没有进行向上转型</span></span><br><span class="line">        play(<span class="keyword">new</span> <span class="title class_">Piano</span>());	  <span class="comment">//向上转型</span></span><br><span class="line">        play(<span class="keyword">new</span> <span class="title class_">Wind</span>());	  <span class="comment">//向上转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Instrument play</span><br><span class="line">Piano play</span><br><span class="line">Wind play</span><br></pre></td></tr></table></figure>

<h3 id="8-2-转机"><a href="#8-2-转机" class="headerlink" title="8.2 转机"></a>8.2 转机</h3><blockquote>
<ul>
<li>将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做&#x3D;&#x3D;前期绑定&#x3D;&#x3D;。在面向过程语言中默认就是这种绑定方式。如c语言就只有这一种。</li>
</ul>
</blockquote>
<blockquote>
<p>上面程序(Test类中的play方法)令人迷惑的地方在于，编译器只有一个Instrument引用，它无法知道究竟调用哪个方法。</p>
<p>解决办法：&#x3D;&#x3D;后期绑定&#x3D;&#x3D;。它的含义就是在运行时根据对象的类型进行绑定。后期绑定又叫动态绑定或运行时绑定。</p>
</blockquote>
<blockquote>
<p>在Java中，除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。这意味着在通常情况下，我们不必判定是否应该进行后期绑定—它会自动发生。</p>
</blockquote>
<blockquote>
<p><font color='red'>特例1：</font>“覆盖”私有方法</p>
</blockquote>
<p><strong>下面这个代码执行不会出错</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;private f()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">PrivateOverride</span> <span class="variable">po</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Derived</span>();		<span class="comment">//因为这里private方法不能被覆盖，但是这里也不会报错，但是执行的是父类中的private方法</span></span><br><span class="line">    po.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;public f()&quot;</span>); &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">private f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>下面这个代码执行就会出错</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test824</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        Base b=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        b.a();  <span class="comment">//编译出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>特例2：</font>域与静态方法</p>
<ul>
<li><font color='red'>当子类对象向上转型赋给父类引用时，在使用父类引用访问子类和父类都有的成员变量时，会直接从当前父类域中获取</font>。因为域操作不是多态，即子类并不会将父类的成员变量覆盖掉，所以继承后子类中实际上包含了两个该成员变量，一个是它自己的还有是从父类中得到的。</li>
<li>静态方法也不具有多态性。静态方法是与类，而并非与单个的对象相关联的。因为静态方法也不允许被重载。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Base staticGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Base dynamicGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSub</span> <span class="keyword">extends</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">  <span class="comment">//这里虽然无法覆盖父类中的staticGet()方法，但是这里的访问权限，返回类型，参数类型也还是要满足重载的要求</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Derived staticGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Derived dynamicGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticPolymorphism</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StaticSuper</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticSub</span>(); <span class="comment">// Upcast</span></span><br><span class="line">    System.out.println(sup.staticGet());			<span class="comment">//注意调用的是父类中方法，</span></span><br><span class="line">    System.out.println(sup.dynamicGet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Base staticGet()</span></span><br><span class="line"><span class="comment">Derived dynamicGet()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-构造器与多态"><a href="#8-3-构造器与多态" class="headerlink" title="8.3 构造器与多态"></a>8.3 构造器与多态</h3><blockquote>
<p>在导出类（子类）的构造器主体中，如果没有明确指定调用某个基类构造器，它就会默认地调用默认构造器（无参构造器），如果不存在无参构造器，编译器就会报错。</p>
<ul>
<li>&#x3D;&#x3D;执行顺序：&#x3D;&#x3D;<ol>
<li>先会进行从根基类到下一个导出类的static初始化。再就是调用的static里面的方法体执行，再是该类中的非static成员创建，再就是从根基类到导出类的构造器，并且具体到每一个类中构造器执行，都是先非static成员创建，然后是构造器里面的方法执行。&#x3D;&#x3D;（总结为：先执行静态变量初始化以及非static成员赋上默认值（0，‘’，null这些的），再就是基类构造器执行，再就是本类非static成员初始化，再是执行本类的构造器里面的语句）&#x3D;&#x3D;</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  Meal() &#123; print(<span class="string">&quot;Meal()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bread</span> &#123;</span><br><span class="line">  Bread() &#123; print(<span class="string">&quot;Bread()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cheese</span> &#123;</span><br><span class="line">  Cheese() &#123; print(<span class="string">&quot;Cheese()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lettuce</span> &#123;</span><br><span class="line">  Lettuce() &#123; print(<span class="string">&quot;Lettuce()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lunch</span> <span class="keyword">extends</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  Lunch() &#123; print(<span class="string">&quot;Lunch()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PortableLunch</span> <span class="keyword">extends</span> <span class="title class_">Lunch</span> &#123;</span><br><span class="line">  PortableLunch() &#123; print(<span class="string">&quot;PortableLunch()&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sandwich</span> <span class="keyword">extends</span> <span class="title class_">PortableLunch</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Bread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bread</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Cheese</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cheese</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lettuce</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lettuce</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Sandwich</span><span class="params">()</span> &#123; print(<span class="string">&quot;Sandwich()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Sandwich</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Meal()</span></span><br><span class="line"><span class="comment">Lunch()</span></span><br><span class="line"><span class="comment">PortableLunch()</span></span><br><span class="line"><span class="comment">Bread()</span></span><br><span class="line"><span class="comment">Cheese()</span></span><br><span class="line"><span class="comment">Lettuce()</span></span><br><span class="line"><span class="comment">Sandwich()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>继承和清理</strong></p>
<ul>
<li>​	对象在销毁的时候应该和初始化的顺序相反，对于字段，则应该和声明的顺序相反。</li>
<li>在对基类中的清理方法进行覆盖时，别忘了要在后面调用基类的清理方法，否则，基类的清理动作不会发生。</li>
</ul>
</blockquote>
<blockquote>
<p>构造器内部的多态方法的行为：在执行类中的方法时，调用的类中的变量还未初始化</p>
<p>所以优化的方法是：最好尽量避免在构造器中调用方法。或者在构造器中只调用基类中的final方法（也适用于private方法，他们自动属于private方法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; print(<span class="string">&quot;Glyph.draw()&quot;</span>); &#125;</span><br><span class="line">  Glyph() &#123;</span><br><span class="line">    print(<span class="string">&quot;Glyph() before draw()&quot;</span>);</span><br><span class="line">    draw();</span><br><span class="line">    print(<span class="string">&quot;Glyph() after draw()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundGlyph</span> <span class="keyword">extends</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  RoundGlyph(<span class="type">int</span> r) &#123;</span><br><span class="line">    radius = r;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.RoundGlyph(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.draw(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyConstructors</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RoundGlyph</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Glyph() before draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.draw(), radius = 0</span></span><br><span class="line"><span class="comment">Glyph() after draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.RoundGlyph(), radius = 5</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-用继承进行设计"><a href="#8-5-用继承进行设计" class="headerlink" title="8.5 用继承进行设计"></a>8.5 用继承进行设计</h3><blockquote>
<p>通用的准则是：用继承表达行为间的差异，并用字段表达状态上的变化</p>
</blockquote>
<p><strong>状态模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HappyActor</span> <span class="keyword">extends</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123; print(<span class="string">&quot;HappyActor&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SadActor</span> <span class="keyword">extends</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123; print(<span class="string">&quot;SadActor&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stage</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HappyActor</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123; actor = <span class="keyword">new</span> <span class="title class_">SadActor</span>(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performPlay</span><span class="params">()</span> &#123; actor.act(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transmogrify</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Stage</span> <span class="variable">stage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stage</span>();</span><br><span class="line">    stage.performPlay();</span><br><span class="line">    stage.change();</span><br><span class="line">    stage.performPlay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HappyActor</span></span><br><span class="line"><span class="comment">SadActor</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>is-a：是只有在基类中已经存在的方法才可以在导出类中被覆盖</p>
<p>is-like-a：除了覆盖的那些方法，他还具有额外方法实现的其他特性，即基类中没有的方法</p>
</blockquote>
<blockquote>
<p>向下转型：是不安全的，所以需要进行一个类型转换，即便这样，Java仍然会在运行期间对其进行检查，如果转换类型失败，则会报类转型异常（ClassCastException）,这个属于运行时异常。（为了防止转换失败，可以适用instanceof进行一个判断后，再进行类型强转）</p>
<p>RTTI(运行时类型识别)：在运行期间对类型进行检查的行为。</p>
</blockquote>
<h2 id="第九章：接口"><a href="#第九章：接口" class="headerlink" title="第九章：接口"></a>第九章：接口</h2><h3 id="9-1-抽象类和抽象方法"><a href="#9-1-抽象类和抽象方法" class="headerlink" title="9.1 抽象类和抽象方法"></a>9.1 抽象类和抽象方法</h3><blockquote>
<p>包含抽象方法的类是叫做抽象类。</p>
<p>抽象类也可能会没有任何抽象方法。是为了阻止创建该类的任何对象。（不允许创建抽象类对象，但是可以有抽象类的引用，例如多态时使用。）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abs</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Abs</span><span class="params">()</span>&#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test9_1</span> <span class="keyword">extends</span> <span class="title class_">Abs</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Test9_1 t=<span class="keyword">new</span> <span class="title class_">Test9_1</span>();</span><br><span class="line">        t.fun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">0</span>    <span class="comment">//此时输出的是尚未进行初始化的i,i只是被赋予零值</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>抽象方法不能用private访问修饰符来进行修饰（即private和abstract不能连用）</p>
</blockquote>
<h3 id="9-2-接口"><a href="#9-2-接口" class="headerlink" title="9.2 接口"></a>9.2 接口</h3><blockquote>
<p>接口可以用public或者包访问权限（没有修饰符）进行修饰。<font color='red'>接口也可以包含域（数据成员），但是这些域隐式地是static和final的。接口中的方法默认就都是public修饰的，</font>因此实现了一个接口的类，在覆盖该接口中定义的方法的时候，必须定义为public，否则权限就会降低，编译器就会报错。</p>
</blockquote>
<h3 id="9-3-完全解耦"><a href="#9-3-完全解耦" class="headerlink" title="9.3 完全解耦"></a>9.3 完全解耦</h3><blockquote>
<p>&#x3D;&#x3D;策略设计模式&#x3D;&#x3D;：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法</p>
<ul>
<li>如下图代码所示：Precessor对象就是一个策略。策略就是传递进去的参数对象，它包含要执行的代码。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">  &#125;</span><br><span class="line">  Object <span class="title function_">process</span><span class="params">(Object input)</span> &#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Upcase</span> <span class="keyword">extends</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  String <span class="title function_">process</span><span class="params">(Object input)</span> &#123; <span class="comment">// Covariant return</span></span><br><span class="line">    <span class="keyword">return</span> ((String)input).toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Downcase</span> <span class="keyword">extends</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  String <span class="title function_">process</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((String)input).toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Splitter</span> <span class="keyword">extends</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  String <span class="title function_">process</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="comment">// The split() argument divides a String into pieces:</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.toString(((String)input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apply</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Processor p, Object s)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Using Processor &quot;</span> + p.name());</span><br><span class="line">    print(p.process(s));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&quot;Disagreement with beliefs is by definition incorrect&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    process(<span class="keyword">new</span> <span class="title class_">Upcase</span>(), s);</span><br><span class="line">    process(<span class="keyword">new</span> <span class="title class_">Downcase</span>(), s);</span><br><span class="line">    process(<span class="keyword">new</span> <span class="title class_">Splitter</span>(), s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Using Processor Upcase</span></span><br><span class="line"><span class="comment">DISAGREEMENT WITH BELIEFS IS BY DEFINITION INCORRECT</span></span><br><span class="line"><span class="comment">Using Processor Downcase</span></span><br><span class="line"><span class="comment">disagreement with beliefs is by definition incorrect</span></span><br><span class="line"><span class="comment">Using Processor Splitter</span></span><br><span class="line"><span class="comment">[Disagreement, with, beliefs, is, by, definition, incorrect]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>&#x3D;&#x3D;适配器设计模式&#x3D;&#x3D;：在设配器中的代码将接受你所拥有的接口，并产生你所需要的接口。</li>
<li>将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器模式：使得CharacterPairSwapper类可以通过适配器类SwapperAdapter与Processor接口进行交互，而不用来自身来实现该接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    Object <span class="title function_">process</span><span class="params">(Object input)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterPairSwapper</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> String <span class="title function_">swap</span><span class="params">(String s)</span> &#123;</span><br><span class="line"> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length() - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> sb.charAt(i);</span><br><span class="line"> <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> sb.charAt(i + <span class="number">1</span>);</span><br><span class="line"> sb.setCharAt(i, c2);</span><br><span class="line"> sb.setCharAt(i + <span class="number">1</span>, c1);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sb.toString();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapperAdapter</span> <span class="keyword">implements</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> CharacterPairSwapper.class.getSimpleName();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">process</span><span class="params">(Object input)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> CharacterPairSwapper.swap((String)input);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E11_Swapper</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> Apply.process(<span class="keyword">new</span> <span class="title class_">SwapperAdapter</span>(), <span class="string">&quot;1234&quot;</span>);</span><br><span class="line"> Apply.process(<span class="keyword">new</span> <span class="title class_">SwapperAdapter</span>(), <span class="string">&quot;abcde&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Using Processor CharacterPairSwapper</span></span><br><span class="line"><span class="comment">2143</span></span><br><span class="line"><span class="comment">Using Processor CharacterPairSwapper</span></span><br><span class="line"><span class="comment">badce</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="9-4-Java中的多重继承"><a href="#9-4-Java中的多重继承" class="headerlink" title="9.4 Java中的多重继承"></a>9.4 Java中的多重继承</h3><blockquote>
<ul>
<li>在继承和多重实现一起存在的时候，继承的具体类应该写在前面，后面跟着的才是接口（否则编译器会报错）。</li>
<li>细节：当继承而来的某个方法是将要实现的某个抽象方法时，在子类中可以不用再对接口中的该方法进行实现，就相当于直接使用父类中的该方法。</li>
<li>使用接口的原因：<ol>
<li>为了能够向上转型为多个基类型（以及由此而带来的灵活性）。</li>
<li>防止客户端程序员创建该类的对象。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="9-5-通过继承来扩展接口"><a href="#9-5-通过继承来扩展接口" class="headerlink" title="9.5 通过继承来扩展接口"></a>9.5 通过继承来扩展接口</h3><blockquote>
<ul>
<li><p>可以使用extends关键字，应用于继承接口。并且extends用于接口继承时，可以继承多个。</p>
<ul>
<li>如：public class c extends interface1,interface2{}</li>
</ul>
</li>
<li><p>将extends用于类时，就只能继承一个类。</p>
</li>
</ul>
</blockquote>
<h3 id="9-6-适配接口（这里还需要再看一下）"><a href="#9-6-适配接口（这里还需要再看一下）" class="headerlink" title="9.6 适配接口（这里还需要再看一下）"></a>9.6 适配接口（这里还需要再看一下）</h3><blockquote>
<ul>
<li>接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现。在简单的情况中，他的体现形式通常是一个接受接口类型的方法，而该接口的实现和向该方法传递的对象则取决于方法的使用者。</li>
<li>因此接口一种常见用法就是前面提到的策略设计模式。</li>
<li>还有一个就是适配器设计模式</li>
<li>在这种模式中，我们可以在任何现有类之上添加新的接口，所以这就一位让方法接受接受接口类型，是一种让任何类都可以对该方法进行适配的方式，这也是使用接口而不是类的强大之处。</li>
</ul>
</blockquote>
<h3 id="9-7-接口中的域"><a href="#9-7-接口中的域" class="headerlink" title="9.7 接口中的域"></a>9.7 接口中的域</h3><blockquote>
<ul>
<li>细节：在接口中的域不能是”空final”，即接口中的域必须被显式初始化。（被非常量表达式也是可以的）</li>
</ul>
</blockquote>
<h3 id="9-8-嵌套接口（没太理解）"><a href="#9-8-嵌套接口（没太理解）" class="headerlink" title="9.8 嵌套接口（没太理解）"></a>9.8 嵌套接口（没太理解）</h3><blockquote>
<ul>
<li>可以在接口中嵌套类或接口</li>
<li>同样，也可以在类中嵌套类或接口</li>
<li>此时，在类中被嵌套的类或接口可以用private修饰</li>
<li>在接口中被嵌套的类或接口只能用public修饰，并且默认就是public的</li>
</ul>
</blockquote>
<h3 id="9-9-接口与工厂"><a href="#9-9-接口与工厂" class="headerlink" title="9.9 接口与工厂"></a>9.9 接口与工厂</h3><blockquote>
<ul>
<li>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是&#x3D;&#x3D;工厂方法设计模式&#x3D;&#x3D;。</li>
<li>这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。理论上，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明得将某个实现替换为另一个实现。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Game</span> &#123; <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GameFactory</span> &#123; Game <span class="title function_">getGame</span><span class="params">()</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Checkers</span> <span class="keyword">implements</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">moves</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Checkers move &quot;</span> + moves);</span><br><span class="line">    <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckersFactory</span> <span class="keyword">implements</span> <span class="title class_">GameFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Game <span class="title function_">getGame</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Checkers</span>(); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chess</span> <span class="keyword">implements</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">moves</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVES</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Chess move &quot;</span> + moves);</span><br><span class="line">    <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChessFactory</span> <span class="keyword">implements</span> <span class="title class_">GameFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Game <span class="title function_">getGame</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Chess</span>(); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Games</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">(GameFactory factory)</span> &#123;</span><br><span class="line">    <span class="type">Game</span> <span class="variable">s</span> <span class="operator">=</span> factory.getGame();</span><br><span class="line">    <span class="keyword">while</span>(s.move())</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    playGame(<span class="keyword">new</span> <span class="title class_">CheckersFactory</span>());</span><br><span class="line">    playGame(<span class="keyword">new</span> <span class="title class_">ChessFactory</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Checkers move 0</span></span><br><span class="line"><span class="comment">Checkers move 1</span></span><br><span class="line"><span class="comment">Checkers move 2</span></span><br><span class="line"><span class="comment">Chess move 0</span></span><br><span class="line"><span class="comment">Chess move 1</span></span><br><span class="line"><span class="comment">Chess move 2</span></span><br><span class="line"><span class="comment">Chess move 3</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第十章：内部类"><a href="#第十章：内部类" class="headerlink" title="第十章：内部类"></a>第十章：内部类</h2><blockquote>
<ul>
<li><p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。</p>
</li>
<li><p>值得注意的是内部类与组合（将一个类引用作为另一个类的数据成员）是完全不同的概念。</p>
</li>
<li><p>内部类它还了解外围类，并能与之通信。</p>
</li>
</ul>
</blockquote>
<h3 id="10-1-创建内部类"><a href="#10-1-创建内部类" class="headerlink" title="10.1 创建内部类"></a>10.1 创建内部类</h3><blockquote>
<ul>
<li><p>创建内部类的方式：将类的定义至于外围类的里面</p>
</li>
<li><p>从外围类的非静态方法中创建内部类的方式如ship()方法中这样</p>
</li>
<li><p>而如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么就必须像在main()方法中一样，具体地致命这个对象的类型：OuterClassName.InnerClassName</p>
</li>
<li><p>在某种典型情况下，外部类中会有方法返回一个指向内部类的引用，就像在to()和contents()方法中看到的那样。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>细节</font>：<ol>
<li>编译器在对含有内部类的文件进行编译时，并不会产生内部类的.java</li>
<li>可以用内部类中的类名称作为另外一个新的外部类的名称。<ol>
<li>在这种情况下创建对象时需要指明。</li>
</ol>
</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel2</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    Destination(String whereTo) &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Destination <span class="title function_">to</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ship</span><span class="params">(String dest)</span> &#123;</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> contents();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> to(dest);</span><br><span class="line">    System.out.println(d.readLabel());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel2</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel2</span>();</span><br><span class="line">    p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    <span class="type">Parcel2</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel2</span>();</span><br><span class="line">    <span class="comment">// Defining references to inner classes:</span></span><br><span class="line">    Parcel2.<span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> q.contents();</span><br><span class="line">    <span class="comment">//下面这种写法也可以</span></span><br><span class="line">    <span class="comment">//Contents c = q.contents();</span></span><br><span class="line">    Parcel2.<span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> q.to(<span class="string">&quot;Borneo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="10-2-链接到外部类"><a href="#10-2-链接到外部类" class="headerlink" title="10.2 链接到外部类"></a>10.2 链接到外部类</h3><blockquote>
<ul>
<li>当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，<font color='red'>所以它能访问其外围对象的所有成员（成员变量和成员方法），而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。</font></li>
<li>原理：<ul>
<li>当某个外围类的对象创建了一个内部类的对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后在访问此外围类的成员时，就是用那个引用来选择外围类的成员。</li>
</ul>
</li>
<li>细节：在内部类是非static类时，内部类的对象只能在与其外围类的对象相关联的情况下才能被创建。构建内部类对象时，需要一个指向其外围类对象的引用，如果没有编译器就会报错。</li>
</ul>
</blockquote>
<h3 id="10-3-使用-this与-new"><a href="#10-3-使用-this与-new" class="headerlink" title="10.3 使用.this与.new"></a>10.3 使用.this与.new</h3><blockquote>
<ul>
<li><font color='red'>.this用法</font>：如果你需要在内部类中生成对外部类对象的引用，可以使用外部类的名字紧跟圆点和this。这样产生的引用自动地具有正确的类型。</li>
<li>如果是一般的this的话，访问的则是内部类的this</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotThis</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> DotThis <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> DotThis.<span class="built_in">this</span>;</span><br><span class="line">      <span class="comment">// A plain &quot;this&quot; would be Inner&#x27;s &quot;this&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Inner <span class="title function_">inner</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DotThis</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DotThis</span>();</span><br><span class="line">    DotThis.<span class="type">Inner</span> <span class="variable">dti</span> <span class="operator">=</span> dt.inner();</span><br><span class="line">    <span class="comment">//DotThis.Inner dti = dt。new Inner();  这是使用.new的方式获取内部类对象</span></span><br><span class="line">    dti.outer().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DotThis.f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>.new用法：有时可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用。如下面所示</li>
<li>因此在有了该种用法之后，就可以在外部类中不用提供返回内部类引用的方法获取到内部类对象。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotNew</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DotNew</span> <span class="variable">dn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DotNew</span>();</span><br><span class="line">    DotNew.<span class="type">Inner</span> <span class="variable">dni</span> <span class="operator">=</span> dn.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<h3 id="10-4-内部类和向上转型"><a href="#10-4-内部类和向上转型" class="headerlink" title="10.4 内部类和向上转型"></a>10.4 内部类和向上转型</h3><blockquote>
<p>在外围类中，可以通过内部类中的对象引用来访问内部类中的private成员变量和成员方法</p>
</blockquote>
<h3 id="10-5-在方法和作用域内的内部类"><a href="#10-5-在方法和作用域内的内部类" class="headerlink" title="10.5 在方法和作用域内的内部类"></a>10.5 在方法和作用域内的内部类</h3><blockquote>
<ol>
<li>一个定义在方法中的类</li>
<li>一个定义在作用域内的类，此作用域在方法的内部</li>
<li>一个实现了接口的匿名类</li>
<li>一个匿名类，它扩展了有非默认构造器的类</li>
<li>一个匿名类，它执行字段初始化</li>
<li>一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）</li>
</ol>
</blockquote>
<blockquote>
<p>案例1：一个定义在方法中的类，这又被称作局部内部类。PDestination该类是destination（）方法中的一部分，而不是Parcel5的一部分，所以在destination（）之外不能访问PDestination。值得注意的是，虽然在destination（）方法中定义了内部类，但并不意味者该方法执行完毕，方法里的内部类就不可用了。</p>
<p>&#x3D;&#x3D;细节：局部内部类不允许用public修饰&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel5</span> &#123;</span><br><span class="line">    <span class="comment">//这是一个方法</span></span><br><span class="line">  <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    	<span class="comment">//定义在方法中的类</span></span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">PDestination</span> <span class="keyword">implements</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> String label;</span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">PDestination</span><span class="params">(String whereTo)</span> &#123;</span><br><span class="line">        label = whereTo;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PDestination</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel5</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel5</span>();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    <span class="comment">//可以调用readLabel()方法，如果PDestination覆盖了该方法，执行时会执行PDestination中的方法体</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例2：当定义在作用域内时，如if(){一个内部类定义}。在作用域之外定义内部类，会编译出错</p>
<p>&#x3D;&#x3D;细节：作用域内部类不允许用public修饰&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>通过下面这个案例体会一下使用内部类的用处</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer5</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inner</span> <span class="keyword">implements</span> <span class="title class_">SimpleInterface</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;Outer5.Inner.f&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> SimpleInterface <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line"> <span class="keyword">public</span> Inner <span class="title function_">get2</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E11_HiddenInnerClass</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"> <span class="type">Outer5</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer5</span>();</span><br><span class="line"> <span class="type">SimpleInterface</span> <span class="variable">si</span> <span class="operator">=</span> out.get();</span><br><span class="line"> si = out.get2();</span><br><span class="line"> <span class="comment">// Won&#x27;t compile -- &#x27;Inner&#x27; not visible:</span></span><br><span class="line"> <span class="comment">//! Inner i1 = out.get2();</span></span><br><span class="line"> <span class="comment">//! Inner i2 = (Inner)si;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">///:~ </span></span><br></pre></td></tr></table></figure>

<h3 id="10-6-匿名内部类"><a href="#10-6-匿名内部类" class="headerlink" title="10.6 匿名内部类"></a>10.6 匿名内部类</h3><blockquote>
<p>语法：创建一个继承自Contents的匿名类的对象，通过new表达式返回的引用被自动向上转型为对Contents的引用。</p>
<p>案例3：一个匿名内部类</p>
</blockquote>
<p>&#x3D;&#x3D;简化形式：&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel7</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contents</span>() &#123; <span class="comment">// Insert a class definition</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;; <span class="comment">// Semicolon required in this case</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel7</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel7</span>();</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> p.contents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;上述匿名内部类的语法是下述形式的简化形式&#x3D;&#x3D;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel7b</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MyContents</span> <span class="keyword">implements</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyContents</span>(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel7b</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel7b</span>();</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> p.contents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例4：扩展了非默认构造器的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapping</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Wrapping</span><span class="params">(<span class="type">int</span> x)</span> &#123; i = x; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel8</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Wrapping <span class="title function_">wrapping</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// Base constructor call:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wrapping</span>(x) &#123; <span class="comment">// Pass constructor argument.</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;; <span class="comment">// Semicolon required</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel8</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel8</span>();</span><br><span class="line">    <span class="type">Wrapping</span> <span class="variable">w</span> <span class="operator">=</span> p.wrapping(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在匿名类中定义字段时，还能够对其执行初始化动作</p>
</blockquote>
<blockquote>
<p><font color='red'>细节：如果定义了一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用时final修饰的就像在destination()的参数中看到的那样。</font></p>
<p>案例5：一个匿名内部类，字段初始化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel9</span> &#123;</span><br><span class="line">  <span class="comment">// Argument must be final to use inside</span></span><br><span class="line">  <span class="comment">// anonymous inner class:</span></span><br><span class="line">  <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(<span class="keyword">final</span> String dest)</span> &#123;  <span class="comment">//参数必须要求是final的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> dest;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel9</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel9</span>();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在此例中，不要求变量i一定是final的，因为i被传递给匿名类的基类的构造器，他并不会在匿名类内部被直接使用。(注意这个例子和上面那个用了final的例子做一个比较)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Base constructor, i = &quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title function_">getBase</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Base</span>(i) &#123;</span><br><span class="line">      &#123; print(<span class="string">&quot;Inside instance initializer&quot;</span>); &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;In anonymous f()&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> getBase(<span class="number">47</span>);</span><br><span class="line">    base.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Base constructor, i = 47</span></span><br><span class="line"><span class="comment">Inside instance initializer</span></span><br><span class="line"><span class="comment">In anonymous f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例6：一个匿名内部类，实例初始化</p>
<p>对于匿名内部类来说，实例初始化的实际效果就是构造器。当然它也受到了限制，不能重载实例初始化方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel10</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Destination</span><br><span class="line">  <span class="title function_">destination</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="type">float</span> price)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> cost;</span><br><span class="line">      <span class="comment">// Instance initialization for each object:</span></span><br><span class="line">      <span class="comment">//实例初始化对象</span></span><br><span class="line">      &#123;  </span><br><span class="line">        cost = Math.round(price);</span><br><span class="line">        <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</span><br><span class="line">          System.out.println(<span class="string">&quot;Over budget!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> dest;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel10</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel10</span>();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>, <span class="number">101.395F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Over budget!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;细节：&#x3D;&#x3D;匿名内部类与正规的继承相比有些受限，因为匿名内部类即可以扩展类，也可以实现接口，但是不能两者兼备，而且如果是实现接口，也只能实现一个接口。</p>
</blockquote>
<blockquote>
<ul>
<li>优先使用类而不是接口</li>
</ul>
</blockquote>
<h3 id="10-7-嵌套类"><a href="#10-7-嵌套类" class="headerlink" title="10.7 嵌套类"></a>10.7 嵌套类</h3><blockquote>
<p>如果不需要内部类对象与其外围类对象之间有联系（即普通的内部类对象隐式的保存了一个引用，指向创建它的外围类对象），那么可以将内部类声明为static.这通常称为嵌套类。</p>
</blockquote>
<blockquote>
<ul>
<li>嵌套类：<ol>
<li>要创建嵌套类的对象，并不需要其外围类的对象</li>
<li>不能从嵌套类的对象中访问非静态的外围类对象</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>嵌套类与普通的内部类的区别：<ol>
<li>普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含有这些东西。</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel11</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParcelContents</span> <span class="keyword">implements</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParcelDestination</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ParcelDestination</span><span class="params">(String whereTo)</span> &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;	</span><br><span class="line">    <span class="comment">// Nested classes can contain other static elements:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnotherLevel</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">      <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title function_">destination</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="comment">//在外围类的静态方法中，可以直接创建嵌套类的对象，这有点类似于在静态方法中调用静态方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ParcelDestination</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ParcelContents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> contents();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节：不论是嵌套类还是普通的内部类，都只会存在与其外围类的.java文件中。但是在编译后，每一个类都会有一个单独的.class文件。</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211213104800721.png" alt="image-20211213104800721"></p>
<blockquote>
<p>接口内部的类：正常情况下，不能在接口内部放置任何代码，但是嵌套类可以作为接口的一部分。放到接口中的类都自动是public和static的，甚至可以在内部类中实现其外围类接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassInInterface</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">howdy</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">ClassInInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">howdy</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Howdy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Test</span>().howdy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Howdy!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节：一个内部类被嵌套多少层并不重要，重要的是它能透明的访问所有它所嵌入的外围类的所有成员。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MNA</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">        g();</span><br><span class="line">        f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiNestingAccess</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MNA</span> <span class="variable">mna</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MNA</span>();</span><br><span class="line">    MNA.<span class="type">A</span> <span class="variable">mnaa</span> <span class="operator">=</span> mna.<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    MNA.A.<span class="type">B</span> <span class="variable">mnaab</span> <span class="operator">=</span> mnaa.<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    mnaab.h();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-8-为什么需要内部类"><a href="#10-8-为什么需要内部类" class="headerlink" title="10.8 为什么需要内部类"></a>10.8 为什么需要内部类</h3><blockquote>
<ol>
<li>每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</li>
<li>内部类提供了可以继承多个具体的、或抽象的类的能力，使多重继承的解决方案变得完整。（接口只是解决了部分问题）</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>使用内部类，还可以获得其他一些特性：<ol>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖与外围类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体。</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>闭包与回调</strong></p>
<ul>
<li>闭包：闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。可以看出&#x3D;&#x3D;内部类是面向对象的闭包&#x3D;&#x3D;，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。</li>
<li>回调：回调的价值在于它的灵活性———可以在运行时动态的决定需要调用什么方法。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内部类与控制框架</strong></p>
<ul>
<li>应用程序框架：就是被设计用以解决某类特定问题的一个类或一组类。</li>
</ul>
</blockquote>
<h3 id="10-9-内部类的继承"><a href="#10-9-内部类的继承" class="headerlink" title="10.9 内部类的继承"></a>10.9 内部类的继承</h3><blockquote>
<p>因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，会有点复杂。问题在于，那个指向外围类对象的“秘密的”引用必须被初始化，而在导出类中不再存在可连接的默认对象，所以需要使用特殊的语法。</p>
</blockquote>
<blockquote>
<p>这是普通的内部类继承</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner &#123;</span><br><span class="line">  <span class="comment">//! InheritInner() &#123;&#125; // Won&#x27;t compile</span></span><br><span class="line">  InheritInner(WithInner wi) &#123;</span><br><span class="line">    wi.<span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">WithInner</span> <span class="variable">wi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">    <span class="type">InheritInner</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是静态内部类的继承方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner &#123;</span><br><span class="line">  InheritInner() &#123;</span><br><span class="line">      <span class="comment">//直接使用super()就可</span></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">WithInner</span> <span class="variable">wi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">    <span class="type">InheritInner</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-10-内部类可以被覆盖吗"><a href="#10-10-内部类可以被覆盖吗" class="headerlink" title="10.10 内部类可以被覆盖吗"></a>10.10 内部类可以被覆盖吗</h3><blockquote>
<p>当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化，&#x3D;&#x3D;这两个内部类是完全独立的两个实体，各自在自己的命名空间内&#x3D;&#x3D;。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Egg</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Yolk y;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;Egg.Yolk()&quot;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">    y = <span class="keyword">new</span> <span class="title class_">Yolk</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEgg</span> <span class="keyword">extends</span> <span class="title class_">Egg</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;BigEgg.Yolk()&quot;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BigEgg</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">New Egg()</span></span><br><span class="line"><span class="comment">Egg.Yolk()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是如果明确地继承某个内部类是可以的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Egg2</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;Egg2.Yolk()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;Egg2.Yolk.f()&quot;</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Yolk</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yolk</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Egg2</span><span class="params">()</span> &#123; print(<span class="string">&quot;New Egg2()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertYolk</span><span class="params">(Yolk yy)</span> &#123; y = yy; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123; y.f(); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEgg2</span> <span class="keyword">extends</span> <span class="title class_">Egg2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> <span class="keyword">extends</span> <span class="title class_">Egg2</span>.Yolk &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;BigEgg2.Yolk()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;BigEgg2.Yolk.f()&quot;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BigEgg2</span><span class="params">()</span> &#123; insertYolk(<span class="keyword">new</span> <span class="title class_">Yolk</span>()); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Egg2</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigEgg2</span>();</span><br><span class="line">    e2.g();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Egg2.Yolk()</span></span><br><span class="line"><span class="comment">New Egg2()</span></span><br><span class="line"><span class="comment">Egg2.Yolk()</span></span><br><span class="line"><span class="comment">BigEgg2.Yolk()</span></span><br><span class="line"><span class="comment">BigEgg2.Yolk.f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="10-11-局部内部类"><a href="#10-11-局部内部类" class="headerlink" title="10.11 局部内部类"></a>10.11 局部内部类</h3><blockquote>
<ul>
<li>可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为他不是外围类的一部分；但是<font color='red'>它可以访问当前代码块内的常量，以及此外围类的所有成员</font>。</li>
<li>使用局部类而不使用匿名内部类的情况：<ol>
<li>我们需要一个命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例化。</li>
<li>另外一个就是需要不止一个该内部类的对象。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="10-12-内部类标识符"><a href="#10-12-内部类标识符" class="headerlink" title="10.12 内部类标识符"></a>10.12 内部类标识符</h3><blockquote>
<ul>
<li><p>每个类都会产生一个.class文件，内部类也必须生成一个.class文件以包含他们的Class对象信息。这些类文件的命名有严格的规则，外围类的名字，加上“$”,再加上内部类的名字。</p>
</li>
<li><p>如果内部类是匿名的，编译器会简单的生成一个数字作为其标识符。 LocalInnerClass&amp;1.class</p>
</li>
<li><p>如果内部类是嵌套在别的内部类之中，只需将他们的名字加在其外围标识符与“$”的后面 LocalInnerClass$1LocalCounter.class</p>
</li>
</ul>
<p>如：Counter.class</p>
<p>​		LocalInnerClass&amp;1.class</p>
<p>​		LocalInnerClass$1LocalCounter.class</p>
<p>​		LocalInnerClass.class</p>
</blockquote>
<h2 id="第十一章：持有对象"><a href="#第十一章：持有对象" class="headerlink" title="第十一章：持有对象"></a>第十一章：持有对象</h2><blockquote>
<p>List,Set,Queue都继承自Collection.注意，&#x3D;&#x3D;map并不是继承自Collection接口&#x3D;&#x3D;</p>
</blockquote>
<h3 id="11-4-容器的打印"><a href="#11-4-容器的打印" class="headerlink" title="11.4 容器的打印"></a>11.4 容器的打印</h3><blockquote>
<p>对于一个数组，我们必须要使用Arrays.toString()来产生数组的可打印表示，但是打印容器无需任何帮助。</p>
</blockquote>
<blockquote>
<p>Collection打印出来的内容用方括号括住，每个元素用逗号隔开。Map则用大括号括住，键与值由等号联系。</p>
</blockquote>
<p><img src="C:\Users\helloworld\Desktop\java.png" alt="java"></p>
<h3 id="11-5-List"><a href="#11-5-List" class="headerlink" title="11.5 List"></a>11.5 List</h3><blockquote>
<ul>
<li>add()、get()</li>
<li>subList()方法：subList()所产生的列表的幕后就是初始列表，&#x3D;&#x3D;因此对所返回的列表的修改都会反映到初始列表中，反之亦然。。&#x3D;&#x3D;</li>
<li>retainAll()方法：是一种有效的交集操作。</li>
</ul>
</blockquote>
<h3 id="11-6-迭代器"><a href="#11-6-迭代器" class="headerlink" title="11.6 迭代器"></a>11.6 迭代器</h3><blockquote>
<p>引入：如果原本是对着List编码的，但是后来发现如果能够把相同的代码应用于Set，将会显得非常方便，如何能保证不重写代码就可以应用于不同类型的容器？</p>
</blockquote>
<blockquote>
<p>迭代器（也是一种设计模式）可以用于完成此目的。迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代器是一个轻量级对象：创建它的代价小。</p>
<ul>
<li><p>下标是从0开始的。</p>
</li>
<li><p>Java中的Iterator只能单向移动。这个Iterator只能用来：</p>
<ol>
<li>使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。</li>
<li>使用next()获得序列中的下一个元素。</li>
<li>使用hasNext()检查序列中是否还有元素。</li>
<li>使用remove()将迭代器新近返回的元素删除。（删除最近一次next()返回的元素）</li>
</ol>
</li>
<li><p>对迭代器进行修改的操作，最终也会导致原始容器内容的修改</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">//注意这里必须要求是ArrayList的对象，</span></span><br><span class="line">    List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//获取到该容器的迭代器</span></span><br><span class="line">    Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// A simpler approach, when possible:</span></span><br><span class="line">    <span class="keyword">for</span>(Pet p : pets)</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();	</span><br><span class="line">    <span class="comment">// An Iterator can also remove elements:</span></span><br><span class="line">    it = pets.iterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">        <span class="comment">//在调用remove方法之前，必须调用next()</span></span><br><span class="line">      it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Iterator的真正威力：能够将遍历序列的操作与序列底层的结构分离，正由于此，我们有时会说：迭代器同意了对容器的访问方式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossContainerIteration</span> &#123;</span><br><span class="line">    <span class="comment">//这里才是真正体现迭代器的威力</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Pet&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Pet&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Pet&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>ListIterator</strong></p>
<blockquote>
<p>ListIterator是一个更加强大的Iterator的子类型，<font color='red'>它只能用于各种List类的访问</font>。尽管Iterator只能向前移动，但是ListIterator可以双向移动。它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后元素。你可以通过调用listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就只想列表索引为n的元素处的ListIterator.</p>
<ul>
<li>set()方法也是修改最近一次next()或者previous()返回的方法。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">    ListIterator&lt;Pet&gt; it = pets.listIterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">      System.out.print(it.next() + <span class="string">&quot;, &quot;</span> + it.nextIndex() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.previousIndex() + <span class="string">&quot;; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// Backwards:</span></span><br><span class="line">    <span class="keyword">while</span>(it.hasPrevious())</span><br><span class="line">      System.out.print(it.previous().id() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(pets);	</span><br><span class="line">    it = pets.listIterator(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.set(Pets.randomPet());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;</span></span><br><span class="line"><span class="comment">7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="11-7-LinkedList"><a href="#11-7-LinkedList" class="headerlink" title="11.7 LinkedList"></a>11.7 LinkedList</h3><blockquote>
<p>可以使用LinkedList实现队列，栈或双端队列等结构</p>
</blockquote>
<h3 id="11-9-Set"><a href="#11-9-Set" class="headerlink" title="11.9  Set"></a>11.9  Set</h3><blockquote>
<ul>
<li>HashSet：快速查找，插入的顺序没有规律，使用的是散列函数</li>
<li>TreeSet：按照插入的元素升序排序，使用的是红-黑树数据结构 <ul>
<li>TreeSet继承自SortedSet。而SortedSet继承自Set</li>
</ul>
</li>
<li>LinkedHashSet：按照插入元素的顺序排序，查询速度也很快，所以也使用了散列。（继承自HashSet）</li>
</ul>
</blockquote>
<h3 id="11-12-Collection和Iterator"><a href="#11-12-Collection和Iterator" class="headerlink" title="11.12 Collection和Iterator"></a>11.12 Collection和Iterator</h3><blockquote>
<p>实现了Collection接口的类，具备了iterator()方法，所以就也需要提供Iterator的特性。</p>
<ul>
<li>当要实现一个不是Collection的外部类时，由于让它去实现Collection接口非常麻烦，因为要实现很多可能不必要的方法。，此时实现Iterator接口就非常有吸引力。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PetSequence</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> Pet[] pets = Pets.createArray(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonCollectionSequence</span> <span class="keyword">extends</span> <span class="title class_">PetSequence</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;Pet&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Pet&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; pets.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> Pet <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> pets[index++]; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">NonCollectionSequence</span> <span class="variable">nc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonCollectionSequence</span>();</span><br><span class="line">    InterfaceVsIterator.display(nc.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="11-13-foreach与迭代器"><a href="#11-13-foreach与迭代器" class="headerlink" title="11.13 foreach与迭代器"></a>11.13 foreach与迭代器</h3><blockquote>
<p>foreach语法不仅可以用于数组，还可以应用于所有的Collection对象，因为这些对象都实现了Iterable接口，该接口包含一个能够产生Iterator的iterator()方法，并且Iterator接口被foreach用来在序列中移动了。因此如果创建了任何实现Iterable的类，都可以将它用于foreach语句。</p>
<ul>
<li>&#x3D;&#x3D;细节：&#x3D;&#x3D;<ol>
<li>实现了Iterable接口的类就具备了foreach的能力</li>
<li>而实现Iterable接口，就需要实现提供I能够产生terator引用的iterator()方法</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IterableClass</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> String[] words = (<span class="string">&quot;And that is how &quot;</span> +</span><br><span class="line">    <span class="string">&quot;we know the Earth to be banana-shaped.&quot;</span>).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;String&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;String&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; words.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> words[index++]; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="keyword">new</span> <span class="title class_">IterableClass</span>())</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">And that is how we know the Earth to be banana-shaped.</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>能够用于foreach的不一定就都实现了Iterable接口，比如普通数组，就不能将一个数组对象传给Iterable接口引用。而必须通过显示转换。</p>
</blockquote>
<blockquote>
<p>Arrays.asList()方法：该方法产生的List对象会使用底层数组作为其物理实现，因此执行修改List的操作就也会修改原有的底层数组。所以如果不想原来的数组被修改，那么就应该在另一个副本中创建一个副本。</p>
<p>如：List<Integer> list&#x3D;new ArrayList(Arrays.asList(arr));此时对list内容的修改，不会影响到数组arr的内容。</p>
<p>​		List<Integer> list&#x3D;Arrays.asList(arr); 此时对list内容的修改也会影响到数组arr的内容。</p>
</blockquote>
<h2 id="第十二章：通过异常处理错误"><a href="#第十二章：通过异常处理错误" class="headerlink" title="第十二章：通过异常处理错误"></a>第十二章：通过异常处理错误</h2><h3 id="12-2-基本异常"><a href="#12-2-基本异常" class="headerlink" title="12.2 基本异常"></a>12.2 基本异常</h3><blockquote>
<ul>
<li>所有标准异常类都有两个构造器：一个是默认构造器，另一个是接受字符串参数作为参数，以便能把相关信息放入异常对象的构造器。</li>
<li>能够抛出任意类型的Throwable对象，它是异常类型的跟类。</li>
</ul>
</blockquote>
<h3 id="12-3-捕获异常"><a href="#12-3-捕获异常" class="headerlink" title="12.3 捕获异常"></a>12.3 捕获异常</h3><blockquote>
<ul>
<li><p>注意：在try块的内部，可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。</p>
</li>
<li><p>当用catch语句要捕获多个异常时，异常类型的父类（如Exception）要放在异常类型的子类（NullPointerException）后面进行捕获，否则会编译出错。</p>
</li>
</ul>
</blockquote>
<h3 id="12-4-创建自定义异常"><a href="#12-4-创建自定义异常" class="headerlink" title="12.4 创建自定义异常"></a>12.4 创建自定义异常</h3><blockquote>
<ul>
<li>要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。建立新的异常类型最简单的方法就是让编译器为你产生默认构造器。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己定义一个新的异常类型，继承自已有的异常类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritingExceptions</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> SimpleException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throw SimpleException from f()&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SimpleException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">InheritingExceptions</span> <span class="variable">sed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritingExceptions</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      sed.f();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SimpleException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Caught it!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Throw SimpleException from f()</span></span><br><span class="line"><span class="comment">Caught it!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">  <span class="comment">//继承了现有的机场类，并且定义了两个构造器方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span> &#123; <span class="built_in">super</span>(msg); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FullConstructors</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throwing MyException from f()&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throwing MyException from g()&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;Originated in g()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      f();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(MyException e) &#123;</span><br><span class="line">      e.printStackTrace(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      g();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(MyException e) &#123;</span><br><span class="line">      e.printStackTrace(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Throwing MyException from f()</span></span><br><span class="line"><span class="comment">MyException</span></span><br><span class="line"><span class="comment">        at FullConstructors.f(FullConstructors.java:11)</span></span><br><span class="line"><span class="comment">        at FullConstructors.main(FullConstructors.java:19)</span></span><br><span class="line"><span class="comment">Throwing MyException from g()</span></span><br><span class="line"><span class="comment">MyException: Originated in g()</span></span><br><span class="line"><span class="comment">        at FullConstructors.g(FullConstructors.java:15)</span></span><br><span class="line"><span class="comment">        at FullConstructors.main(FullConstructors.java:24)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>e1.printStackTrace(System.out); 在异常处理程序中，调用了子啊Throwable类声明（Exception即从此类继承）的printStackTrace()方法。他将打印“从方法调用处直到异常抛出处”的方法调用序列。这里信息就被发送到了System.out,并自动地捕获和显示在输出中。</li>
<li>但是如果调用默认版本：e1.printStackTrace();则信息将被输出到标准错误流。</li>
</ul>
</blockquote>
<p><strong>#这是默认的打印版本：</strong></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211216161902399.png" alt="image-20211216161902399"></p>
<p>#这是使用了System.out的方式</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211216162030348.png" alt="image-20211216162030348"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">NullPointerException</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestError</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test fun()&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TestError ts=<span class="keyword">new</span> <span class="title class_">TestError</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ts.fun();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MyException e1)&#123;</span><br><span class="line">            <span class="comment">//使用与不使用System.out的输出结果在上面</span></span><br><span class="line">            e1.printStackTrace(System.out);</span><br><span class="line">            System.out.println(<span class="string">&quot;进来没&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于异常类来说，Throwable类的getMessage()方法有点类似于toString()方法，所以当在定义完自己的异常类之后，可以对继承的Throwable类或者其子类中一些方法进行覆盖。</p>
</blockquote>
<h3 id="12-5-异常说明"><a href="#12-5-异常说明" class="headerlink" title="12.5 异常说明"></a>12.5 异常说明</h3><blockquote>
<p>异常说明：就是以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行响应的处理。属于方法声明的一部分，紧跟在形式参数列表之后。</p>
<ul>
<li>异常说明使用了附加的关键字throws，后面借一个所有潜在异常类型的列表。</li>
<li>形式如：void fun(int x1,…) throws 异常1，异常2{方法体内容}</li>
<li><font color='red'>细节：运行时异常（RuntimeException）可以不用显示声明（即用throws说明），或者catch也可以。而其他异常则必须进行异常说明或者进行捕获catch</font></li>
<li>可以声明方法将抛出异常，但是方法体内并不抛出异常（非运行时异常），此时会强制使用该方法的用户要像真的抛出异常那样使用这个方法（如必须对该声明的异常进行处理，要么抛出，要么捕获）</li>
</ul>
</blockquote>
<h3 id="12-6-捕获所有异常"><a href="#12-6-捕获所有异常" class="headerlink" title="12.6 捕获所有异常"></a>12.6 捕获所有异常</h3><blockquote>
<p>可以使用抛出异常的基类来进行捕获，这样就不用每一个都要进行捕获了，但是捕获基类的语句要写在导出类的后面，否则会出错。</p>
</blockquote>
<blockquote>
<p>printStackTrace()方法：这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一帧。细节：main()方法总是第一个进栈，所以在输出时就处于最后一个。(栈是先进后出结构)</p>
</blockquote>
<p><strong>重新抛出异常</strong></p>
<blockquote>
<ul>
<li><p>如果只是把当前异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。要想更新这个信息，可以调用fillInStackTrace()方法，这将返回一个Throwable对象。它是通过把当前调用栈信息填入原来那个异常对象而建立的。那么有关原来异常发生点的信息会丢失，剩下的是与新的抛出点有关的信息。</p>
</li>
<li><p>有可能在捕获异常之后抛出另一种异常，这么做的话，得到的效果类似于使用fillInStackTrace()，有关原来异发生点的信息将会丢失，剩下的是与新的抛出点有关的信息。</p>
</li>
</ul>
</blockquote>
<h3 id="12-7-Java标准异常"><a href="#12-7-Java标准异常" class="headerlink" title="12.7 Java标准异常"></a>12.7 Java标准异常</h3><blockquote>
<ul>
<li>Throwable这个Java类表示任何可以作为异常抛出的类。Throwable对象分为两种类型（指从Throwable继承而得到的类型）：Error(用来表示编译时和系统错误，除特殊情况外，一般不用关心)，Exception(是可以被抛出的基本类型)。而Exception又主要分为运行时异常（RuntimeException）和非运行时异常。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>运行时异常：他们会自动被虚拟机抛出，所以不必在异常说明中把他们列出来。他们也被称为不受检查异常。而其他类型的异常（非运行时异常）的异常处理是由编译器强制实施的。</li>
<li>如果运行时异常没有被捕获而直达main()，那么在程序退出前将调用异常的printStackTrace()方法</li>
</ul>
</blockquote>
<blockquote>
<p>运行时异常主要常见的有：NullPointerException。ArrayIndexOutofBoundsException。</p>
</blockquote>
<h3 id="12-8-用finally进行清理"><a href="#12-8-用finally进行清理" class="headerlink" title="12.8 用finally进行清理"></a>12.8 用finally进行清理</h3><p><strong>finally用来做什么</strong></p>
<blockquote>
<p>当要把除内存之外的资源恢复到他们的初始状态，就要用到finally子句。这种需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关</p>
</blockquote>
<blockquote>
<p>细节：当涉及到break和continue语句的时候，finally子句也会得到执行。</p>
</blockquote>
<p>在return中使用finally</p>
<blockquote>
<ul>
<li>因为finally子句总是会被执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。(&#x3D;&#x3D;finally语句总是会在return语句执行前就执行了&#x3D;&#x3D;)</li>
</ul>
</blockquote>
<blockquote>
<p>缺憾：异常丢失</p>
<ul>
<li>当有多层try块时，如果提前在finally块中执行了return语句的话，则在后面的catch语句就得不到执行，但应该注意的是后面的finally块仍然会被执行。</li>
</ul>
</blockquote>
<blockquote>
<p>细节：如果在finally语句中存在return语句，那么该方法后面的语句就都得不到调用，所以如果有，编译器就会报错。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test18</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;jjjj&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-9-异常的限制"><a href="#12-9-异常的限制" class="headerlink" title="12.9 异常的限制"></a>12.9 异常的限制</h3><blockquote>
<ul>
<li>当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常（或者父类抛出的异常的子类）。这个限制很重要，因为这意味着，当基类使用的代码应用到其派生类对象的时候，一样能够工作。（这个有点类似于限制覆盖方法时对返回值类型，形参有要求一样）</li>
<li>所以如果基类如果没有抛出异常，子类就也不能抛出异常</li>
</ul>
</blockquote>
<blockquote>
<p>细节：构造器方法也可以抛出异常（异常声明）</p>
<ul>
<li>细节：覆盖方法时对异常的限制，这个限制对构造器不能起作用。因为基类构造器必须以这样或那样的方式被调用（这里默认构造器将自动被调用），</li>
<li>但是派生类构造器的异常说明必须包括基类构造器的异常说明（必须是基类的异常或者其父类，与方法恰好相反）</li>
<li>派生类构造器不能捕获基类构造器抛出的异常。（因为super()语句永远在第一行执行）</li>
<li>所以，在某种意义上，在继承和覆盖的过程中，某个特定方法的异常说明的接口不是变大了而是变小了。这恰好和类接口在继承时的情形相反。</li>
</ul>
</blockquote>
<h3 id="12-10-构造器"><a href="#12-10-构造器" class="headerlink" title="12.10 构造器"></a>12.10 构造器</h3><blockquote>
<p>对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句</p>
<p>&#x3D;&#x3D;基本规则是：在创建要清理的对象之后，立即进入一个try-finally语句块&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cleanup</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputFile</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputFile</span>(<span class="string">&quot;Cleanup.java&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((s = in.getLine()) != <span class="literal">null</span>)</span><br><span class="line">          ; <span class="comment">// Perform line-by-line processing here...</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Caught Exception in main&quot;</span>);</span><br><span class="line">        e.printStackTrace(System.out);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.dispose();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;InputFile construction failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">dispose() successful</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="12-11-异常匹配"><a href="#12-11-异常匹配" class="headerlink" title="12.11 异常匹配"></a>12.11 异常匹配</h3><blockquote>
<ul>
<li><p>抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续寻找。</p>
</li>
<li><p>查找的时候并不要求完全匹配，派生类的对象也可以匹配基类的处理程序。如Exception可以接受RuntimeException的异常</p>
</li>
<li><p>如果把捕获基类的catch子句放在最前面，以此想把派生类的异常全给屏蔽掉，编译器会报错。</p>
</li>
</ul>
</blockquote>
<h3 id="12-12-其他可选方式"><a href="#12-12-其他可选方式" class="headerlink" title="12.12 其他可选方式"></a>12.12 其他可选方式</h3><blockquote>
<p>异常处理的一个重要原则是：只有在知道如何处理的情况下才捕获异常。</p>
</blockquote>
<h2 id="第十三章：字符串"><a href="#第十三章：字符串" class="headerlink" title="第十三章：字符串"></a>第十三章：字符串</h2><h3 id="13-2-重载“-”与StringBuilder"><a href="#13-2-重载“-”与StringBuilder" class="headerlink" title="13.2 重载“+”与StringBuilder"></a>13.2 重载“+”与StringBuilder</h3><blockquote>
<ul>
<li>String字符串在进行拼接时，实际上内部还是创建StringBuilder对象，调用该对象方法。</li>
<li>因此如果在进行频繁的拼接操作时，可以显式创建一个StringBuilder对象，这样减少了创建对象的过程以及利用垃圾回收机制回收中间对象的过程。</li>
<li>细节：StringBuilder是在jdk5引入的，之前用的是StringBuffer,后者是线程安全的，因此开销也会大些。</li>
</ul>
</blockquote>
<h3 id="13-5格式化输出"><a href="#13-5格式化输出" class="headerlink" title="13.5格式化输出"></a>13.5格式化输出</h3><blockquote>
<ul>
<li>format()方法与printf()是等价的，它们只需要一个简单的格式化字符串，加上一串参数即可，每个参数对应一个格式修饰符。</li>
<li>format()方法可以用于PrintStream或PrintWriter对象，其中也包括System.out对象。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFormat</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5.332542</span>;</span><br><span class="line">    <span class="comment">// The old way:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Row 1: [&quot;</span> + x + <span class="string">&quot; &quot;</span> + y + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="comment">// The new way:</span></span><br><span class="line">    System.out.format(<span class="string">&quot;Row 1: [%d %f]\n&quot;</span>, x, y);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;Row 1: [%d %f]\n&quot;</span>, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542]</span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542]</span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>Fomatter类</strong></p>
<blockquote>
<p>在Java中，所有新的格式化功能都由java.util.Formatter类处理。可以将Fomatter看作一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。</p>
</blockquote>
<blockquote>
<p>String.format()方法，以生成格式化的String对象。这是一个static方法，它接受与Formatter.format()方法一样的参数，但返回一个String对象 。</p>
</blockquote>
<h3 id="13-6-正则表达式（需要重点关注）"><a href="#13-6-正则表达式（需要重点关注）" class="headerlink" title="13.6 正则表达式（需要重点关注）"></a>13.6 正则表达式（需要重点关注）</h3><blockquote>
<ul>
<li>在Java中，字符串操作还主要集中于String,StringBuffer和StringTokenizer类，与正则表达式相比，他们只能提供相对简单的功能。</li>
<li>正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索。一旦找到了匹配这些模式的部分，你就能够随心所欲的对他们进行处理。正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题：匹配、选择、编辑以及验证。</li>
</ul>
</blockquote>
<blockquote>
<p>应用正则表达式的最简单的途径，就是利用String类内建的功能。例如，你可以检查一个String是否匹配如上所述的正则表达式：</p>
<ul>
<li>规则：<ul>
<li>-?：表示要找一个数字，它可能有一个负号在最前面</li>
<li>-?\d+：表示“可能有一个负号，后面跟着一位或多位数字”</li>
<li>\\：表示要插入一个普通的反斜杠</li>
<li>\d：表示想表示一个数字</li>
<li>(-|\+)?：表示可能以一个加号或减号开头   （因为+在正则表达式中有特殊的意义，所以必须使用\进行转义，使之成为一个普通字符）</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerMatch</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;-1234&quot;</span>.matches(<span class="string">&quot;-?\\d+&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;5678&quot;</span>.matches(<span class="string">&quot;-?\\d+&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;+911&quot;</span>.matches(<span class="string">&quot;-?\\d+&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;+911&quot;</span>.matches(<span class="string">&quot;(-|\\+)?\\d+&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>String类还自带了一个非常有用的正则表达式工具，split()方法，其功能是将字符串从正则表达式匹配的地方切开。</p>
<ul>
<li>规则：<ul>
<li>\W：他表示是一个非单词字符（如果W小写，\w,则表示一个单词字符）</li>
<li>\W+：他表示是一个或多个非单词字符（如果W小写，\w,则表示一个单词字符）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>String类自带的最后一个正则表达式工具是替换。你可以只替换正则表示式第一个匹配的子串，或是替换所有匹配的地方。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Replacing</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Splitting.knights;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(s.replaceFirst(<span class="string">&quot;f\\w+&quot;</span>, <span class="string">&quot;located&quot;</span>));</span><br><span class="line">    print(s.replaceAll(<span class="string">&quot;shrubbery|tree|herring&quot;</span>,<span class="string">&quot;banana&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Then, when you have located the shrubbery, you must cut down the mightiest tree in the forest... with... a herring!</span></span><br><span class="line"><span class="comment">Then, when you have found the banana, you must cut down the mightiest banana in the forest... with... a banana!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;Pattern和Matcher&#x3D;&#x3D;</p>
<blockquote>
<p>下面演示了这两个类的用法</p>
<ul>
<li>find()</li>
<li>matches()</li>
<li>start()</li>
<li>end()</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRegularExpression</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      print(<span class="string">&quot;Usage:\njava TestRegularExpression &quot;</span> +</span><br><span class="line">        <span class="string">&quot;characterSequence regularExpression+&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Input: \&quot;&quot;</span> + args[<span class="number">0</span>] + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String arg : args) &#123;</span><br><span class="line">      print(<span class="string">&quot;Regular expression: \&quot;&quot;</span> + arg + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(arg);</span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(args[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">        print(<span class="string">&quot;Match \&quot;&quot;</span> + m.group() + <span class="string">&quot;\&quot; at positions &quot;</span> +</span><br><span class="line">          m.start() + <span class="string">&quot;-&quot;</span> + (m.end() - <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Input: &quot;abcabcabcdefabc&quot;</span></span><br><span class="line"><span class="comment">Regular expression: &quot;abcabcabcdefabc&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abcabcabcdefabc&quot; at positions 0-14</span></span><br><span class="line"><span class="comment">Regular expression: &quot;abc+&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 0-2</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 3-5</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 6-8</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 12-14</span></span><br><span class="line"><span class="comment">Regular expression: &quot;(abc)+&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abcabcabc&quot; at positions 0-8</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 12-14</span></span><br><span class="line"><span class="comment">Regular expression: &quot;(abc)&#123;2,&#125;&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abcabcabc&quot; at positions 0-8</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第十四章：类型信息"><a href="#第十四章：类型信息" class="headerlink" title="第十四章：类型信息"></a>第十四章：类型信息</h2><blockquote>
<p><strong>运行时类型信息使得你可以在程序运行时发现和使用类型信息</strong></p>
<ul>
<li>Java是如何让我们在运行时识别对象和类的信息的。主要有两种方式：<ol>
<li>传统的RTTI,他假定我们在编译时已经知道了所有的类型。</li>
<li>另一种是反射机制，它允许我们在运行时发现和使用类的信息</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="14-2-Class对象"><a href="#14-2-Class对象" class="headerlink" title="14.2 Class对象"></a>14.2 Class对象</h3><blockquote>
<p>要理解RTTI在Java中的工作原理，首先需要知道类型信息在运行时是如何表示的。这项工作由Class对象的特殊对象来完成，它包含了与类有关的信息。Class对象就是用来创建类的所有的常规对象的。Java使用Class对象来执行其RTTI.Class类拥有大量的使用RTTI的其他方式。</p>
</blockquote>
<blockquote>
<p>使用Class.forName()来获取到某个类的Class对象的引用</p>
<p>细节：这里name是要用到带上包名的如javase.Hello,即使用全限定类名（包含包名）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;jinlaile&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;javase.Hello&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;没有发现&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(c.getName());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果已经拥有了该类的对象，则可以通过调用继承自Object类中的getClass()方法来获取该Class对象。</p>
</blockquote>
<blockquote>
<p>getInterfaces()：确定由该对象表示的类或接口实现的接口。</p>
<p>getSuperclass()：返回 <code>类</code>表示此所表示的实体（类，接口，基本类型或void）的超类 <code>类</code></p>
<p>getSimpleName()：来产生不包含包名的类名</p>
<p>getCanonicalName()：来产生全限定类名（包含包名）</p>
<p>newInstance()：是实现虚拟构造器的一种途径。可以不用new创建对象的一种方式。（该类必须有默认构造器）</p>
<p>getDeclaredFields()：返回此类或接口上所有的字段类对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HasBatteries</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Waterproof</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shoots</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Toy</span> &#123;</span><br><span class="line">  <span class="comment">// Comment out the following default constructor</span></span><br><span class="line">  <span class="comment">// to see NoSuchMethodError from (*1*)</span></span><br><span class="line">  Toy() &#123;&#125;</span><br><span class="line">  Toy(<span class="type">int</span> i) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FancyToy</span> <span class="keyword">extends</span> <span class="title class_">Toy</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">HasBatteries</span>, Waterproof, Shoots &#123;</span><br><span class="line">  FancyToy() &#123; <span class="built_in">super</span>(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToyTest</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(Class cc)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Class name: &quot;</span> + cc.getName() +</span><br><span class="line">      <span class="string">&quot; is interface? [&quot;</span> + cc.isInterface() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    print(<span class="string">&quot;Simple name: &quot;</span> + cc.getSimpleName());</span><br><span class="line">    print(<span class="string">&quot;Canonical name : &quot;</span> + cc.getCanonicalName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      c = Class.forName(<span class="string">&quot;typeinfo.toys.FancyToy&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Can&#x27;t find FancyToy&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printInfo(c);	</span><br><span class="line">    <span class="keyword">for</span>(Class face : c.getInterfaces())</span><br><span class="line">      printInfo(face);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">up</span> <span class="operator">=</span> c.getSuperclass();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Requires default constructor:</span></span><br><span class="line">      obj = up.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InstantiationException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Cannot instantiate&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalAccessException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Cannot access&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printInfo(obj.getClass());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.FancyToy is interface? [false]</span></span><br><span class="line"><span class="comment">Simple name: FancyToy</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.FancyToy</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.HasBatteries is interface? [true]</span></span><br><span class="line"><span class="comment">Simple name: HasBatteries</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.HasBatteries</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.Waterproof is interface? [true]</span></span><br><span class="line"><span class="comment">Simple name: Waterproof</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.Waterproof</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.Shoots is interface? [true]</span></span><br><span class="line"><span class="comment">Simple name: Shoots</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.Shoots</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.Toy is interface? [false]</span></span><br><span class="line"><span class="comment">Simple name: Toy</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.Toy</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>类字面常量</strong></p>
<p>Java还提供了另一种方法生成对Class对象的引用，即使用类字面常量。将如Person.class;</p>
<ul>
<li><p>好处：</p>
<ul>
<li>这样做更简单，而且更安全，因为它在编译时就会受到检查（不需要使用try-catch进行捕获），并且根除了对forName()方法的调用，所以也更高效。</li>
<li>该常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型，另外对于基本数据类型的包装器类，还有一个标准字段TYPE.TYPE是一个引用，指向对应的基本数据类型的Class对象。</li>
</ul>
</li>
<li><p>细节：当使用.class来创建对Class对象的引用时，不会自动地初始化Class对象。初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行。</p>
</li>
<li><p>为了使用类做的&#x3D;&#x3D;准备工作步骤&#x3D;&#x3D;：</p>
<ol>
<li>加载：这是由类加载器执行的。（类加载器是JVM的一部分）该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个Class对象。</li>
<li>链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并非如果必需的话，将解析这个类创建的对其他类的所有引用。</li>
<li>初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Initable</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">staticFinal</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">staticFinal2</span> <span class="operator">=</span></span><br><span class="line">    ClassInitialization.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Initializing Initable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Initable2</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticNonFinal</span> <span class="operator">=</span> <span class="number">147</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Initializing Initable2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Initable3</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticNonFinal</span> <span class="operator">=</span> <span class="number">74</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Initializing Initable3&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitialization</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">initable</span> <span class="operator">=</span> Initable.class;</span><br><span class="line">    System.out.println(<span class="string">&quot;After creating Initable ref&quot;</span>);</span><br><span class="line">    <span class="comment">// Does not trigger initialization:</span></span><br><span class="line">    System.out.println(Initable.staticFinal);</span><br><span class="line">    <span class="comment">// Does trigger initialization:</span></span><br><span class="line">    System.out.println(Initable.staticFinal2);</span><br><span class="line">    <span class="comment">// Does trigger initialization:</span></span><br><span class="line">    System.out.println(Initable2.staticNonFinal);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">initable3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Initable3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After creating Initable3 ref&quot;</span>);</span><br><span class="line">    System.out.println(Initable3.staticNonFinal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">After creating Initable ref</span></span><br><span class="line"><span class="comment">47</span></span><br><span class="line"><span class="comment">Initializing Initable</span></span><br><span class="line"><span class="comment">258</span></span><br><span class="line"><span class="comment">Initializing Initable2</span></span><br><span class="line"><span class="comment">147</span></span><br><span class="line"><span class="comment">Initializing Initable3</span></span><br><span class="line"><span class="comment">After creating Initable3 ref</span></span><br><span class="line"><span class="comment">74</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Class<T></p>
<p>Class&lt;?&gt;优于平凡的Class,即便它们是等价的。</p>
<p>Class&lt;? extends T&gt;为了创建一个Class引用，它被限定为某种类型，或该类型的任何子类型，你需要将通配符与extends关键字结合，创建一个范围。因此这与仅仅声明Class<Number>不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedClassReferences</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; bounded = <span class="type">int</span>.class;</span><br><span class="line">    bounded = <span class="type">double</span>.class;</span><br><span class="line">    bounded = Number.class;</span><br><span class="line">    <span class="comment">// Or anything else derived from Number.</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//Class&lt;Number&gt; c2=int.class;  //该种方式会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<p>当将泛型语法用于Class对象时，会发生一件有趣的事：newInstance()将返回该对象的确切类型，而不是平凡的Class那样返回的Object.</p>
<p>Class&lt;? extends T&gt;而如果和extends结合了，则返回的则是T.   </p>
</blockquote>
<h3 id="14-3-类型转换前先做检查"><a href="#14-3-类型转换前先做检查" class="headerlink" title="14.3 类型转换前先做检查"></a>14.3 类型转换前先做检查</h3><blockquote>
<p>RTTI在Java中还有第三种形式，就是关键字instanceof,它返回一个布尔值。告诉我们对象是不是某个&#x3D;&#x3D;特定类型&#x3D;&#x3D;的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">	((Dog)x).bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>动态的instanceof.Class.isInstanceof方法提供了一种动态的测试对象的途径。该方法返回<code>true</code>如果指定<code>Object</code>参数为非空并且可以转换为通过此表示的引用类型<code>类</code>对象</p>
</blockquote>
<h3 id="14-5-instanceof与Class的等价性"><a href="#14-5-instanceof与Class的等价性" class="headerlink" title="14.5 instanceof与Class的等价性"></a>14.5 instanceof与Class的等价性</h3><blockquote>
<p>子类对象或引用 instaceof 父类时会返回真</p>
<p>instanceof和isInstance()指的是“你是这个类吗，或者你是这个类的派生类吗”</p>
<p>而equals()和&#x3D;&#x3D;则比较的是实际的Class对象，而没有考虑继承，只是指是这个确切的类型吗或者不是</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FamilyVsExactType</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Testing x of type &quot;</span> + x.getClass());</span><br><span class="line">    print(<span class="string">&quot;x instanceof Base &quot;</span> + (x <span class="keyword">instanceof</span> Base));</span><br><span class="line">    print(<span class="string">&quot;x instanceof Derived &quot;</span>+ (x <span class="keyword">instanceof</span> Derived));</span><br><span class="line">    print(<span class="string">&quot;Base.isInstance(x) &quot;</span>+ Base.class.isInstance(x));</span><br><span class="line">    print(<span class="string">&quot;Derived.isInstance(x) &quot;</span> +</span><br><span class="line">      Derived.class.isInstance(x));</span><br><span class="line">    print(<span class="string">&quot;x.getClass() == Base.class &quot;</span> +</span><br><span class="line">      (x.getClass() == Base.class));</span><br><span class="line">    print(<span class="string">&quot;x.getClass() == Derived.class &quot;</span> +</span><br><span class="line">      (x.getClass() == Derived.class));</span><br><span class="line">    print(<span class="string">&quot;x.getClass().equals(Base.class)) &quot;</span>+</span><br><span class="line">      (x.getClass().equals(Base.class)));</span><br><span class="line">    print(<span class="string">&quot;x.getClass().equals(Derived.class)) &quot;</span> +</span><br><span class="line">      (x.getClass().equals(Derived.class)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">Base</span>());</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">Derived</span>());</span><br><span class="line">  &#125;	</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Testing x of type class typeinfo.Base</span></span><br><span class="line"><span class="comment">x instanceof Base true</span></span><br><span class="line"><span class="comment">x instanceof Derived false</span></span><br><span class="line"><span class="comment">Base.isInstance(x) true</span></span><br><span class="line"><span class="comment">Derived.isInstance(x) false</span></span><br><span class="line"><span class="comment">x.getClass() == Base.class true</span></span><br><span class="line"><span class="comment">x.getClass() == Derived.class false</span></span><br><span class="line"><span class="comment">x.getClass().equals(Base.class)) true</span></span><br><span class="line"><span class="comment">x.getClass().equals(Derived.class)) false</span></span><br><span class="line"><span class="comment">Testing x of type class typeinfo.Derived</span></span><br><span class="line"><span class="comment">x instanceof Base true</span></span><br><span class="line"><span class="comment">x instanceof Derived true</span></span><br><span class="line"><span class="comment">Base.isInstance(x) true</span></span><br><span class="line"><span class="comment">Derived.isInstance(x) true</span></span><br><span class="line"><span class="comment">x.getClass() == Base.class false</span></span><br><span class="line"><span class="comment">x.getClass() == Derived.class true</span></span><br><span class="line"><span class="comment">x.getClass().equals(Base.class)) false</span></span><br><span class="line"><span class="comment">x.getClass().equals(Derived.class)) true</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="14-6-反射：运行时的类信息"><a href="#14-6-反射：运行时的类信息" class="headerlink" title="14.6 反射：运行时的类信息"></a>14.6 反射：运行时的类信息</h3><blockquote>
<ul>
<li>Class类与java.lang.reflect类库一起对反射的概念进行了支持。，该类库包含了Field,Method以及Constructor类。这些类型的对象是由jvm在运行的时候创建的，用以表示未知类里对应的成员。</li>
<li>这样就可以使用Constructor创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。</li>
<li>还可以调用getFields()和getMethods()以及getConstructors()等很便利的方法，以返回表示字段、方法以及构造器的对象的数组</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>RTTI和反射之间真正的区别在于：<ul>
<li>对于RTTI来说，编译器在编译时打开和检查.class文件，换句话说，我们可以用普通方式调用对象的所有方法。</li>
<li>而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件的。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="14-7-动态代理"><a href="#14-7-动态代理" class="headerlink" title="14.7 动态代理"></a>14.7 动态代理</h3><blockquote>
<p>代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替实际对象的对象。这些操作通常涉及与实际对象的通信，因此代理通常充当着中间人的角色。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MethodSelector</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Object proxied;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MethodSelector</span><span class="params">(Object proxied)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.proxied = proxied;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Object</span><br><span class="line">  <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">  <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;interesting&quot;</span>))</span><br><span class="line">      print(<span class="string">&quot;Proxy detected the interesting method&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SomeMethods</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">boring1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">boring2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">interesting</span><span class="params">(String arg)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">boring3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementation</span> <span class="keyword">implements</span> <span class="title class_">SomeMethods</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boring1</span><span class="params">()</span> &#123; print(<span class="string">&quot;boring1&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boring2</span><span class="params">()</span> &#123; print(<span class="string">&quot;boring2&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interesting</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;interesting &quot;</span> + arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boring3</span><span class="params">()</span> &#123; print(<span class="string">&quot;boring3&quot;</span>); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectingMethods</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SomeMethods proxy= (SomeMethods)Proxy.newProxyInstance(</span><br><span class="line">      SomeMethods.class.getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; SomeMethods.class &#125;,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MethodSelector</span>(<span class="keyword">new</span> <span class="title class_">Implementation</span>()));</span><br><span class="line">    proxy.boring1();</span><br><span class="line">    proxy.boring2();</span><br><span class="line">    proxy.interesting(<span class="string">&quot;bonobo&quot;</span>);</span><br><span class="line">    proxy.boring3();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">boring1</span></span><br><span class="line"><span class="comment">boring2</span></span><br><span class="line"><span class="comment">Proxy detected the interesting method</span></span><br><span class="line"><span class="comment">interesting bonobo</span></span><br><span class="line"><span class="comment">boring3</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第十五章：泛型"><a href="#第十五章：泛型" class="headerlink" title="第十五章：泛型"></a>第十五章：泛型</h2><h2 id="第十六章：数组"><a href="#第十六章：数组" class="headerlink" title="第十六章：数组"></a>第十六章：数组</h2><h2 id="第十七章：容器深入研究"><a href="#第十七章：容器深入研究" class="headerlink" title="第十七章：容器深入研究"></a>第十七章：容器深入研究</h2><h2 id="第十八章：Java-I-O系统"><a href="#第十八章：Java-I-O系统" class="headerlink" title="第十八章：Java I&#x2F;O系统"></a>第十八章：Java I&#x2F;O系统</h2><h2 id="第十九章：枚举类型"><a href="#第十九章：枚举类型" class="headerlink" title="第十九章：枚举类型"></a>第十九章：枚举类型</h2><h2 id="第二十章：注解"><a href="#第二十章：注解" class="headerlink" title="第二十章：注解"></a>第二十章：注解</h2><h2 id="第二十一章：并发"><a href="#第二十一章：并发" class="headerlink" title="第二十一章：并发"></a>第二十一章：并发</h2><blockquote>
<p>因为web服务器经常包含多个处理器，而并发是充分利用这些处理器的理想方式。</p>
</blockquote>
<h3 id="21-1-并发的多面性"><a href="#21-1-并发的多面性" class="headerlink" title="21.1 并发的多面性"></a>21.1 并发的多面性</h3><blockquote>
<p>并发编程令人困惑的一个主要原因是：使用并发时需要解决的问题有多个，而实现并发的方式也有多种，并且在这两者之间没有明显的映射关系（通常只有模糊的界限）</p>
</blockquote>
<blockquote>
<p>并发解决的问题大体上可以分为“速度”和“设计可管理性”两种</p>
</blockquote>
<p><strong>21.1.1 更快的执行</strong></p>
<blockquote>
<p>并发是用于多处理器编程的基本工具。速度提高是以多核处理器的形式而不是更快的芯片的形式出现的，</p>
</blockquote>
<blockquote>
<ul>
<li><p>如果你有一台多处理器的机器，那么就可以在这些处理器之间分布多个任务，从而可以极大地提高吞吐量。这是使用强有力的多处理器Web服务器的常见情况，在为每个请求分配一个线程的程序中，它可以将大量的用户请求分布到多个CPU上。</p>
</li>
<li><p>但是并发是提高运行在单处理器上的程序的性能。</p>
</li>
<li><p>事实上，从性能角度看，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。（因为在单处理器上运行并发程序开销会更大，增加了上下文切换的代价【从一个任务切换到另一个任务】）</p>
</li>
<li><p>在单处理器系统中的性能提高的常见示例是事件驱动的编程。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>实现并发最直接的方式是操作系统级别使用进程。操作系统会将进程相互隔离开，因此他们不会彼此干涉，这使得使用进程编程相对容易一些。与此相反的是，像Java使用的这种并发系统会共享诸如内存和I&#x2F;O这样的资源，因此编写多线程程序最基本的困难在于协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。</li>
</ul>
</blockquote>
<blockquote>
<p>Java采取了更加创痛的方式，在顺序语言的基础上提供对线程的支持，与在多任务操作系统中分叉外部进程不同，线程机制是在由执行程序表示的单一的进程中创建任务，这种方式产生的一个好处是操作系统的透明性。</p>
</blockquote>
<p><strong>21.1.2 改进代码设计</strong></p>
<blockquote>
<ul>
<li><p>对于线程数量不够的处理方式是协作多线程。Java的线程机制是抢占式的，这表示调度机制对周期性地终端线程，将上下文切换到i给你一个线程，从而为每个线程都提供时间片，使得每个县册灰姑娘都会分配到数量合理的时间去驱动它的任务。</p>
</li>
<li><p>通常线程使你能够创建更加松散耦合的设计。</p>
</li>
</ul>
</blockquote>
<h3 id="21-2-基本的线程机制"><a href="#21-2-基本的线程机制" class="headerlink" title="21.2 基本的线程机制"></a>21.2 基本的线程机制</h3><blockquote>
<ul>
<li>并发编程是我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务（也被称为子任务），zh哦那个的每一个都将由执行线程来驱动。一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个人物都好像有其自己的CPU一样。&#x3D;&#x3D;其底层机制是切分CPU时间。&#x3D;&#x3D;</li>
<li>线程的一大好处是代码不必知道它是运行在具有一个还是多个CPU的机器上。</li>
<li>多任务和多线程时使用多处理器系统的最合理方式</li>
</ul>
</blockquote>
<p><strong>21.2.1 定义任务</strong></p>
<blockquote>
<ul>
<li>线程可以驱动任务，因此你需要&#x3D;&#x3D;一种描述任务的方式，这可以由Runnable接口来提供，要想定义任务，只需实现Runnable接口并编写run()方法，使得该任务可以执行你的命令&#x3D;&#x3D;。例如，下面的LiftOff任务将显式发射之前的倒计时.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiftOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> countDown=<span class="number">10</span>; <span class="comment">//default</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> taskCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id=taskCount++;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiftOff</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiftOff</span><span class="params">(<span class="type">int</span> countDown)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.countDown=countDown;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">status</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id+<span class="string">&quot;(&quot;</span>+(countDown&gt;<span class="number">0</span>?countDown:<span class="string">&quot;LiftOff!&quot;</span>)+<span class="string">&quot;),&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(status());</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在run()中对&#x3D;&#x3D;静态方法Thread.yield()的调用是对线程调度器（Java线程机制的一部分，可以将CPU从一个线程转义给另一个线程）的一种建议&#x3D;&#x3D;，它在声明：“我已经执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机”。这是可选的，这是为了能够看到任务换进换出的证明。（线程切换）</p>
</li>
<li><p>下面示例中，这个任务的run()不是由单独的线程驱动的，它是在main()中直接带哦用的（实际上，这里仍旧使用了线程，即总是分配给main()的那个线程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        LiftOff launch=<span class="keyword">new</span> <span class="title class_">LiftOff</span>();</span><br><span class="line">        launch.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x3D;&#x3D;当从Runnable导出一个类是，它必须具有run()方法，但是这个方法并无特殊之处——即它不会产生任何内在的线程能力。要实现线程行为，你必须显式的将一个任务附着到线程上。&#x3D;&#x3D;</p>
</li>
</ul>
</blockquote>
<p><strong>21.2.2 Thread类</strong></p>
<blockquote>
<ul>
<li>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器，下面的示例展示了如何使用Thread来驱动LiftOff对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicThreads</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for LiftOff&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">Waiting for LiftOff</span></span><br><span class="line"><span class="comment">#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Thread构造器只需要一个Runnable对象。&#x3D;&#x3D;调用Thread对象的start()方法为该线程执行必需的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务&#x3D;&#x3D;。可以看到Wating for LiftOff消息在倒计时完成之前就出现了。这是因为LiftOff.run()是由不同的线程的执行的，因此你仍旧可以执行main()线程中的其他操作。（这种能力并不局限于main()线程，任何线程都可以启动另一个线程）</li>
<li>可以很容易的添加更多的线程去驱动更多的任务。下面，你可以看到所有任务彼此之间是如何相互呼应的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoreBasicThreads</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LiftOff</span>()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting for liftOff&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">Waiting for LiftOff</span></span><br><span class="line"><span class="comment">#0(9), #1(9), #2(9), #3(9), #4(9), #0(8), #1(8), #2(8), #3(8), #4(8), #0(7), #1(7), #2(7), #3(7), #4(7), #0(6), #1(6), #2(6), #3(6), #4(6), #0(5), #1(5), #2(5), #3(5), #4(5), #0(4), #1(4), #2(4), #3(4), #4(4), #0(3), #1(3), #2(3), #3(3), #4(3), #0(2), #1(2), #2(2), #3(2), #4(2), #0(1), #1(1), #2(1), #3(1), #4(1), #0(Liftoff!), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的输出说明不同任务的执行在线程被换进换出时混在了一起。这种交换是由线程调度器自动控制的。如果在你的机器上有多个处理器，线程调度器将会在这些处理器之间默默地分发进程。</li>
<li>当main()创建Thread对象时，它并没有捕获任何对这些对象的引用。在使用普通对象时，这对于垃圾回收来说是一场公平的游戏，但是在使用Thread时，情况就不同了。每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且&#x3D;&#x3D;在它的任务退出其run()并死亡之前，垃圾回收器无法清除它&#x3D;&#x3D;。你可以从输出中看到，这些任务确实运行到了结束，因此，&#x3D;&#x3D;一个线程会创建一个单独的执行线程，在对start()的调用完成之后，它仍旧会在继续存在。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<p><strong>21.2.3 使用Executor</strong></p>
<blockquote>
<ul>
<li>JavaSE5的java.util.concurrent包中的&#x3D;&#x3D;执行器&#x3D;&#x3D;（Executor）将为你管理Thread对象，从而简化了并发编程。Excecutor在客户端和任务执行之间提供了一个间接层；与客户端直接执行任务不同这个中介对象将执行任务。Executor在JavaSE5&#x2F;6中是启动任务的优选方法。</li>
<li>可以使用Executor来代替在MoreBasicThreads.java中显式地创建Thread对象。ListOff对象知道如何运行具体的任务，与命令设计模式一样，它暴露了要执行的单一方法。ExecutorService(具有服务生命周期的Executor,例如关闭)知道如何构建恰当的上下文来执行Runnable对象。</li>
<li>在下面的实例中，&#x3D;&#x3D;CachedThreadPool将为每个任务都创建一个线程&#x3D;&#x3D;。注意，ExecutorService对象时使用静态的Executor方法创建的，这个方法可以确定其Executor类型：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务。</li>
<li>对shutdown()方法的调用可以防止新任务被提交给这个Executor,当前线程（在本例中，即驱动main()的线程）将继续运行在shutdown()被调用之前提交的所任务。这个程序将在Executor中的所有任务完成之后尽快退出。</li>
<li>可以将前面的CachedThreadPool替换为不同类型的Executor.&#x3D;&#x3D;FixedThreadPool使用了有限的线程集来执行所提交的任务。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//构造器参数就是线程的数量</span></span><br><span class="line">        ExecutorService exec=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(itn i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有了FixedThreadPool，你就可以一次性预先执行代价高昂的线程分配，因而也就可以限制线程的数量。</li>
<li>尽管本书将使用CachedThreadPool，但是也应该考虑在产生线程的代码中使用FixedThreadPool.CachedThreadPool在程序执行过程中通常会创建于所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式会引发问题是，才需要切换到FixedThreadPool.</li>
<li>SingleThreadExecutor就像是线程数量为1的FixedThreadPool.(它提供了一种重要的并发保证，其他线程额不会被并发调用。这会改变任务的加锁需求)。如果向SinglethreadExecutor提交了多个任务，那么么这些任务将排队，每个人物都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。SingleThreadExecutor会序列化所有提交给它的任务，并会维护它自己（隐藏）的悬挂任务队列。在下面的实例中，可以看到每个任务都是按照他们被提交的顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadExecutor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ExecutorService exec=Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!), #1(9), #1(8), #1(7), #1(6), #1(5), #1(4), #1(3), #1(2), #1(1), #1(Liftoff!), #2(9), #2(8), #2(7), #2(6), #2(5), #2(4), #2(3), #2(2), #2(1), #2(Liftoff!), #3(9), #3(8), #3(7), #3(6), #3(5), #3(4), #3(3), #3(2), #3(1), #3(Liftoff!), #4(9), #4(8), #4(7), #4(6), #4(5), #4(4), #4(3), #4(2), #4(1), #4(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;可以使用SingleThreadExecutor来运行很多个线程，以确保任意时刻在任何线程中都只有唯一的任务在运行&#x3D;&#x3D;，你不需要在共享资源上处理同步。有时候更好的解决方案是在资源上处理同步（后面学习），但是SingleThreadExecutor可以让你省区只是为了维持某些事物的原型而进行的各种努力。通过序列化任务，你可以消除对序列化对象的需求。</li>
</ul>
</blockquote>
<p><strong>21.2.4 从任务中产生返回值</strong></p>
<blockquote>
<ul>
<li>Runnable是执行工作的独立任务，但是它不返回任何值。&#x3D;&#x3D;如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口&#x3D;&#x3D;。在JavaSE5中引入的Callable是一个具有类型参数的泛型，&#x3D;&#x3D;它的类型参数表示的是从方法call()（而不是run()）中返回的值，并且必须使用executorService.submit()方法调用它&#x3D;&#x3D;，下面是一个实例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskWithResult</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TaskWithResult</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;result of TaskWithResult &quot;</span> + id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    ArrayList&lt;Future&lt;String&gt;&gt; results =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      results.add(exec.submit(<span class="keyword">new</span> <span class="title class_">TaskWithResult</span>(i)));</span><br><span class="line">    <span class="keyword">for</span>(Future&lt;String&gt; fs : results)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// get() blocks until completion:</span></span><br><span class="line">        System.out.println(fs.get());</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(ExecutionException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">result of TaskWithResult 0</span></span><br><span class="line"><span class="comment">result of TaskWithResult 1</span></span><br><span class="line"><span class="comment">result of TaskWithResult 2</span></span><br><span class="line"><span class="comment">result of TaskWithResult 3</span></span><br><span class="line"><span class="comment">result of TaskWithResult 4</span></span><br><span class="line"><span class="comment">result of TaskWithResult 5</span></span><br><span class="line"><span class="comment">result of TaskWithResult 6</span></span><br><span class="line"><span class="comment">result of TaskWithResult 7</span></span><br><span class="line"><span class="comment">result of TaskWithResult 8</span></span><br><span class="line"><span class="comment">result of TaskWithResult 9</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。你可以用isDone()方法来查询Future是否已经完成。当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果。你也可以不用isDone()进行检查就直接调用get(),在这种情况下，get()将阻塞，直至结果准备就绪。</li>
</ul>
</blockquote>
<p><strong>21.2.5 休眠</strong></p>
<blockquote>
<ul>
<li>影响任务行为的一种简单方法是调用sleep(),这将使任务中止来执行给定的时间。</li>
<li>对sleep()的调用可以抛出InterruptedException异常，并且你可以看到，它在run()中被捕获。&#x3D;&#x3D;因为异常不能跨线程传播会main(),所以必须在本地处理所有在任务内部产生的异常。&#x3D;&#x3D;</li>
<li>除了使用Thread.sleep()方法。JavaSE5引入了更加显式的sleep版本，作为TimeUnit类的一部分，因此可以提供更好的可阅读性，TimeUnit还可以被用来执行转换</li>
<li>如TimeUnit.MILLISECONDS.sleep(100);效果通Thread.sleep(100);</li>
</ul>
</blockquote>
<p><strong>21.2.6 优先级</strong></p>
<blockquote>
<ul>
<li>线程的优先级将线程的重要性传递给了调度器。尽管CPU处理现有县城及的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。然而，这并不意味这优先权较低的线程将得不到执行（也就是说，优先权不会导致死锁）。优先权较低的线程仅仅是执行的频率较低。</li>
<li>在绝大数时间里，所有线程都应该以默认的优先级运行。试图操纵现车给优先级通常是一种错误。</li>
<li>下面是一个演示优先级等级的实例，&#x3D;&#x3D;你可以用getPriority()来读取现有线程的优先级，并且在任何时刻都可以通过setPriority()来修改它。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePriorities</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> d; <span class="comment">// No optimization</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimplePriorities</span><span class="params">(<span class="type">int</span> priority)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.priority = priority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread() + <span class="string">&quot;: &quot;</span> + countDown;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().setPriority(priority);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// An expensive, interruptable operation:</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        d += (Math.PI + Math.E) / (<span class="type">double</span>)i;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">          Thread.<span class="keyword">yield</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">if</span>(--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimplePriorities</span>(Thread.MIN_PRIORITY));</span><br><span class="line">    exec.execute(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimplePriorities</span>(Thread.MAX_PRIORITY));</span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (70% match)</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 4</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 3</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 2</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 1</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-3,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-2,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-1,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-5,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-4,1,main]: 5</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Thread.toString()方法来打印线程的名称、线程的优先级以及线程所属的线程组。你可以通过构造器来自己设置这个名称。这里是自动生成的名称，如ppol-1-thred-1,pool-1-thred-2等。</li>
<li>通过调用Thread.currentThread()来获得对驱动该任务的Thread对象的引用。</li>
<li>优先级是在run()的开头部分设定的，在构造器中设置他们不会有任何好处，因为executor在此刻还没有开始执行任务。</li>
<li>变量d是用volatile修饰的，以努力确保不进行任何编译器优化。</li>
<li>尽管JDK有10个优先级，但它与多数操作系统不饿能映射得很好，唯一可移植得方法是当调整优先级得时候，只是用MAX_PRIORITY、NORM_PRIORITY和MIN_PRIORITY三种级别。</li>
</ul>
</blockquote>
<p><strong>21.2.7 让步</strong></p>
<blockquote>
<p>让步是通过Thread.yield()方法来完成的，这个只是建议并不是强制，所以大体上对于重要的控制或在调整应用时，都不能依赖于yield().</p>
</blockquote>
<p><strong>21.2.8 后台线程</strong></p>
<blockquote>
<ul>
<li>所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程。并且这种线程并不属于程序中不可或缺的部分。因此，&#x3D;&#x3D;当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程&#x3D;&#x3D;。反过来说，只要有任何非后台线程还在执行，程序就不会终止。比如，执行main()的就是一个非后台线程。</li>
<li>必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        print(Thread.currentThread() + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;sleep() interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SimpleDaemons</span>());</span><br><span class="line">      daemon.setDaemon(<span class="literal">true</span>); <span class="comment">// Must call before start()</span></span><br><span class="line">      daemon.start();</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;All daemons started&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">All daemons started</span></span><br><span class="line"><span class="comment">Thread[Thread-0,5,main] SimpleDaemons@530daa</span></span><br><span class="line"><span class="comment">Thread[Thread-1,5,main] SimpleDaemons@a62fc3</span></span><br><span class="line"><span class="comment">Thread[Thread-2,5,main] SimpleDaemons@89ae9e</span></span><br><span class="line"><span class="comment">Thread[Thread-3,5,main] SimpleDaemons@1270b73</span></span><br><span class="line"><span class="comment">Thread[Thread-4,5,main] SimpleDaemons@60aeb0</span></span><br><span class="line"><span class="comment">Thread[Thread-5,5,main] SimpleDaemons@16caf43</span></span><br><span class="line"><span class="comment">Thread[Thread-6,5,main] SimpleDaemons@66848c</span></span><br><span class="line"><span class="comment">Thread[Thread-7,5,main] SimpleDaemons@8813f2</span></span><br><span class="line"><span class="comment">Thread[Thread-8,5,main] SimpleDaemons@1d58aae</span></span><br><span class="line"><span class="comment">Thread[Thread-9,5,main] SimpleDaemons@83cc67</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过调用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程。</li>
<li>你应该意识到后台进程在不执行finally子句的情况下就会终止其run()方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADaemon</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      print(<span class="string">&quot;Starting ADaemon&quot;</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via InterruptedException&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      print(<span class="string">&quot;This should always run?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonsDontRunFinally</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ADaemon</span>());</span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    t.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Starting ADaemon</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当运行这个程序时，将看到finally子句就不会执行。但是如果注释掉对setDaemon()的调用，就会看到fiinally的调用，就会看到finally的执行。</li>
<li>&#x3D;&#x3D;当最后一个非后台线程终止时，后台线程会突然终止。因此一旦main()退出，jvm就会立即关闭所有的后台进程。&#x3D;&#x3D;而不会有任何你希望出现的确认形式。因为你不能以优雅的方式来关闭后台线程，所以它们呢几乎不是一种好的思想。非后台的Executor通常是一种更好的方式，因为Executor控制的所有任务可以同时被关闭，关闭并且以有序的方式执行。</li>
</ul>
</blockquote>
<p><strong>21.2.9 编码的变体</strong></p>
<blockquote>
<ul>
<li>在前面的示例中，任务类都实现了Runnable.在非常简单的情况下，你可能会希望使用直接从Thread继承这种可替换的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> threadCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleThread</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//store the thread name</span></span><br><span class="line">        <span class="built_in">super</span>(Integer.toString(++threadCount));</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>+getName()+<span class="string">&quot;(&quot;</span>+countDown+<span class="string">&quot;),&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span>(--countDown==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SimpleThread</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过调用适当的Thread构造器为Thread对象赋予具体的名称，这个名称可以通过使用getName()从toString()中获得。</li>
<li>另一种可能会看到的管用法是自管理的Runnable:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfManaged</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SelfManaged</span><span class="params">()</span> &#123; t.start(); &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName() +</span><br><span class="line">      <span class="string">&quot;(&quot;</span> + countDown + <span class="string">&quot;), &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      System.out.print(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">if</span>(--countDown == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SelfManaged</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Thread-0(5), Thread-0(4), Thread-0(3), Thread-0(2), Thread-0(1), Thread-1(5), Thread-1(4), Thread-1(3), Thread-1(2), Thread-1(1), Thread-2(5), Thread-2(4), Thread-2(3), Thread-2(2), Thread-2(1), Thread-3(5), Thread-3(4), Thread-3(3), Thread-3(2), Thread-3(1), Thread-4(5), Thread-4(4), Thread-4(3), Thread-4(2), Thread-4(1),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这与从Thread继承并没有什么特别的差异，但是实现接口使得可以继承另一个不同的类。</li>
</ul>
</blockquote>
<p><strong>21.2.10 术语</strong></p>
<blockquote>
<ul>
<li>在Java中，Thread类自身并不执行任何操作，它只是驱动赋予它的任务，但在线程研究中总是不变得使用线程执行这项或那项动作的语言。</li>
<li>我将尝试着在描述将要执行的工作时使用术语“任务”，只有在我引用到驱动任务的具体机制时，才使用线程。</li>
</ul>
</blockquote>
<p><strong>21.2.11 加入一个线程</strong></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复&#x3D;&#x3D;。（即t.isAlive()返回为假）【如下面的Joiner这个线程在Sleeper线程t上调用t.join()】</li>
<li>也可以在调用join()时带上一个超时参数（单位可以是秒，或者毫秒，纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。</li>
<li>对join()方法的调用可以被中断，做法时在调用线程上调用interrupt()方法，这时需要用到try-catch子句</li>
<li>下面这个例子演示了所有这些操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sleeper</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> duration;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sleeper</span><span class="params">(String name,<span class="type">int</span> sleepTime)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        duration=sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//线程正常情况下处于非中断状态，即 isInterrupted()返回false</span></span><br><span class="line">            sleep(duration);   <span class="comment">//但是在执行完sleep、wait这些方法时就会进入中断状态</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            print(getName()+<span class="string">&quot; was interrupted.&quot;</span>+<span class="string">&quot;isInterrupted():&quot;</span>+isInterrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print(getName()+<span class="string">&quot; has awakened&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Joiner</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sleeper sleeper;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Joiner</span><span class="params">(String name,Sleeper sleeper)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.sleeper=sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sleeper.join();  <span class="comment">//joiner这个线程自身会被挂起，要等到 sleeper线程执行结束后太进行执行</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            print(<span class="string">&quot;Interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        print(getName()+<span class="string">&quot; join completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joining</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Sleeper sleepy=<span class="keyword">new</span> <span class="title class_">Sleeper</span>(<span class="string">&quot;Sleepy&quot;</span>,<span class="number">1500</span>),grumpy=<span class="keyword">new</span> <span class="title class_">Sleeper</span>(<span class="string">&quot;Grumpy&quot;</span>,<span class="number">1500</span>);</span><br><span class="line">        Joiner dopey=<span class="keyword">new</span> <span class="title class_">Joiner</span>(<span class="string">&quot;Dopey&quot;</span>,sleepy),doc=<span class="keyword">new</span> <span class="title class_">Joiner</span>(<span class="string">&quot;Doc&quot;</span>,grumpy);</span><br><span class="line">        <span class="comment">//打破当前线程的中断状态，并返回一个中断异常</span></span><br><span class="line">        grumpy.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**Output:</span></span><br><span class="line"><span class="comment">Grumpy was interrupted. isInterrupted():false</span></span><br><span class="line"><span class="comment">Doc join completed</span></span><br><span class="line"><span class="comment">Sleepy has awakened</span></span><br><span class="line"><span class="comment">Dopey join completed</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:/~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Sleeper是一个Thread类型，它要休眠一段时间，这段时间是通过构造器传进来的参数所指定的。在run()中,sleep()方法有可能在指定的时间期满时返回，但也有可能中断。在catch子句中，将根据isInterrupted()的返回值报告这个中断。&#x3D;&#x3D;当另一个线程在该线程上调用interrupt()时，将给该线程设定一个标志，表明该线程已经被中断。然而，异常被捕获时将清理这个标志，所以在catch子句中，在一场被捕获的时候这个标志总是为假&#x3D;&#x3D;。除异常之外，这个标志还可用于其他情况，比如线程可能会检查其中断状态。</li>
<li>JavaSE5的java.util.concurrent类库包含诸如CyclicBarrier(后面会展示)这样的工具，他们可能比最初的线程类库中的join()更加合适。</li>
</ul>
</blockquote>
<p><strong>21.2.12 建立有响应的页面</strong></p>
<p><strong>21.2.13 线程组</strong></p>
<blockquote>
<p>线程组是一个线程集合。最好把线程组看成是一次不成功的尝试，你只要忽略它就好了。</p>
</blockquote>
<p><strong>21.2.14 捕获异常</strong></p>
<blockquote>
<ul>
<li>由于线程的本质特性，使得你不能捕获从线程中逃逸的异常，一旦一场逃出任务的run()方法，它就会向外传播到控制台。除非采取特殊的步骤捕获这种错误的异常。在JavaSE5之前，可以使用i安承祖来捕获这些异常，但是有了Java SE5，就可以用Executor来解决这个问题。</li>
<li>下面的任务总是会抛出一个异常，该异常会传播到其run()方法的外部，并且main()展示了你运行它时所发生的事情。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面这个会报错。如果把main主体放入try-catch中也是没有作用的。</li>
<li>为了解决这个问题，我们要修改Executor产生线程的方式。Thread.UncaughtExceptionHandler是Java SE5中的新接口，它允许你再每个Thread对象上给附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;run() by &quot;</span> + t);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;caught &quot;</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span> + <span class="string">&quot; creating new Thread&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    System.out.println(<span class="string">&quot;created &quot;</span> + t);</span><br><span class="line">    t.setUncaughtExceptionHandler(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptureUncaughtException</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">HandlerThreadFactory</span>());</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread2</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">HandlerThreadFactory@de6ced creating new Thread</span></span><br><span class="line"><span class="comment">created Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">eh = MyUncaughtExceptionHandler@1fb8ee3</span></span><br><span class="line"><span class="comment">run() by Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">eh = MyUncaughtExceptionHandler@1fb8ee3</span></span><br><span class="line"><span class="comment">caught java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在程序中添加了额外的跟踪机制，用来验证工厂创建的线程会传递给UncaughtExceptionHandler。现在可以看到，未捕获的异常是通过uncaughtException来捕获的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方式是在Thread类中设置一个静态域，并将这个处理器设置为默认的未捕获异常处理器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t,Throwable e)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;caught &quot;</span>+e);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SettingDefaultHandler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>());</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**output:</span></span><br><span class="line"><span class="comment">caught java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">*/</span>/~</span><br></pre></td></tr></table></figure>

<ul>
<li>这个处理器只有在不存在线程专有的未捕获异常处理器的情况下才会被调用。系统会检查线程专有版本，如果没有发现，则检查线程组是否有其专有的uncaughtException()方法，如果也没有，再调用defaultUncaughtExceptionHandler.</li>
</ul>
</blockquote>
<h3 id="21-3-共享受限资源"><a href="#21-3-共享受限资源" class="headerlink" title="21.3  共享受限资源"></a>21.3  共享受限资源</h3><p><strong>21.3.1 不正确的访问资源</strong></p>
<blockquote>
<p>我们可以发现，在Java中，递增不是原子性的操作</p>
</blockquote>
<p><strong>21.3.2 解决共享资源竞争</strong></p>
<blockquote>
<ul>
<li>对于并发工作，你需要某种方式来防止两个任务访问相同的资源，至少在关键阶段不能出现这种情况。</li>
<li>防止这种冲突的方法就是当资源被一个任务使用时，在其上加上锁。</li>
<li>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。这意味着在给定时刻只允许一个任务访问共享资源。&#x3D;&#x3D;通常这是通过在代码前面加上一条锁语句来实现的。因为锁语句产生了一种相排斥的效果，所以这种机制常常称为互斥量（mutex）&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;Java以提供关键字synchronized的形式，为防止资源冲突提供了内置支持。&#x3D;&#x3D;当任务要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，然后获取锁，执行代码，释放锁。</li>
<li>共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入&#x2F;输出端口，或者是打印机。要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为synchronized。如果某个任务处于一个对标记为synchronized的方法的调用中，那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。</li>
<li>对于某个特定对象来说，其所有synchronized方法共享同一个锁，这可以用来放置多个任务同时访问被编码为对象内存。</li>
<li>注意，&#x3D;&#x3D;在使用并发时，将域设置为private是非常重要的&#x3D;&#x3D;，否则，synchronized关键字就不能放置其他任务直接访问域，这样就会产生冲突。</li>
<li>一个任务可以多次获得对象的锁。</li>
<li>针对每个类，也有一个类（作为类的Class对象的一部分），所以synchronized static方法可以在类的范围内防止对static数据的并发访问。</li>
<li>你应该什么时候同步（synchronized）呢？可以运用Brian的同步规则：<ul>
<li>如果&#x3D;&#x3D;你正在写一个变量，它可能接下来将被另一个线程读取&#x3D;&#x3D;，或者&#x3D;&#x3D;正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步&#x3D;&#x3D;，并且，&#x3D;&#x3D;读写线程都必须用相同的监视器锁同步&#x3D;&#x3D;。</li>
</ul>
</li>
<li>如果在你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。如果只同步一个方法，那么其他方法将会随意地忽略这个对象锁，并可以在无任何惩罚地情况下被调用。这是很重要地一点：每个访问临界共享资源地方法都必须被同步，否则它们就不会正确地工作。</li>
<li>示例可以见练习11</li>
</ul>
</blockquote>
<p><strong>使用显式地Lock对象</strong></p>
<blockquote>
<ul>
<li><p>JavaSE5地java.util.concurrent类库还包含有定义在java.util.concurrent.locks中地显式地互斥机制</p>
</li>
<li><p>Lock对象必须被显式地创建、锁定和释放，因此它与内建地锁形式相比，代码缺乏优雅性。但是，对于解决某些类型地问题来说，它更加灵活。</p>
</li>
<li><p>示例见：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title class_">IntGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentEvenValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      Thread.<span class="keyword">yield</span>(); <span class="comment">// Cause failure faster</span></span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    EvenChecker.test(<span class="keyword">new</span> <span class="title class_">MutexEvenGenerator</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MutexEvenGenerator添加了一个被相互调用地锁，并使用lock()和unlock()方法在next()内部创建了临界资源。当你在使用Lock对象时，将这里地惯用写法内部化非常重要：紧接着地对lock()地调用，你必须放置在finally子句中带有unlock()的try-finally语句中。注意，return语句必须在try子句中出现，以确保unlock()不会过早发生，从而将数据暴露给了第二个任务。</li>
<li>如果在使用synchronized关键字时，如果某些事务失败了，那么就会抛出一个异常。但是你没有机会去做任何清理动作，以维护系统使其处于良好状态。有了显式的Lock对象，你就可以使用finally子句将维护系统在正确的状态。</li>
<li>大体上，当你使用synchronized关键字时，需要写的代码量更少，并且用户错误出现的可能性也会降低，因此通常只有解决特殊问题时，才使用显式的Lock对象。例如，用synchronized关键字蹦年尝试和获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后放弃它，要实现这些，你必须使用concurrent类库。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttemptLocking</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">untimed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">captured</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;tryLock(): &quot;</span> + captured);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(captured)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">captured</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      captured = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;tryLock(2, TimeUnit.SECONDS): &quot;</span> +</span><br><span class="line">        captured);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(captured)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AttemptLocking</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AttemptLocking</span>();</span><br><span class="line">    al.untimed(); <span class="comment">// True -- lock is available</span></span><br><span class="line">    al.timed();   <span class="comment">// True -- lock is available</span></span><br><span class="line">    <span class="comment">// Now create a separate task to grab the lock:</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      &#123; setDaemon(<span class="literal">true</span>); &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        al.lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;acquired&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    Thread.<span class="keyword">yield</span>(); <span class="comment">// Give the 2nd task a chance</span></span><br><span class="line">    al.untimed(); <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">    al.timed();   <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">tryLock(): true</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class="line"><span class="comment">acquired</span></span><br><span class="line"><span class="comment">tryLock(): false</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): false</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显式的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁来说，还赋予了你更细粒度的控制力。这对于实现专有同步结构是很有用的，例如用于遍历链接列表中的节点的节点传递的加锁机制（也称为锁耦合），这种遍历代码必须在释放当前节点的锁之前捕获下一个节点的锁</li>
</ul>
</blockquote>
<p><strong>21.3.3 原子性与易变性</strong></p>
<blockquote>
<ul>
<li>在有关Java线程的讨论中，一个常不正确的知识是“原子操作不需要进行同步控制”。&#x3D;&#x3D;原子操作是不能被线程调度机制中断的操作；&#x3D;&#x3D;一旦操作开始，那么它一定可以在可能发生的上下文切换之前（切换到其他线程执行）执行完毕。&#x3D;&#x3D;依赖于原子性是很棘手且很危险的。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;原子性可以应用于除long和double之外的所有基本类型之上的简单操作&#x3D;&#x3D;。对于读取和写入除long和double之外的基本类型变量这样的操作，可以保证他们会被当做不可分（原子）的操作来操作内存。但是jvm可以将64位（long和double变量）的读取和写入当作两个分离的32位操作来执行，这就产生了一个读取和写入操作中间发生上下文切换，从而导致不同的任务可以看到不正确结果的可能性。&#x3D;&#x3D;但是当你定义long或double变量时，如果使用volatile关键字，就会获得（简单的赋值于返回操作的）原子性&#x3D;&#x3D;。</li>
<li>原子操作可由线程机制来保证其不可中断，但是这是一种过于简化的机制，有时看起来应该是安全的原子操作，实际上也可能不安全。&#x3D;&#x3D;因此不要尝试用原子操作来替换同步。&#x3D;&#x3D;</li>
<li>多处理器系统（现在以多核处理器的形式出现，即在单个芯片上有多个CPU），相对于单处理器系统而言，可视性问题远比原子性问题多得多。</li>
<li>一个任务做出的修改，即使在不中断的意义上讲是原子性的，对其他任务也可能是不可视的（例如修改只是暂时性地存储在本地处理器地缓存中），因此不同地任务对应用地状态有不同的视图。另一方面，&#x3D;&#x3D;同步机制强制在处理器系统中，一个任务做出的修改必须在应用中是可视的。如果没有同步机制，那么修改时可视将无法确定。&#x3D;&#x3D;</li>
<li>volatile关键字还确保了应用中的可视性。如果你讲一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。即便使用本地缓存，情况也确实如此，volatile域会立即被写入到主存中，而读取操作就大声在主存中。</li>
<li>理解原子性和易变性是不同的概念这一点很重要。在非volatile域上的操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值。如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。&#x3D;&#x3D;同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来保护，那就不必将其设置为是volatile的&#x3D;&#x3D;。</li>
<li>一个任务所作的任何写入操作对这个任务来说都是可视的，因此如果它只需要在这个任务内部可视，那么你就不需要将其设置为volatile的。</li>
<li>当一个域的值依赖于它之前的值（例如递增一个计数器），volatile就无法工作了。如果某个某个域的值受到其他域的值的限制，那么volatile也无法工作，例如Range类的lower和upper边界就必须遵循lower&lt;&#x3D;upper的限制。</li>
<li>&#x3D;&#x3D;使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域&#x3D;&#x3D;。因此我们的第一选择还应该是使用synchronized关键字，这是最安全的方式。</li>
<li>什么才是原子操作呢？<ul>
<li>对域中的值做赋值和返回操作通常都是原子性的。</li>
</ul>
</li>
<li>基本上，如果一个域可能会被多个任务同时访问，或者这些任务中至少有一个是写入任务，那么你就应该将这个域设置为volatile的。</li>
</ul>
</blockquote>
<p><strong>21.3.4 原子类</strong></p>
<blockquote>
<ul>
<li>Java SE5引入了诸如AtomicInteger,AtomicLong,AtomicReference等特殊的原子性变量类，他们提供下面形式的原子性条件更新操作：<ul>
<li>boolean compareAndSet(expectedValue,updateVaule);</li>
</ul>
</li>
<li>这些类被调整为可以使用在某些现代处理器上的而可获得的、并且是在机器级别上的原子性，，可以同时使用这些而消除了synchronized关键字。</li>
<li>应该强调的是，Atomic类被设计用来用来构建java.util.concurrent中的类，因此只有在特殊情况下才在自己的代码中使用。通常依赖于锁要更安全一些（要么是synchronized关键字，要么是显式的Lock对象）</li>
</ul>
</blockquote>
<p><strong>21.3.5 临界区</strong></p>
<blockquote>
<ul>
<li>有时，你只是希望防止多个线程同时防问方法内部的部分代码，而不是防止访问整个方法。通过这种方式分离出来的代码被称为临界区（critical section）,它也使用synchronized关键字建立。这里，synchronized被用来指定某个对象，此对象的锁被用来对花括号内代码进行同步控制：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject)&#123;   <span class="comment">//这里面一般放类对象this</span></span><br><span class="line">	<span class="comment">//This code can be accessed by only one task at a time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这也被称为同步控制快，在进入此段代码前，必须得到syncObject对象的锁。如果其他线程已经得到这个锁，那么就得等到锁被释放以后，才能进入临界区。</li>
<li>通过使用同步控制块，而不是对整个方法进行同步控制，可以使多个任务访问对象的时间性能得到显著提高，所以对象不加锁的时间更长。这也是宁愿使用同步控制快而不是整个方法进行同步控制的典型原因：使得其他线程能更多的访问（在安全的情况下尽可能多）。</li>
<li>还可以使用显式的Lock对象来创建临界区</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synchronize the entire method:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitPairManager1</span> <span class="keyword">extends</span> <span class="title class_">PairManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      p.incrementX();</span><br><span class="line">      p.incrementY();</span><br><span class="line">      store(getPair());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use a critical section:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitPairManager2</span> <span class="keyword">extends</span> <span class="title class_">PairManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    Pair temp;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      p.incrementX();</span><br><span class="line">      p.incrementY();</span><br><span class="line">      temp = getPair();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    store(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExplicitCriticalSection</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">PairManager</span></span><br><span class="line">      <span class="variable">pman1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExplicitPairManager1</span>(),</span><br><span class="line">      pman2 = <span class="keyword">new</span> <span class="title class_">ExplicitPairManager2</span>();</span><br><span class="line">    CriticalSection.testApproaches(pman1, pman2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">pm1: Pair: x: 15, y: 15 checkCounter = 174035</span></span><br><span class="line"><span class="comment">pm2: Pair: x: 16, y: 16 checkCounter = 2608588</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主要重要的点是在ExplicitPairManager2中的store()方法在临界区外</li>
</ul>
</blockquote>
<p><strong>21.3.6 在其它对象上同步</strong></p>
<blockquote>
<ul>
<li>synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象：synchronized(this),在这种方式中，如果获得了synchronized块上的锁，那么该对象其他的synchronized方法和临界区就不能被调用了。因此，如果在this上同步，临界区的效果就会直接缩小在同步的范围内。</li>
<li>有时必须在另一个对象上同步，但是如果你这么做，就必须确保所有相关的任务都是在同一个对象上同步的。下面的示例演示了两个任务可以同时进入同一个对象，只要这个对象上的方法是在不同的锁上同步的即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DualSynch</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">syncObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">      Thread.<span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(syncObject) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        print(<span class="string">&quot;g()&quot;</span>);</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncObject</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DualSynch</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DualSynch</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ds.f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    ds.g();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>DualSync.f()（通过同步整个方法）在this同步，而g()有一个在syncObject上同步的syncchronized块。因此这两个同步是相互独立的。通过在main()中创建调用f()的Thread对这一个点进行了演示，因为main()线程是被用爱调用g()的。从输出中可以看到，这两个方式在同时运行，因此任何一个方法都没有因为对另一个方法的同步而阻塞。</p>
</li>
<li><p>当使用synchronized临界区时，通过不同的syncObject对象来进行演示，这是重点。</p>
</li>
<li><p>下面这个练习是使用显式对象，来演示在其他对象上同步。重点在于使用不同的锁对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test16</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj2=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> Object obj3=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock locka=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Lock lockb=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Lock lockc=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            locka.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            locka.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lockb.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockb.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lockc.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockc.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exec16</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test16 test16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exec16</span><span class="params">(Test16 test16)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.test16=test16;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        test16.funA();</span><br><span class="line"><span class="comment">//        Thread.yield();</span></span><br><span class="line">        test16.funB();</span><br><span class="line"><span class="comment">//        Thread.yield();</span></span><br><span class="line">        test16.funC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exec16Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Test16 t=<span class="keyword">new</span> <span class="title class_">Test16</span>();</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Exec16</span>(t));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>21.3.7 线程本地存储</strong></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。&#x3D;&#x3D;因此，如果你有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储块。主要是，他们可以使得你可以将状态与线程关联起来。</li>
<li>创建和管理线程本地存储可以由java.lang.ThreadLocal类来实现，如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Accessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Accessor</span><span class="params">(<span class="type">int</span> idn)</span> &#123; id = idn; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      ThreadLocalVariableHolder.increment();</span><br><span class="line">      System.out.println(<span class="built_in">this</span>);</span><br><span class="line">      Thread.<span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">      ThreadLocalVariableHolder.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalVariableHolder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(<span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    value.set(value.get() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value.get(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">Accessor</span>(i));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);  <span class="comment">// Run for a while</span></span><br><span class="line">    exec.shutdownNow();         <span class="comment">// All Accessors will quit</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">#0: 9259</span></span><br><span class="line"><span class="comment">#1: 556</span></span><br><span class="line"><span class="comment">#2: 6694</span></span><br><span class="line"><span class="comment">#3: 1862</span></span><br><span class="line"><span class="comment">#4: 962</span></span><br><span class="line"><span class="comment">#0: 9260</span></span><br><span class="line"><span class="comment">#1: 557</span></span><br><span class="line"><span class="comment">#2: 6695</span></span><br><span class="line"><span class="comment">#3: 1863</span></span><br><span class="line"><span class="comment">#4: 963</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象的内容，其中，get()方法将返回与其线程相关联的对象的副本，而set()会将参数插入到为其线程存储的对象种，并返回存储中原有的对象。上面increment()和get()方法在ThreadLocalVariableHolder种演示了这一点。注意，increment()和get()方法都不是synchronized的，因为ThreadLocal保证不会出现竞争条件</li>
</ul>
</blockquote>
<h3 id="21-4-终结任务"><a href="#21-4-终结任务" class="headerlink" title="21.4 终结任务"></a><strong>21.4 终结任务</strong></h3><p><strong>21.4.2 在阻塞时终结</strong></p>
<blockquote>
<ul>
<li>slepp()是一种情况，它使任务从执行状态变为被阻塞状态，而有时你必须终止被阻塞的状态。</li>
</ul>
</blockquote>
<p><strong>线程状态</strong></p>
<blockquote>
<p>一个线程可以处于以下四种状态之一：</p>
<ol>
<li>&#x3D;&#x3D;新建（new）:&#x3D;&#x3D;当线程被创建时，它只会短暂的处于这种状态。此时它已经分配了必需的系统资源，并执行了初始化。此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。</li>
<li>&#x3D;&#x3D;就绪（Runnable）&#x3D;&#x3D;:在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程，它就可以运行；这不同于死亡和阻塞状态。</li>
<li>&#x3D;&#x3D;阻塞（Blocked）&#x3D;&#x3D;:线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间。直到线程重新进入了就绪状态，它才有可能执行操作。</li>
<li>&#x3D;&#x3D;死亡（Dead）&#x3D;&#x3D;:处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已结束，或不再是可运行的。任务死亡的方式通常时从run()方法返回，但是任务的线程还可以被中断，你将要看到这一点。</li>
</ol>
</blockquote>
<p><strong>进入阻塞状态</strong></p>
<blockquote>
<p>一个任务进入阻塞状态，可能有如下原因：</p>
<ol>
<li>通过调用sleep(millseconds)是任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。</li>
<li>通过调用wait()是现成挂起。直到线程得到了notify()或notifyAll()消息（或者在JavaSE5的java.util.concurrent类库中等价的signal()或signalAll()消息），线程才会进行就绪状态。</li>
<li>任务在等待某个输入&#x2F;输出完成。</li>
<li>任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。</li>
</ol>
</blockquote>
<p><strong>21.4.3 中断</strong></p>
<blockquote>
<ul>
<li>在Runable.run()方法的中间打断它，与等待该方法到达棘手的多。因为当打断被阻塞的任务时，可能需要清理资源。</li>
<li>Thread类包含interrupt()方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态。如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptException.当抛出该异常或者该任务调用Thread.interrupted()时，中断状态将被复位。所以Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SleepBlocked</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;InterruptedException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Exiting SleepBlocked.run()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOBlocked</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> InputStream in;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">IOBlocked</span><span class="params">(InputStream is)</span> &#123; in = is; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      print(<span class="string">&quot;Waiting for read():&quot;</span>);</span><br><span class="line">      in.read();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        print(<span class="string">&quot;Interrupted from blocked I/O&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Exiting IOBlocked.run()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedBlocked</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) <span class="comment">// Never releases lock</span></span><br><span class="line">      Thread.<span class="keyword">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SynchronizedBlocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        f(); <span class="comment">// Lock acquired by this thread</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Trying to call f()&quot;</span>);</span><br><span class="line">    f();</span><br><span class="line">    print(<span class="string">&quot;Exiting SynchronizedBlocked.run()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interrupting</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span></span><br><span class="line">    Executors.newCachedThreadPool();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Runnable r)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    Future&lt;?&gt; f = exec.submit(r);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    print(<span class="string">&quot;Interrupting &quot;</span> + r.getClass().getName());</span><br><span class="line">    f.cancel(<span class="literal">true</span>); <span class="comment">// Interrupts if running</span></span><br><span class="line">    print(<span class="string">&quot;Interrupt sent to &quot;</span> + r.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">SleepBlocked</span>());</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">IOBlocked</span>(System.in));</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">SynchronizedBlocked</span>());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    print(<span class="string">&quot;Aborting with System.exit(0)&quot;</span>);</span><br><span class="line">    System.exit(<span class="number">0</span>); <span class="comment">// ... since last 2 interrupts failed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (95% match)</span></span><br><span class="line"><span class="comment">Interrupting SleepBlocked</span></span><br><span class="line"><span class="comment">InterruptedException</span></span><br><span class="line"><span class="comment">Exiting SleepBlocked.run()</span></span><br><span class="line"><span class="comment">Interrupt sent to SleepBlocked</span></span><br><span class="line"><span class="comment">Waiting for read():</span></span><br><span class="line"><span class="comment">Interrupting IOBlocked</span></span><br><span class="line"><span class="comment">Interrupt sent to IOBlocked</span></span><br><span class="line"><span class="comment">Trying to call f()</span></span><br><span class="line"><span class="comment">Interrupting SynchronizedBlocked</span></span><br><span class="line"><span class="comment">Interrupt sent to SynchronizedBlocked</span></span><br><span class="line"><span class="comment">Aborting with System.exit(0)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面的每个任务都表示了一种不同类型的阻塞。SleepBlock是可终端的阻塞示例，而IOBlocked和SynchronizedBlocked是不可中断的阻塞示例。所以证明了I&#x2F;O和在synchronized块上的等待是不可中断的，但是通过浏览代码，也可以预见到这一点——无论是I&#x2F;O还是尝试调用synchronized方法，都不需要任何InterruptedException处理器。</p>
</li>
<li><p>从输出中可以看到，你能够中断对sleep()的调用（或者任何要求抛出InterruptedException的调用）。但是你不能中断正在试图获取synchronized锁或者试图执行I&#x2F;O操作的线程。这令人烦恼，特别是在创建执行I&#x2F;O的任务时，因为这意味着I&#x2F;O具有锁住你的多线程程序的潜在可能性。特别是对基于Web的程序，这更是关乎利害。</p>
</li>
<li><p>对于这类问题，有一个略显笨拙但是有时确实行之有效的解决方案，即&#x3D;&#x3D;关闭任务在其上发生阻塞的底层资源&#x3D;&#x3D;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseResource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">socketInput</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).getInputStream();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">IOBlocked</span>(socketInput));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">IOBlocked</span>(System.in));</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    print(<span class="string">&quot;Shutting down all threads&quot;</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    print(<span class="string">&quot;Closing &quot;</span> + socketInput.getClass().getName());</span><br><span class="line">    socketInput.close(); <span class="comment">// Releases blocked thread</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    print(<span class="string">&quot;Closing &quot;</span> + System.in.getClass().getName());</span><br><span class="line">    System.in.close(); <span class="comment">// Releases blocked thread</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (85% match)</span></span><br><span class="line"><span class="comment">Waiting for read():</span></span><br><span class="line"><span class="comment">Waiting for read():</span></span><br><span class="line"><span class="comment">Shutting down all threads</span></span><br><span class="line"><span class="comment">Closing java.net.SocketInputStream</span></span><br><span class="line"><span class="comment">Interrupted from blocked I/O</span></span><br><span class="line"><span class="comment">Exiting IOBlocked.run()</span></span><br><span class="line"><span class="comment">Closing java.io.BufferedInputStream</span></span><br><span class="line"><span class="comment">Exiting IOBlocked.run()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在shutdownNow()被调用之后，以及在两个输入流撒谎给你调用close()之前的延迟强调的是一旦底层资源被关闭，任务将接触阻塞。interrupt()看起来发生在关闭Socket而不是关闭System.in的时刻。这是由18章介绍的各种nio类提供了更人性化的I&#x2F;O中断。被阻塞的nio通道会自动地响应中断。</p>
</li>
<li><p>如你所见，&#x3D;&#x3D;还可以通过关闭底层资源以释放锁&#x3D;&#x3D;，尽管和种做法一般不是必需地。注意使用execute()来启动两个任务，并调用e.shutdownNow()将可以很容易地终止所有事物，而对于捕获上面实例中地Future，只有将中断发送给一个线程，同时不发送给另一个线程时才是必需地。</p>
</li>
</ul>
</blockquote>
<p><strong>被互斥所阻塞</strong></p>
<blockquote>
<ul>
<li>就像在Interrupting.java中看到地，如果你尝试着在一个对象上调用其synchronized方法，而这个对象地锁已经被其他任务所获得，那么调用任务将被挂起（阻塞），直至这个锁可获得。下面的示例说明了同一个互斥可以如何能被同一个任务多次获得：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiLock</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      print(<span class="string">&quot;f1() calling f2() with count &quot;</span> + count);</span><br><span class="line">      f2(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      print(<span class="string">&quot;f2() calling f1() with count &quot;</span> + count);</span><br><span class="line">      f1(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MultiLock</span> <span class="variable">multiLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiLock</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        multiLock.f1(<span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 9</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 8</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 7</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 6</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 5</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 4</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 3</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 2</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 1</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 0</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在main()中创建了一个调用f()地Thread,然后f1()和f2()互相调用直至count变为0.由于这个任务已经在第一个对f1()的调用中获得了multiLock对象锁，因此同一个任务将在对f2()的调用中再次获取这个锁，依次类推，这么做是有意义的，因为一个任务应该能够调用在同一个对象中的其他的synchronized方法，而这个任务已经持有锁了。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>就像前面在不可中断的I&#x2F;O中所观察到的那样，无论在任何时刻，只要任务以不可中断的方式被阻塞，那么都有潜在的会锁柱程序的可能。&#x3D;&#x3D;Java SE5并发库中添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力，这与在synchronized方法或临界区上阻塞的任务完全不同&#x3D;&#x3D;。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockedMutex</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BlockedMutex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Acquire it right away, to demonstrate interruption</span></span><br><span class="line">    <span class="comment">// of a task blocked on a ReentrantLock:</span></span><br><span class="line">    lock.lock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// This will never be available to a second task</span></span><br><span class="line">      lock.lockInterruptibly(); <span class="comment">// Special call  用来获取锁定，</span></span><br><span class="line">      print(<span class="string">&quot;lock acquired in f()&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Interrupted from lock acquisition in f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blocked2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="type">BlockedMutex</span> <span class="variable">blocked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockedMutex</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Waiting for f() in BlockedMutex&quot;</span>);</span><br><span class="line">    blocked.f();</span><br><span class="line">    print(<span class="string">&quot;Broken out of blocked call&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interrupting2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Blocked2</span>());</span><br><span class="line">    t.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Issuing t.interrupt()&quot;</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Waiting for f() in BlockedMutex</span></span><br><span class="line"><span class="comment">Issuing t.interrupt()</span></span><br><span class="line"><span class="comment">Interrupted from lock acquisition in f()</span></span><br><span class="line"><span class="comment">Broken out of blocked call</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>BlockedMutex类有一个构造器，它要获取所拆挂那件对象上自身的Lock，并且从不释放这个锁。出于这个原因，如果你试图从第二个任务中调用f()（不同于创建这个BlockedMutex的任务），那么将会总是因Mutex不可获得而被阻塞。在Blocked2中，run()方法总是总是在调用blocked.f()的地方停止。当运行这个程序时，你将会看到，与I&#x2F;O调用不同，interrupt()可以打破被互斥所阻塞的调用。</li>
</ul>
</blockquote>
<p><strong>21.4.4 检查中断</strong></p>
<blockquote>
<ul>
<li>注意：当你在线程上调用interrupt()时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时（如前面所见，除了不可中断的I&#x2F;O或被阻塞的synchronized方法之外，在其余的例外情况下，你无可事事）。因此，如果你调用interrupt()已停止某个任务，那么在run()循环碰巧没有产生任何阻塞调用的情况下，你的任务将需要第二种方式来退出。</li>
<li>这种机会是由中断状态来表示的，其状态可以通过调用interrupted()来设置。你可以通过调用interrupted来检查中断状态，这不仅可以告诉你interrupt()是否被调用过，而且还可以清除中断状态。清除中断状态可以确保并发结构不会就，某个任务被中断这个问题通知你两次，你可以经由单一的InterruptedException或单一的成功的Thread.interrupted()测试来得到这种通知。如果想要再次检查以了解是否被中断，则可以在调用Thread.interrupted()时将结果存储起来，</li>
</ul>
</blockquote>
<h3 id="21-5-线程之间的协作"><a href="#21-5-线程之间的协作" class="headerlink" title="21.5 线程之间的协作"></a>21.5 线程之间的协作</h3><blockquote>
<ul>
<li>正如前面所见到的，当使用线程来同时运行多个任务时，可以通过使用锁（互斥）来同步两个任务的行为，从而使得一个任务不会干涉另一个任务的资源。</li>
<li>接下来时&#x3D;&#x3D;学习如何使任务彼此之间可以协作，以使得任务可以一起取解决某个问题&#x3D;&#x3D;。现在的问题不是彼此之间的干涉，而是彼此之间的协调，因为这类问题中，某些部分必须在其他部分被解决之前解决。在这些任务中，某些可以并行执行，但是某些步骤需要所有的任务都结束之后才能开动。</li>
<li>当任务协作时，关键问题是这些任务之间的握手。为了实现这种握手，我们使用了相同的基础特性：互斥。在这种情况下，互斥能够确保只有一个任务可以响应某个信号。，这样就可以根除任何可能的竞争条件。在互斥之上，我们为任务添加了一种途径，可以将自身挂起，直至某些外部条件发生变化，表示是时候让这个任务向前开动了为止。</li>
<li>在本节，我们将浏览任务间的握手，这种握手可以通过Object的方法wait()和notify()来安全地实现。Java SE5并发类库换提供了具有await()和signal()方法的Condition对象。</li>
</ul>
</blockquote>
<p><strong>21.5.1 wait()与notifyAll()</strong></p>
<blockquote>
<ul>
<li><p>wait()使你可以等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。通常，这种条件由另一个任务来改变。因此wait()会在等待外部世界产生变化的时候将任务挂起，并且只有在notify()或notifyAll()发生时，即表示发生了某些感兴趣的事物。这个任务才会被唤醒并去检查所产生的变化。因此，wait()提供了一种在任务之间对活动同步的方式。</p>
</li>
<li><p>&#x3D;&#x3D;调用sleep()的时候并没有被释放，调用yield()也属于这种情况&#x3D;&#x3D;，理解这一点很重要。另一方面，当一个任务在方法里遇到了&#x3D;&#x3D;对wait()的调用的时候，线程的执行被挂起，对象上的锁被释放&#x3D;&#x3D;。因为wait()将释放锁，这就意味着另一个任务可以获得这个锁，因此在该对象（现在是未锁顶的）中的其他synchronized方法可以在wait()期间被调用。这一点至关重要，因为这些其他的方法通常将会产生改变，而这种改变正是使被挂起的任务重新唤醒所感兴趣的变化。因此，&#x3D;&#x3D;当你调用wait()时，就是在声明：“我已经刚刚做完能做的所有事情，因此我要在这里等待，但是我希望其他的synchronized操作在条件适合的情况下能够执行。”&#x3D;&#x3D;</p>
</li>
<li><p>有两种形式的wait().第一种版本接受毫秒数作为参数，含义与sleep()方法里参数的意思相同，都是指“在此期间暂停”，但是与sleep()不同的是，对于wait()而言：</p>
<ol>
<li>在wait()期间对象锁是释放的。</li>
<li>可以通过notify(),notifyAll(),或者令时间到期，从wait()中恢复执行。</li>
</ol>
</li>
<li><p>第二种，也是更常用形式的wait()不接受任何参数。这种wait()将无限等待下去，直到线程接受到notify()或者notifyAll()消息</p>
</li>
<li><p>这些方法是基类Object的一部分。因为这些方法操作的锁也是所有对象的一部分，所以，你可以把wait()放进任何同步控制方法里，而不用考虑这个类是继承自Thread还是实现了Runnable接口。实际上，只能在同步控制方法或同步控制块里调用wait()，notify(),notifyAll()（因为不用操作锁，所以sleep()可以在非同步控制方法里调用）。如果在非同步控制方法里调用这些方法，程序能通过编译，但运行的时候，将得到IllegalMonitorStateException异常，并伴随着一些含糊的消息，比如“当前线程不是拥有者”。消息的意思是，调用这个方法钱必需拥有获取（获取）对象的锁。</p>
</li>
<li><p>可以让另一个对象执行某种操作以维护其自己的锁。要这么做的话，必需首先得到对象的锁。如果要向对象x发送notifyAll()，那么就必须在能够取得x的锁的同步控制快中这么做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(x)&#123;</span><br><span class="line">	x.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面有一个讲解的示例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">waxOn</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waxed</span><span class="params">()</span> &#123;</span><br><span class="line">    waxOn = <span class="literal">true</span>; <span class="comment">// Ready to buff</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buffed</span><span class="params">()</span> &#123;</span><br><span class="line">    waxOn = <span class="literal">false</span>; <span class="comment">// Ready for another coat of wax</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForWaxing</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">while</span>(waxOn == <span class="literal">false</span>)</span><br><span class="line">      wait();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForBuffing</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">while</span>(waxOn == <span class="literal">true</span>)</span><br><span class="line">      wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOn</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOn</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        printnb(<span class="string">&quot;Wax On! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.waxed();</span><br><span class="line">        car.waitForBuffing();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax On task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOff</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        car.waitForWaxing();</span><br><span class="line">        printnb(<span class="string">&quot;Wax Off! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.buffed();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax Off task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaxOMatic</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOff</span>(car));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOn</span>(car));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// Run for a while...</span></span><br><span class="line">    exec.shutdownNow(); <span class="comment">// Interrupt all tasks</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (95% match)</span></span><br><span class="line"><span class="comment">Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax On task</span></span><br><span class="line"><span class="comment">Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax Off task</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>前面的示例强调你必须用一个检查感兴趣的条件的while循环包围wait()。这很重要，因为：<ul>
<li>你可能有多个任务出于相同的原因在等待同一个锁，而第一个唤醒任务可能会改变这种状况（即使你没有这么做，有人也会通过继承你的类去这么做）。如果属于这种情况，那么这个任务应该被再次挂起，直至感兴趣的条件发生变化。</li>
<li>在这个任务从其wait()中被唤醒的时刻，有可能会有某个其他的任务已经做出了改变，从而使得这个任务在此时不能执行，或者执行其操作已显得无关紧要。此时，应该通过再次调用wait()来将其重新挂起。</li>
<li>也有可能某些任务出于不同的原因在等待你的对象上的锁（在这种情况下必须使用notifyAll()）。在这种情况下，你需要检查是否已经由正确的原因唤醒，如果不是，就再次调用wait()</li>
</ul>
</li>
<li>因此，其本质就是要检查所感兴趣的特定条件，并在条件不满足的情况下返回到wait()中，惯用的方法就是使用while来编写这种代码。</li>
</ul>
</blockquote>
<p><strong>错失的信号</strong></p>
<blockquote>
<p>当两个线程使用notify()&#x2F;wait()或notifyAll()&#x2F;wait()进行协作时，有可能会错过某个信号。假设T1是通知T2的线程，而这两个线程都是使用下面（有缺陷的）方式实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T1:</span><br><span class="line"><span class="keyword">synchronized</span>(shareMonitor)&#123;</span><br><span class="line">	&lt;setup condition <span class="keyword">for</span> T2&gt;</span><br><span class="line">	shareMonitor.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2:</span><br><span class="line"><span class="keyword">while</span>(someCondition)&#123;</span><br><span class="line">	<span class="comment">//Point1</span></span><br><span class="line">	<span class="keyword">synchronized</span>(sharedMonitor)&#123;</span><br><span class="line">		sharedMonitor.wait();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><setup condition for T2>是防止T2调用wait()的一个操作，当然前提是T2还没有调用wait()。</li>
<li>假设T2对someCondition求值并发现其为true.在Point1里，线程调度器可能切换到了T1,而T1将执行其设置，然后调用notify()。当T2继续执行时，此时对于T2来说，时机已经太晚了，以至于不能意识到条件已经发生了变化，因此会盲目进入到wait()。此时notify()将错失，而T2也将无限的等待这个已经发送过的信号，从而产生死锁。</li>
<li>该问题的解决方案是防止在someCondition变量上产生竞争条件。下面是T2正确的执行方式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(sharedMonitor)&#123;</span><br><span class="line">	<span class="keyword">while</span>(someCondition)&#123;</span><br><span class="line">		sharedMonitor.wait();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在，如果T1首先执行，当控制返回T2时，它将发现条件发生了变化，从而不会进入wait().反过来，如果T2首先执行，那它将进入wait(),并且稍后会有T1唤醒，因此，信号不会错失。</li>
</ul>
</blockquote>
<p><strong>21.5.2 notify()与notifyAll()</strong></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;因为在技术上，可能有多个任务在单个Car对象上处于wait()状态，因此调用notifyAll()比只调用notify()要更安全&#x3D;&#x3D;。但是，上面程序的结构只会有一个任务实际处于wait()状态，因此你可以使用notify()来代替notifyAll()。</li>
<li>使用notify()而不是notifyAll()是一种优化，使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒，因此如果你希望用notify()，就必须保证唤醒的是恰当的任务。另外，为了使用notify()，所有任务必须等待相同的条件，因为如果你有多个任务在等待不同的条件，那么你就不会指代是否唤醒了恰当的任务。如果使用notify()，当条件发生变化时，必须只有一个任务从中受益。最后，这些限制对所有可能存在的子类都必须总是起作用的。如果这些规则中有任何一条不满足，那么你就必须使用notifyAll()而不是notify()。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Blocker</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitingCall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">          <span class="comment">//这里会有多个任务被挂起。</span></span><br><span class="line">        wait();</span><br><span class="line">        System.out.print(Thread.currentThread() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// OK to exit this way</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">prod</span><span class="params">()</span> &#123; notify(); &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">prodAll</span><span class="params">()</span> &#123; notifyAll(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Blocker</span> <span class="variable">blocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blocker</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; blocker.waitingCall(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="comment">// A separate Blocker object:</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Blocker</span> <span class="variable">blocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blocker</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; blocker.waitingCall(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyVsNotifyAll</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">Task2</span>());</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">prod</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prod) &#123;</span><br><span class="line">          System.out.print(<span class="string">&quot;\nnotify() &quot;</span>);</span><br><span class="line">          Task.blocker.prod();</span><br><span class="line">          prod = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.print(<span class="string">&quot;\nnotifyAll() &quot;</span>);</span><br><span class="line">          Task.blocker.prodAll();</span><br><span class="line">          prod = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">400</span>, <span class="number">400</span>); <span class="comment">// Run every .4 second</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// Run for a while...</span></span><br><span class="line">    timer.cancel();</span><br><span class="line">    System.out.println(<span class="string">&quot;\nTimer canceled&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;Task2.blocker.prodAll() &quot;</span>);</span><br><span class="line">    Task2.blocker.prodAll();</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\nShutting down&quot;</span>);</span><br><span class="line">    exec.shutdownNow(); <span class="comment">// Interrupt all tasks</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</span></span><br><span class="line"><span class="comment">Timer canceled</span></span><br><span class="line"><span class="comment">Task2.blocker.prodAll() Thread[pool-1-thread-6,5,main]</span></span><br><span class="line"><span class="comment">Shutting down</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>浏览Blocker中的prod()和prodAll()，就会发现这是有意义的。这些方法是synchronized的，这意味着他们将获取自身的锁，因此当它们调用notify()或notifyAll()时，只在这个锁上调用是符合逻辑的——因此，将脂环星在等待这个特定锁的任务。</li>
</ul>
</blockquote>
<p><strong>21.5.3 生产者与消费者</strong></p>
<blockquote>
<ul>
<li>有一个饭店，他有一个厨师和一个服务员。这个服务员必须等待厨师准备好膳食。当厨师准备好时，他会通知服务员，之后服务员上菜，然后返回继续等待。这是一个任务协作的示例：厨师代表生产者，而服务员代表消费者。两个任务必须在膳食被生产和消费时进行握手，而系统必须以有序的方式关闭。下面是对这个叙述建模的代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> orderNum;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Meal</span><span class="params">(<span class="type">int</span> orderNum)</span> &#123; <span class="built_in">this</span>.orderNum = orderNum; &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Meal &quot;</span> + orderNum; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitPerson</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaitPerson</span><span class="params">(Restaurant r)</span> &#123; restaurant = r; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(restaurant.meal == <span class="literal">null</span>)</span><br><span class="line">            wait(); <span class="comment">// ... for the chef to produce a meal</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">&quot;Waitperson got &quot;</span> + restaurant.meal);</span><br><span class="line">        <span class="keyword">synchronized</span>(restaurant.chef) &#123;</span><br><span class="line">          restaurant.meal = <span class="literal">null</span>;</span><br><span class="line">          restaurant.chef.notifyAll(); <span class="comment">// Ready for another</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;WaitPerson interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chef</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Chef</span><span class="params">(Restaurant r)</span> &#123; restaurant = r; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(restaurant.meal != <span class="literal">null</span>)</span><br><span class="line">            wait(); <span class="comment">// ... for the meal to be taken</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++count == <span class="number">10</span>) &#123;</span><br><span class="line">          print(<span class="string">&quot;Out of food, closing&quot;</span>);</span><br><span class="line">          restaurant.exec.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">        printnb(<span class="string">&quot;Order up! &quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(restaurant.waitPerson) &#123;</span><br><span class="line">          restaurant.meal = <span class="keyword">new</span> <span class="title class_">Meal</span>(count);</span><br><span class="line">          restaurant.waitPerson.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Chef interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line">  Meal meal;</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">  <span class="type">WaitPerson</span> <span class="variable">waitPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitPerson</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="type">Chef</span> <span class="variable">chef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chef</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Restaurant</span><span class="params">()</span> &#123;</span><br><span class="line">    exec.execute(chef);</span><br><span class="line">    exec.execute(waitPerson);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Restaurant</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 1</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 2</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 3</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 4</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 5</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 6</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 7</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 8</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 9</span></span><br><span class="line"><span class="comment">Out of food, closing</span></span><br><span class="line"><span class="comment">WaitPerson interrupted</span></span><br><span class="line"><span class="comment">Order up! Chef interrupted</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在前面的示例中，对于一个任务而言，只有一个单一的地点用于存放对象，从而使得另一个任务稍后可以使用这个对象。但是，在典型的生产者-消费者实现中，应使用先进先出队列来存储被生产和消费的对象。</li>
</ul>
</blockquote>
<p><strong>使用显式的Lock和Condition对象</strong></p>
<blockquote>
<ul>
<li>在Java SE5的java.util.concurrent类库中还有额外的显式工具可以用来重写WaxOMatic.java。使用互斥并允许任务挂起的基本类是Condition,你可以通过在Condition上调用await()来挂起一个任务。当外部条件发生变化，意味着某个任务应该继续执行时，你可以通过调用signal()来同这个任务，从而唤醒一个任务，或者调用signalAll()来唤醒所有在这个Condition上被其自身挂起的任务（与使用notifyAll相比，signallAll是更安全的方式）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">waxOn</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waxed</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      waxOn = <span class="literal">true</span>; <span class="comment">// Ready to buff</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buffed</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      waxOn = <span class="literal">false</span>; <span class="comment">// Ready for another coat of wax</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitForWaxing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(waxOn == <span class="literal">false</span>)</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitForBuffing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(waxOn == <span class="literal">true</span>)</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOn</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOn</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        printnb(<span class="string">&quot;Wax On! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.waxed();</span><br><span class="line">        car.waitForBuffing();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax On task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOff</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        car.waitForWaxing();</span><br><span class="line">        printnb(<span class="string">&quot;Wax Off! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.buffed();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax Off task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaxOMatic2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOff</span>(car));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOn</span>(car));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax Off task</span></span><br><span class="line"><span class="comment">Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax On task</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在Car的构造器中，单个的Lock将产生一个Condition对象，这个对象被用来管理任务间的通信。但是，这个Condition对象不包含任何有关处理状态的信息，因此你需要管理额外的表示处理状态的信息，即boolean wanOn.</li>
<li>每个对lock()的调用都必须紧跟一个try-finally子句，用来保证在所有情况下都可以释放锁。在使用内建版本时，任务在可以调用await(),signal()或signalAll()之前，必须拥有这个锁。</li>
</ul>
</blockquote>
<p><strong>21.5.4 生产者-消费者与队列</strong></p>
<blockquote>
<ul>
<li>wait()与notifyAll()方法以一种非常低级的方式解决了任务互操作问题，即每次交互时都握手。在许多情况下，可以瞄向更高的抽象级别，&#x3D;&#x3D;使用同步队列来解决任务协作问题，同步队列在任何时刻都只允许一个任务插入或移除元素。&#x3D;&#x3D;在java.util.concurrent.BlockingQueue接口中提供了这个队列，这个接口有大量的标准实现。通常可以使用LinkedBlockingQueue,它是一个无界队列，还可以使用ArrayBlockingQueue,它具有固定的尺寸，因此你可以在它被阻塞之前，向其中放置有限数量的元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LiftOffRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> BlockingQueue&lt;LiftOff&gt; rockets;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">LiftOffRunner</span><span class="params">(BlockingQueue&lt;LiftOff&gt; queue)</span> &#123;</span><br><span class="line">    rockets = queue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(LiftOff lo)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rockets.put(lo);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Interrupted during put()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="type">LiftOff</span> <span class="variable">rocket</span> <span class="operator">=</span> rockets.take();</span><br><span class="line">        rocket.run(); <span class="comment">// Use this thread</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Waking from take()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Exiting LiftOffRunner&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBlockingQueues</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getkey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Compensate for Windows/Linux difference in the</span></span><br><span class="line">      <span class="comment">// length of the result produced by the Enter key:</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)).readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(java.io.IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getkey</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    print(message);</span><br><span class="line">    getkey();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">  <span class="title function_">test</span><span class="params">(String msg, BlockingQueue&lt;LiftOff&gt; queue)</span> &#123;</span><br><span class="line">    print(msg);</span><br><span class="line">    <span class="type">LiftOffRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiftOffRunner</span>(queue);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runner);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      runner.add(<span class="keyword">new</span> <span class="title class_">LiftOff</span>(<span class="number">5</span>));</span><br><span class="line">    getkey(<span class="string">&quot;Press &#x27;Enter&#x27; (&quot;</span> + msg + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">    print(<span class="string">&quot;Finished &quot;</span> + msg + <span class="string">&quot; test&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="string">&quot;LinkedBlockingQueue&quot;</span>, <span class="comment">// Unlimited size</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;LiftOff&gt;());</span><br><span class="line">    test(<span class="string">&quot;ArrayBlockingQueue&quot;</span>, <span class="comment">// Fixed size</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;LiftOff&gt;(<span class="number">3</span>));</span><br><span class="line">    test(<span class="string">&quot;SynchronousQueue&quot;</span>, <span class="comment">// Size of 1</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;LiftOff&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>各个人物由main()放置到了BlockingQueue中，并且由LiftOffRunner从BlockingQueue中取出。注意，LiftOffRunner可以忽略同步问题，因为它们已经由BlockingQueue解决了。</li>
</ul>
</blockquote>
<p><strong>21.5.5 任务间使用管道进行输入&#x2F;输出</strong></p>
<blockquote>
<ul>
<li>通过输入&#x2F;输出在线程间进行通信通常很有用。提供县城额功能的类库以“管道”的形式对线程间的输入&#x2F;输出提供了支持。它们在Java输入&#x2F;输出类库中的对应物就是PipedWriter类（允许任务向管道写）和PipedReader类（允许不同任务从同一个管道中读取）。管道基本上是一个阻塞队列，存在于多个引入BlockingQueue之前的Java版本中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="type">PipedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">  <span class="keyword">public</span> PipedWriter <span class="title function_">getPipedWriter</span><span class="params">()</span> &#123; <span class="keyword">return</span> out; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">          out.write(c);</span><br><span class="line">          TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      print(e + <span class="string">&quot; Sender write exception&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(e + <span class="string">&quot; Sender sleep interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> PipedReader in;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Receiver</span><span class="params">(Sender sender)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    in = <span class="keyword">new</span> <span class="title class_">PipedReader</span>(sender.getPipedWriter());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// Blocks until characters are there:</span></span><br><span class="line">        printnb(<span class="string">&quot;Read: &quot;</span> + (<span class="type">char</span>)in.read() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      print(e + <span class="string">&quot; Receiver read exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipedIO</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>();</span><br><span class="line">    <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>(sender);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(sender);</span><br><span class="line">    exec.execute(receiver);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (65% match)</span></span><br><span class="line"><span class="comment">Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read: G, Read: H, Read: I, Read: J, Read: K, Read: L, Read: M, java.lang.InterruptedException: sleep interrupted Sender sleep interrupted</span></span><br><span class="line"><span class="comment">java.io.InterruptedIOException Receiver read exception</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Sender和Receiver代表了需要互相通信两个任务，Sender创建了一个PipedWriter,它是一个单独的对象。但是对于Receiver,PipedReader的建立必须在构造器中与一个PipedWriter相关联。Sender把数据放进Writer。</li>
<li>在shutdownNow()被调用时，可以看到PipedReader与普通I&#x2F;O之间最重要的差异——PipedReader是可中断的。如果你将将in.read()调用修改为System.in.read()，那么interrupt()将不能打断read()调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CharQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Character&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">CharQueue</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharQueue</span>();</span><br><span class="line">    <span class="keyword">public</span> CharQueue <span class="title function_">getQueue</span><span class="params">()</span> &#123; <span class="keyword">return</span> out; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                    out.put(c);</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e + <span class="string">&quot; Sender interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CharQueue in;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Receiver</span><span class="params">(Sender sender)</span> &#123; in = sender.getQueue(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// Blocks until characters are there:</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Read: &quot;</span> + in.take() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e + <span class="string">&quot; Reader interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E30_SendReceive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>();</span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>(sender);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(sender);</span><br><span class="line">        exec.execute(receiver);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read:</span></span><br><span class="line"><span class="comment">G, Read: H, Read: I, Read: J, Read: K, Read: L, Read: M,</span></span><br><span class="line"><span class="comment">Read: N, Read: O, Read: P, Read: Q,</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException Reader interrupted</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException: sleep interrupted Sender</span></span><br><span class="line"><span class="comment">interrupted</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="21-6-死锁"><a href="#21-6-死锁" class="headerlink" title="21.6 死锁"></a>21.6 死锁</h3><blockquote>
<ul>
<li>哲学家就餐问题。</li>
<li>当下列四个条件满足时，就会产生死锁：<ul>
<li>互斥条件。任务使用的资源中至少有一个是不能共享的。这里一根筷子一次只能欸一个哲学家使用。</li>
<li>至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源。ye就是说，要发生死锁，哲学家必须拿着一根筷子并且等待另一根</li>
<li>资源不能被任务抢占，任务必须把资源释放当作普通事件。哲学家很有礼貌，它们不会从其他哲学家那里抢筷子</li>
<li>必须有循环等待，这时一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，直到有一个任务在等待第一个任务所持有的资源，使得大家都被锁住。因为哲学家们默认都是先得到右边的筷子，然后得到左边的筷子，所以发生了循环等待。</li>
</ul>
</li>
<li>打破死锁的方法就是消除存在的循环等待问题。然而如果让最后一个哲学家是先拿左边的筷子，后拿右边的筷子就可以消除。</li>
</ul>
</blockquote>
<h3 id="21-7-新类库中的构件"><a href="#21-7-新类库中的构件" class="headerlink" title="21.7 新类库中的构件"></a>21.7 新类库中的构件</h3><blockquote>
<ul>
<li>Java SE5的java.util.concurrent引入了大量设计来解决并发问题的新类。</li>
</ul>
</blockquote>
<p><strong>21.7.1 CountDownLatch</strong></p>
<blockquote>
<ul>
<li>他被用用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。</li>
<li>可以向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()的方法都将阻塞，直至这个计数值到达0.其他任务在结束其工作时，可以在该对象上调用countDown()来减少这个计数值。&#x3D;&#x3D;CountDownLatch被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用CyclicBarrier.&#x3D;&#x3D;</li>
<li>调用countDown()的任务在产生这个调用时并没有被阻塞，只有对awit()的调用会被阻塞，直至计数值到达0.</li>
<li>CountDownLatch的典型用法是将一个程序分为n个互相独立的可解决任务，并创建值为0的CountDownLatch。当每个任务完成时，都会在这个锁存器上调用countDown()。等待问题被解决的任务在这个锁存器上调用await()，将它们自己拦住，直至锁存器计数结束。下面是演示这种奇数的一个框架示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskPortion</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> counter++;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">  TaskPortion(CountDownLatch latch) &#123;</span><br><span class="line">    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork();</span><br><span class="line">      latch.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">      <span class="comment">// Acceptable way to exit</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">2000</span>));</span><br><span class="line">    print(<span class="built_in">this</span> + <span class="string">&quot;completed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%1$-3d &quot;</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Waits on the CountDownLatch:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitingTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> counter++;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">  WaitingTask(CountDownLatch latch) &#123;</span><br><span class="line">    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      latch.await();</span><br><span class="line">      print(<span class="string">&quot;Latch barrier passed for &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">      print(<span class="built_in">this</span> + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;WaitingTask %1$-3d &quot;</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// All must share a single CountDownLatch object:</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">WaitingTask</span>(latch));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">TaskPortion</span>(latch));</span><br><span class="line">    print(<span class="string">&quot;Launched all tasks&quot;</span>);</span><br><span class="line">    exec.shutdown(); <span class="comment">// Quit when all tasks complete</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* (Execute to see output) */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>TaskPortion将随机地休眠一段时间，以模拟这部分工作地完成，而WaitingTask表示系统中必须等待地部分，它要等待到问题地初始部分完成为止。所有任务都使用了在main()种定义地同一个单一地CountDownLatch。</li>
</ul>
</blockquote>
<p><strong>21.7.2 CyclicBarrier</strong></p>
<blockquote>
<ul>
<li>CyclicBarrier适用于这样地情况：你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成（看起来有些像join()）。它使得所有的并行任务都将在栅栏处列队，因此可以一致地向前移动。&#x3D;&#x3D;这非常像CountDownLatch,只是CountDownLatch是只触发一次地事件，而CyclicBarrier可以多次重用。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<p><strong>21.7.3 DelayQueue</strong></p>
<blockquote>
<ul>
<li>这是一个无界的BlockingQueue,用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素，并且poll()将返回null(正因为这样，你不能将null放置到这种队列中)</li>
<li>下面是一个示例，其中的Delayed对象自身就是任务，而DelayedTaskConsumer将最紧急的任务（到期时间最长的任务）从队列中取出，然乎运行它。注意，&#x3D;&#x3D;这样DelayQueue就成为了优先级队列的一种变体。&#x3D;&#x3D;</li>
<li>从输出的顺序可以看到，任务创建的顺序对执行顺序没有任何影响，任务是按照所期望的延迟顺序执行的。</li>
</ul>
</blockquote>
<p><strong>21.7.4 PriorityBlockingQueue</strong></p>
<blockquote>
<ul>
<li>这是一个很基础的优先队列，它具有可阻塞的读取操作。下面是一个示例，其中在优先级队列中的对象是按照优先级顺序从队列中出现的任务。PrioritedTask被赋予了一个优先级数字，以此来提供这种顺序。</li>
<li>与前一个示例相同，PrioritizedTask对象的创建序列被记录在sequence List中，用于和实际执行顺序比较。run()方法将休眠一小段时间，然后大一i你对象信息，而EndSentinel提供了和前面相同的功能，要确保它是队列中最后一个对象。而且这种队列提供了同步的功能。因此不需要有显式的同步。</li>
</ul>
</blockquote>
<p><strong>21.7.6 Semaphore</strong></p>
<blockquote>
<ul>
<li>正常的锁（来自concurrent.locks或内建的synchronized锁）在任何时刻都只允许一个任务访问一项资源，而计数信号量允许n个任务同时访问这个资源。你还可以将信号量看作是在向外分发使用资源的“许可证”，尽管实际上没有使用任何许可证对象。</li>
<li>作为一个示例，请考虑对象池的概念，它管理着数量有限的对象，当要使用对象时可以签出它们，而在用户使用完毕时，可以将它们签回。这种功能可以封装到一个泛型类中。</li>
</ul>
</blockquote>
<p><strong>21.7.7 Exchanger</strong></p>
<blockquote>
<ul>
<li>Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，他们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。Exchanger的典型应用场景是：一个任务在创建对象，这些对象的而生产代价很高昂，二零一个任务在消费这些对象。通过这种方式，可以有更多的对象在被创建的同时被消费。</li>
</ul>
</blockquote>
<h3 id="21-8-仿真"><a href="#21-8-仿真" class="headerlink" title="21.8 仿真"></a>21.8 仿真</h3><h3 id="21-9-性能调优"><a href="#21-9-性能调优" class="headerlink" title="21.9 性能调优"></a>21.9 性能调优</h3><blockquote>
<ul>
<li>在Java SE的java.util.concurrent类库中存在着数量庞大的用于性能提高的类。当你细读concurrent类库时就会发现很难辨认哪些类适用于常规应用（例如BlockingQueue）,而哪些类只适用于提高性能。</li>
</ul>
</blockquote>
<p><strong>21.9.1 比较各类互斥技术</strong></p>
<blockquote>
<ul>
<li>既然Java包括老式的synchronized关键字和Java SE5中新的Lock和Atomic类，那么比较这些不同的方式，更多地理解它们各自的价值和适用范围，就会显得很有意义。</li>
<li>适用Lock通常会比适用synchronized要高效的多，而且synchronized的开销看起来变化范围更大，而Lock相对比较一致。但是通常，为了代码阅读的高效性，适用synchronized的方式更多一点。而Lock和Atomic则适用的更少。</li>
</ul>
</blockquote>
<p><strong>21.9.2 免锁容器</strong></p>
<blockquote>
<ul>
<li><p>容器是所有编程中的基础工具，这其中自然也包括并发编程。处于这个原因，像Vector和Hashtable这类早期容器具有许多synchronized方法，当他们用于非多线程的应用程序中时，便会导致不可接受的开销。</p>
</li>
<li><p>Java SE5特别添加了新的容器，通过使用更灵巧的技术来消除加锁，从而提高线程安全的性能。</p>
</li>
<li><p>&#x3D;&#x3D;这些免锁容器背后的通用策略是&#x3D;&#x3D;：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。修改是在容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到 这个修改了。</p>
</li>
<li><p>在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而原数组将保留在原地，使得赋值的数组在被修改时，读取操作可以安全地执行。当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改。</p>
</li>
<li><p>CopyOnWriteArrayList的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationWxception，因此不必编写特殊的代码去防范这种异常，就想你之前必须坐的那样。</p>
</li>
<li><p>CopyOnWriteArraySet将使用CopyOnWriteArrayList来实现其免锁行为。</p>
</li>
<li><p>ConcurrentHashMap和ConcurrentLinkedQueue使用了类似的技术，允许并发的读取和写入，但是容器中只有部分内容而不是整个容器可以被复制和修改。然而，任何修改在完成之前，读取者仍旧不能看到它们。ConcurrentHashMap不会抛出ConcurrentModificationWxception。</p>
</li>
</ul>
</blockquote>
<p><strong>乐观锁</strong></p>
<blockquote>
<p>只要你主要是从免锁容器中读取，那么它就会比其synchronized对应物快许多，因为获取和释放锁的开销被省掉了。如果需要向免锁容器中执行少量写入，那么情况也仍旧如此。</p>
</blockquote>
<p><strong>比较各种Map实现</strong></p>
<blockquote>
<ul>
<li>我们可以使用相同的框架来得到synchronizedHashMap和ConcurrentHashMap在性能方面的比较结果。向ConcurrentHashMap添加写入者的影响甚至还不如CopyOnWriteArrayList明显，这是因为ConcurrentHashMap使用了一种不同的技术，它可以明显地最小化写入所造成的影响。</li>
</ul>
</blockquote>
<p><strong>21.9.3 乐观加锁</strong></p>
<blockquote>
<p>在正常情况下将使用互斥（synchronized或Lock）来放置多个任务同时修改一个对象，但是这里我们是乐观的，因为我们保持数据为未锁定状态，并希望没有任何其他任务插入修改它。所有这些又都是以性能的名义执行的——通过使用Atomic来替代synchronized或Lock,可以获得性能上的好处。</p>
</blockquote>
<p><strong>21.9.4 ReadWriteLock</strong></p>
<blockquote>
<ul>
<li>ReadWriteLock对向数据结构相对不频繁的写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为主。</li>
<li>ReadWriteLock是否能够提高程序的性能是完全不可确定的，它取决于诸如数据被读取的频率与被修改的频率相比较的结果，读取和写入操作的时间，有多少线程竞争以及是否在都哦系处理机器上运行等因素。最终，唯一可以了解是否能带来好处就是通过做实验。</li>
</ul>
</blockquote>
<h3 id="21-10-活动对象"><a href="#21-10-活动对象" class="headerlink" title="21.10 活动对象"></a>21.10 活动对象</h3><blockquote>
<p>有一种可替换的方式被称为活动对象或行动者。之所以称这些对象是活动的，是因为每个对象都维护者它自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中的一个。因此有了活动对象，我们就可以串行化消息而不是方法，这意味着不再需要防备一个任务在其循环的中间被中断这种问题了。</p>
</blockquote>
<h3 id="21-11-总结"><a href="#21-11-总结" class="headerlink" title="21.11 总结"></a>21.11 总结</h3><blockquote>
<ul>
<li>线程的一个额外好处是它们提供了轻量级的执行上下文切换（大约100条指令），而不是重量级的进程上下文切换（要上千条指令）。因为一个给定进程内的所有进程共享相同的内存空间，轻量级的上下文切换只是改变了程序的执行序列和局部变量。进程切换（重量级的上下文切换）必须改变所有内存空间。</li>
<li>多线程的主要缺陷有：<ul>
<li>等待共享资源的时候性能低</li>
<li>需要处理线程的额外CPU花费</li>
<li>糟糕的程序设计导致不必要的复杂度</li>
<li>有可能产生一些病态行为，如饿死，竞争，死锁和活锁（多个运行各自任务的线程使得整体无法完成）</li>
<li>不同平台导致的不一致性</li>
</ul>
</li>
<li>因为多个线程可能共享一个资源，比如一个对象的内存，而且你必须确定多个线程不会同时读取和改变这个资源，这就是线程产生的最大难题。</li>
</ul>
</blockquote>
<blockquote>
<p>创建Java对象的五种方式：</p>
<ol>
<li>使用new关键字</li>
<li>使用Class类的newInstance方法</li>
<li>使用Constructor类的newInstance方法</li>
<li>使用clone方法</li>
<li>使用反序列化</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/08/27/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/" data-id="clrv16wj80006z5ku3mr7cs0j" data-title="Java编程思想" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/27/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2022-07-26T16:00:00.000Z" itemprop="datePublished">2022-07-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/27/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">docker常用命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker version		#显示版本信息	</span><br><span class="line">docker info			#显示更详细的信息</span><br><span class="line">docker 命令 --help  	# 万能命令</span><br><span class="line">帮助文档地址： https://docs.docker.com/reference/ </span><br></pre></td></tr></table></figure>

<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ol>
<li><strong>docker images  	#查看所有本地的主机上的镜像</strong></li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 解释</span></span><br><span class="line"><span class="code">	Repository	镜像的仓库源</span></span><br><span class="line"><span class="code">	TAG			镜像的标签</span></span><br><span class="line"><span class="code">	IMAGEID		镜像的ID</span></span><br><span class="line"><span class="code">	CREATED		镜像的创建时间</span></span><br><span class="line"><span class="code">	SIZE		镜像的大小</span></span><br><span class="line"><span class="code"># 可选项</span></span><br><span class="line"><span class="code">	-a,--all 	#列出所有镜像    # docker images -a</span></span><br><span class="line"><span class="code">	-q,--quiet	#只显示镜像的ID  # docker images -q</span></span><br></pre></td></tr></table></figure>

<p>2.<strong>docker search 搜索镜像</strong></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20210913105236807.png" alt="image-20210913105236807"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可选项，通过搜索来过滤</span><br><span class="line">	--filter=STARS=3000		#搜索出来就是STARS大于等于3000的</span><br></pre></td></tr></table></figure>

<p>3.<strong>docker pull 下载镜像</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 下载镜像 docker pull 镜像名[:tag]</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker pull mysql</span><br><span class="line">Using default tag: latest	# 如果不写tag,默认就是latest</span><br><span class="line">latest: Pulling from library/mysql	</span><br><span class="line">a330b6cecb98: Pull complete 	# 分层下载，docker image的核心，联合文件系统</span><br><span class="line">9c8f656c32b8: Pull complete </span><br><span class="line">88e473c3f553: Pull complete </span><br><span class="line">062463ea5d2f: Pull complete </span><br><span class="line">daf7e3bdf4b6: Pull complete </span><br><span class="line">1839c0b7aac9: Pull complete </span><br><span class="line">cf0a0cfee6d0: Pull complete </span><br><span class="line">1b42041bb11e: Pull complete </span><br><span class="line">10459d86c7e6: Pull complete </span><br><span class="line">b7199599d5f9: Pull complete </span><br><span class="line">1d6f51e17d45: Pull complete </span><br><span class="line">50e0789bacad: Pull complete </span><br><span class="line">Digest: sha256:99e0989e7e3797cfbdb8d51a19d32c8d286dd8862794d01a547651a896bcf00c #签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest	#真实地址</span><br><span class="line"></span><br><span class="line"><span class="section"># 等价于</span></span><br><span class="line"><span class="code">	docker pull mysql</span></span><br><span class="line"><span class="code">	docker pull docker.io/library/mysql:latest</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 指定版本下载</span></span><br><span class="line"><span class="code">	docker pull mysql:5.7</span></span><br></pre></td></tr></table></figure>

<p>3.<strong>删除镜像docker rmi</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 通过IMAGE ID来删除  </span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">mysql         latest    0716d6ebcc1a   9 days ago     514MB</span><br><span class="line">hello-world   latest    d1165f221234   6 months ago   13.3kB</span><br><span class="line"><span class="section"># 删除指定容器</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker rmi -f 0716d6ebcc1a</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:99e0989e7e3797cfbdb8d51a19d32c8d286dd8862794d01a547651a896bcf00c</span><br><span class="line">Deleted: sha256:0716d6ebcc1a61c5a296fcb187e71f93531e510d4e4400267e2e502103d0194c</span><br><span class="line">Deleted: sha256:dc895a08d34b5b81fc4ca087d2ad52cbe1a2050e249040a22c5f2eabf2f384ba</span><br><span class="line">Deleted: sha256:660229dcf1a452460127a498b9f3f161e7ca94507353ded8af92fe9ab55a32ed</span><br><span class="line">Deleted: sha256:6b26fa2fc4e2150aee2f2557bcbfaf727c00d1650ea08d8ed3fe7c8a6caaa88b</span><br><span class="line">Deleted: sha256:c20303553d5d2594e1655000089b12eca8db7afdcb068cc35fc47ebfe3dab5fb</span><br><span class="line">Deleted: sha256:77a3d69619bfea7b30831a41a32bbf61756c9f95513743deea8daa9a83ff2646</span><br><span class="line">Deleted: sha256:9578f1c7f00f400b3f71be0ee721cbc0892e05e454323e1a74a6e56ae1dafdab</span><br><span class="line">Deleted: sha256:335f9f9fbbd8977530806ed5439a2b67f1c06117f752a2598698de4ae304c516</span><br><span class="line">Deleted: sha256:e15ed274d47a7d6ddff0afcc628143254c69128a9d2379900ebb519e7c6c2bce</span><br><span class="line">Deleted: sha256:51930b767631b583738d75519bed2a8cc757c5b0c904617972386462deee2ca7</span><br><span class="line">Deleted: sha256:43bd682fb659113a8ab168032d8f82dee86d2cee5cee2e146af6c3a6f9ccef18</span><br><span class="line">Deleted: sha256:1957f1873568b423369e0299de6c9b75a111fea807b0c07506ba45d075ca8f80</span><br><span class="line">Deleted: sha256:d000633a56813933cb0ac5ee3246cf7a4c0205db6290018a169d7cb096581046</span><br><span class="line"></span><br><span class="line"><span class="section"># 删除所有</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker images -q</span><br><span class="line">d1165f221234</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker images -aq</span><br><span class="line">d1165f221234</span><br><span class="line"><span class="section"># 删除所有容器</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker rmi -f $(docker images -aq)</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:7d91b69e04a9029b99f3585aaaccae2baa80bcf318f4a5d2165a9898cd2dc0a1</span><br><span class="line">Deleted: sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726	</span><br><span class="line"></span><br><span class="line"><span class="section"># 删除多个容器</span></span><br><span class="line">docker rmi -f 容器ID 容器ID</span><br></pre></td></tr></table></figure>



<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明：我们有了镜像才可以创建容器，linux,下载一个centos镜像来测试学习</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos </span><br></pre></td></tr></table></figure>

<p><strong>新建容器并启动</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"><span class="section"># 参数说明</span></span><br><span class="line">--name=&quot;Name&quot;   容器名字 tomcat01  tomcat02,用来区分容器</span><br><span class="line">-d				后台方式运行</span><br><span class="line">-it				使用交互方式进行，进入容器查看内容</span><br><span class="line">-p				指定容器端口 -p 8000:8000</span><br><span class="line"><span class="code">	-p ip地址:主机端口：容器端口</span></span><br><span class="line"><span class="code">	-p 主机端口：容器端口（常用的）</span></span><br><span class="line"><span class="code">	-p 容器端口</span></span><br><span class="line"><span class="code">	容器端口</span></span><br><span class="line"><span class="code">-p 				随机指定端口</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 测试</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker run -it centos /bin/bash</span><br><span class="line"><span class="section"># 查看容器内的centos,基础版本</span></span><br><span class="line">[root@0c6a69a53f4c /]# ls  </span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="section"># 推出容器内的centos，回到主机</span></span><br><span class="line">[root@0c6a69a53f4c /]# exit  </span><br><span class="line">exit</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# ls /   ##查看服务器内的centos</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  patch  proc  root  run  sbin  srv  sys  tmp  usr  var  www</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>列出所有正在运行的容器</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># docker ps 命令</span></span><br><span class="line"><span class="code">		** 列出当前正在运行的命令</span></span><br><span class="line"><span class="code">-a 		** 列出当前正在运行的容器，带出历史运行过的容器</span></span><br><span class="line"><span class="code">-n=? 	** 显示最近创建的容器</span></span><br><span class="line"><span class="code">-q		** 只显示容器的编号</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 列出正在运行的容器</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line"><span class="section"># 列出当前正在运行的容器，带出历史运行过的容器</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                     PORTS     NAMES</span><br><span class="line">0c6a69a53f4c   centos         &quot;/bin/bash&quot;   10 minutes ago   Exited (0) 4 minutes ago             tender<span class="emphasis">_tesla</span></span><br><span class="line"><span class="emphasis">88fd93955de3   d1165f221234   &quot;/hello&quot;      13 hours ago     Exited (0) 13 hours ago              gracious_</span>ramanujan</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker ps -a -n=1</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">0c6a69a53f4c   centos    &quot;/bin/bash&quot;   18 minutes ago   Exited (0) 13 minutes ago             tender<span class="emphasis">_tesla</span></span><br><span class="line"><span class="emphasis">[root@iZ0jl11vshonpqxdtne6kmZ ~]# </span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit		#容器停止并退出</span><br><span class="line">ctrl键+P+Q  	#容器不停止退出</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id					#删除指定的容器，不能删除正在运行的容器，如果要强制删除，就rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)	 #删除所有容器				</span><br><span class="line">docker ps -a -q|xargs docker rm	 #删除所有容器</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>启动和停止容器的操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id		#启动容器</span><br><span class="line">docker restart 容器id		#重启容器</span><br><span class="line">docker stop 容器id		#停止当前正在运行的容器</span><br><span class="line">docker kill 容器id		#强制停止当前容器</span><br></pre></td></tr></table></figure>



<h2 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h2><p><strong>后台启动容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker run -d 镜像名</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker run -d centos</span><br><span class="line">6a99002cc9904ef0bc14c4957b14f52dd4a46129b8ca4457ae2a074045d45f8b</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">问题docker ps 发现centos停止了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常见的坑：docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用（前台），就会自动停止</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mginx,容器启动后，发现自己没有提供服务，就会立刻停止，就没有程序了。</span></span><br></pre></td></tr></table></figure>

<p><strong>查看日志</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail （10：想输出的日志条数） 17ad99456ebe（容器id）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己编写一段shell脚本</span></span><br><span class="line">&quot;while true;do echo kuangshen;sleepm1;done&quot;</span><br><span class="line"></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker run -d centos /bin/sh -c &quot;while true;do echo kuangshen;sleep 1;done;&quot;</span><br><span class="line">f3c8d96c82dc4ffa585275ae6dba6ab532cfc43341f9a77fa60ef1c9029d581b</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS        PORTS     NAMES</span><br><span class="line">f3c8d96c82dc   centos    &quot;/bin/sh -c &#x27;while t…&quot;   2 seconds ago   Up 1 second             sharp_wing</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示日志</span></span><br><span class="line">-tf								#显示日志</span><br><span class="line">--tail string(输入要显示的日志条数) #显示日志条数	</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker logs -f -t --tail 10 f3c8d96c82dc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>查看容器中进程信息ps</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker top f3c8d96c82dc</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                23694               23674               0                   13:18               ?                   00:00:00            /bin/sh -c while true;do echo kuangshen;sleep 1;done;</span><br><span class="line">root                24826               23694               0                   13:24               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br></pre></td></tr></table></figure>

<p><strong>查看镜像的元数据</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令</span></span><br><span class="line">docker inspect 容器id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker inspect f3c8d96c82dc</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;f3c8d96c82dc4ffa585275ae6dba6ab532cfc43341f9a77fa60ef1c9029d581b&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-09-13T05:18:20.185554446Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true;do echo kuangshen;sleep 1;done;&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 23694,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2021-09-13T05:18:20.476634103Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/f3c8d96c82dc4ffa585275ae6dba6ab532cfc43341f9a77fa60ef1c9029d581b/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/f3c8d96c82dc4ffa585275ae6dba6ab532cfc43341f9a77fa60ef1c9029d581b/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/f3c8d96c82dc4ffa585275ae6dba6ab532cfc43341f9a77fa60ef1c9029d581b/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/f3c8d96c82dc4ffa585275ae6dba6ab532cfc43341f9a77fa60ef1c9029d581b/f3c8d96c82dc4ffa585275ae6dba6ab532cfc43341f9a77fa60ef1c9029d581b-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/sharp_wing&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;host&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/3796c89db1f13d2226cbba13c32503dc6d5b10c9f95298e7d5a16a56bca16955-init/diff:/var/lib/docker/overlay2/92c81934a38db2efb0e3032553acff231ab8edb5292ef4847fce5d32976dbdfa/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/3796c89db1f13d2226cbba13c32503dc6d5b10c9f95298e7d5a16a56bca16955/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/3796c89db1f13d2226cbba13c32503dc6d5b10c9f95298e7d5a16a56bca16955/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/3796c89db1f13d2226cbba13c32503dc6d5b10c9f95298e7d5a16a56bca16955/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;f3c8d96c82dc&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;while true;do echo kuangshen;sleep 1;done;&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20201204&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;ae9f33cc33692fb784f0fb0f34cd8f9c9103c3b3076873adc2505b1e83983c38&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/ae9f33cc3369&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;0f673569c4f41b752f272602d529e7c60f6df10cc5bb30d0b1b28195f2896f2e&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;c1e7b3ee3e4bfb8e34ccac00a6539618102155da2ac56bd49f5f088a1aea1f54&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;0f673569c4f41b752f272602d529e7c60f6df10cc5bb30d0b1b28195f2896f2e&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>进入当前正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们通常容器都是使用后方方式运行的，需要进如容器，修改一些配置</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式一</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ ~]# docker exec -it f3c8d96c82dc /bin/bash</span><br><span class="line">[root@f3c8d96c82dc /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@f3c8d96c82dc /]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 05:18 ?        00:00:00 /bin/sh -c while true;do echo kuangshen;sleep 1;done;</span><br><span class="line">root      1084     0  0 05:36 pts/0    00:00:00 /bin/bash</span><br><span class="line">root      1123     1  0 05:36 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br><span class="line">root      1124  1084  0 05:36 pts/0    00:00:00 ps -ef</span><br><span class="line">[root@f3c8d96c82dc /]#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试</span></span><br><span class="line">[root@f3c8d96c82dc /]# docker attach f3c8d96c82dc</span><br><span class="line">正在执行的代码...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式一与方式二的区别</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">exec</span>  	<span class="comment"># 进入容器后开启一个新的终端，可以在里面操作</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker attach	<span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span></span><br></pre></td></tr></table></figure>

<p><strong>把容器中的文件拷贝到主机上</strong>（这个在主机的终端上操作）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令</span></span><br><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入容器内部</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# docker attach e585a460968b</span><br><span class="line">[root@e585a460968b /]# cd /home</span><br><span class="line">[root@e585a460968b home]# ls </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在容器内新建一个文件</span></span><br><span class="line">[root@e585a460968b home]# touch test.java</span><br><span class="line">[root@e585a460968b home]# ls</span><br><span class="line">test.java</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">退回到主机</span></span><br><span class="line">[root@e585a460968b home]# exit</span><br><span class="line">exit</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                      PORTS     NAMES</span><br><span class="line">e585a460968b   300e315adb2f   &quot;/bin/bash&quot;   3 minutes ago   Exited (0) 14 seconds ago             optimistic_diffie</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将这文件拷贝到主机上</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# docker cp e585a460968b:/home/test.java /home</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# ls</span><br><span class="line">kuangshen  kuangshen.java  redis  test.java  www</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝是一个手动动作，未来我们使用 -V 卷的技术，可以实现</span></span><br></pre></td></tr></table></figure>



<h1 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h1><h2 id="docker安装nginx"><a href="#docker安装nginx" class="headerlink" title="docker安装nginx"></a>docker安装nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.搜索镜像 search 建议去dockerhub搜索，可以看到更多信息</span></span><br><span class="line">	docker hub地址：  https://hub.docker.com/ </span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.下载镜像 pull</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# docker pull nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">a330b6cecb98: Pull complete </span><br><span class="line">e0ad2c0621bc: Pull complete </span><br><span class="line">9e56c3e0e6b7: Pull complete </span><br><span class="line">09f31c94adc6: Pull complete </span><br><span class="line">32b26e9cdb83: Pull complete </span><br><span class="line">20ab512bbb07: Pull complete </span><br><span class="line">Digest: sha256:853b221d3341add7aaadf5f81dd088ea943ab9c918766e295321294b035f3f3e</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line">docker.io/library/nginx:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.运行测试</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否下载成功</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">nginx        latest    ad4c705f24d3   3 days ago     133MB</span><br><span class="line">centos       latest    300e315adb2f   9 months ago   209MB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启nginx容器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name 给容器命名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 宿主机端口，容器内部接口</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">93a6a420ec8c9590e885f5d13559bba55c1060aac48b278baae54452bdddafe9</span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                  NAMES</span><br><span class="line">93a6a420ec8c   nginx     &quot;/docker-entrypoint.…&quot;   9 seconds ago   Up 8 seconds   0.0.0.0:3344-&gt;80/tcp   nginx01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试nginx是否下载成功</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# curl localhost:3344</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.进入容器</span></span><br><span class="line">[root@iZ0jl11vshonpqxdtne6kmZ home]# docker exec -it 93a6a420ec8c /bin/bash</span><br><span class="line">root@93a6a420ec8c:/# </span><br><span class="line">root@93a6a420ec8c:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@93a6a420ec8c:/# cd /etc/nginx</span><br><span class="line">root@93a6a420ec8c:/etc/nginx# ls</span><br><span class="line">conf.d	fastcgi_params	mime.types  modules  nginx.conf  scgi_params  uwsgi_params</span><br><span class="line">root@93a6a420ec8c:/etc/nginx# </span><br></pre></td></tr></table></figure>

<h2 id="docker-安装tomcat"><a href="#docker-安装tomcat" class="headerlink" title="docker 安装tomcat"></a>docker 安装tomcat</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/07/27/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="clrv16wj60003z5kug6zm6lyv" data-title="docker常用命令" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-并发编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2022-06-26T16:00:00.000Z" itemprop="datePublished">2022-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发编程学习"><a href="#并发编程学习" class="headerlink" title="并发编程学习"></a>并发编程学习</h1><p><strong>java快捷键：</strong></p>
<p>CTRL+alt：给代码加上一些语句，如try-catch,if-else</p>
<p>F4：查看类的层级关系</p>
<p>双击shift：进行全局搜索</p>
<p>Alt+Enter：抛出try-catch异常对码</p>
<p>Alt+Shift+M：将代码提取成一个方法</p>
<h2 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2.进程与线程"></a>2.进程与线程</h2><h3 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h3><blockquote>
<ul>
<li>进程：<ul>
<li>进程可以视为程序的一个实例。大部分程序可以同时运行多个实例进程。但也有的程序只能启动一个实例进程。</li>
<li>进程就是用来加载指令、管理内存的。</li>
</ul>
</li>
<li>线程：（内核态线程，内核态，线程跑多个协程，栈MB级别）<ul>
<li>一个进程之内，可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行</li>
<li>Java中，线程作为最小的调度单位，进程作为资源分配的最小单位，在windows中进程是不活动的，只是作为线程的容器。</li>
</ul>
</li>
<li>两者对比：<ul>
<li>进程基本上是独立的，而线程存在于进程内，是进程的一个子集。</li>
<li>进程拥有共享的资源，如内存空间，供其内部的线程共享</li>
<li>线程更轻量，线程上下文切换成本一般要比进程上下文切换低。</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。</li>
<li>进程间通信更加复杂</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-2-并行与并发"><a href="#2-2-并行与并发" class="headerlink" title="2.2 并行与并发"></a>2.2 并行与并发</h3><blockquote>
<ul>
<li>一般会将这种线程轮流使用CPU的做法称为并发，concurrent</li>
<li>多核CPU下，每个核（core）都可以调度运行线程，这时候线程可以是并行的。</li>
<li>并发：是同一时间应对多件事情的能力 （同一时间段内做多件）</li>
<li>并行：是同一时间动手做多件事情的能力 （同一时间做多件）</li>
</ul>
</blockquote>
<h3 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3 应用"></a>2.3 应用</h3><blockquote>
<ul>
<li>同步与异步：<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
</li>
<li>注意：同步在多线程中还有另外一层意思，是让多个线程步调一致</li>
</ul>
</blockquote>
<h2 id="3-Java线程"><a href="#3-Java线程" class="headerlink" title="3. Java线程"></a>3. Java线程</h2><h3 id="3-1-创建和运行线程"><a href="#3-1-创建和运行线程" class="headerlink" title="3.1 创建和运行线程"></a>3.1 创建和运行线程</h3><blockquote>
<ul>
<li><p>方法一，直接使用Thread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法的参数是给线程指定名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体内实现了要执行的任务</span></span><br><span class="line">        XXXXXXXX</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Thread t = new Thread(&quot;t1&quot;)&#123;
        @Override
        public void run() &#123;
            log.debug(&quot;hello&quot;);
        &#125;
    &#125;;
    //t.setName(&quot;t1&quot;);
    t.start();
    log.debug(&quot;main&quot;);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 方法二，使用Runnable配合使用Thread</span><br><span class="line"></span><br><span class="line">  - 把线程和任务（要执行的代码分开）</span><br><span class="line">  - Thread代表线程</span><br><span class="line">  - Runnable可运行的任务（线程要执行的代码）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Runnable runnable = new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //要执行的任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">          </span><br><span class="line">    //创建线程对象</span><br><span class="line">    Thread t = new Thread(runnable);</span><br><span class="line">    //启动线程</span><br><span class="line">    t.start();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>例如</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Runnable runnable = new Runnable() &#123;
        @Override
        public void run() &#123;
            log.debug(&quot;hello&quot;);
        &#125;
    &#125;;
    Thread t = new Thread(runnable,&quot;t2&quot;);
    t.setName(&quot;t2&quot;);
    t.start();
    log.debug(&quot;main&quot;);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在Java 8之后也可以使用lambda 表达式进行简化</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      Runnable runnable = () -&gt; &#123;</span><br><span class="line">          log.debug(&quot;hello&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line">      Thread t = new Thread(runnable,&quot;t2&quot;);</span><br><span class="line">      t.setName(&quot;t2&quot;);</span><br><span class="line">      t.start();</span><br><span class="line">      log.debug(&quot;main&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>原理之Thread与Runnable的关系：</p>
<ul>
<li>分析Thread的源码，理清它与Runnable的关系：</li>
<li>小结：<ul>
<li>方法一是把线程和任务合并在了一起，方法二是把线程和任务分开了</li>
<li>用Runnable更容易与线程池等高级API配合</li>
<li>用Runnable让任务脱离了Thread继承体系，更灵活</li>
</ul>
</li>
</ul>
</li>
<li><p>方法三，FutureTask</p>
<ul>
<li><p>FutureTask能够接收Callable类型的参数，用来处理有返回结果的情况</p>
</li>
<li><pre><code class="java">//创建任务对象
FutureTask&lt;Integer&gt; task3 = new FutureTask&lt;Integer&gt;(() -&gt; &#123;
   log.debug(&quot;hello&quot;);
   return 100;
&#125;);
            
//参数1是任务对象，参数2是线程名字，推荐
new Thread(task3,&quot;t3&quot;).start();
            
//主线程阻塞，同步等待task执行完毕的结果
Integer result = task3.get();
log.debug(result);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 例如：</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">      Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public Integer call() throws Exception &#123;</span><br><span class="line">              log.debug(&quot;hello&quot;);</span><br><span class="line">              TimeUnit.MILLISECONDS.sleep(1000);</span><br><span class="line">              return 100;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">      Thread thread = new Thread(futureTask,&quot;t3&quot;);</span><br><span class="line">      thread.start();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      Integer integer = futureTask.get();</span><br><span class="line">      log.debug(&quot;结果是：&quot;+integer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-3-查看进程线程的方法"><a href="#3-3-查看进程线程的方法" class="headerlink" title="3.3 查看进程线程的方法"></a>3.3 查看进程线程的方法</h3><blockquote>
<ul>
<li>windows<ul>
<li>任务管理器查看进程</li>
<li>tasklist查看进程</li>
<li>taskkill杀死进程</li>
</ul>
</li>
<li>linux<ul>
<li>ps -fe 查看所有进程</li>
<li>ps  -fT -p <PID>  查看某个进程（PID）的所有线程</li>
<li>kill  [PID] 杀死进程[PID]</li>
<li>top 查看进程中相关信息</li>
</ul>
</li>
<li>java<ul>
<li>jps 命令查看所有Java线程</li>
<li>jstack <PID>查看某个Java进程的所有线程状态</li>
<li>jconsole 来查看某个Java进程中线程的运行情况（图形界面）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-4-原理之线程运行"><a href="#3-4-原理之线程运行" class="headerlink" title="3.4 原理之线程运行"></a>3.4 原理之线程运行</h3><blockquote>
<p>栈与栈帧</p>
<ul>
<li>我们都知道JVM中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</li>
<li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存。</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li>
</ul>
<p>线程上下文切换（Thread Context Switch）</p>
<ul>
<li>因为以下原因导致cpu不再执行当前的线程，转而执行另一个线程的代码<ul>
<li>线程的CPU时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要执行</li>
<li>线程自己调用了sleep,yield,wait,join,park,synchronized,lock等方法</li>
</ul>
</li>
<li>当Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的方法，Java中对应的概念就是程序计数器，它的作用是记住下一条JVM指令的执行地址，是线程私有的。<ul>
<li>Context Switch频繁发生会影响性能。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-5-常见方法"><a href="#3-5-常见方法" class="headerlink" title="3.5 常见方法"></a>3.5 常见方法</h3><blockquote>
<ul>
<li>start( ) ：启动新线程，start( )方法只能被调用一次，让线程进行就绪状态 （执行前，该线程的状态是NEW,执行后状态是RUNNABLE） </li>
<li>run( )：让线程进行运行。</li>
</ul>
</blockquote>
<h3 id="3-6-run-和start-区别"><a href="#3-6-run-和start-区别" class="headerlink" title="3.6  run()和start() 区别"></a>3.6  run()和start() 区别</h3><blockquote>
<ul>
<li>直接运行run( )方法，这并没有开启线程来进行执行，只是普通的方法执行由main线程来进行执行。</li>
<li>start( )方法会启动一个线程，并且由这个新开启的线程来运行run( )方法。start（）方法只能执行一次</li>
</ul>
</blockquote>
<h3 id="3-7-sleep-与yield-区别"><a href="#3-7-sleep-与yield-区别" class="headerlink" title="3.7 sleep() 与yield()区别"></a>3.7 sleep() 与yield()区别</h3><blockquote>
<ul>
<li><p>sleep:</p>
<ul>
<li>调用sleep会让当前线程从Running进入Timed Waiting状态(阻塞)</li>
<li>其他线程可以使用interrupt()方法来打断正在睡眠的线程，这是sleep方法会抛出InterruptedException </li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;enter sleep&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">//                    Thread.sleep(2000);</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;中断异常了&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.run();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">      </span><br><span class="line">    thread.start();</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;interrupt...&quot;</span>);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>yield:</p>
<ul>
<li>调用yield会让当前线程从Running进入Runnable就绪状态，然后调度执行其他同优先级的线程。如果这是没有同优先级的线程，那么不能保证让当前线程暂停的效果</li>
<li>具体的实现依赖于操作系统的任务调度</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>线程优先级：</p>
<ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果cpu比较忙，那么优先级高的线程会获得更多的时间片，但CPU空闲，优先级几乎没作用。</li>
</ul>
</blockquote>
<blockquote>
<p>案例：防止CPU占用100%</p>
<ul>
<li><p>&#x3D;&#x3D;sleep实现。&#x3D;&#x3D;【在没有利用cpu来进行计算时，不要让while(true)空转浪费CPU,这时可以用yield&#x2F;sleep来出让CPU的使用权给其他程序】</p>
</li>
<li><pre><code class="java">while (true) &#123;
    try &#123;
        Thread.sleep(50);
    &#125; catch(Exception e) &#123;
        sout(e);
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 可以用wait() 或条件变量来达到类似效果</span><br><span class="line">- 不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景</span><br><span class="line">- sleep适用于无需锁同步的场景</span><br><span class="line">- ==wait实现==</span><br><span class="line"></span><br><span class="line">### 3.8 join方法详解</span><br><span class="line"></span><br><span class="line">- ==join（）方法就是需要让调用该方法的线程 执行结束以后才可以继续往下运行。==（通过isAlive()来进行判断，如果为true，就在这里wait( )等待）</span><br><span class="line"></span><br><span class="line">- join(long mills)  方法是进行等待mills毫秒后，如果调用join方法的调用者依然存活，就不会继续进行等待，而是去执行后面的内容</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">   static int r = 0;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) throws Exception&#123;</span><br><span class="line">       test1();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void test1() throws Exception&#123;</span><br><span class="line">       log.debug(&quot;开始&quot;);</span><br><span class="line">       Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">           log.debug(&quot;开始&quot;);</span><br><span class="line">           try &#123;</span><br><span class="line">               sleep(1);</span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           r = 10;</span><br><span class="line">       &#125;);</span><br><span class="line">       thread.start();</span><br><span class="line">       thread.join(); //main线程会等待thread这个线程执行完后才开始往后继续执行，这里的join方法就是等待thread线程执行完</span><br><span class="line">       log.debug(&quot;jieguowei &quot;+r);</span><br><span class="line">       log.debug(&quot;结束&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<p>应用之同步（案例1）：</p>
<ul>
<li>以调用角度来讲，如果<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果，就能继续运行就是异步</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-9-interrupt方法详解"><a href="#3-9-interrupt方法详解" class="headerlink" title="3.9 interrupt方法详解"></a>3.9 interrupt方法详解</h3><blockquote>
<p>打断sleep、wait、join的线程 【打断处于阻塞状态】</p>
<ul>
<li><p>&#x3D;&#x3D;打断正在sleep的线程，会清空打断状态&#x3D;&#x3D;（初始情况下为false），即打断后，打断状态依然为false.以sleep为例</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Thread t1 = new Thread(() -&gt; &#123;
        log.debug(&quot;sleep...&quot;);
        try &#123;
            TimeUnit.SECONDS.sleep(5);
        &#125; catch (InterruptedException e) &#123;
                  
            e.printStackTrace();
        &#125;
    &#125;,&quot;t1&quot;);
      
    t1.start();
      
    log.debug(&quot;interrupt&quot;);
    try &#123;
        TimeUnit.SECONDS.sleep(1);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    log.debug(&quot;打断前，中断标记 &quot;+t1.isInterrupted());  //false
    t1.interrupt();
    log.debug(&quot;打断后，中断标记 &quot;+t1.isInterrupted());  //false
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ==打断正常执行的线程，不会清空中断状态，打断后，打断状态变为true.==</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">              if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                  //这里在主线程将该线程打断后，就会进入到其中来，然后break跳出。</span><br><span class="line">                  break;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  //没有被中断就做事</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,&quot;t1&quot;);</span><br><span class="line">        </span><br><span class="line">      t1.start();</span><br><span class="line">        </span><br><span class="line">      log.debug(&quot;interrupt&quot;);</span><br><span class="line">      try &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(1);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      log.debug(&quot;打断前，中断标记 &quot;+t1.isInterrupted());  //false</span><br><span class="line">      t1.interrupt();</span><br><span class="line">      log.debug(&quot;打断后，中断标记 &quot;+t1.isInterrupted());  //true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;两阶段终止模式：&#x3D;&#x3D;</p>
<ul>
<li>在一个线程T1中如何优雅地终止线程T2?这里的优雅指的是给T2一个料理后事的机会</li>
</ul>
<p>错误思路：</p>
<ul>
<li><p>使用线程对象的stop( )方法停止线程</p>
<ul>
<li>stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其他线程将永远无法获取锁</li>
</ul>
</li>
<li><p>使用system.exit(int)方法停止线程</p>
<ul>
<li>目的是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
</li>
<li><p>正确的解决办法：通过interrupt( ) + isInterrupted()方式来进行处理。【isInterrupted( )在返回中断状态后，不会清除中断状态，而interrupted( )方法功能是一样的，但是会清除掉中断状态，即会变成false】</p>
</li>
<li><pre><code class="java">@Slf4j(topic = &quot;c.Test3&quot;)
public class Test3 &#123;
    public static void main(String[] args) &#123;
        TwoPhaseTermination termination = new TwoPhaseTermination();
        termination.start();
        try &#123;
            TimeUnit.SECONDS.sleep(4);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        termination.stop();
    &#125;
&#125;
      
@Slf4j(topic = &quot;c.Test3&quot;)
class TwoPhaseTermination &#123;
    private Thread monitor;
    //启动监控线程
    public void start() &#123;
        monitor = new Thread(() -&gt; &#123;
            while (true) &#123;
                if (Thread.currentThread().isInterrupted()) &#123;
                    //如果被打断
                    log.debug(&quot;料理后事&quot;);
                    break;
                &#125;
                try &#123;
                    TimeUnit.SECONDS.sleep(1); //情况1
                    log.debug(&quot;执行监控记录&quot;);
                &#125; catch (InterruptedException e) &#123;
                    //这里是在线程处于sleep时，被主线程interrupt之后进入，但是此时isInterrupted()依然为false,
                    //因为打断sleep会清空中断状态，所以为了真正退出，所以需要再次进行interrupt,此时就是自己中断自己
                    //这是一次正常的interrupt，所以isInterrupted()就变为true了，因此就可以通过上面退出while了。
                    Thread.currentThread().interrupt();
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;);
        monitor.start();
    &#125;
      
    //停止监控线程
    public void stop() &#123;
        monitor.interrupt();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ==打断park线程==</span><br><span class="line"></span><br><span class="line">  - 打断park线程，不会清空打断状态</span><br><span class="line"></span><br><span class="line">  - park( )方法只有在中断状态为false （即isInterrupt( )方法返回false）的时候，才能够停下来。</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(&quot;park...&quot;);</span><br><span class="line">            LockSupport.park();  //执行到这里会一直等待</span><br><span class="line">            log.debug(&quot;unpark...&quot;);</span><br><span class="line">            log.debug(&quot;打断状态 &#123;&#125;&quot;,Thread.currentThread().isInterrupted());</span><br><span class="line">            //log.debug(&quot;打断状态 &#123;&#125;&quot;,Thread.currentThread().interrupted());</span><br><span class="line">            log.debug(&quot;park...&quot;);</span><br><span class="line">            LockSupport.park();  //执行到这里会一直等待</span><br><span class="line">            log.debug(&quot;unpark...&quot;);</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">                </span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                </span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<h3 id="3-10-不推荐使用的方法"><a href="#3-10-不推荐使用的方法" class="headerlink" title="3.10 不推荐使用的方法"></a>3.10 不推荐使用的方法</h3><blockquote>
<p>这些方法已经过时，容易破坏同步代码块，造成线程死锁</p>
<ul>
<li>stop( ) 停止线程运行</li>
<li>suspend( ) 挂起（暂停）线程运行</li>
<li>resume( ) 恢复线程运行</li>
</ul>
</blockquote>
<h3 id="3-11-主线程与守护线程（damon线程）"><a href="#3-11-主线程与守护线程（damon线程）" class="headerlink" title="3.11 主线程与守护线程（damon线程）"></a>3.11 主线程与守护线程（damon线程）</h3><blockquote>
<ul>
<li>默认情况下，Java进程需要等待所有线程都运行结束，才会结束。正常创建的线程都是非守护线程。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</li>
<li>通过 setDamon(true)  来进行设置是否是守护线程，默认为false。</li>
<li>注意：<ul>
<li>垃圾回收器线程（finalizer）就是一种守护线程</li>
<li>Tomcat中的Accept都是守护线程。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-12-线程状态（五种状态）"><a href="#3-12-线程状态（五种状态）" class="headerlink" title="3.12 线程状态（五种状态）"></a>3.12 线程状态（五种状态）</h3><blockquote>
<p>操作系统层面有五种状态：</p>
<ul>
<li>初始状态：仅是在语言层面创建了线程对象，还未与操作系统线程关联</li>
<li>可运行状态：就绪状态，指该状态已经被创建（与操作系统相关联），可以由CPU调度执行</li>
<li>运行状态：指获取了CPU时间片运行中的状态<ul>
<li>当CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>阻塞状态：<ul>
<li>如果调用了阻塞API，如BIO （阻塞IO）读写文件，这是该线程实际不会用到CPU，会导致线程上下文切换，进入阻塞状态</li>
<li>等BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说，只要它们一直不唤醒，调度器就一直不会考虑调度它们。</li>
</ul>
</li>
<li>终止状态：表示线程已经执行完毕，生命周期已经结束，不会再转换为其他状态</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220518164204214.png" alt="image-20220518164204214"></p>
</blockquote>
<h3 id="3-13-线程状态（六种状态）"><a href="#3-13-线程状态（六种状态）" class="headerlink" title="3.13 线程状态（六种状态）"></a>3.13 线程状态（六种状态）</h3><blockquote>
<p>Java层面有六种状态：（主要针对的是State枚举类字段有六个值，NEW，RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED）</p>
<ul>
<li>NEW：new线程刚被创建，但是还没有调用start( )方法</li>
<li>RUNNABLE：当调用了start( )方法之后，注意Java API层面的RUNNABLE状态涵盖了操作系统层面的【可运行状态】、【运行状态】、【阻塞状态】（由于BIO导致的线程阻塞，在Java里无法区分，仍然认为是可运行）</li>
<li>BLOCKED，WAITING,TIMED_WAITING都是Java API层面对阻塞状态的细分</li>
<li>TERMINATED当线程代码运行结束</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70" alt="线程状态图"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示线程的六种状态</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestState&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;t1状态&#123;&#125;&quot;</span>,t1.getState());</span><br><span class="line">        t1.start();</span><br><span class="line">        log.debug(<span class="string">&quot;t1状态&#123;&#125;&quot;</span>,t1.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;t1状态&#123;&#125;&quot;</span>,t1.getState());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;t2状态&#123;&#125;&quot;</span>,t2.getState());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;t3状态&#123;&#125;&quot;</span>,t3.getState());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            func();</span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line">        t4.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            func();</span><br><span class="line">        &#125;, <span class="string">&quot;t5&quot;</span>);</span><br><span class="line">        t5.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;t4状态&#123;&#125;&quot;</span>,t4.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t5状态&#123;&#125;&quot;</span>,t5.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">00</span> <span class="number">779</span> [main] c.TestState - t1状态NEW</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">00</span> <span class="number">787</span> [main] c.TestState - t1状态RUNNABLE</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">01</span> <span class="number">1795</span> [main] c.TestState - t1状态TERMINATED</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">02</span> <span class="number">2799</span> [main] c.TestState - t2状态TIMED_WAITING</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">03</span> <span class="number">3802</span> [main] c.TestState - t3状态WAITING</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">04</span> <span class="number">4809</span> [main] c.TestState - t4状态TIMED_WAITING</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">04</span> <span class="number">4809</span> [main] c.TestState - t5状态BLOCKED</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(洗水壶 1分钟) --&gt; b(烧开水 15分钟)</span><br><span class="line">c(洗茶壶,洗茶杯,拿茶叶 4分钟)  </span><br><span class="line">b --&gt; f(泡茶)</span><br><span class="line">c --&gt; f(泡茶)</span><br></pre></td></tr></table></figure>

<h3 id="3-14-本章小结"><a href="#3-14-本章小结" class="headerlink" title="3.14 本章小结"></a>3.14 本章小结</h3><blockquote>
<p>本章的重点在于：</p>
<ul>
<li>线程创建</li>
<li>线程重要的方法：如 start( ),run( ),sleep( ),join( ),interrupt( ),isInterrupted( )</li>
<li>线程状态</li>
<li>同步等待 join( )</li>
<li>模式方面：两阶段终止（isInterrupted( )）</li>
</ul>
</blockquote>
<h2 id="4-共享模型之管程（Monitor）"><a href="#4-共享模型之管程（Monitor）" class="headerlink" title="4.共享模型之管程（Monitor）"></a>4.共享模型之管程（Monitor）</h2><h3 id="4-1-线程共享存在的问题"><a href="#4-1-线程共享存在的问题" class="headerlink" title="4.1 线程共享存在的问题"></a>4.1 线程共享存在的问题</h3><blockquote>
<ul>
<li><p>Java的体现：</p>
<ul>
<li><p>两个线程对初始值进行操作</p>
</li>
<li><pre><code class="java">public class Test4 &#123;
    private static int count = 0;
    public static void main(String[] args) throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                count++;
            &#125;
        &#125;, &quot;t1&quot;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                count--;
            &#125;
        &#125;);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug(&quot;&#123;&#125;&quot;,count);
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 问题分析：以上的结果值是随机的？因为Java中对静态变量的自增，自建操作并不是原子操作，要彻底理解，必须从字节码来进行分析？</span><br><span class="line"></span><br><span class="line">- 例如：对于i++而言（i为静态变量），实际会产生如下的JVM字节码指令。</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  0: getstatic     #2                  // Field count:I  获取静态变量i的值</span><br><span class="line">  3: iconst_1							//准备常量1</span><br><span class="line">  4: iadd								//自增</span><br><span class="line">  5: putstatic     #2                  // Field count:I   将修改后的值存入静态变量i</span><br><span class="line">              </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>而对应的i–也是类似</p>
</li>
<li><pre><code class="java">0: getstatic     #2                  // Field count:I
3: iconst_1
4: isub
5: putstatic     #2                  // Field count:I
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 而Java内存的模型如下，完成静态变量的自增和自减需要在主存和工作内存中进行数据交换。（静态变量存放在方法区/元空间中，由所有线程共享，而非静态变量i存放在虚拟机栈中，每个线程各自有一份）</span><br><span class="line">  - 如果上面代码是在单线程下是不会存在问题的。</span><br><span class="line">  - 在多线程环境下，会出现上下文切换，导致会出问题。</span><br><span class="line"></span><br><span class="line">==临界区==：一段代码块内如果存在对共享资源的多线程读写操作，称这段代码为临界区。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static int counter = 0;</span><br><span class="line">static void increment() &#123;</span><br><span class="line">	//临界区</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void increment() &#123;</span><br><span class="line">	//临界区</span><br><span class="line">    counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;竟态条件(RaceCondition)&#x3D;&#x3D;：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竟态条件。</p>
</blockquote>
<h3 id="4-2-synchronized解决方案"><a href="#4-2-synchronized解决方案" class="headerlink" title="4.2 synchronized解决方案"></a>4.2 synchronized解决方案</h3><blockquote>
<p>应用之互斥：</p>
<ul>
<li><p>为了避免临界区的竟态条件发生，有多种手段可以达到目的：</p>
<ul>
<li>阻塞式的解决方案：synchronized,Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
</li>
<li><p>本次课使用阻塞式的解决方案：synchronized，来解决问题，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其他线程再想获取这个对象锁时就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<ul>
<li>注意：</li>
<li>虽然Java中互斥和同步都可以采用synchronized关键字来完成，但它们是有区别的<ul>
<li>互斥是保证临界区的竟态条件发生，同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后、顺序不同，需要一个线程等待其他线程运行到某个点</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>synchronized：</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">	临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决上面的问题代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="comment">//临界区</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="comment">//临界区</span></span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：</p>
<ul>
<li>synchronized实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程所打断</li>
</ul>
</blockquote>
<h3 id="4-3-方法上的synchronized"><a href="#4-3-方法上的synchronized" class="headerlink" title="4.3 方法上的synchronized"></a>4.3 方法上的synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            方法体</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">######################################################</span><br><span class="line"><span class="comment">//锁住的是类对象，类对象只有一个。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">            方法体</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所谓的线程八锁：</p>
<p>其实就是考察synchronized锁住的是哪个对象：</p>
</blockquote>
<h3 id="4-4-变量的线程安全分析"><a href="#4-4-变量的线程安全分析" class="headerlink" title="4.4 变量的线程安全分析"></a>4.4 变量的线程安全分析</h3><blockquote>
<p>&#x3D;&#x3D;成员变量和静态变量是否线程安全？&#x3D;&#x3D;</p>
<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全。</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadUnsafe</span> <span class="variable">threadUnsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafe</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                threadUnsafe.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;Thread&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadUnsafe</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的代码存在问题：</span></span><br><span class="line">因为两个线程使用的是同一个ThreadUnsafe对象，而这个对象使用的是成员变量list,成员变量位于方法区或者叫元空间，所以两个线程操作的是堆中的同一个对象，因此会存在一个线程在add操作时读取了list，准备进行add但是还没有add成功的时候，而另一个线程就也读取了list对象，准备add,所以会出现虽然每个线程都add了一次，但是list对象本身可能只add了一个值，因此在后面进行两次remove的时候，就会出现ArrayIndexOutOfBoundsException。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;局部变量是否线程安全?&#x3D;&#x3D;</p>
<ul>
<li>局部变量是线程安全的</li>
<li>但局部变量引用的对象则未必：<ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的</li>
<li>如果该对象逃离方法的作用访问，它是线程不安全的</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadSafe</span> <span class="variable">threadsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafe</span>();  <span class="comment">//此时操作的是局部变量就是线程安全的了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                threadsafe.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;Thread&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象逃离对象的访问，就是线程不安全的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadSafeSubClass</span> <span class="variable">threadsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafeSubClass</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                threadsafe.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;Thread&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//这里就又会导致多个线程操作同一个对象，虽然该对象是一个对于前面来说是局部变量的对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;   </span><br><span class="line">           list.add(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常见的线程安全类：</p>
<ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>HashTable</li>
<li>java.util.concurrent包下的类</li>
</ul>
<p>这里说它们是线程安全的，多个线程调用它们同一个实例的某个方法时，是线程安全的，也可以理解为</p>
<ul>
<li>它们的每个方法是原子的 （例如HashTable中的put方法上加了synchronized）</li>
<li>但注意它们多个方法的组合不是原子的</li>
</ul>
</blockquote>
<blockquote>
<p>不可变类线程安全性：</p>
<ul>
<li>String，Integer等都是不可变类，因为其内部的对象是不可改变，因此它们的方法都是线程安全的</li>
</ul>
</blockquote>
<h3 id="4-5-习题"><a href="#4-5-习题" class="headerlink" title="4.5 习题"></a>4.5 习题</h3><blockquote>
<p>买票练习：</p>
<p>下面的代码是存在线程安全问题的。改进的方法就是在sell售票方法上面加上synchronized,对象加锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Sell&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sell</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//模拟多人买票</span></span><br><span class="line">        <span class="type">TicketWindow</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketWindow</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//卖出的票数统计</span></span><br><span class="line">        List&lt;Integer&gt; amount = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sell</span> <span class="operator">=</span> window.sell(randomAmount());</span><br><span class="line">                amount.add(sell);</span><br><span class="line">            &#125;,<span class="string">&quot;thread&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">            thread.start();</span><br><span class="line">            list.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread th : list) &#123;</span><br><span class="line">            th.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计卖出的票数与剩余的票数是否符合</span></span><br><span class="line">        log.debug(<span class="string">&quot;剩余票数&#123;&#125;&quot;</span>,window.getCount());</span><br><span class="line">        log.debug(<span class="string">&quot;卖出的票数&#123;&#125;&quot;</span>,amount.stream().mapToInt(i -&gt; i).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//售票窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketWindow</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TicketWindow</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取余票数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//售票</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sell</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.count &gt;= amount) &#123;</span><br><span class="line">            <span class="built_in">this</span>.count -= amount;</span><br><span class="line">            <span class="keyword">return</span> amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /L %n <span class="keyword">in</span> (1,1,10) <span class="keyword">do</span> java -<span class="built_in">cp</span> <span class="string">&quot;.;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repository\ch\qos\logback\logback-classic\1.2.11\logback-classic-1.2.11.jar;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repository\ch\qos\logback\logback-core\1.2.11\logback-core-1.2.11.jar;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repository\org\slf4j\slf4j-api\1.7.32\slf4j-api-1.7.32.jar&quot;</span> com.example.n4.Sell</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行命令如下：</span></span><br><span class="line">D:\workspace\idea\JVMDemo\concurrent\target\classes&gt;java -<span class="built_in">cp</span> <span class="string">&quot;.;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repositor</span></span><br><span class="line"><span class="string">y\ch\qos\logback\logback-classic\1.2.11\logback-classic-1.2.11.jar;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_reposi</span></span><br><span class="line"><span class="string">tory\ch\qos\logback\logback-core\1.2.11\logback-core-1.2.11.jar;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repositor</span></span><br><span class="line"><span class="string">y\org\slf4j\slf4j-api\1.7.32\slf4j-api-1.7.32.jar&quot;</span> com.example.n4.Sell</span><br></pre></td></tr></table></figure>

<blockquote>
<p>转账练习：</p>
<ul>
<li>下面的代码存在线程安全问题，但是注意解决的办法不能简单的在transfer方法上面加synchronized,因为这样是等同于给某一个具体的Account对象进行加锁，并不能防止另一个Account对象对共享资源的访问，所以应该加Account.class对象，这样两个对象共用同一个锁对象，此时就能锁住了。但是这样做效率不是很高。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Transfer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                a.transfer(b,randomAmount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                b.transfer(a,randomAmount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="comment">//查看2000次转账后的总金额看是否发生变化</span></span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,(a.getMoney()+b.getMoney()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//账户</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target,<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="comment">//synchronized(Account.class) &#123;</span></span><br><span class="line">        <span class="comment">//synchronized(this) &#123;   </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= amount) &#123;</span><br><span class="line">                <span class="built_in">this</span>.setMoney(<span class="built_in">this</span>.getMoney() - amount);</span><br><span class="line">                target.setMoney(target.getMoney() + amount);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-Monitor概念"><a href="#4-6-Monitor概念" class="headerlink" title="4.6 Monitor概念"></a>4.6 Monitor概念</h3><p>Java对象头：（以32位虚拟机为例）</p>
<ul>
<li>普通对象</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                     Object Header (64 bits)                  </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|        <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)         |<span class="params">    Klass Word (32 bits) </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组对象</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">---------------------------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                                 Object Header (96 bits)                         </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br><span class="line">|<span class="params">        Mark Word(32bits)       </span>|    <span class="title class_">Klass</span> <span class="title class_">Word</span>(32bits) |<span class="params">  array length(32bits)  </span>|</span><br><span class="line">|<span class="params">----------------------------- --</span>|-----------------------|<span class="params">------------------------</span>|</span><br></pre></td></tr></table></figure>

<ul>
<li>其中Mark Word结构为</li>
</ul>
<blockquote>
<ul>
<li><p>mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位。JVM将字的最低两个位设置为标记位。</p>
</li>
<li><p>age:4：表示gc分代年龄，即转化为老年代的阈值</p>
</li>
</ul>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                  <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)                  |<span class="params">       State        </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| <span class="symbol">identity_hashcode:</span><span class="number">25</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span> |<span class="params"> 01     </span>|       <span class="title class_">Normal</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">  thread:23 </span>| <span class="symbol">epoch:</span><span class="number">2</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">1</span> |<span class="params"> 01     </span>|       <span class="title class_">Biased</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">               ptr_to_lock_record:30          </span>| <span class="number">00</span>     |<span class="params"> Lightweight Locked </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|               <span class="symbol">ptr_to_heavyweight_monitor:</span><span class="number">30</span>  |<span class="params"> 10     </span>| <span class="title class_">Heavyweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                                              </span>| <span class="number">11</span>     |<span class="params">    Marked <span class="keyword">for</span> GC   </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Monitor（锁）</strong></p>
<p>Monitor被翻译为<strong>监视器或管程</strong>。【注意】Monitor是在操作系统中的表示</p>
<ul>
<li><p>每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针</p>
</li>
<li><p>正常情况下，Java对象头中的Mark Word处于Normal状态（标志位为01），当执行synchronized代码之后，就转化到标识为10状态，其中ptr_to_heavyweight_monitor就会指向操作系统中的Monitor管程。后面的过程如下。</p>
</li>
<li><p>大致过程如下：</p>
<ul>
<li>刚开始Monitor中Owner为null</li>
<li>当Thread-2执行synchronized(obj){ }就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner</li>
<li>在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入Monitor中的entryList字段，进入 Blocked状态</li>
<li>Thread-2执行完同步代码块以后，然后会唤醒EntryList中等待的线程来竞争锁，竞争的是非公平的。</li>
<li>其中Monitor中还有WAITING字段，Thread-0，Thread-1是之前获得过锁，但条件不满足进行WAITING状态的线程，后面讲wait-notify时会分析。</li>
</ul>
</li>
<li><blockquote>
<p>注意：</p>
<ul>
<li>synchronized必须是进入同一个对象的monitor,才有上述的效果</li>
<li>不加synchronized的对象不会关联监视器，不遵从以上规则。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<p>原理之synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的代码编译成字节码文件为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: getstatic     #2    //&lt;- lock引用       // Field lock:Ljava/lang/Object;</span><br><span class="line">         3: dup						</span><br><span class="line">         4: astore_1			//lock引用 -&gt; slot 1  局部变量表</span><br><span class="line">         5: monitorenter		//将lock对象 Mark Word置为Monitor指针</span><br><span class="line">         6: getstatic     #3    // &lt;- i             // Field counter:I</span><br><span class="line">         9: iconst_1			//准备常数1</span><br><span class="line">        10: iadd				//+1操作</span><br><span class="line">        11: putstatic     #3    // -&gt; i              // Field counter:I</span><br><span class="line">        14: aload_1				//&lt;- lock引用</span><br><span class="line">        15: monitorexit			//将lock对象Mark Word重置，唤醒EntryList</span><br><span class="line">        16: goto          24</span><br><span class="line">        19: astore_2			//e -&gt; slot 2</span><br><span class="line">        20: aload_1				// &lt;- lock引用</span><br><span class="line">        21: monitorexit			//将lock对象Mark Word重置，唤醒entryList</span><br><span class="line">        22: aload_2				//&lt;- slot 2 (e)</span><br><span class="line">        23: athrow				//throw e</span><br><span class="line">        24: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             6    16    19   any</span><br><span class="line">            19    22    19   any</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>synchronized原理进阶</p>
</blockquote>
<ol>
<li><strong>轻量级锁</strong></li>
</ol>
<blockquote>
<ul>
<li><p>轻量级锁的适用场景：如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
</li>
<li><p>轻量级锁对使用者是透明的，即语法仍然是synchronized</p>
</li>
<li><p>假设有两个方法同步块，利用同一个对象加锁</p>
</li>
<li><pre><code class="java">static final Object obj = new Object();
public static void method1() &#123;
    synchronized (obj) &#123;
        //同步块A
        method2();
    &#125;
&#125;
    
public static void method2() &#123;
    synchronized (obj) &#123;
        //同步块B
    
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</span><br><span class="line"></span><br><span class="line">- 让锁记录中Object reference指向锁对象，并开始尝试用cas替换Object的Mark Word，将Mark Word的值存入锁记录。</span><br><span class="line"></span><br><span class="line">- 如果cas替换成功，对象头中存储了锁记录地址和状态 00，表示由该线程给对象加锁</span><br><span class="line"></span><br><span class="line">- 如果cas失败，有两种情况：</span><br><span class="line"></span><br><span class="line">  - 如果是其他线程已经持有了该Object的轻量级锁，这时表明有竞争，后进来的这个线程就进入锁膨胀过程</span><br><span class="line">  - 如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数。【每次重入，都会有一次CAS检查】</span><br><span class="line"></span><br><span class="line">- 当退出synchronized代码块（解锁时），如果有取值为null的记录，表示有重入，这时重置锁记录，表示重入计数减一。</span><br><span class="line"></span><br><span class="line">- 当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark Word的值恢复给对象头</span><br><span class="line"></span><br><span class="line">  - 成功，则解锁成功</span><br><span class="line">  - 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程。</span><br><span class="line"></span><br><span class="line">2. **锁膨胀**</span><br><span class="line"></span><br><span class="line">- 如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁，这时需要进行锁膨胀，将轻量级锁变为重量级锁。</span><br><span class="line"></span><br><span class="line">- Thread-0刚开始执行 synchronized(obj) 时是轻量级锁，然后在执行的过程中，Thread-1也来执行synchronized(obj)，发现已经有了轻量级锁了，所以加轻量级锁失败，进入锁膨胀流程。即为Object对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入Monitor的EntryList BlOCKED。当Thread-0执行完synchronized代码时，准备退出同步块解锁，使用cas将Mark Word的值恢复给对象头，失败，这时会进入重量级锁解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null,唤醒EntryList 中的BLOCKED线程。</span><br><span class="line"></span><br><span class="line">3. **自旋优化**</span><br><span class="line"></span><br><span class="line">- 重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞（上下文切换）</span><br><span class="line">- 自旋适用于多核CPU，因为自旋重试需要获取CPU的执行，因此单核没有意义，因为另外一个线程可能正在执行。</span><br><span class="line">- 在Java 6 之后，自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性就会高，就多自旋几次，反之，就少自旋，甚至不自旋。</span><br><span class="line">- 自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势</span><br><span class="line">- Java 7之后不能控制是否开启自旋功能</span><br><span class="line"></span><br><span class="line">4. **偏向锁**</span><br><span class="line"></span><br><span class="line">- 轻量级锁在没有竞争时（就自己这一个线程），每次重入仍然需要执行CAS操作</span><br><span class="line"></span><br><span class="line">- Java 6中引入了偏向锁来做进一步优化，只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS，以后只要不发生竞争，这个对象就归该线程所有。（线程ID就是看Mark Word中的偏向锁的thread字段）</span><br><span class="line"></span><br><span class="line">**偏向状态：**</span><br><span class="line"></span><br><span class="line">- Mark word头结构（64bit）</span><br><span class="line"></span><br><span class="line">![img](https://img-blog.csdnimg.cn/20190111092408622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWR1bl9jb29s,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">一个对象创建时：</span><br><span class="line"></span><br><span class="line">- 如果开启了偏向锁（默认开启），那么对象创建后，mark word值为0x05即最后三位为101，这时它的thread,epoch,age都为0，</span><br><span class="line">- 偏向锁是默认是延迟的，不会再程序启动立即生效，如果想避免延迟，可以加VM参数 -XX:BiasedLockingStartupDelay=0来禁用延迟</span><br><span class="line">- 如果没有开启偏向锁，那么对象创建后，mark word值为0x01,即最后3位为001，这时它的hashcode,age,都为0，第一次用到hashcode时才会赋值。</span><br><span class="line">- 可以通过-XX:-UseBiasedLocking 参数来设置是否开启 偏向锁，默认是开启的。</span><br><span class="line">- 当我们调用对象的hashcode（）方法以后，就会将对象hashcode（31位）存入到Mark Word中，此时Mark Word里面的空间就不足以来存储54位的thread(线程ID)，所以锁状态会强制从偏向锁换为正常锁</span><br><span class="line"></span><br><span class="line">**撤销——调用对象hashcode**</span><br><span class="line"></span><br><span class="line">- 调用了对象hashcode，但偏向锁的对象Mark Word中存储的是线程ID,如果调用hashcode会导致偏向锁被撤销</span><br><span class="line">- 轻量级锁会在锁记录中记录hashcode</span><br><span class="line">- 重量级锁会在Monitor中记录hashcode</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       //-XX:BiasedLockingStartupDelay=0  VM参数</span><br><span class="line">   	Dog dog = new Dog();</span><br><span class="line">       TimeUnit.SECONDS.sleep(4);</span><br><span class="line">       dog.hashCode();  //该操作会禁用对象的偏向锁</span><br><span class="line">       log.debug(ClassLayout.parseInstance(dog).toPrintable());  </span><br><span class="line">       synchronized (dog) &#123;</span><br><span class="line">           log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">       &#125;</span><br><span class="line">       log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<p><strong>撤销——其他线程使用对象</strong></p>
<blockquote>
<p>当有其他对象使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBiased</span> &#123;</span><br><span class="line">    <span class="comment">//-XX:BiasedLockingStartupDelay=0 -XX:-UseBiasedLocking  参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable()); <span class="comment">//偏向锁，可偏向</span></span><br><span class="line">            <span class="keyword">synchronized</span> (dog) &#123;</span><br><span class="line">                log.debug(ClassLayout.parseInstance(dog).toPrintable());<span class="comment">//偏向锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable());<span class="comment">//偏向锁</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">                TestBiased.class.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TestBiased.class.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable());  <span class="comment">//偏向锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (dog) &#123;</span><br><span class="line">                log.debug(ClassLayout.parseInstance(dog).toPrintable());  <span class="comment">//此时转为轻量级锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable()); <span class="comment">//正常锁状态</span></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插销——调用wait&#x2F;notify</strong></p>
<blockquote>
<p>也会让偏向锁变为重量级锁，因为wait和notify方法只有monitor对象才有。即就变为了重量级锁。</p>
</blockquote>
<p><strong>批量重定向</strong></p>
<blockquote>
<ul>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的ThreadID 【这里指的偏向指的Mark Word中的Thread字段，这个只与线程有关，而与synchronized（obj）中的这个obj无关系】</li>
<li>当&#x3D;&#x3D;撤销偏向锁【指的是由偏向锁状态转换为其他锁状态，如轻量级线程锁】&#x3D;&#x3D;阈值超过20次后，jvm会这样觉得，我是不是偏向错了呢，于是会在这些给这些对象加锁时重新偏向至加锁线程的线程ID，于是在20次之后于是就变成了偏向锁，而不是轻量级锁。</li>
</ul>
</blockquote>
<p><strong>批量撤销</strong></p>
<blockquote>
<p>当插销偏向锁阈值超过40次后，jvm会这样觉得，自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBiased</span> &#123;</span><br><span class="line">    <span class="comment">//-XX:BiasedLockingStartupDelay=0 -XX:-UseBiasedLocking  参数</span></span><br><span class="line">    <span class="comment">// 【10 0000 1000 1010 1110 1110 0100 0110 10】00 0000 0101  对应的偏向Mark word，</span></span><br><span class="line">    <span class="comment">// 【10 0000 1000 1010 1110 1110 0100 0110 10】  对应的偏向锁Mark word中的Thread</span></span><br><span class="line">    <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">static</span> Thread t3;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Vector&lt;Dog&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lopNumber</span> <span class="operator">=</span> <span class="number">39</span>;</span><br><span class="line">        <span class="comment">//刚开始偏向锁偏向 biased: 0x00000000822bb91a</span></span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lopNumber; i++) &#123;</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">                list.add(d);</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lopNumber; i++) &#123;</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">                log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t3);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lopNumber; i++) &#123;</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">                log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">		log.debug(<span class="string">&quot;###########&quot;</span>+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Dog</span>()).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190111092408622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWR1bl9jb29s,size_16,color_FFFFFF,t_70" alt="img"></p>
<blockquote>
<p>分析上面的代码：</p>
<ul>
<li>刚一开始时，t1线程第一个Dog对象d为偏向锁状态中的biasable，此时还没有偏向具体的哪一个线程（线程ID）.</li>
<li>当t1线程中开始执行synchronized( d )之后，Dog对象d依然为偏向锁，此时，此时就会有具体偏向的线程ID，因此就不是bisable了，而变成了biased:(t1的线程ID).</li>
<li>所以当在t1线程中的剩余的38个Dog对象d来进行访问的时候，此时为偏向锁，并且偏向的线程ID还是线程t1的ID，因此就不用发生撤销（即转换为轻量级锁），所以剩余的对象在执行synchronized后依然是偏向锁</li>
<li>当线程t2开始执行的时候，在没执行synchronized之前，对象d的状态为偏向锁状态，并且指向线程t1的线程ID，因此在执行到第一个对象d的synchronized (d)时，由于偏向锁的偏向线程ID并不是指向的线程t2的ID，因此就会发生一次撤销偏向锁，d的状态变为轻量级锁。当执行完synchronized代码块之后，就解锁成为了一个正常锁。后面的【0-18】都是这种情况</li>
<li>当t2线程中的循环执行到执行到i&#x3D;19的时候，就相当于是已经达到&#x3D;&#x3D;撤销偏向锁&#x3D;&#x3D;阈值超过20次，因此就会改变偏向锁里面的偏向线程ID，就重新偏向至加锁线程的线程ID，因此偏向线程ID变为此时的线程ID即t2线程的线程ID。因此后面的循环里的i&#x3D;19-38，由于线程偏向的ID已经变为了t2，所以就不会发生撤销偏向锁。</li>
<li>当t3线程到来的时候，这39个变化的过程与在t2线程中是一样的，在执行完后，由于已经达到了插销偏向锁阈值超过40次的条件【这里的次数是三个线程中总的次数】，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的，所以后面新建的对象都是不可偏向的，即是正常的。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###线程t1中的执行情况</span></span><br><span class="line">13:44:26 6424 [t1] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6431 [t1] c.TestBiased -&gt; 1	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6514 [t1] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line"><span class="comment">###线程t2中的执行情况</span></span><br><span class="line">13:44:26 6516 [t2] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6518 [t2] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x00000096d2eff108 (thin lock: 0x00000096d2eff108)</span><br><span class="line">13:44:26 6519 [t2] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">13:44:26 6591 [t2] c.TestBiased -&gt; 18	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6592 [t2] c.TestBiased -&gt; 18	  0   8                    (object header: mark)     0x00000096d2eff108 (thin lock: 0x00000096d2eff108)</span><br><span class="line">13:44:26 6592 [t2] c.TestBiased -&gt; 18	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line"><span class="comment">###插销偏向锁阈值超过20次后发生的情况</span></span><br><span class="line">13:44:26 6594 [t2] c.TestBiased -&gt; 19	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6595 [t2] c.TestBiased -&gt; 19	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6596 [t2] c.TestBiased -&gt; 19	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6681 [t2] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6687 [t2] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6689 [t2] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line"><span class="comment">###线程t3中的执行情况</span></span><br><span class="line">13:44:26 6692 [t3] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">13:44:26 6693 [t3] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x00000096d2fff0c8 (thin lock: 0x00000096d2fff0c8)</span><br><span class="line">13:44:26 6694 [t3] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">13:44:26 6851 [t3] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6856 [t3] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x00000096d2fff0c8 (thin lock: 0x00000096d2fff0c8)</span><br><span class="line">13:44:26 6858 [t3] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line"></span><br><span class="line"><span class="comment">###插销偏向锁阈值超过40次后的情况</span></span><br><span class="line">13:44:26 6863 [main] c.TestBiased -&gt; <span class="comment">###########	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>锁消除</strong></li>
</ol>
<blockquote>
<ul>
<li>JIT即时编译器，进行热点代码探测，进行优化，如果发现synchronized代码块并不与其他线程进行竞争，所以JIT会进行一个锁消除的动作。</li>
</ul>
</blockquote>
<h3 id="4-7-wait与notify"><a href="#4-7-wait与notify" class="headerlink" title="4.7 wait与notify"></a>4.7 wait与notify</h3><p><strong>原理之wait&#x2F;notify</strong></p>
<blockquote>
<ul>
<li>Owner线程发现条件不满足，调用wait方法，即可进入waitset变为WAITING状态</li>
<li>BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片</li>
<li>BLOCKED线程会在Owner线程释放锁时唤醒</li>
<li>WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进入EntryList重新竞争</li>
</ul>
</blockquote>
<p><strong>API介绍</strong></p>
<blockquote>
<ul>
<li>obj.wait()：让进入obj监视器的线程到waitSet等待</li>
<li>obj.notify()：让obj上正在等待waitSet等待的线程中&#x3D;&#x3D;挑一个&#x3D;&#x3D;唤醒</li>
<li>obj.notifyAll()：让obj上正在waitSet等待的线程全部唤醒</li>
<li>obj.wait(long n)：有时限的等待，到n毫秒后结束等待，或是被notify.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>它们都是线程之间进行协作的手段，都属于Object对象的方法，&#x3D;&#x3D;必须获得此对象的锁，才能调用这几个方法。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="4-8-wait与notify的正确使用姿势"><a href="#4-8-wait与notify的正确使用姿势" class="headerlink" title="4.8 wait与notify的正确使用姿势"></a>4.8 wait与notify的正确使用姿势</h3><blockquote>
<p><strong>sleep(long n)和wait(long n)的区别</strong></p>
<ul>
<li>sleep是Thread方法，而wait是Object方法</li>
<li>sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起用</li>
<li>sleep在睡眠的同时，不会释放对象锁，但wait在等待的时候会释放对象锁</li>
<li>共同点：它们执行后，都进入TIMED_WAITING状态</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">	<span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">		obj.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//干活</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">	obj.notifyAll( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;同步&#x3D;&#x3D;&#x3D;&#x3D;模式之保护性暂停（Guarded Suspension）&#x3D;&#x3D;：用在一个线程等待另一个线程的执行结果</p>
<p>要点：</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个对象GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li>
<li>JDK中，join的实现，Future的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="comment">//线程1等待线程2的下载结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//等待结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.get();</span><br><span class="line">            log.debug((String)o);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行下载&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            obj.complete(result);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加了超时等待的情况实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果的方法</span></span><br><span class="line">    <span class="comment">//timeout 等待超时时间</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//开始时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;  <span class="comment">//while循环是解决虚假唤醒的问题</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> timeout - passTime;</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//注意这里要写的是waitTime，不能是timeOut，因为如果在虚假唤醒的情况下，就会导致超出timeOut的等待时间</span></span><br><span class="line">                    <span class="built_in">this</span>.wait(waitTime); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//求得经历时间</span></span><br><span class="line">                passTime = System.currentTimeMillis() - start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="comment">//线程1等待线程2的下载结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//等待结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.get(<span class="number">2000</span>);</span><br><span class="line">            log.debug((String)o);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行下载&quot;</span>);</span><br><span class="line"><span class="comment">//            Object result = new String(&quot;hello,world&quot;);</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            obj.complete(result);</span></span><br><span class="line">            obj.complete(<span class="literal">null</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>原理之join</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;保护者暂停模式（生产者与消费者一一对应）&#x3D;&#x3D;</p>
<blockquote>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MailBoxes</span> &#123;</span><br><span class="line">    <span class="comment">//Hashtable是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,GuardedObject&gt; boxes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//产生唯一ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">createGuardedObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>(generateId());</span><br><span class="line">        boxes.put(go.getId(),go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">getGuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//收信</span></span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> MailBoxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">&quot;收信 id：&#123;&#125;&quot;</span>,guardedObject.getId());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">mail</span> <span class="operator">=</span> guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;收信 id：&#123;&#125;，内容：&#123;&#125;&quot;</span>,guardedObject.getId(),mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Postman&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Postman</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Postman</span><span class="params">(<span class="type">int</span> id,String mail)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.mail = mail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> MailBoxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">&quot;送信 id:&#123;&#125;,内容&#123;&#125;&quot;</span>,guardedObject.getId(),mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果的方法</span></span><br><span class="line">    <span class="comment">//timeout 等待超时时间</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//开始时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;  <span class="comment">//while循环是解决虚假唤醒的问题</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> timeout - passTime;</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//求得经历时间</span></span><br><span class="line">                passTime = System.currentTimeMillis() - start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="comment">//线程1等待线程2的下载结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*GuardedObject obj = new GuardedObject();</span></span><br><span class="line"><span class="comment">        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            //等待结果</span></span><br><span class="line"><span class="comment">            log.debug(&quot;等待结果&quot;);</span></span><br><span class="line"><span class="comment">            Object o = obj.get(2000);</span></span><br><span class="line"><span class="comment">            log.debug((String)o);</span></span><br><span class="line"><span class="comment">        &#125;,&quot;t1&quot;).start();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            log.debug(&quot;执行下载&quot;);</span></span><br><span class="line"><span class="comment">//            Object result = new String(&quot;hello,world&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">//            obj.complete(result);</span></span><br><span class="line"><span class="comment">            obj.complete(null);</span></span><br><span class="line"><span class="comment">        &#125;,&quot;t2&quot;).start();*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">People</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id : MailBoxes.getIds())&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Postman</span>(id,<span class="string">&quot;内容:&quot;</span>+id).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&#x3D;&#x3D;异步模式之生产者&#x2F;消费者&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>与前面的保护性暂停中的GuardedObject不同，不需要产生结果和消费结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK中各种阻塞队列采用的就是这种模式。</li>
</ul>
</blockquote>
<blockquote>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test7&quot;)</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> id,Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test7&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="comment">//消息的队列集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列为空,消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从队列头部获取消息并返回</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            log.debug(<span class="string">&quot;已消费信息&#123;&#125;&quot;</span>,message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列已满，生产者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从尾部加，从头部取，先进后出</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            log.debug(<span class="string">&quot;以生产消息&#123;&#125;&quot;</span>,message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test7&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id,<span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">            &#125;,<span class="string">&quot;生产者&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-9-park-unpark"><a href="#4-9-park-unpark" class="headerlink" title="4.9 park &amp; unpark"></a>4.9 park &amp; unpark</h3><blockquote>
<p>基本使用</p>
<ul>
<li><p>它们是LockSupport类中的方法，静态方法（类方法）</p>
</li>
<li><pre><code class="java">//暂停当前线程
LockSupport.park()
        
//恢复某个线程
LockSupport.unpark(暂停的线程对象)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 先park再unpark</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      Thread th = new Thread(() -&gt; &#123;</span><br><span class="line">          log.debug(&quot;start...&quot;);</span><br><span class="line">          try &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(1);</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          log.debug(&quot;park...&quot;);</span><br><span class="line">          LockSupport.park();</span><br><span class="line">          log.debug(&quot;resume...&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      th.start();</span><br><span class="line">      try &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(2);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      LockSupport.unpark(th);</span><br><span class="line">      log.debug(&quot;unpark...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //输出结果为：</span><br><span class="line">  10:14:23 804 [Thread-0] c.Test8 -&gt; start...</span><br><span class="line">  10:14:24 1812 [Thread-0] c.Test8 -&gt; park...</span><br><span class="line">  10:14:25 2800 [Thread-0] c.Test8 -&gt; resume...</span><br><span class="line">  10:14:25 2800 [main] c.Test8 -&gt; unpark...</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>先unpark再park</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Thread th = new Thread(() -&gt; &#123;
        log.debug(&quot;start...&quot;);
        try &#123;
            TimeUnit.SECONDS.sleep(2);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        log.debug(&quot;park...&quot;);
        LockSupport.park();   //注意先unpark,再park并不会在这里停住
        log.debug(&quot;resume...&quot;);
    &#125;);
    th.start();
    try &#123;
        TimeUnit.SECONDS.sleep(1);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    LockSupport.unpark(th);
    log.debug(&quot;unpark...&quot;);
&#125;
//输出结果为：
10:11:02 732 [Thread-0] c.Test8 -&gt; start...
10:11:03 1731 [main] c.Test8 -&gt; unpark...
10:11:04 2742 [Thread-0] c.Test8 -&gt; park...
10:11:04 2742 [Thread-0] c.Test8 -&gt; resume...
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">- 与Object的wait &amp; notify相比</span><br><span class="line">  - wait，notify和notifyAll必须配合Object Monitor一起使用，而unpark不必</span><br><span class="line">  - park &amp; unpark是以线程为单位来阻塞和唤醒线程，而notify只能唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么精确</span><br><span class="line">  - park &amp; unpark可以先unpark，而wait &amp; notify不能先notify</span><br><span class="line"></span><br><span class="line">**原理之park &amp; unpark**</span><br><span class="line"></span><br><span class="line">每个线程都有自己的一个Parker对象，由三部分组成  _counter, _cond,和 _mutex。</span><br><span class="line"></span><br><span class="line">- 情况一：先调用park方法，再调用unpark方法</span><br><span class="line">  - 当前线程th0调用Unsafe.park()方法</span><br><span class="line">  - 检查 _counter，这种情况下为0，这时，获得 _mutex互斥锁</span><br><span class="line">  - 线程进入 _cond条件变量阻塞</span><br><span class="line">  - 设置 _counter = 0</span><br><span class="line">  - 另一个线程调用Unsafe.unpark()方法后</span><br><span class="line">  - 调用Unsafe.unpark(th0)方法，设置 _counter为1</span><br><span class="line">  - 唤醒 _cond条件变量中的th0</span><br><span class="line">  - th0线程恢复运行</span><br><span class="line">  - 设置 _counter为0</span><br><span class="line"></span><br><span class="line">- 情况二：先调用unpark( )方法，再调用park() 方法</span><br><span class="line">  - 调用Unsafe.unpark(th0)方法，设置 _counter为1</span><br><span class="line">  - 当前线程th0调用Unsafe.park()方法</span><br><span class="line">  - 检查_counter ,本情况为1，这时线程无需阻塞，继续运行</span><br><span class="line">  - 设置 _counter为0</span><br><span class="line"></span><br><span class="line">### 4.10 重新理解线程状态转换</span><br><span class="line"></span><br><span class="line">![image-20220523104544527](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220523104544527.png)</span><br><span class="line"></span><br><span class="line">- 情况一：NEW ——》RUNNABLE</span><br><span class="line">  - 当调用t.start() 方法时，由NEW ——》RUNNABLE</span><br><span class="line">- 情况二：RUNNABLE 《 ——》WAITING</span><br><span class="line">  - t线程用synchronized(obj) 获取了对象锁后</span><br><span class="line">    - 调用obj.wait()方法时，t线程从RUNNABLE ——》WAITING</span><br><span class="line">    - 调用obj.notify()，obj.notyAll(),t.interrupt()时（从waitSet ——》entryList）</span><br><span class="line">      - 竞争锁成功，t线程从 WAITING ——》BLOCKED ——》RUNNABLE</span><br><span class="line">      - 竞争锁失败，t线程从 WAITING ——》BLOCKED</span><br><span class="line">- 情况三：RUNNABLE 《 ——》WAITING</span><br><span class="line">  - 当前线程调用 t.join() 方法时，当前线程从RUNNABLE ——》WAITING</span><br><span class="line">    - 注意是当前线程在t线程对象的监视器上等待</span><br><span class="line">  - t线程运行结束，或调用了当前线程的interrupt()时，当前线程从WAITING ——》RUNNABLE</span><br><span class="line">- 情况四：RUNNABLE 《 ——》WAITING</span><br><span class="line">  - 当线程调用LockSupport.part()方法会让当前线程从RUNNABLE ——》WAITING</span><br><span class="line">  - 调用LockSupport.unpark(目标线程)或调用了线程的interrupt()，会让目标线程从WAITING ——》RUNNABLE</span><br><span class="line">- 情况五：RUNNABLE 《——》TIMED_WAITING</span><br><span class="line">  - t线程用 synchronized(obj)获取了对象锁后</span><br><span class="line">    - 调用obj.wait(long n)方法时，t线程从 RUNNABLE ——》TIMED_WAITING</span><br><span class="line">    - t线程等待时间超过了n毫秒，或调用obj.notify（）,obj.notifyAll(),t.interrupt()时</span><br><span class="line">      - 竞争锁成功，t线程从TIMED_WAITING——》BLOCKED——》RUNNABLE</span><br><span class="line">      - 竞争锁失败，t线程从TIMED_WAITING——》BLOCKED</span><br><span class="line">- 情况六：RUNNABLE 《——》TIMED_WAITING</span><br><span class="line">  - 当前线程调用t.join(long n)方法时，当前线程从RUNNABLE ——》TIMED_WAITING</span><br><span class="line">    - 注意是当前线程在t线程对象的监视器上等待</span><br><span class="line">  - 当前线程等待时间超过了n毫秒或t线程运行结束，或调用了当前线程的interrupt()时，当前线程从WAITING ——》RUNNABLE</span><br><span class="line">- 情况七：RUNNABLE 《——》TIMED_WAITING</span><br><span class="line">  - 当前线程调用Thread.sleep(long n),当前线程从RUNNABLE ——》TIMED_WAITING</span><br><span class="line">  - 当前线程等待时间超过了n毫秒，当前线程从TIMED_WAITING ——》RUNNABLE</span><br><span class="line">- 情况八：RUNNABLE 《——》TIMED_WAITING</span><br><span class="line">  - 当前线程调用LockSupport.parkNanos(long nanos) 或LockSupport.parkUntil(long millis)时，当前线程从RUNNABLE ——》TIMED_WAITING</span><br><span class="line">  - 调用LockSupport.unpark(目标线程)或调用了线程的interrupt()，或是等待超时，会让目标线程从TIMED_WAITING——》RUNNABLE</span><br><span class="line">- 情况九：RUNNABLE 《——》BLOAKED</span><br><span class="line">  - t线程用synchronized(obj)获取对象锁时 ，如果竞争失败，从RUNNABLE ——》BLOCKED</span><br><span class="line">  - 持obj线程的同步代码块执行完毕，会唤醒该对象上所有BLOCKED的线程重新竞争，如果其中t线程竞争成功，从BLOCKED ——》RUNNABLE，其他失败的线程仍然BLOCKED</span><br><span class="line">- 情况十：RUNNABLE ——》TERMINATED</span><br><span class="line">  - 当前线程执行完毕，进入TERMINATED</span><br><span class="line"></span><br><span class="line">### 4.11 多把锁</span><br><span class="line"></span><br><span class="line">- 多把不相关的锁，可以使用不同的锁对象，增加并发度</span><br><span class="line"></span><br><span class="line">- 将锁的粒度细分：</span><br><span class="line"></span><br><span class="line">  - 好处：增强并发度</span><br><span class="line"></span><br><span class="line">  - 缺点：容易死锁</span><br><span class="line"></span><br><span class="line">### 4.12 活跃性</span><br><span class="line"></span><br><span class="line">**死锁：**</span><br><span class="line"></span><br><span class="line">有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁</span><br><span class="line"></span><br><span class="line">- t1线程获得A对象锁，接下来想获取B对象的锁</span><br><span class="line">- t2线程获得B对象锁，接下来想获取A对象的锁</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//死锁的案例</span><br><span class="line">@Slf4j(topic = &quot;c.Test10&quot;)</span><br><span class="line">public class Test10 &#123;</span><br><span class="line">   public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       Object lock1 = new Object();</span><br><span class="line">       Object lock2 = new Object();</span><br><span class="line">       new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (lock1) &#123;</span><br><span class="line">               log.debug(&quot;lock1&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(2);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronized (lock2)&#123;</span><br><span class="line">                   log.debug(&quot;lock2&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;).start();</span><br><span class="line">       new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (lock2) &#123;</span><br><span class="line">               log.debug(&quot;lock 2&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(2);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronized (lock1) &#123;</span><br><span class="line">                   log.debug(&quot;lock 1&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">//        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">//        log.debug(&quot;neng&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<p><strong>定位死锁</strong></p>
<blockquote>
<ul>
<li>检测死锁可以使用 jstack 进程ID 这个控制台命令来进行查看是否死锁。以及还可以使用jconsole工具来进行检测死锁。</li>
</ul>
</blockquote>
<p><strong>哲学家就餐问题</strong></p>
<ul>
<li>下面是问题代码演示</li>
<li>解决办法：可以将一个哲学家获取筷子的顺序改为先右再左，其他哲学家都是先左后右。但是这样虽然能够解决死锁，但还有可能存在饥饿的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筷子类</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chopstick&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哲学家类</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name,Chopstick left,Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//尝试获得 左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">//尝试获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>,c1,c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>,c2,c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>,c3,c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>,c4,c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>,c5,c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为：</span></span><br><span class="line">08:<span class="number">48</span>:<span class="number">32</span> <span class="number">714</span> [苏格拉底] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">32</span> <span class="number">714</span> [亚里士多德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">33</span> <span class="number">1723</span> [亚里士多德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">33</span> <span class="number">1723</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">34</span> <span class="number">2729</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">34</span> <span class="number">2735</span> [柏拉图] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">35</span> <span class="number">3732</span> [赫拉克利特] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">35</span> <span class="number">3742</span> [苏格拉底] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">36</span> <span class="number">4733</span> [亚里士多德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">36</span> <span class="number">4742</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">37</span> <span class="number">5745</span> [赫拉克利特] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">38</span> <span class="number">6747</span> [亚里士多德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">39</span> <span class="number">7749</span> [柏拉图] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">40</span> <span class="number">8751</span> [苏格拉底] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">41</span> <span class="number">9753</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">42</span> <span class="number">10755</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">陷入了等待...  </span><br></pre></td></tr></table></figure>

<p><strong>活锁</strong></p>
<blockquote>
<p>活锁出现在两个线程互相改变对方的结果条件，最后谁也无法结束，例如：</p>
</blockquote>
<p>活锁案例演示：</p>
<blockquote>
<p>解决办法是让两者交错执行，就可以解决，例如将其中一个的睡眠时间设为800毫秒</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test12&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test12</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count：&#123;&#125;&quot;</span>,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count：&#123;&#125;&quot;</span>,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饥饿</strong></p>
<p>一个线程由于优先级太低，始终得不到CPU调度执行，也不能够结束。</p>
<h3 id="4-13-ReentrantLock"><a href="#4-13-ReentrantLock" class="headerlink" title="4.13 ReentrantLock"></a>4.13 ReentrantLock</h3><blockquote>
<p>ReentrantLock是Lock的子类</p>
</blockquote>
<blockquote>
<p>相对于synchronized它具备以下特点：</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁【防止线程饥饿】</li>
<li>支持多个条件变量【实际上是指有多个waitSet】</li>
<li>与synchronized一样，都支持可重入。</li>
</ul>
</blockquote>
<blockquote>
<p>基本语法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ReentrantLock对象</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可重入</strong></p>
<blockquote>
<p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁，如果是不可重入锁，那么第二次获得锁是，自己也会把锁挡住。</p>
</blockquote>
<p>可重入代码的演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;mian...&quot;</span>);</span><br><span class="line">            m1();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;m1...&quot;</span>);</span><br><span class="line">            m2();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;m2...&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可中断</strong></p>
<blockquote>
<ul>
<li>这里的可中断是指：当一个线程在获取某个锁对象时，如果没有获取到，就进入BOLCKED阻塞等待，通过ReentrantLock加锁的锁对象可以通过interrupt()方法打断，让正在等待这个锁对象的线程停止等待，避免死等下去。</li>
<li>而通过synchronized( )加锁的对象，不能够通过interrupt( )方法打断，即当一个线程如果在等待获取synchronized加锁的对象时，不能被interrupt( )打断，只有等待其他持有这个synchronized锁对象释放之后，才能获取到。</li>
<li>代码演示</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test14</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有竞争，那么此方法就会获取lock对象锁</span></span><br><span class="line">                <span class="comment">//如果有竞争就进入阻塞队列，可以被其他线程用interrupt()方法打断</span></span><br><span class="line">                log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line"><span class="comment">//                lock.lock();  该方法加锁不能被中断</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;没有获取锁，返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t1.isInterrupted());</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>锁超时</strong></p>
<p>立刻失败</p>
<ul>
<li>tryLock( ) ：返回boolean值，如果获取锁成功，返回true,获取锁失败，返回false.</li>
<li>tryLock(2, TimeUnit.SECONDS);</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test16</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//如果成功了</span></span><br><span class="line">            log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line"><span class="comment">//            boolean b = lock.tryLock();  </span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                b = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//临界区代码</span></span><br><span class="line">                log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;或得到锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.debug(<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用tryLock( )方法来解决哲学家就餐问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筷子类</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chopstick&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哲学家类</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name,Chopstick left,Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*//尝试获得 左手筷子</span></span><br><span class="line"><span class="comment">            synchronized (left) &#123;</span></span><br><span class="line"><span class="comment">                //尝试获得右手筷子</span></span><br><span class="line"><span class="comment">                synchronized (right) &#123;</span></span><br><span class="line"><span class="comment">                    eat();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="comment">//尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//尝试获得右手筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>,c1,c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>,c2,c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>,c3,c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>,c4,c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>,c5,c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>公平锁</strong></p>
<blockquote>
<p>ReentrantLock锁默认是不公平锁</p>
<p>公平锁一般没有必要，会降低并发度，后面分析原理时会讲解</p>
</blockquote>
<p><strong>条件变量</strong></p>
<blockquote>
<ul>
<li>synchronized中也有条件变量，就是我们讲原理时哪个waitSet休息室，当条件不满足时进入waitSet等待。</li>
<li>ReentrantLock的条件变量比synchronized强大之处在于，它是支持多个条件变量的，这就好比<ul>
<li>synchronized是那些不满足条件的线程都在一间休息室等消息</li>
<li>而ReentrantLock支持多间休息室，有专门等烟的休息室，专门等早餐的休息室，唤醒时也是按休息室来唤醒</li>
</ul>
</li>
<li>使用流程：<ul>
<li>await前需要获得锁</li>
<li>&#x3D;&#x3D;await执行后，会释放锁&#x3D;&#x3D;，进入conditionObject等待</li>
<li>await的线程被唤醒（或打断，或超时）去重新竞争lock锁</li>
<li>竞争lock锁成功后，从await后继续执行</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object room= <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasFood</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">ROOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//等烟的休息室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteSet</span> <span class="operator">=</span> ROOM.newCondition();</span><br><span class="line">    <span class="comment">//等外卖的休息室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitTakeoutSet</span> <span class="operator">=</span> ROOM.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           ROOM.lock();</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">              log.debug(<span class="string">&quot;有烟没？&#123;&#125;&quot;</span>,hasCigarette);</span><br><span class="line">              <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                  log.debug(<span class="string">&quot;没烟，先等会&quot;</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      waitCigaretteSet.await();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              log.debug(<span class="string">&quot;有烟没？&#123;&#125;&quot;</span>,hasCigarette);</span><br><span class="line">              log.debug(<span class="string">&quot;可以开始干活&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               ROOM.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？&#123;&#125;&quot;</span>,hasFood);</span><br><span class="line">                <span class="keyword">while</span> (!hasFood) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先等会&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitTakeoutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有外卖没？&#123;&#125;&quot;</span>,hasFood);</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                hasFood = <span class="literal">true</span>;</span><br><span class="line">                waitTakeoutSet.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                hasCigarette = <span class="literal">true</span>;</span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">34</span> <span class="number">785</span> [小南] c.Test5 -&gt; 有烟没？<span class="literal">false</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">34</span> <span class="number">797</span> [小南] c.Test5 -&gt; 没烟，先等会</span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">34</span> <span class="number">799</span> [小女] c.Test5 -&gt; 外卖送到没？<span class="literal">false</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">34</span> <span class="number">799</span> [小女] c.Test5 -&gt; 没外卖，先等会</span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">35</span> <span class="number">1800</span> [小女] c.Test5 -&gt; 有外卖没？<span class="literal">true</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">35</span> <span class="number">1800</span> [小女] c.Test5 -&gt; 可以开始干活</span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">36</span> <span class="number">2808</span> [小南] c.Test5 -&gt; 有烟没？<span class="literal">true</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">36</span> <span class="number">2808</span> [小南] c.Test5 -&gt; 可以开始干活</span><br></pre></td></tr></table></figure>

<p><strong>同步模式之顺序控制</strong></p>
<ul>
<li><p><strong>固定运行顺序</strong></p>
<ul>
<li>比如，必须先2后1打印</li>
</ul>
</li>
<li><p>代码实例：(使用synchronized方法进行解决)</p>
</li>
<li><pre><code class="java">public class Test19 &#123;
    static final Object lock = new Object();
    //表示t2是否运行过
    static boolean t2Rununed = false;
    public static void main(String[] args) &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                while (!t2Rununed) &#123;
                    try &#123;
                        lock.wait();
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;

            log.debug(&quot;1&quot;);
        &#125;,&quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                log.debug(&quot;2&quot;);
                t2Rununed = true;
                lock.notifyAll();
            &#125;
        &#125;,&quot;t2&quot;);
        t1.start();
        t2.start();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 代码实例2：（使用ReentrantLock进行解决）</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class Test19 &#123;</span><br><span class="line">      static final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">      static Condition condition = lock.newCondition();</span><br><span class="line">      //表示t2是否运行过</span><br><span class="line">      static boolean t2Rununed = false;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try &#123;</span><br><span class="line">                  while (!t2Rununed) &#123;</span><br><span class="line">                      try &#123;</span><br><span class="line">                          condition.await();</span><br><span class="line">                      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  log.debug(&quot;1&quot;);</span><br><span class="line">              &#125;finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">  </span><br><span class="line">          &#125;,&quot;t1&quot;);</span><br><span class="line">  </span><br><span class="line">          Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try&#123;</span><br><span class="line">                  log.debug(&quot;2&quot;);</span><br><span class="line">                  t2Rununed = true;</span><br><span class="line">                  condition.signal();</span><br><span class="line">              &#125;finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,&quot;t2&quot;);</span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>代码示例三：（使用park 和unpark解决）</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Thread t1 = new Thread(() -&gt; &#123;
        LockSupport.park();
        log.debug(&quot;1&quot;);
    &#125;,&quot;t1&quot;);

    Thread t2 = new Thread(() -&gt; &#123;
        log.debug(&quot;2&quot;);
        LockSupport.unpark(t1);
    &#125;,&quot;t2&quot;);
    t1.start();
    t2.start();
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **交替输出**</span><br><span class="line"></span><br><span class="line">- 线程1输出 a 5次，线程2输出 b 5次，线程3输出c 5次。现在要求输出abcabcabcabcabcabc</span><br><span class="line"></span><br><span class="line">- 代码示例一：（wait &amp; notify版）</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class Test20 &#123;</span><br><span class="line">      //这里也可以取余来进行解决</span><br><span class="line">      static boolean aTrue = true;</span><br><span class="line">      static boolean bTrue = false;</span><br><span class="line">      static boolean cTrue = false;</span><br><span class="line">      static Object lock = new Object();</span><br><span class="line">  </span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          //打印a的线程1</span><br><span class="line">          Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">  </span><br><span class="line">              synchronized (lock) &#123;</span><br><span class="line">                  for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                      while (!aTrue) &#123;</span><br><span class="line">                          try &#123;</span><br><span class="line">                              lock.wait();</span><br><span class="line">                          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      log.debug(&quot;a&quot;);</span><br><span class="line">                      aTrue = false;</span><br><span class="line">                      bTrue = true;</span><br><span class="line">                      lock.notifyAll();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, &quot;t1&quot;);</span><br><span class="line">          //打印b的线程2</span><br><span class="line">          Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">              synchronized (lock) &#123;</span><br><span class="line">                  for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                      while (!bTrue) &#123;</span><br><span class="line">                          try &#123;</span><br><span class="line">                              lock.wait();</span><br><span class="line">                          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      log.debug(&quot;b&quot;);</span><br><span class="line">                      bTrue = false;</span><br><span class="line">                      cTrue = true;</span><br><span class="line">                      lock.notifyAll();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, &quot;t2&quot;);</span><br><span class="line">          //打印c的线程3</span><br><span class="line">          Thread t3 = new Thread(() -&gt; &#123;</span><br><span class="line">              synchronized (lock) &#123;</span><br><span class="line">                  for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                      while (!cTrue) &#123;</span><br><span class="line">                          try &#123;</span><br><span class="line">                              lock.wait();</span><br><span class="line">                          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      log.debug(&quot;c&quot;);</span><br><span class="line">                      cTrue = false;</span><br><span class="line">                      aTrue = true;</span><br><span class="line">                      lock.notifyAll();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, &quot;t3&quot;);</span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line">          t3.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>代码示例二：【await &amp; signal】</p>
</li>
<li><pre><code class="java">@Slf4j(topic = &quot;c.Test21&quot;)
public class Test21 &#123;
    public static void main(String[] args) &#123;
        AwaitSignal awaitSignal = new AwaitSignal(5);
        Condition a = awaitSignal.newCondition();
        Condition b = awaitSignal.newCondition();
        Condition c = awaitSignal.newCondition();
        Thread tha = new Thread(() -&gt; &#123;
            awaitSignal.print(&quot;a&quot;, a, b);
        &#125;);
        Thread thb = new Thread(() -&gt; &#123;
            awaitSignal.print(&quot;b&quot;, b, c);
        &#125;);
        Thread thc = new Thread(() -&gt; &#123;
            awaitSignal.print(&quot;c&quot;, c, a);
        &#125;);
        tha.start();
        thb.start();
        thc.start();
        try &#123;
            TimeUnit.SECONDS.sleep(1);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        awaitSignal.lock();
        try&#123;
            System.out.println(&quot;开始。。。&quot;);
            a.signal();
        &#125;finally &#123;
            awaitSignal.unlock();
        &#125;
    &#125;

&#125;

@Slf4j(topic = &quot;c.Test21&quot;)
class AwaitSignal extends ReentrantLock &#123;
    private int loopNumber;

    public AwaitSignal(int loopNumber) &#123;
        this.loopNumber = loopNumber;
    &#125;

    //参数1：要打印得内容
    //参数2：进入哪一间休息室
    //参数3：下一间休息室
    public void print(String str,Condition current,Condition next) &#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            this.lock();
            try &#123;
                //先等待唤醒后再进行打印
                try &#123;
                    current.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                log.debug(str);
                next.signal();

            &#125;finally &#123;
                this.unlock();
            &#125;
        &#125;

    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 代码示例三：【park &amp; unpark】</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Slf4j(topic = &quot;c.Test22&quot;)</span><br><span class="line">  public class Test22 &#123;</span><br><span class="line">      private static Thread tha,thb,thc;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          ParkUnpark parkUnpark = new ParkUnpark(5);</span><br><span class="line">          tha = new Thread(() -&gt; &#123;</span><br><span class="line">              parkUnpark.print(&quot;a&quot;,thb);</span><br><span class="line">          &#125;);</span><br><span class="line">          thb = new Thread(() -&gt; &#123;</span><br><span class="line">              parkUnpark.print(&quot;b&quot;,thc);</span><br><span class="line">          &#125;);</span><br><span class="line">          thc = new Thread(() -&gt; &#123;</span><br><span class="line">              parkUnpark.print(&quot;c&quot;,tha);</span><br><span class="line">          &#125;);</span><br><span class="line">          tha.start();</span><br><span class="line">          thb.start();</span><br><span class="line">          thc.start();</span><br><span class="line">          try &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(1);</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          LockSupport.unpark(tha);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Slf4j(topic = &quot;c.Test22&quot;)</span><br><span class="line">  class ParkUnpark &#123;</span><br><span class="line">      private int loopNumber;</span><br><span class="line">  </span><br><span class="line">      public ParkUnpark(int loopNumber) &#123;</span><br><span class="line">          this.loopNumber = loopNumber;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public void print(String str, Thread next) &#123;</span><br><span class="line">          for (int i = 0; i &lt; loopNumber; i++) &#123;</span><br><span class="line">              LockSupport.park();</span><br><span class="line">              log.debug(str);</span><br><span class="line">              LockSupport.unpark(next);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="5-共享模型之内存"><a href="#5-共享模型之内存" class="headerlink" title="5.共享模型之内存"></a>5.共享模型之内存</h2><blockquote>
<ul>
<li><p>上一章主要讲解的Monitor主要关注的是访问共享变量时，保证临界区代码的<strong>原子性</strong>。</p>
</li>
<li><p>这一章进一步深入学习共享变量在多线程间的<strong>可见性</strong>问题与多条指令执行时的<strong>有序性</strong>问题。</p>
</li>
</ul>
</blockquote>
<h3 id="5-1-Java内存模型"><a href="#5-1-Java内存模型" class="headerlink" title="5.1 Java内存模型"></a>5.1 Java内存模型</h3><blockquote>
<ul>
<li><p>JMM即Java Memory Model，它定义了主存【所有线程共享的，如静态成员变量】、工作内存【每个线程私有的】等抽象概念，底层对应着CPU寄存器，缓存，硬件内存，CPU指令优化等</p>
</li>
<li><p>JMM体现在以下几个方面：</p>
<ul>
<li>原子性：保证指令不会受到线程上下文切换的影响</li>
<li>可见性：保证指令不会受cpu缓存的影响</li>
<li>有序性：保证指令不会受CPU指令并行优化的影响</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-2-可见性"><a href="#5-2-可见性" class="headerlink" title="5.2 可见性"></a>5.2 可见性</h3><blockquote>
<p>停不下来的循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (run) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;停止t&quot;</span>);</span><br><span class="line">        run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序会一直执行而不会停下来</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>为什么呢？分析一下</p>
<ol>
<li>初始状态，t线程刚开始从主内存中读取了run的值到工作内存</li>
<li>因为t线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存值自己工作内存中的高速缓存，减少对主存中run的访问，提高效率。</li>
<li>1秒之后，main线程修改了run的值，并同步至主存，而t是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。</li>
</ol>
<blockquote>
<p>上面代码的解决办法：</p>
<ul>
<li>volatile（易变关键字）</li>
<li>它可以用来修饰&#x3D;&#x3D;成员变量和静态成员变量&#x3D;&#x3D;，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">//易变</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (run) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;停止t&quot;</span>);</span><br><span class="line">        run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>synchronized（关键字）</p>
</li>
<li><pre><code class="java">@Slf4j(topic = &quot;c.Test1&quot;)
public class Test1 &#123;
    static boolean run = true;
    
    //锁对象
    final static Object lock = new Object();
    
    public static void main(String[] args) &#123;
        new Thread(() -&gt; &#123;
           while (run) &#123;
               synchronized (lock) &#123;
                   if(!run) &#123;
                       break;
                   &#125;
               &#125;
           &#125;
        &#125;).start();
        try &#123;
            TimeUnit.SECONDS.sleep(1);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        log.debug(&quot;停止t&quot;);
        synchronized (lock) &#123;
            run = false;
        &#125;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**可见性 VS  原子性**</span><br><span class="line"></span><br><span class="line">- 前面例子体现的实际就是可见性，它保证的是在多个线程之间，==一个线程对volatile变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况==</span><br><span class="line">- volatile只能保证看到最新值，不能解决指令交错的问题。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">- synchronized语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性，但缺点是synchronized是属于重量级操作，性能相对更低</span><br><span class="line"></span><br><span class="line">- 如果在前面示例的死循环代码中加入System.out.println( )会发现即使不加volatile，线程t也能正确看到run变量的修改了，想一想为什么？</span><br><span class="line"></span><br><span class="line">  - 因为println( )方法是synchronized的</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public void println(String x) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<p><strong>同步模式之两阶段终止模式</strong></p>
<ul>
<li>使用volatile实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestTwoPhase</span> <span class="variable">twoPhase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTwoPhase</span>();</span><br><span class="line">        twoPhase.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        twoPhase.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTwoPhase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步模式之Balking</strong></p>
<ul>
<li>Balking(犹豫)模式用在一个线程发现另一个线程或者本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestTwoPhase</span> <span class="variable">twoPhase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTwoPhase</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            twoPhase.start();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            twoPhase.start();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            twoPhase.start();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        twoPhase.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        twoPhase.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTwoPhase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否执行过start方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">starting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>它还经常用来实现线程安全的单例模式【懒汉式】</p>
</li>
<li><pre><code class="java">public final class SingleInstance &#123;
    private static SingleInstance singleInstance;
    
    private SingleInstance() &#123;
    &#125;
    //线程安全的单例模式
    public static synchronized SingleInstance getInstance() &#123;
        if (singleInstance != null) &#123;
            return singleInstance;
        &#125;
        singleInstance = new SingleInstance();
        return singleInstance;
    &#125; 
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.3 有序性</span><br><span class="line"></span><br><span class="line">- JVM会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static int i;</span><br><span class="line">static int j;</span><br><span class="line"></span><br><span class="line">//在某个线程内执行如下赋值操作</span><br><span class="line">i = ...;</span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>可以看到，至于是先执行i还是先执行j，对最终的结果不会产生影响。所以，上面代码真正执行时，两种顺序都可以。</p>
</li>
<li><p>这种特性称之为指令重排，多线程下指令重排会影响正确性，为什么要有重排指令这项优化呢？从CPU执行指令的原理来理解一下吧。【指令流水】</p>
</li>
<li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，这一技术在一段时间内占据了计算机架构的重要地位</p>
</li>
<li><p>提示：&#x3D;&#x3D;分阶段，分工是提升效率的关键。&#x3D;&#x3D;</p>
</li>
<li><p>指令重排的前提是，重排指令不能影响结果</p>
</li>
<li><p>&#x3D;&#x3D;在成员变量或者静态成员变量上加上volatile变量后，可以禁用指令重排。&#x3D;&#x3D;</p>
</li>
</ul>
<p><strong>volatile原理</strong></p>
<blockquote>
<p>volatile的底层实现原理是内存屏障，Memory Barrier(Memory Fence)</p>
<ul>
<li>对volatile变量的写指令后会加入写屏障</li>
<li>对volatile变量的读指令前会加入读屏障</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;1.如何保证可见性&#x3D;&#x3D;</p>
<ul>
<li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中。</p>
</li>
<li><pre><code class="java">public void actor2(T_Result r) &#123;
    num = 2;
    ready = true; //ready是volatile赋值带写屏障
    // 写屏障
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public void actor1(I_Result r) &#123;</span><br><span class="line">      //读屏障</span><br><span class="line">      //ready是volatile读取值带读屏障</span><br><span class="line">      if (ready) &#123;</span><br><span class="line">          r.r1 = num + num;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          r.r1 = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;2.如何保证有序性&#x3D;&#x3D;</p>
<ul>
<li><p>写屏障会确保指令重排序时，不会将写屏幕之前的代码排在写屏障之后</p>
</li>
<li><pre><code class="java">public void actor2(T_Result r) &#123;
    num = 2;
    ready = true; //ready是volatile赋值带写屏障
    // 写屏障
&#125;
//即num = 2;不会出现在 ready=true;之后了
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public void actor1(I_Result r) &#123;</span><br><span class="line">      //读屏障</span><br><span class="line">      //ready是volatile读取值带读屏障</span><br><span class="line">      if (ready) &#123;</span><br><span class="line">          r.r1 = num + num;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          r.r1 = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>还是那句话，不能解决指令交错（不能保证原子性）</p>
<ul>
<li>写屏障仅仅是保证之后的读能读到最新的数据，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
</li>
</ul>
<p>3.double-checked locking问题</p>
<blockquote>
<p>如著名的double-checked locking单例模式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance singleInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程安全的单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SingleInstance.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleInstance != <span class="literal">null</span>) &#123;</span><br><span class="line">            	<span class="keyword">return</span> singleInstance;</span><br><span class="line">       		&#125;</span><br><span class="line">        	singleInstance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">        	<span class="keyword">return</span> singleInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优化后</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance singleInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程安全的单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//首次访问会同步，而之后的使用没有synchronized</span></span><br><span class="line">        <span class="keyword">if</span> (singleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleInstance.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                   	singleInstance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance( )才使用synchronized加锁，后续使用时无需加锁</li>
<li>有隐含的，但很关键的一点：第一个if使用了singleInstance变量，是在同步块之外</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的，因为synchronized虽然能够解决原子性、可见性、有序性，但是有序性这是在代码被synchronized全部包括的前提下才成立的。对于上面代码singleInstance &#x3D;&#x3D; null在synchronized代码块之外，所以会出现singleInstance &#x3D; new SingleInstance();的指令重排，该代码分为两条指令，一条是调用构造函数创建对象，一条是将创建了的对象进行赋值，如果发生了指令重排，就会导致先将还未构造完成的对象赋值给了变量（但是此时变量不是null，但指向的对象不可用，因为还没有构造完成）,因此在此时如果另外一个线程来进行判断singleInstance &#x3D;&#x3D; null时会为false,所以会将变量进行返回，但是该变量指向的对象还为空。所以会出现问题。</p>
<ul>
<li><p>上面问题的解决办法:</p>
</li>
<li><p>将变量加上 volatile,就可以防止指令重排。</p>
</li>
<li><pre><code class="java">public final class SingleInstance &#123;
    private static volatile SingleInstance singleInstance;
        
    private SingleInstance() &#123;
    &#125;
    //线程安全的单例模式
    public static SingleInstance getInstance() &#123;
        //实例没创建，才会进入内部的synchronized代码块
        if (singleInstance == null) &#123;
            synchronized (SingleInstance.class) &#123;
                //也许有其他线程已经创建了实例，所以再判断一次
                if (singleInstance == null) &#123;
                       singleInstance = new SingleInstance();
                &#125;
            &#125;
        &#125;
        return singleInstance;
    &#125; 
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">volatile是在jdk1.5之后才生效。</span><br><span class="line"></span><br><span class="line">**happens-before**</span><br><span class="line"></span><br><span class="line">happens-before规定了对共享变量的写操作对其他线程的读操作可见，它是可见性与有序性的一套规则总结，抛开一下happens-before规则，JMM并不能保证一个线程对共享变量的写，对于其他线程对该共享变量的读可见。</span><br><span class="line"></span><br><span class="line">- 线程解锁m之前对变量的写，对于接下来对m加锁的其他线程对该变量的读可见</span><br><span class="line"></span><br><span class="line"> - ```java</span><br><span class="line">   static int x;</span><br><span class="line">   static Object m = new Object();</span><br><span class="line">   new Thread(() -&gt; &#123;</span><br><span class="line">   	synchronized(m) &#123;   //synchronized能保证对象的可见性</span><br><span class="line">   		x = 10;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;,&quot;t1&quot;).start();</span><br><span class="line">   new Thread(() -&gt; &#123;</span><br><span class="line">   	synchronized(m) &#123;</span><br><span class="line">           sout(x);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).start();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<ul>
<li><p>线程对volatile变量的写，对接下来的其他线程对该变量的读可见</p>
<ul>
<li><pre><code class="java">volatile static int x;
new Thread(() -&gt; &#123;
    x = 10;
&#125;).start();

new Thread(() -&gt; &#123;
    sout(x);
&#125;).start();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 线程start前对变量的写，对该线程开始后对该变量的读可见</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    static int x;</span><br><span class="line">    x = 10;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">    	sout(x);</span><br><span class="line">    &#125;).start();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>线程结束前对变量的写，对其他线程得知它结束后的读可见（比如其他线程调用t1.isAlive( )或t1.join()等待它结束）</p>
<ul>
<li><pre><code>static int x;
Thread th = new Thread(() -&gt; &#123;
    x = 10;
&#125;);
th.start();
th.join();
sout(x);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 线程t1打断t2前（interrupt）对变量的写，对于其他线程得知c2被打断后对变量的读可见（通过t2.interrupted( )或t2.isInterrupted( )）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    static int x;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">    		while (true) &#123;</span><br><span class="line">    			if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">    				sout(x);</span><br><span class="line">    				break;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;,&quot;t2&quot;);</span><br><span class="line">    	t2.start();</span><br><span class="line">    	new Thread(() -&gt; &#123;</span><br><span class="line">    		sleep(1);</span><br><span class="line">    		x = 10;</span><br><span class="line">    		t2.interrupt();</span><br><span class="line">    	&#125;).start();</span><br><span class="line">    	while (!t2.isInterrupt()) &#123;</span><br><span class="line">    		Thread.yield();</span><br><span class="line">    	&#125;</span><br><span class="line">    	sout(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>对变量默认值（0，false，null）的写，对其他线程对该变量的读可见</p>
</li>
<li><p>具有传递性，如果x  hb-&gt; y 并且 y hb-&gt; z ，那么有x  hb-&gt; z，配合volatile的防指令重排，有下面的例子</p>
<ul>
<li><pre><code class="java">volatile static int x;
static int y;
new Thread(() -&gt; &#123;
   y = 10;
   x = 20;
&#125;).start();

new Thread(() -&gt; &#123;
    //x = 20 对t2可见，同时 y = 10也对t2可见
    sout(x);
&#125;)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ==注意：上面这些规则中说的变量都是指的成员变量或静态成员变量。==</span><br><span class="line"></span><br><span class="line">**线程安全单例习题**</span><br><span class="line"></span><br><span class="line">- 单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance() ）时的线程安全，并思考注释中的问题。</span><br><span class="line"></span><br><span class="line">  &gt; 饿汉式：类加载就会导致该单例对象被创建</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</span><br><span class="line"></span><br><span class="line">实现1：【饿汉式】</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//问题1：为什么加final? 防止子类继承它，重写方法，破坏它的单例</span><br><span class="line">//问题2：如果实现了序列化接口，还要做什么来防止反序列化破坏单例？因为反序列化生成的对象与单例对象相比就是不同的对象，解决办法就是实现一个方法readResolve.当有该方法后，就会返回方法中返回的对象，而不是反序列化后的对象。</span><br><span class="line">public final class Singleton implements Serializable &#123;</span><br><span class="line">    //问题3：为什么设置为私有？是否能防止反射创建新的实例？防止其他类通过构造方法无限创建对象。不能防止反射创建新的实例。因为反射可以获得类的构造器，并且通过构造器的setAccessable()为true来进行暴力反射，通过构造方法来进行创建对象</span><br><span class="line">	private Singleton()&#123;&#125;</span><br><span class="line">    //问题4：这样初始化是否能保证单例对象创建时的线程安全？ 可以，静态变量是在类加载的时候进行初始化的，由JVM来保证它的安全性。 cinit只执行一次，所以是线程安全的</span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">	//问题5：为什么提供静态方法而不是直接将INSTANCE设置为public,说出你知道的理由。用方法可以进行更好的封装，可以对其进行改进，可以创建对象时支持更多的控制，可以有范型的支持。</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object readResolve() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>实现2：【枚举】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题1：枚举单例是如何限制实例个数的</span></span><br><span class="line"><span class="comment">//问题2：枚举单例在创建的时候是否存在并发问题？ 不存在</span></span><br><span class="line"><span class="comment">//问题3：枚举单例能否被反射破坏单例？不能</span></span><br><span class="line"><span class="comment">//问题4：枚举单例能否被被反序列化破坏单例？不能</span></span><br><span class="line"><span class="comment">//问题5：枚举单例属于懒汉式还是饿汉式？ 饿汉式</span></span><br><span class="line"><span class="comment">//问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？可以添加构造方法</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分析这里的线程安全，并说明有什么缺点。锁粒度太大，效率太低</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现4：【DCL double check locking】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//问题1：解释为什么要加volatile?防止指令重排，导致获取到的对象是空对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="comment">//问题2：对比实现3为什么这样做？减小锁的粒度，提高效率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//问题3：为什么还要在这里添加非空判断，之前不是判断过了吗？防止在多线程环境下进行多次创建</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//也许有其他线程已经创建了实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                   	INSTANCE = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现5：【静态内部类】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//问题1：属于懒汉式还是饿汉式? 懒汉式，只有在调用getInstance时才创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//问题2：在创建时是否有并发问题？没有并发安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-共享模型之无锁"><a href="#6-共享模型之无锁" class="headerlink" title="6.共享模型之无锁"></a>6.共享模型之无锁</h2><blockquote>
<ul>
<li>CAS与volatile</li>
<li>原子整数</li>
<li>原子引用</li>
<li>原子累加器</li>
<li>Unsafe</li>
</ul>
</blockquote>
<h3 id="6-1-问题的引出"><a href="#6-1-问题的引出" class="headerlink" title="6.1 问题的引出"></a>6.1 问题的引出</h3><h3 id="6-2-CAS与volatile"><a href="#6-2-CAS与volatile" class="headerlink" title="6.2 CAS与volatile"></a>6.2 CAS与volatile</h3><blockquote>
<p>前面看到的AtomicInteger的解决办法，&#x3D;&#x3D;内部并没有用锁来保护共享变量的线程安全&#x3D;&#x3D;，那么它是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意balance是一个AtomicInteger类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">        <span class="keyword">if</span> (balance.compareAndSet(prev,next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键是compareAndSet（比较并设置），它的简称就是CAS，它必须是原子操作。</p>
<ul>
<li>注意：<ul>
<li>其实CAS的底层是lock cmpxchg指令（X86架构），在单核CPU和多核CPU下都能够保证（比较—交换）的原子性</li>
<li>在多核状态下，某个核执行到带lock的指令时，CPU会让总线锁住，当这个核把此指令执行完毕，再开启总线，这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>volatile</strong></p>
<blockquote>
<ul>
<li><p>获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。</p>
</li>
<li><p>它可以用来修饰成员变量或者静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存，即一个线程对volatile变量的修改，对另一个线程可见</p>
<ul>
<li><p>注意：</p>
</li>
<li><p>volatile仅仅保证了共享变量的可见性，让其他线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p>
</li>
</ul>
</li>
<li><p>CAS必须借助volatile才能读取到共享变量的最新值来实现【比较并交换】的效果</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>无锁效率为什么高？</p>
<ul>
<li>因为CAS虽然在while循环中一直高速运行，所以并不会发生线程上下文切换。而synchronized会由可运行状态转换为阻塞状态，发生上下文切换</li>
<li>但是CAS要在多核环境下才有效果，因为线程数过多，就无法给每个线程分配时间片，所以还是会发生上下文切换。</li>
</ul>
</blockquote>
<p><strong>CAS的特点</strong></p>
<ul>
<li>结合CAS和volatile可以实现无锁并发，适用于线程数少，多核CPU的场景下。</li>
<li>CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没有关系，可以进行重试</li>
<li>synchronized是基于悲观锁的思想：最悲观的估计，得防着其他线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会</li>
<li>CAS体现得是无所并发，无阻塞并发，请仔细体会这两句话得意思<ul>
<li>因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升得因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h3 id="6-3-原子整数"><a href="#6-3-原子整数" class="headerlink" title="6.3 原子整数"></a>6.3 原子整数</h3><p>J.U.C并发包提供了</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<p>以AtomicInteger为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">System.out.println(i.incrementAndGet());  <span class="comment">// ++i</span></span><br><span class="line">System.out.println(i.getAndIncrement());  <span class="comment">// i++</span></span><br><span class="line">System.out.println(i.get());</span><br><span class="line">System.out.println(i.addAndGet(<span class="number">5</span>)); <span class="comment">//</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>)); <span class="comment">//这是有步长，步长可正可负</span></span><br><span class="line">System.out.println(i.get());</span><br><span class="line">System.out.println(i.getAndAdd(-<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//updateAndGet接受的是一个接口类型的参数，</span></span><br><span class="line"><span class="comment">//其中operand是i.get()读取到的值，返回的是执行operand*10结果的值并将这个值设置到i中去</span></span><br><span class="line">i.updateAndGet((<span class="type">int</span> operand) -&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> operand * <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//i.updateAndGet(operand -&gt; operand * 10); //这与上面表达得意思相同</span></span><br><span class="line">System.out.println(i.get());</span><br></pre></td></tr></table></figure>

<h3 id="6-4-原子引用"><a href="#6-4-原子引用" class="headerlink" title="6.4 原子引用"></a>6.4 原子引用</h3><blockquote>
<p>为什么需要原子引用类型？</p>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
</blockquote>
<p>有如下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestAccount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAccount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DecimalAccount.demo(<span class="keyword">new</span> <span class="title class_">DecimalAccountCas</span>(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountCas</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line"><span class="comment">//    private BigDecimal balance;</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountCas</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">next</span> <span class="operator">=</span> prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span>(balance.compareAndSet(prev,next))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="comment">//获取余额</span></span><br><span class="line">    BigDecimal <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(DecimalAccount account)</span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>经典的ABA问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="comment">//获取值A</span></span><br><span class="line">        <span class="comment">//这个共享变量被其他线程修改过？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">        other();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试改为C.问题在于主线程无法感知共享变量是否被其他线程修改过，即便是最终又修改回来了</span></span><br><span class="line">        log.debug(<span class="string">&quot;change A -&gt; C &#123;&#125;&quot;</span>,ref.compareAndSet(prev,<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change A -&gt; B &#123;&#125;&quot;</span>,ref.compareAndSet(ref.get(),<span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change B -&gt; A &#123;&#125;&quot;</span>,ref.compareAndSet(ref.get(),<span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主线程仅能判断出共享变量的值与最初值A是否相同，不能感知到这种从A改为B又改回A的情况，如果主线程希望：</p>
<p>只要有其他线程【动过了】共享变量，那么自己的CAS就算失败，这是，仅比较值是不够的，需要再加一个版本号</p>
</blockquote>
<p><strong>AtomicStampedReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="comment">//获取值A</span></span><br><span class="line">        <span class="comment">//这个共享变量被其他线程修改过？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">        <span class="comment">//获取版本号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        other();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试改为C.问题在于主线程无法感知共享变量是否被修改过</span></span><br><span class="line">        log.debug(<span class="string">&quot;change A -&gt; C &#123;&#125;&quot;</span>,ref.compareAndSet(prev,<span class="string">&quot;C&quot;</span>,stamp,stamp+<span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,ref.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            log.debug(<span class="string">&quot;change A -&gt; B &#123;&#125;&quot;</span>,ref.compareAndSet(ref.getReference(),<span class="string">&quot;B&quot;</span>,stamp,stamp+<span class="number">1</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            log.debug(<span class="string">&quot;change B -&gt; A &#123;&#125;&quot;</span>,ref.compareAndSet(ref.getReference(),<span class="string">&quot;A&quot;</span>,stamp,stamp+<span class="number">1</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AtomicStampedReference可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; A -&gt; C，通过AtomicStampedReference，我们可以知道，引用变量中途被修改了几次，但是有时候，并不关心引用变量更改了几次，只是单纯的关心&#x3D;&#x3D;是否更改过&#x3D;&#x3D;，所以就有了AtomicMarkableReference</p>
</blockquote>
<p><strong>AtomicMarkableReference</strong></p>
<h3 id="6-5-原子数组"><a href="#6-5-原子数组" class="headerlink" title="6.5 原子数组"></a>6.5 原子数组</h3><ul>
<li>AtomicIntegerArray  </li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<p>有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这会存在多线程访问的问题</span></span><br><span class="line">        demo(() -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>],</span><br><span class="line">                (array) -&gt; array.length,</span><br><span class="line">                (array,index) -&gt; array[index]++,</span><br><span class="line">                array -&gt; System.out.println(Arrays.toString(array)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这是使用原子数组的方法</span></span><br><span class="line">        demo(() -&gt; <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">10</span>),</span><br><span class="line">                (array) -&gt; array.length(),</span><br><span class="line">                (array,index) -&gt;array.getAndIncrement(index),</span><br><span class="line">                array -&gt; System.out.println(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arraySupplier:提供数组，可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFun：获取数组长度的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> putConsumer：自增方法，回传array，index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> printConsumer：打印数组的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="line"><span class="params">                                 Function&lt;T,Integer&gt; lengthFun,</span></span><br><span class="line"><span class="params">                                 BiConsumer&lt;T,Integer&gt; putConsumer,</span></span><br><span class="line"><span class="params">                                 Consumer&lt;T&gt; printConsumer)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">T</span> <span class="variable">array</span> <span class="operator">=</span> arraySupplier.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> lengthFun.apply(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">//每个线程对数组作10000次操作</span></span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    putConsumer.accept(array,j%length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(thread -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-原子更新器"><a href="#6-6-原子更新器" class="headerlink" title="6.6 原子更新器"></a>6.6 原子更新器</h3><ul>
<li>AtomicReferenceFieldUpdate  &#x2F;&#x2F; 域&#x2F;字段</li>
<li>AtomicIntegerFieldUpdate</li>
<li>AtomicLongFiledUpdate</li>
</ul>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合volatile修饰的字段使用，否则会出现异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">AtomicReferenceFieldUpdater</span> <span class="variable">updater</span> <span class="operator">=</span> AtomicReferenceFieldUpdater.newUpdater(Student.class,String.class,<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        updater.compareAndSet(student,<span class="literal">null</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        log.debug(student.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-7-原子累加器"><a href="#6-7-原子累加器" class="headerlink" title="6.7 原子累加器"></a>6.7 原子累加器</h3><p>累加器性能比较</p>
<blockquote>
<ul>
<li><p>比较AtomicLong 与LongAdder</p>
</li>
<li><pre><code class="java">for (int i = 0; i &lt; 5; i++) &#123;
    demo( () -&gt; new LongAdder(), adder -&gt; adder.increment());
&#125;
    
for (int i = 0; i &lt; 5; i++) &#123;
    demo( () -&gt; new AtomicLong(), adder -&gt; adder.getAndIncrement());
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- LongAdder 输出的性能比ActomicLong快很多倍。</span><br><span class="line">- 性能提升的原因很简单，就是在有竞争的时候，设置多个累加单元，Thread-0累加Cell[0],而Thread-1累加Cell[1],最后将结果汇总，这样他们在累加时操作的不同的Cell变量，因此减少了CAS重试失败，从而提高性能</span><br><span class="line"></span><br><span class="line">**源码之LongAdder**</span><br><span class="line"></span><br><span class="line">LongAdder类有几个关键域</span><br><span class="line"></span><br><span class="line">### 6.8 Unsafe</span><br><span class="line"></span><br><span class="line">**概述**</span><br><span class="line"></span><br><span class="line">Unsafe对象提供了非常底层的，操作内存，线程的方法，Unsafe对象不能直接调用，只能通过反射获得</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test6 &#123;</span><br><span class="line">   public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">       //通过反射来获取对象</span><br><span class="line">       Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">       theUnsafe.setAccessible(true);</span><br><span class="line">       Unsafe unsafe = (Unsafe) theUnsafe.get(null);</span><br><span class="line">       System.out.println(unsafe);</span><br><span class="line"></span><br><span class="line">       Teacher t = new Teacher();</span><br><span class="line">       //1.获取域的偏移地址</span><br><span class="line">       long idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(&quot;id&quot;));</span><br><span class="line">       long nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(&quot;name&quot;));</span><br><span class="line">       //2.执行cas操作</span><br><span class="line">       unsafe.compareAndSwapInt(t,idOffset,0,1);</span><br><span class="line">       unsafe.compareAndSwapObject(t,nameOffset,null,&quot;张三&quot;);</span><br><span class="line">       //3.打印结果</span><br><span class="line">       log.debug(&quot;&#123;&#125;&quot;,t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher &#123;</span><br><span class="line">   volatile int id;</span><br><span class="line">   volatile String name;</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line">sun.misc.Unsafe@2eafffde</span><br><span class="line">10:32:13 632 [main] c.Test6 -&gt; Teacher(id=1, name=张三)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<h2 id="7-共享模型之不可变"><a href="#7-共享模型之不可变" class="headerlink" title="7.共享模型之不可变"></a>7.共享模型之不可变</h2><ul>
<li>不可变类的使用</li>
<li>不可变类的设计</li>
<li>无状态类设计</li>
</ul>
<h3 id="7-1-日期转换的问题"><a href="#7-1-日期转换的问题" class="headerlink" title="7.1 日期转换的问题"></a>7.1 日期转换的问题</h3><p><strong>问题提出</strong></p>
<p>下面的代码在运行时，由于SimpleDateFormat不是线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//不存在线程安全问题</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;1951-04-21&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,parse);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//存在线程安全问题</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (simpleDateFormat) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,simpleDateFormat.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-不可变设计"><a href="#7-2-不可变设计" class="headerlink" title="7.2 不可变设计"></a>7.2 不可变设计</h3><p>另一个更为熟悉的String类也是不可变的，以它为例，来说明不可变设计的要素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final的使用</strong></p>
<p>发现该类，类中所有属性都是final的</p>
<ul>
<li>属性用final修饰保证了该属性只是可读的，不能修改</li>
<li>类用final修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏可变性</li>
</ul>
<p><strong>保护性拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了确保不变性，都是使用保护性拷贝，而不是使用引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>享元模式</strong></p>
<ol>
<li>简介</li>
</ol>
<blockquote>
<p>定义：Flyweight pattern当需要重用数量有限的同一类对象时</p>
<ul>
<li>为了最小化内存使用，通过共享尽可能多的数据与其他类似的对象</li>
</ul>
<p>归类于 Structural patterns</p>
</blockquote>
<ol start="2">
<li>体现</li>
</ol>
<p><strong>2.1 包装类</strong></p>
<ul>
<li><p>在JDK中Boolean,Byte,Short,Integer,Long,Charactor等包装类提供了valueOf()方法，例如Long的valueOf( )会缓存-128~127之间的Long对象,在这个范围之间会重用对象，大于这个范围，才会新建Long对象</p>
</li>
<li><pre><code class="java">public static Long valueOf(long l) &#123;
    final int offset = 128;
    if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache
        return LongCache.cache[(int)l + offset];
    &#125;
    return new Long(l);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line">  - Byte,Short,Long缓存的范围都是-128~127</span><br><span class="line">  - Charactor缓存的范围是0-127</span><br><span class="line">  - Integer的默认范围是-128~127，最小值不能变，但最大值可以通过调整虚拟机参数来IntegerCache.high改变</span><br><span class="line">  - Boolean缓存了TRUE和FALSE</span><br><span class="line"></span><br><span class="line">**2.2 String串池**</span><br><span class="line"></span><br><span class="line">**2.3 BigDecimal BigInteger**</span><br><span class="line"></span><br><span class="line">**3.DIY**</span><br><span class="line"></span><br><span class="line">自定义模拟实现数据库连接池</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pool pool = new Pool(2);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                Connection connection = pool.borrow();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                pool.free(connection);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j(topic = &quot;c.Test&quot;)</span><br><span class="line">class Pool &#123;</span><br><span class="line">    //1.连接池大小</span><br><span class="line">    private final int poolSize;</span><br><span class="line">    //2.连接对象数组</span><br><span class="line">    private Connection[] connections;</span><br><span class="line">    //3.连接状态 0 表示空闲， 1表示繁忙 用原子数组</span><br><span class="line">    private AtomicIntegerArray status;</span><br><span class="line"></span><br><span class="line">    //4.构造方法初始化</span><br><span class="line">    public Pool(int poolSize) &#123;</span><br><span class="line">        this.poolSize = poolSize;</span><br><span class="line">        this.connections = new Connection[poolSize];</span><br><span class="line">        this.status = new AtomicIntegerArray(new int[poolSize]);</span><br><span class="line">        for (int i = 0; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = new MockConnection(&quot;connection &quot;+i+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.借连接</span><br><span class="line">    public Connection borrow() &#123;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            for (int i = 0; i &lt; poolSize; i++) &#123;</span><br><span class="line">                if (status.get(i) == 0) &#123;</span><br><span class="line">                    if(status.compareAndSet(i,0,1)) &#123;</span><br><span class="line">                        log.debug(&quot;borrow借连接 &#123;&#125;&quot;,connections[i]);</span><br><span class="line">                        return connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有空闲连接，让当前线程进入等待</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log.debug(&quot;wait&quot;);</span><br><span class="line">                    this.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //6.归还连接</span><br><span class="line">    public void free(Connection conn) &#123;</span><br><span class="line">        for (int i = 0; i &lt; poolSize; i++) &#123;</span><br><span class="line">            if (connections[i] == conn) &#123;</span><br><span class="line">                //只有一个线程能获取到该连接</span><br><span class="line">                status.set(i,0);</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    log.debug(&quot;free连接 &#123;&#125;&quot;,conn);</span><br><span class="line">                    this.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MockConnection implements Connection &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public MockConnection(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MockConnection&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Statement createStatement() throws SQLException &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><strong>final原理</strong></p>
<p>1.设置final变量的原理</p>
<p>理解了volatile原理，在对比final的实现就比较简单了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 aload_0</span><br><span class="line">1 invokespecial <span class="comment">#1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;</span></span><br><span class="line">4 aload_0</span><br><span class="line">5 bipush 20</span><br><span class="line">7 putfield <span class="comment">#2 &lt;com/example/n7/TestFinal.a : I&gt;</span></span><br><span class="line">	&lt;-- 写屏障【确保了可见性和有序性】</span><br><span class="line">10 <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>发现final变量的赋值也会通过putfield指令来完成，同样在这条指令之后也会加入写屏障，保证在其他线程读到它的值时不会出现为0的情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestFinal &#123;</span><br><span class="line">    final static int A = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T &#123;</span><br><span class="line">    public void <span class="function"><span class="title">test</span></span> () &#123;</span><br><span class="line">        System.out.println(TestFinal.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#test函数的字节码，在 A有final修饰的时候</span></span><br><span class="line">0 getstatic <span class="comment">#2 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span></span><br><span class="line">3 bipush 20     </span><br><span class="line">5 invokevirtual <span class="comment">#4 &lt;java/io/PrintStream.println : (I)V&gt;</span></span><br><span class="line">8 <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestFinal &#123;</span><br><span class="line">    static int A = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T &#123;</span><br><span class="line">    public void <span class="function"><span class="title">test</span></span> () &#123;</span><br><span class="line">        System.out.println(TestFinal.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#test函数的字节码，在 A没有final修饰的时候</span></span><br><span class="line">0 getstatic <span class="comment">#2 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span></span><br><span class="line">3 getstatic <span class="comment">#3 &lt;com/example/n7/TestFinal.A : I&gt;  </span></span><br><span class="line">6 invokevirtual <span class="comment">#4 &lt;java/io/PrintStream.println : (I)V&gt;</span></span><br><span class="line">9 <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在有final修饰的时候，会在其他类中也拷贝一份该数据，使用的是bipush指令，而在没有用final修饰的时候，字节码指令是getstatic，去类中获取静态变量，所以消耗的时间会长很多。</p>
</blockquote>
<h3 id="7-3-无状态"><a href="#7-3-无状态" class="headerlink" title="7.3 无状态"></a>7.3 无状态</h3><ul>
<li>在web阶段学习时，设计Servlet时为了保证其线程安全，都会有这样的建议，不要为Servlet设置成员变量，这种没有任何成员变量的类是线程安全的。<ul>
<li>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</li>
</ul>
</li>
</ul>
<h2 id="8-共享模型之工具"><a href="#8-共享模型之工具" class="headerlink" title="8.共享模型之工具"></a>8.共享模型之工具</h2><h3 id="8-1-线程池"><a href="#8-1-线程池" class="headerlink" title="8.1 线程池"></a>8.1 线程池</h3><h4 id="1-自定义线程池"><a href="#1-自定义线程池" class="headerlink" title="1.自定义线程池"></a><strong>1.自定义线程池</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestPool&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">RejectPolicy</span>&lt;Runnable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;Runnable&gt; queue, Runnable task)</span> &#123;</span><br><span class="line">                <span class="comment">//1.死等策略</span></span><br><span class="line"><span class="comment">//                queue.put(task);</span></span><br><span class="line">                <span class="comment">//2.带超时等待</span></span><br><span class="line"><span class="comment">//                queue.offer(task,1500,TimeUnit.MILLISECONDS);</span></span><br><span class="line">                <span class="comment">//3.让主线程放弃任务执行</span></span><br><span class="line"><span class="comment">//                log.debug(&quot;放弃&#123;&#125;&quot;,task);</span></span><br><span class="line">                <span class="comment">//4.抛出异常</span></span><br><span class="line"><span class="comment">//                throw new RuntimeException(&quot;任务执行失败&#123;&#125;&quot;+task);</span></span><br><span class="line">                <span class="comment">//5.让调用者自己执行任务</span></span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;在执行&#123;&#125;&quot;</span>,j);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue,T task)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置任务的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="comment">//当任务数没有超过coreSize时，直接交给worker对象执行</span></span><br><span class="line">        <span class="comment">//如果任务超过coreSize时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增worker&#123;&#125;,任务&#123;&#125;&quot;</span>,worker,task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">//1.死等</span></span><br><span class="line">                <span class="comment">//2.带超时等待</span></span><br><span class="line">                <span class="comment">//3.让主线程放弃任务执行</span></span><br><span class="line">                <span class="comment">//4.抛出异常</span></span><br><span class="line">                <span class="comment">//5.让调用者自己执行任务</span></span><br><span class="line"></span><br><span class="line">                taskQueue.tryPut(rejectPolicy,task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit,<span class="type">int</span> queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = taskQueue;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            <span class="comment">//1.当task不为空，就执行任务</span></span><br><span class="line">            <span class="comment">//2.当task执行完毕从任务队列中获取任务并执行</span></span><br><span class="line"><span class="comment">//            while (task != null || (task = taskQueue.take()) != null) &#123;</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = taskQueue.poll(timeout,timeUnit)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行。。。&#123;&#125;&quot;</span>,task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker被移除&#123;&#125;&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//1.任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时的阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//将timeout统一转换为纳秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//该方法返回的就是剩余时间</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞获取 获取可用的线程</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待任务队列&#123;&#125;&quot;</span>,element);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列&#123;&#125;&quot;</span>,element);</span><br><span class="line">            queue.addLast(element);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时时间阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task,<span class="type">long</span> timeout,TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待任务队列&#123;&#125;&quot;</span>,task);</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> )&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列&#123;&#125;&quot;</span>,task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断任务队列是否已满</span></span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capacity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>,task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//有空闲</span></span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列&#123;&#125;&quot;</span>,task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-ThreadPoolExecutor"><a href="#2-ThreadPoolExecutor" class="headerlink" title="2.ThreadPoolExecutor"></a><strong>2.ThreadPoolExecutor</strong></h4><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220528111352661.png" alt="image-20220528111352661"></p>
<h4 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1)线程池状态"></a><strong>1)线程池状态</strong></h4><p>ThreadPoolExecutor使用int的高3位来表示线程池状态，低20位表示线程数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runState 提供主要的生命周期控制，取值： RUNNING：接受新任务并处理排队任务 SHUTDOWN：不接受新任务，但处理排队任务 STOP：不接受新任务，不处理排队任务，并中断正在进行的任务 TIDYING：所有任务都已终止，workerCount 为零，转换到状态 TIDYING 的线程将运行 terminate() 钩子方法. </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rs为高三位代表线程状态，wc为低29位代表线程果树，ctl是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这些信息存储在一个原子变量ctl中，目的是将线程状态与线程果树合二为一，这样就可以用一次cas原子操作进行赋值。</p>
</li>
<li><pre><code class="java">//c为旧值，ctlOf返回结果为新值
ctl.compareAndSet(c,ctlOf(targetState,workerCountOd(c)));
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### **2)构造方法**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>corePoolSize核心线程数目（最多保留的线程数）</p>
</li>
<li><p>maximumPoolSize最大线程数目 （核心线程数corePoolSize+救急线程【是在核心线程和阻塞队列都满的时候才进行创建的】）</p>
</li>
<li><p>keepAliveTime 生存时间 ——针对救急线程</p>
</li>
<li><p>unit 时间单位——针对救急线程</p>
</li>
<li><p>workQueue阻塞队列</p>
</li>
<li><p>threadFactory线程工厂，可以为线程创建时起个好名字</p>
</li>
<li><p>handler拒绝策略</p>
</li>
</ul>
<hr>
<ul>
<li>线程池中刚开始没有线程，当有一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li>
<li>当线程数达到corePoolSize并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue阻塞队列排队，直到有空闲的线程。</li>
<li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建maximumPoolSize—corePoolSize数目的线程来救急。</li>
<li>如果线程到达maximumPoolSize仍然有新任务这时会执行拒绝策略。拒绝策略jdk提供了4种实现，其它著名框架也提供了实现。<ul>
<li>AbortPolicy让调用者抛出RejectedExecutionException异常，这是默认策略</li>
<li>CallerRunsPolicy让调用者运行任务</li>
<li>DiscardPolicy放弃本次任务</li>
<li>DiscardOldestPolicy防疫队列中最早的任务，本任务取而代之</li>
<li>Dubbo的实现，在抛出RejectedExecutionException异常之前会记录日志，并dump线程栈信息，方便定位问题。</li>
<li>Netty的实现，是创建一个新线程来执行任务</li>
<li>ActiveMQ的实现，带超时等待（60S）尝试放入队列，类似我们之前自定义的拒绝策略</li>
<li>PinPoint的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
</li>
<li>当高峰过去后，超过corePoolSize的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由KeepAliveTime和unit来控制</li>
<li>根绝这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</li>
</ul>
<h4 id="3）newFixedThreadPool"><a href="#3）newFixedThreadPool" class="headerlink" title="3）newFixedThreadPool"></a><strong>3）newFixedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Executors类中</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>核心线程数&#x3D;&#x3D;最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务<ul>
<li>评价：适用于任务量已知，相对耗时的任务</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//线程工厂就是为了起一个更好的名字</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;myPool_t&quot;</span>+t.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    pool2.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool2.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool2.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2781</span> [myPool_t1] c.Test -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2790</span> [myPool_t1] c.Test -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2792</span> [myPool_t2] c.Test -&gt; <span class="number">2</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2793</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] c.Test -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2794</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] c.Test -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2796</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] c.Test -&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="4）newCachedThreadPool"><a href="#4）newCachedThreadPool" class="headerlink" title="4）newCachedThreadPool"></a><strong>4）newCachedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>核心线程数是0，最大线程数是Integer.Max_VALUE，救急线程的空闲生存时间是60S，意味着全部都是救急线程（60s后可以回收）</li>
<li>救急线程可以无限创建</li>
<li>队列采用了SynchronousQueue实现特点是：<ul>
<li>它没有容量，没有线程来取是放不进去的（一手交钱一手交货）</li>
</ul>
</li>
</ul>
<blockquote>
<p>评价：</p>
<ul>
<li>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲一分钟后释放线程</li>
<li>适合任务数比较密集，但每个任务执行时间较短的情况</li>
</ul>
</blockquote>
<ul>
<li><p>SynchronousQueue的使用示例【有点类似于golang中的无缓冲区的channel】</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    SynchronousQueue&lt;Integer&gt; integers = new SynchronousQueue&lt;&gt;();
    new Thread(() -&gt; &#123;
        try&#123;
            log.debug(&quot;putting &#123;&#125;&quot;,1);
            integers.put(1);
            log.debug(&quot;&#123;&#125; putted...&quot;,1);

            log.debug(&quot;putting &#123;&#125;&quot;,2);
            integers.put(2);
            log.debug(&quot;&#123;&#125; putted...&quot;,2);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;,&quot;t1&quot;).start();

    try &#123;
        TimeUnit.SECONDS.sleep(1);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;

    new Thread(() -&gt; &#123;
        try&#123;
            //取数据
            log.debug(&quot;take &#123;&#125;&quot;,1);
            integers.take();
            log.debug(&quot;&#123;&#125; taked...&quot;,1);

            log.debug(&quot;take &#123;&#125;&quot;,2);
            integers.take();
            log.debug(&quot;&#123;&#125; taked...&quot;,2);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;,&quot;t2&quot;).start();
&#125;
//output
14:58:00 1601 [t1] c.Test -&gt; putting 1
14:58:01 2585 [t2] c.Test -&gt; take 1
14:58:01 2586 [t1] c.Test -&gt; 1 putted...
14:58:01 2586 [t1] c.Test -&gt; putting 2
14:58:01 2586 [t2] c.Test -&gt; 1 taked...
14:58:01 2587 [t2] c.Test -&gt; take 2
14:58:01 2587 [t1] c.Test -&gt; 2 putted...
14:58:01 2588 [t2] c.Test -&gt; 2 taked...
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### **5）newSingleThreadExecutor**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>适用场景：</p>
<ul>
<li><p>希望多个任务排队执行。线程数固定为1，任务数多于1时，会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放</p>
</li>
<li><p>区别：</p>
<ul>
<li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</li>
<li>Executors.newSingleThreadExecutor()线程个数始终为1，不能修改<ul>
<li>FinalizableDelegatedExecutorService应用的是装饰器模式，只对外暴露了ExecutorService接口，因此不能调用ThreadPoolExecutor中特有的方法</li>
</ul>
</li>
<li>Executors.newFixedThreadPool(1)初始时为1，以后还可以修改<ul>
<li>对外暴露的是ThreadPoolExecutor对象，可以强转后调用setCorePoolSize等方法进行修改。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6）提交任务"><a href="#6）提交任务" class="headerlink" title="6）提交任务"></a><strong>6）提交任务</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交任务task,用返回值Future获得任务执行结果</span></span><br><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">Future&lt;String&gt; future = service.submit(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;main...&quot;</span>);</span><br><span class="line">log.debug(future.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交task中所有任务</span></span><br><span class="line">List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交task中所有任务，带超时时间</span></span><br><span class="line">List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交tasks中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其他任务取消</span></span><br><span class="line">&lt;T&gt; invokeAny(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Callable</span>&lt;T&gt; tasks&gt;) <span class="keyword">throws</span> InterruptedException,ExcutionExection</span><br><span class="line">    </span><br><span class="line"><span class="comment">//提交tasks中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其他任务取消,带超时时间</span></span><br><span class="line">&lt;T&gt; invokeAny(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Callable</span>&lt;T&gt;&gt; tasks，<span class="type">long</span> timeout,TimeUnit unit) <span class="keyword">throws</span> InterruptedException,ExcutionExection,TimeoutException</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;方法用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试invokeAny</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testInvokeAny</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">any</span> <span class="operator">=</span> service.invokeAny(Arrays.asList(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    log.debug(any);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试invokeAll方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testInvokeAll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    List&lt;Future&lt;String&gt;&gt; futures = service.invokeAll(Arrays.asList(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    futures.forEach(stringFuture -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(stringFuture.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7）关闭线程池"><a href="#7）关闭线程池" class="headerlink" title="7）关闭线程池"></a><strong>7）关闭线程池</strong></h4><p><strong>shutdown</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">	- 不会接收新任务</span></span><br><span class="line"><span class="comment">	- 但已提交任务会执行完</span></span><br><span class="line"><span class="comment">	- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//修改线程状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//仅会打断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">//扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终结没有运行的线程可以立刻终结，如果还有运行的线程也不会等</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shutdownNow</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程状态变为stop</span></span><br><span class="line"><span class="comment">	- 不会接收新任务</span></span><br><span class="line"><span class="comment">	- 会将队列中的任务返回</span></span><br><span class="line"><span class="comment">	- 并用interrupt的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//修改线程状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//打断所有线程，空闲的和正在执行的</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//获取队列中剩余任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终结</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不在RUNNING状态的线程池，此方法就返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池状态是否是TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用shutdown后，由于线程并不会等待所有任务运行结束，因此如果它想在线程池TERMINATED后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testShutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1 running...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;task1 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task2 running...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;task2 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task3 running...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;task3 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;shutdownNow...&quot;</span>);</span><br><span class="line">    List&lt;Runnable&gt; runnables = service.shutdownNow();</span><br><span class="line">    log.debug(<span class="string">&quot;other &#123;&#125;&quot;</span>,runnables.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1 running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;task1 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task2 running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;task2 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task3 running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;task3 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;shutdown...&quot;</span>);</span><br><span class="line">    service.shutdown();</span><br><span class="line">    <span class="comment">//等shutdown之前的线程执行完或者等够3秒后才往下执行</span></span><br><span class="line">    service.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    log.debug(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">    <span class="comment">//shutdown执行后再开启任务就会抛出错误</span></span><br><span class="line">    <span class="comment">/*service.submit(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            log.debug(&quot;task4 running...&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            log.debug(&quot;task4 finish...&quot;);</span></span><br><span class="line"><span class="comment">            return 1;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步模式之工作线程</strong></p>
<p><strong>1.定义</strong></p>
<ul>
<li>让有限的工作线程（worker thread）来轮流异步处理无限多的任务，也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</li>
<li>注意：不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</li>
<li>例如：如果一个餐馆的工人既要招呼客人（任务类型A）,又要到后厨做菜（任务类型B）显然效率不高，分成服务员（线程池A）与厨师（线程池B）更为合理。</li>
</ul>
<p><strong>2.饥饿</strong></p>
<p>固定大小线程池会有饥饿现象</p>
<ul>
<li>两个工人是同一个线程池中的两个线程</li>
<li>它们要做的事情是：为客人点菜和到后厨做菜，这是两个阶段的工作<ul>
<li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li>
<li>后厨做菜：没啥说的，做就是了</li>
</ul>
</li>
<li>比如工人A处理了点餐任务，接下来它要等着工人B把菜做好，然后上菜，这样配合的话没问题</li>
<li>但现在同时来了两个客人，这个时候工人A和工人B都去处理点餐了，这时没人做饭了，饥饿。（因为线程不足）</li>
</ul>
<p>解决办法：</p>
<ul>
<li>工人A专门处理点餐</li>
<li>工人B专门负责做菜</li>
</ul>
<p><strong>3.创建多少线程池合适</strong></p>
<ul>
<li>过小会导致程序不能充分地利用系统资源，容易导致饥饿</li>
<li>过大会导致更多的线程上下文切换，占用更多的内存</li>
</ul>
<p><strong>3.1 CPU密集型运算</strong>【数据分析】</p>
<p>通常采用CPU核数+1能够实现最优的CPU利用率，+1是保证当线程由于页缺失故障（操作系统）或其他原因导致暂停时，额外的这个线程就能顶上去，保证CPU时钟周期不被浪费。</p>
<p><strong>3.2 I&#x2F;O密集型运算</strong>【web应用程序】</p>
<p>CPU不总是处于繁忙状态，例如当你执行业务计算时，这时候会使用CPU资源，但当你执行I&#x2F;O操作时，远程RPC调用时，包括进行数据库操作时，这时候CPU就闲下来了，你可以利用多线程提高它的利用率</p>
<p>经验公式：</p>
<p>线程数  &#x3D; 核数 * 期望CPU利用率 * 总时间（CPU计算时间+等待时间）&#x2F;CPU计算时间</p>
<h4 id="8）任务调度线程池"><a href="#8）任务调度线程池" class="headerlink" title="8）任务调度线程池"></a>8）任务调度线程池</h4><p>在【任务调度线程池】功能加入之前，可以使用java.util.Timer来实现定时功能，Timer的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务再执行，前一个任务的延迟或异常都将会影响到之后的任务。</p>
<ul>
<li><p>Timer的使用案例</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Timer timer = new Timer();
    TimerTask task1 = new TimerTask() &#123;
        @Override
        public void run() &#123;
            log.debug(&quot;task1...&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(2);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;;
    TimerTask task2 = new TimerTask() &#123;
        @Override
        public void run() &#123;
            log.debug(&quot;task2...&quot;);
        &#125;
    &#125;;

    log.debug(&quot;start...&quot;);
    timer.schedule(task1,1000);
    timer.schedule(task2,1000);
&#125;
//output
10:53:26 706 [main] c.TestTimer -&gt; start...
10:53:27 1713 [Timer-0] c.TestTimer -&gt; task1...
10:53:29 3717 [Timer-0] c.TestTimer -&gt; task2...   //taks2必须在task1执行完以后才能执行
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);</span><br><span class="line">    log.debug(&quot;begin...&quot;);</span><br><span class="line">    //这个方法里面指的是执行到该方法后等待的时间</span><br><span class="line">    /*executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.debug(&quot;running...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,2,1,TimeUnit.SECONDS);*/</span><br><span class="line"></span><br><span class="line">    //这里面delay指的是上一个任务结束之后才开始算的</span><br><span class="line">    executorService.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">        log.debug(&quot;running2...&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,1,1,TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

9）利用调度线程池来实现调度任务

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSchedule</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//获取当前时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">//获取这一周设置的时间点时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> now.withHour(<span class="number">11</span>).withMinute(<span class="number">41</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.SUNDAY);</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间大于上面设置的本周时间，必须找到下周设置的该时间点</span></span><br><span class="line">        <span class="keyword">if</span> (now.compareTo(time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">between</span> <span class="operator">=</span> Duration.between(now, time);</span><br><span class="line">        <span class="type">long</span> <span class="variable">millis</span> <span class="operator">=</span> between.toMillis();</span><br><span class="line">        System.out.println(millis);</span><br><span class="line">        <span class="comment">//initialDelay表示的当前时间内与周四时间的差值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialDelay</span> <span class="operator">=</span> millis;</span><br><span class="line">        <span class="comment">//period表示一周的时间毫秒数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">period</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">        pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        &#125;,initialDelay,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="3-Fork-Join"><a href="#3-Fork-Join" class="headerlink" title="3.Fork&#x2F;Join"></a>3.Fork&#x2F;Join</h4><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1)概念"></a>1)概念</h4><ul>
<li>Fork&#x2F;join是jdk1.7加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的CPU密集型运算。</li>
<li>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解，即递归相关的一些计算，如归并排序，斐波那契数列，都可以用分治思想进行求解</li>
<li>Fork&#x2F;Join在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</li>
<li>Fork&#x2F;Join默认会创建与CPU核心数小大相同的线程池。</li>
</ul>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2)使用"></a>2)使用</h4><ul>
<li><p>提交给Fork&#x2F;Join线程池的任务需要继承RecursiveTask(有返回值)或RecursiveAction()</p>
</li>
<li><pre><code class="java">public class TestForkJoin &#123;
    public static void main(String[] args) &#123;
        ForkJoinPool pool = new ForkJoinPool(4);
        System.out.println(pool.invoke(new MyTask(5)));


    &#125;
&#125;

class MyTask extends RecursiveTask&lt;Integer&gt; &#123;
    private int n;
    public MyTask(int n) &#123;
        this.n = n;
    &#125;

    @Override
    protected Integer compute() &#123;
        if (n == 1) &#123;
            return 1;
        &#125;
        MyTask task = new MyTask(n - 1);
        task.fork();  //让一个线程去执行任务
        Integer result =n + task.join();//接受任务结果
        return result;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 8.2 J.U.C</span><br><span class="line"></span><br><span class="line">#### 1.AQS原理*</span><br><span class="line"></span><br><span class="line">**1)概述**</span><br><span class="line"></span><br><span class="line">&gt; 全称是AbstractQueuedSynchronizer,是阻塞式和相关的同步器工具的框架</span><br><span class="line">&gt;</span><br><span class="line">&gt; 特点：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 用state属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</span><br><span class="line">&gt;   - getState——获取state状态</span><br><span class="line">&gt;   - setState——设置state状态</span><br><span class="line">&gt;   - compareAndSetState——乐观锁机制设置状态</span><br><span class="line">&gt;   - 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</span><br><span class="line">&gt; - 提供了基于FIFO的等待队列，类似于Monitor的EntryList</span><br><span class="line">&gt; - 条件变量来实现等待，唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</span><br><span class="line">&gt;</span><br><span class="line">&gt; 子类主要实现这样一些方法（默认抛出UnsupportedOperationException）</span><br><span class="line">&gt;</span><br><span class="line">&gt; - tryAcquire</span><br><span class="line">&gt; - tryRelease</span><br><span class="line">&gt; - tryAcquireShared</span><br><span class="line">&gt; - tryReleaseShared</span><br><span class="line">&gt; - isHeldExclusively</span><br><span class="line">&gt;</span><br><span class="line">&gt; 获取锁的姿势</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```java</span><br><span class="line">&gt; //如果获取锁失败</span><br><span class="line">&gt; if (!tryAcquire(arg)) &#123;</span><br><span class="line">&gt; 	//入队，可以选择阻塞当前线程  park /unpark</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p>释放锁的姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果释放锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">	<span class="comment">//让阻塞线程恢复执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义实现锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAqs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();  <span class="comment">//不可重入锁</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义锁  （不可重入锁）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//独占锁  同步器类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>,<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//加上了锁,并设置owner为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//                return super.tryAcquire(arg);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁，不成功会进入等待队列等待</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁，可打断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试加锁，一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试加锁，带超时时间</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加条件变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-ReentrantLock原理"><a href="#2-ReentrantLock原理" class="headerlink" title="2.ReentrantLock原理*"></a>2.ReentrantLock原理*</h4><p><strong>1.非公平锁实现原理</strong></p>
<blockquote>
<p>加锁解锁流程</p>
<ul>
<li><p>先从构造器开始看，默认为非公平锁</p>
</li>
<li><pre><code class="java">public ReentrantLock() &#123;
    sync = new NonfairSync();
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- NonFairSync继承自AQS</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  final void lock() &#123;</span><br><span class="line">      if (compareAndSetState(0, 1))</span><br><span class="line">          //没有竞争时，直接设置当前线程为owner</span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">      else</span><br><span class="line">          acquire(1);</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  public final void acquire(int arg) &#123;</span><br><span class="line">      if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>当第一个竞争出现时</p>
<ul>
<li>CAS尝试将state由0改为1，结果失败</li>
<li>进入tryAcquire逻辑，这时state已经是1，结果仍然失败</li>
<li>接下来进入addWaiter逻辑，构造Node队列（等待队列）<ul>
<li>Node的创建是懒惰的</li>
<li>其中第一个Node称为Dummy(哑元)或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
<li>当前线程进入acquireQueued逻辑<ul>
<li>acquiredQueued会在一个死循环中不断尝试获得锁，失败后进入park阻塞</li>
<li>如果自己是紧邻着head(排第二位)，那么再次tryAcquire尝试获得锁，当然这时state仍为1，失败</li>
<li>进入shouldParkAfterFailedAcquire逻辑，将前驱node,即head的waitStatus改为-1，这次返回false。</li>
<li>shouldParkAfterFailedAcquire执行完毕回到acquireQueued，再次tryAcquire尝试获取锁，当然这是state仍为1，失败</li>
<li>当再次进入shouldParkAfterFailedAcquire时，这时因为其前驱node的waitStatus已经是-1，这时返回true。</li>
<li>进入parkAndCheckInterrupt，Thread-1 park（灰色表示）</li>
</ul>
</li>
<li>再次有多个线程经历上述过程竞争失败，变成这个样子</li>
<li>Thread-0释放锁，进入tryRelease流程，如果成功<ul>
<li>设置exclusiveOwnerThread为null</li>
<li>state&#x3D;0</li>
</ul>
</li>
<li>当前队列不为null，并且head的waitStatus &#x3D; -1，进入unparkSuccessor流程</li>
<li>找到流程中离head最近的一个Node(没取消的)，unpark恢复其运行，本例中即为Thread-1</li>
<li>回到 Thread-1de acquireQueued流程</li>
<li>如果加锁成功（没有竞争），会设置<ul>
<li>exclusiveOwnerThread为Thread-1,state &#x3D; 1</li>
<li>head指向刚刚Thread-1所在的Node,该Node清空Thread</li>
<li>原本的head因为从链表断开，而可被垃圾回收</li>
</ul>
</li>
<li>如果这时候有其他线程来竞争（非公平的体现），例如这时候Thread-4来了</li>
<li>如果不巧又被Thread-4占了先<ul>
<li>Thread-4被设置为exclusiveOwnerThread，state &#x3D; 1</li>
<li>Thread-1再次进入acquireQueued流程，获取锁失败，重新进入park阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>2.可重入原理</strong></p>
<p><strong>3.可打断原理</strong></p>
<ul>
<li>不可打断模式：在此模式下，即使它被打断，仍会驻留在AQS队列中，等获得锁后方能继续运行（是继续运行，只是打断标记被设置为true）</li>
<li>可打断模式：会抛出打断异常</li>
</ul>
<p><strong>4.公平锁实现原理</strong></p>
<p><strong>5.条件变量实现原理</strong></p>
<p>每个条件变量其实就对应着一个等待队列，其实现类是ConditionObject</p>
<p><strong>await流程</strong></p>
<p>开始Thread-0持有锁，调用await，进入ConditionObject的addConditionWaiter流程创建新的Node状态为-2（Node Condition）,关联Thread-0，加入等待队列尾部</p>
<p><strong>signal流程</strong></p>
<p>假设Thread-1要来唤醒Thread-0。进入ConditionObject的doSignal流程，取得等待队列中第一个Node,即Thread-0所在Node。执行transferForSignal流程，将该Node加入AQS队列尾部，将Thread-0的waitStatus改为0，Thread-3的waitStatus改为-1。Thread-1释放锁，进入unpark流程。</p>
<h4 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3.读写锁"></a>3.读写锁</h4><p><strong>3.1 ReentrantReadWriteLock</strong></p>
<ul>
<li><p>当读操作远远高于写操作时，这时候使用读写锁。让读-读可以并发，提高性能。类似于数据库中的select … from … lock in share node</p>
</li>
<li><p>提供一个数据容器类内部分别使用读锁保护数据的read方法，写锁保护数据的write（）方法</p>
</li>
<li><pre><code class="java">public class TestReadWrite &#123;
    public static void main(String[] args) &#123;
        DataContainer dataContainer = new DataContainer();
        new Thread(() -&gt; &#123;
            dataContainer.write();
        &#125;,&quot;t1&quot;).start();
        try &#123;
            TimeUnit.MILLISECONDS.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        new Thread(() -&gt; &#123;
            dataContainer.write();
        &#125;,&quot;t2&quot;).start();
    &#125;
&#125;

@Slf4j(topic = &quot;c.DataContainer&quot;)
class DataContainer &#123;
    private Object data;
    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
    //获取读锁
    private ReentrantReadWriteLock.ReadLock r = rw.readLock();
    //获取写锁
    private ReentrantReadWriteLock.WriteLock w = rw.writeLock();


    public Object read() &#123;
        log.debug(&quot;获取读锁&quot;);
        r.lock();
        try &#123;
            log.debug(&quot;读取&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return data;
        &#125;finally &#123;
            log.debug(&quot;释放读锁&quot;);
            r.unlock();
        &#125;

    &#125;
    public void write() &#123;
        log.debug(&quot;获取写锁&quot;);
        w.lock();
        try &#123;
            log.debug(&quot;写入&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;finally &#123;
            log.debug(&quot;释放写锁&quot;);
            w.unlock();
        &#125;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **注意事项：**</span><br><span class="line"></span><br><span class="line">  - 读锁不支持条件变量</span><br><span class="line"></span><br><span class="line">  - 重入时升级不支持，即持有锁的情况下去获取写锁，会导致获取写锁永久等待</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    r.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        log.debug(&quot;读取&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

- 重入时降级支持：即持有写锁的情况下去获取读锁【这样可以防止在释放写锁的时候，数据被其他写线程更改，直接加上读线程】
</code></pre>
</li>
<li><p><strong>应用之缓存</strong></p>
<ul>
<li>&#x3D;&#x3D;缓存更新策略&#x3D;&#x3D;：<ul>
<li>更新时，是先清缓存还是先更新数据库<ul>
<li>先清缓存：导致的问题是清空后，在更新数据库之前，被其他线程读到了更新前数据库的内容并存入缓存，即使后面更新了数据库中的内容，也会继续使用已经存入缓存的旧数据【因为更新操作一般比查询操作慢】</li>
<li><strong>先更新数据库</strong>：可能会存在一段时间内，一个线程更新了数据库，但是在清空缓存前，另外一个线程可能正在使用缓存中与更新后数据库不一样的数据，但是这个时间会很短。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3.2 读写锁原理</strong></p>
<p>1.图解流程</p>
<p>读写锁用的是同一个Sync同步器，因此等待队列，state等也是同一个。</p>
<p>线程t1 w.lock，线程t2 r.lock</p>
<ul>
<li>t1成功上锁，流程与ReentrantLock加锁相比没有特殊之处，不同是写锁状态占了state的低16位，而读锁使用的是state的高16位</li>
<li>t2执行r.lock，这时进入读锁的sync.acquireShared(1) 流程，首先会进入tryAcquireShared流程，如果有下所占据，那么tryAcquireShared返回-1表示失败<ul>
<li>tryAcquireShared返回值表示<ul>
<li>-1表示失败</li>
<li>0表示成功，但后继节点不会继续唤醒</li>
<li>正数白哦是成功，而且数值是还有几个后继节点需要唤醒，读写锁返回1</li>
</ul>
</li>
</ul>
</li>
<li>这时会进入sync.doAcquireShared(1)流程，首先也是调用addWaiter添加节点，不同之处在于节点被设置为Node.SHARED模式而非Node.EXCLUSIVE模式，注意此时t2仍处于活跃状态</li>
<li>t2会看着自己的节点是不是老二，如果是，还会再次调用tryAcquireShared(1)来尝试获取锁</li>
<li>如果没有成功，在doAcquireShared内for(; ;)循环一次，把前驱节点的waitStatus改为-1，再for(; ;)循环一次尝试tryAcquireShared()如果还不成功，那么再parkAndChaeckInterrupt()处park</li>
</ul>
<p>线程t3 r.lock( )  线程 t4 w.lock( )</p>
<ul>
<li>在上面的那种状态下，假设又有t3加读锁和t4加写锁，这期间t1仍然持有锁，就变成了下面的样子</li>
</ul>
<p>线程t1 w.unlock( )</p>
<ul>
<li><p>这时会走到写锁的sync.release(1)流程，调用sync.tryRelease( 1 )成功，变成下面的样子</p>
</li>
<li><p>接下来执行唤醒流程sync.unparkSuccessor，既让老二恢复运行，这时t2在doAcquireShared内parkAndCheckInterrupt()处恢复运行</p>
</li>
<li><p>这回再来一次for(; ;)执行tryAcquireShared成功则让读锁计数加1 </p>
</li>
<li><p>这时t2已经恢复运行，接下来t2调用setHeadAndPropagate(node,1),它原本所在节点被设置为头节点</p>
</li>
<li><p>事情还没完，在setHeadAndPropagate方法内还会检查下一个节点是否是shared，如果是则调用doReleaseShared( )将head的状态从-1改为0并唤醒老二，这时t3在doAcquireShared内parkAndCheckInterrupt( )处恢复运行</p>
</li>
<li><p>这回再来一次for(; ;)执行tryAcquireShared成功则让读锁计数加一</p>
</li>
<li><p>这时t3已经恢复运行，接下来t3调用setHeadAndPropagate(node,1),它原本所在节点被设置为头节点</p>
</li>
</ul>
<p>线程t2.unlock( )  线程t3.unlock()</p>
<ul>
<li>t2进入sync.releaseShared( )中，调用tryReleaseShared( 1 )让计数减一，但由于计数还不为零</li>
<li>t3进入sync.releaseShared( 1)中，调用tryReleaseShared(1)让计数减一，这回计数为零了，进入doReleaseShared( )将头节点从-1改为0并唤醒老二，即</li>
<li>之后t4在acquireQueued中parkAndCheckInterrupt处恢复运行，再次for(; ;)这次自己是老二，并没有其他竞争，tryAcquire(1)成功，修改头节点，流程结束。</li>
</ul>
<p><strong>3.3 StampedLock</strong></p>
<p>该类自JDK8加入，是为了进一步优化读性能，它的特点是在使用读锁，写锁时都必须配合【戳】使用</p>
<p>加解读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock()</span><br><span class="line">lock.unlockRead(stamp)</span><br></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p>乐观读，StampedLock支持tryOptimisticRead( )方法（乐观读），读取完毕后需要做一次戳检验，如果检验通过，表示这期间确实没有写操作，数据可以安全使用，如果检验没通过，需要重新获取读锁，保证数据安全</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long stamp = lock.tryOptimisticRead();</span><br><span class="line">//验戳</span><br><span class="line">if (!lock.validate(stamp)) &#123;</span><br><span class="line">	//锁升级</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestStampedLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStampedLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DataContainerStamped</span> <span class="variable">dataContainerStamped</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            dataContainerStamped.read(<span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            dataContainerStamped.write(<span class="number">1000</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.DataContainerStamped&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataContainerStamped</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">&quot;optimistic read locking &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(readTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lock.validate(stamp)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;updating to read lock...&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(readTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>StampedLock不支持条件变量</li>
<li>StampedLock不支持可重入</li>
</ul>
</blockquote>
<h4 id="4-Semaphore"><a href="#4-Semaphore" class="headerlink" title="4.Semaphore"></a>4.Semaphore</h4><p>信号量，用来限制能同时访问共享资源的线程上限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSemaphore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建Semaphore对象</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);  <span class="comment">//限制上限为3，即在同时运行的线程数上限为3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(<span class="string">&quot;ending...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    s.release();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Semaphore应用</strong>：</p>
<ul>
<li>使用Semaphore限流，在访问高峰时，让请求线程阻塞，敢封其过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比Tomcat  LimitLatch的实现）</li>
<li>用Semaphore实现简单连接池，&#x3D;&#x3D;对比享元模式下的实现（用wait&#x2F;notify），性能和可读性显然更好&#x3D;&#x3D;，注意下面的实现中线程数和数据库连接数是相等的</li>
</ul>
<p><strong>Semaphore原理</strong>：</p>
<p><strong>1.加锁解锁流程</strong></p>
<ul>
<li>Semaphore有点像一个停车场，permits就好像停车位数量，当线程获得了permits就像是获得了停车位，然后停车场显示空余车位减一。</li>
<li>刚开始，permits(state)为3，这时5个线程来获取资源</li>
<li>假设其中Thread-1,Thread-2,Thread-4 cas竞争成功，而Thread-0和Thread-3竞争失败，进入AQS队列park阻塞</li>
<li>这时Thread-4释放了permits，状态如下</li>
<li>接下来Thread-0竞争成功，permits再次设置为0，设置自己为head节点，断开原来的head节点，unpark接下来的Thread-3节点，但由于permits是0，因此Thread-3在尝试不成功后再次进入park状态</li>
</ul>
<h4 id="5-CountDownLatch"><a href="#5-CountDownLatch" class="headerlink" title="5.CountDownLatch"></a>5.CountDownLatch</h4><ul>
<li>用来进行线程同步协作，等待所有线程完成倒计时，其中构造参数用来初始化等待计数值，await( )用来等待计数归零，countDown( )用来让计数减一</li>
<li>功能类似于golang里面的waitgroup</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCountDownLatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;ending...&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;awaiting...&quot;</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;await ending...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将CountDownLatch应用于线程池</p>
</li>
<li><pre><code class="java">     public static void main(String[] args) &#123;
        CountDownLatch countDownLatch = new CountDownLatch(3);
        ExecutorService service = Executors.newFixedThreadPool(4);
        service.submit(() -&gt; &#123;
            log.debug(&quot;begin...&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            countDownLatch.countDown();
            log.debug(&quot;ending...&#123;&#125;&quot;,countDownLatch.getCount());
        &#125;);
        service.submit(() -&gt; &#123;
            log.debug(&quot;begin...&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(2);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            countDownLatch.countDown();
            log.debug(&quot;ending...&#123;&#125;&quot;,countDownLatch.getCount());
        &#125;);
        service.submit(() -&gt; &#123;
            log.debug(&quot;begin...&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(3);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            countDownLatch.countDown();
            log.debug(&quot;ending...&#123;&#125;&quot;,countDownLatch.getCount());
        &#125;);
  
        service.submit(() -&gt; &#123;
            try &#123;
                log.debug(&quot;waiting...&quot;);
                countDownLatch.await();
                log.debug(&quot;wait end&quot;);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;);
        
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**应用之同步等待多个远程调用结束**</span><br><span class="line"></span><br><span class="line">#### 6.CyclicBarrier</span><br><span class="line"></span><br><span class="line">循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置【计数个数】，每个线程执行到某个需要同步的时刻调用await( )方法进行等待，当等待的线程数满足【计数个数】时，继续执行。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class TestCyclicBarrier &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //这里的线程池中的个数与barrier中的个数应该一致，这样才能出现我们想要的结果</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(2);</span><br><span class="line">//        CyclicBarrier cyclicBarrier = new CyclicBarrier(2);</span><br><span class="line">        </span><br><span class="line">        //注意这里的cyclicbarrier对象可以复用，这一点与countdownlatch是不一样的，因为cyclicbarrier在await方法调用后，设置的count变为了0，之后又会开启下一次 nextGeneration( ),count就又变为了最初设置的2</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(2,() -&gt; &#123;</span><br><span class="line">            log.debug(&quot;task1 task2 finished...&quot;);  //count = 2</span><br><span class="line">        &#125;);  </span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(&quot;task1 begin...&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();  //2-1</span><br><span class="line">//                    log.debug(&quot;task1 end...&quot;);</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(&quot;task2 begin...&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();  //1-1 = 0</span><br><span class="line">//                    log.debug(&quot;task1 end...&quot;);</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="7-线程安全集合类概述"><a href="#7-线程安全集合类概述" class="headerlink" title="7.线程安全集合类概述"></a>7.线程安全集合类概述</h4><p>线程安全集合类可以分为三类：</p>
<ul>
<li>遗留的线程安全集合如HashTable,Vector 【并发性能比较低，因为方法全部用synchronized加锁了，不推荐使用，有替代的类】</li>
<li>使用Collections装饰的线程安全集合，如：<ul>
<li>Collections.synchronizedCollection</li>
<li>Collections.synchronizedList</li>
<li>Collections.synchronizedMap</li>
<li>Collections.synchronizedSet</li>
<li>Collections.synchronizedNavigableMap</li>
</ul>
</li>
<li>java.util.concurrent.*</li>
</ul>
<p>重点介绍java.util.concurrent.*下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：Blocking、CopyOnWrite、Concurrent</p>
<ul>
<li><p>Blocking大部分实现基于锁，并提供用来阻塞的方法</p>
</li>
<li><p>CopyOnWrite之类容器修改开销相对较重 【适用于读多写少】</p>
</li>
<li><p>Concurrent类型的容器：</p>
<ul>
<li><p>内部很多操作使用cas优化，一般可以提供高吞吐量</p>
</li>
<li><p>弱一致性</p>
<ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li>
<li>求大小弱一致性，size操作未必是100%准确</li>
<li>读取弱一致性</li>
</ul>
</li>
<li><blockquote>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用fail-fast机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="8-ConcurrentHashMap"><a href="#8-ConcurrentHashMap" class="headerlink" title="8.ConcurrentHashMap"></a>8.ConcurrentHashMap</h4><p><strong>练习：单词计数</strong></p>
<p>生成测试数据</p>
<ul>
<li>下面的代码会存在线程安全问题，即便ConcurrentHashMap类中的每个方法都是线程安全的，但是多个方法组合到一起的时候就会出现线程安全问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String,Integer&gt; concurrentHashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//检查key有没有</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">counter</span> <span class="operator">=</span> concurrentHashMap.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> counter == <span class="literal">null</span> ? <span class="number">1</span> : counter + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//没有则put</span></span><br><span class="line">concurrentHashMap.put(<span class="string">&quot;hello&quot;</span>,newValue);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, LongAdder&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//computeIfAbsent 如果缺少一个key,则计算生成一个value，然后将key value放入map</span></span><br><span class="line"><span class="comment">/*LongAdder value = map.computeIfAbsent(&quot;hello&quot;, new Function&lt;String, LongAdder&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public LongAdder apply(String s) &#123;</span></span><br><span class="line"><span class="comment">                return new LongAdder();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"><span class="type">LongAdder</span> <span class="variable">value</span> <span class="operator">=</span> map.computeIfAbsent(<span class="string">&quot;hello&quot;</span>, (key) -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>());</span><br><span class="line"><span class="comment">//执行累加</span></span><br><span class="line">value.increment();</span><br></pre></td></tr></table></figure>

<p><strong>ConcurrentHashMap原理</strong></p>
<p><strong>1.JDK 7并发死链</strong></p>
<p>Map是采用的 数组+链表来进行实现。</p>
<p>JDK7在发生下标冲突的时候，在链表中进行插入是采用头插法。而在JDK8中采用的是尾插法</p>
<ul>
<li>在自动扩容的时候会出现并发死链。扩容因子就是里面的元素超过map中数组的比例是多少的时候就开始扩容，默认是3&#x2F;4.</li>
</ul>
<p><strong>测试代码</strong></p>
<p>注意：</p>
<ul>
<li>要在JDK 7下运行，否则扩容机制和hash的计算方法都变了</li>
<li>代码不要随便改动</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk 7中的HashMap源码</span></span><br><span class="line"><span class="comment">//newTable是rehash之后的数组链表。table是之前的数组链表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapcity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span>(rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span>:hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash,newCapcity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#####################################</span><br><span class="line">假设有两个线程来进行put元素，此时发生扩容进入到transfer函数</span><br><span class="line">table中的元素是这样的</span><br><span class="line"><span class="number">1</span>——》<span class="number">35</span>——》<span class="number">16</span>——》<span class="literal">null</span></span><br><span class="line"><span class="number">2</span>——》<span class="literal">null</span></span><br><span class="line"><span class="number">3</span>——》<span class="literal">null</span></span><br><span class="line">...</span><br><span class="line">	首先是Thread <span class="number">0</span>遍历到table中的第一个元素节点<span class="number">1</span>。e就相当于是 <span class="number">1</span>——》<span class="number">35</span>——》<span class="number">16</span>——》<span class="literal">null</span>.然后进入到<span class="keyword">while</span>循环Entry&lt;K,V&gt; next = e.next;此时next就相当于是<span class="number">35</span>——》<span class="number">16</span>——》<span class="literal">null</span>。</span><br><span class="line">    然后此时另外一个线程线程<span class="number">1</span>也执行到transfer函数，并且它将整个扩容流程都执行结束。执行完后newTable和table的结果变为</span><br><span class="line"><span class="number">35</span>——》<span class="number">1</span>——》<span class="literal">null</span></span><br><span class="line"><span class="number">16</span>——》<span class="literal">null</span></span><br><span class="line">...</span><br><span class="line">    此时切换到线程<span class="number">0</span>来进行执行，此时局部变量e,next被恢复，引用没变但内容变了，e的内容变为了<span class="number">1</span>——》<span class="literal">null</span>,next的内容<span class="number">35</span>——》<span class="number">1</span>——》<span class="literal">null</span>.此时开始执行<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash,newCapcity);的代码以及后面的代码，执行完第一次循环后</span><br><span class="line">newTable[<span class="number">1</span>] = <span class="number">1</span>——》<span class="literal">null</span></span><br><span class="line">	进行赋值操作，e=next,所以 e = <span class="number">35</span>——》<span class="number">1</span>——》<span class="literal">null</span>,然后进行<span class="keyword">while</span>循环的判断<span class="keyword">while</span>(<span class="literal">null</span> != e) 为真所以进行第二次循环，此时Entry&lt;K,V&gt; next = e.next; 因此next = <span class="number">1</span>——》<span class="literal">null</span>,然后执行e.next = newTable[i];</span><br><span class="line">newTable[i] = e;这两条语句，第二次循环后，</span><br><span class="line">newTable[<span class="number">1</span>] = <span class="number">35</span>——》<span class="number">1</span>——》<span class="literal">null</span></span><br><span class="line">	进行赋值操作，e=next,所以 e = <span class="number">1</span>——》<span class="literal">null</span>,然后有进行<span class="keyword">while</span>循环判断后进入给next进行赋值，此时next=<span class="literal">null</span>，然后执行 e.next = newTable[i];newTable[i] = e;这两条语句之后，</span><br><span class="line">newTable[<span class="number">1</span>] = <span class="number">1</span>——》<span class="number">35</span>——》<span class="number">1</span>——》<span class="number">35</span>。。。此时就形成了死链，</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>究其原因，是因为在多线程环境下使用了非线程安全的map集合</li>
<li>JDK8虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其他问题（如扩容丢数据）</li>
</ul>
<p><strong>JDK8中的ConcurrentHashMap里面的重要属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整个ConcurrentHashMap就是一个Node[ ]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment"> * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment"> * bins数组。在第一次插入时延迟初始化。大小总是二的幂。由迭代器直接访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment"> * 下一个要使用的表；仅在调整大小时为非空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment"> * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment"> * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment"> * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment"> * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment"> * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment"> * 表初始化和调整大小控制。如果为负数，则表正在初始化或调整大小：-1 表示初始化，否则 -(1 + 活动调整大小线程   * 的数量)。否则，当 table 为 null 时，保存要在创建时使用的初始表大小，或者默认为 0。初始化后，保存下一个   * 元素计数值，根据该值调整表的大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容时如果某个bin迁移完毕，用ForwardingNode作为旧table bin的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为treebin的头结点，存储root和first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为treebin的节点，存储parent,left,right   链表阈值为8,当链表长度过长时，性能由O(1)退化为O(n),并且能避免DPOS攻击（洪泛攻击），某一个链表长度超过8后，优先进行扩容，让让整个table数组的长度扩容到64的时候就会将链表转化为红黑树。如果转换为红黑树后，随着删除，红黑树结点的个数小于6后，就又会将红黑树转换为链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重要方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Node[] 中第i个Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab,<span class="type">int</span> i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cas修改Node[]中第i个Node的值，c为旧值，v为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab,<span class="type">int</span> i,Node&lt;K,V&gt; c,Node&lt;K,V&gt; v)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//直接修改Node[]中第i个Node的值，v为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab,<span class="type">int</span> i,Node&lt;K,V&gt; v)</span></span><br></pre></td></tr></table></figure>

<p><strong>构造器分析</strong></p>
<p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了table的大小，以后在第一次使用时才会真正创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// tableSizeFor方法时保证计算的大小是2^n，即16，32，64，要不然哈希表无法正常工作</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get流程</strong>【全程没有加锁，这也是为什么并发度高的原因】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//spread方法能确保返回结果是正数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">//(n - 1) &amp; h 找出桶下标，这个比取模运算快</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果头结点已经是要查找的key</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hash为负数表示该bin在扩容中或者是treebin,这时调用find方法来查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">//正常遍历链表，用equals比较</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>put流程</strong></p>
<p>以下数组简称（table）,链表简称bin</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//其中spread方法会综合高位低位，具有更好的hash性</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f是链表头结点</span></span><br><span class="line">        <span class="comment">//fh是链表头结点的hash</span></span><br><span class="line">        <span class="comment">//i是链表在table中的下标</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//要创建table</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//初始化table使用了cas，无需synchronized创建成功，进入下一轮循环</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//要创建链表头结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//添加链表头结点时使用了cas，无需synchronized</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//帮忙扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮忙之后进入下一轮循环</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//锁住链表头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//再次确认链表头结点没有被移动</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//找到相同的key</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">//更新</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//已经是最后的节点了，新增Node,追加至链表尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//putTreeVal会看key是否已经在数中，是，则返回对应的TreeNode</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//释放链表头结点的锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//如果链表长度 》= 树化阈值（8），进行链表转为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加size计数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//尝试将sizeCtl设置为-1（表示初始化table）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//获得锁，创建table,这时其他线程会在while()循环中yield直至table创建</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check是之前binCount的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">//已经有了counterCells,向cell累加</span></span><br><span class="line">        (as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        <span class="comment">//还没有，向baseCount累加</span></span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">//创建累加单元数组和cell,累加重试</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK7中的ConcurrentHashMap</strong></p>
<p>它维护了一个segment数组，每个segment对应一把锁</p>
<ul>
<li>优点：如果多个线程访问不同的segment,实际是没有冲突的，这与jdk8中是类似的</li>
<li>缺点：Segments数组默认大小为16，这个容量初始化指定后就不能改变，并且不是懒惰初始化</li>
</ul>
<p>每个segment数组都对应一个hashEntry数组【一个小的hash表】，就实现了分段锁，每个HashEntry数组又是数组+链表的结构</p>
<ul>
<li>其中this.segmentShift和this.segmentMask的作用是决定将key的hash结果匹配到哪个segment</li>
</ul>
<h4 id="9-LinkedBlockingQueue"><a href="#9-LinkedBlockingQueue" class="headerlink" title="9.LinkedBlockingQueue"></a><strong>9.LinkedBlockingQueue</strong></h4><ul>
<li>高明之处在于用了两把锁和dummy节点<ul>
<li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li>
<li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul>
<li>消费者与消费者线程仍让串行</li>
<li>生产者与生产者线程仍然串行</li>
</ul>
</li>
<li>一把锁用于队头，一把锁用于队尾</li>
</ul>
</li>
<li>与ArrayBlockingQueue的性能比较<ul>
<li>Linked支持有界，Array强制有界</li>
<li>Linked实现是链表，Array实现是数组</li>
<li>Linked是懒惰的，而Array需要提前初始化Node数组</li>
<li>Linked每次入队会生成新Node，而Array的Node是提前创建好的</li>
<li>Linked两把锁，Array一把锁</li>
</ul>
</li>
</ul>
<h4 id="10-ConcurrentLinkedQueue"><a href="#10-ConcurrentLinkedQueue" class="headerlink" title="10.ConcurrentLinkedQueue"></a>10.ConcurrentLinkedQueue</h4><p>ConcurrentLinkedQueue的设计与LinkedBlockingQueue非常像，也是</p>
<ul>
<li>两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li>
<li>dummy节点的引入让两把锁将来锁住的是不同对象，避免竞争</li>
<li>只是这锁使用了cas来实现</li>
</ul>
<p>事实上，ConcurrentLinkedQueue应用很广泛，例如Tomcat的Connector结构</p>
<h4 id="11-CopyOnWriteArrayList"><a href="#11-CopyOnWriteArrayList" class="headerlink" title="11.CopyOnWriteArrayList"></a><strong>11.CopyOnWriteArrayList</strong></h4><p>CopyOnWriteArraySet是它的马甲</p>
<ul>
<li><p>底层实现采用了写入时拷贝的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其他线程的&#x3D;&#x3D;并发读，读写分离&#x3D;&#x3D;</p>
</li>
<li><pre><code class="java">public boolean add(E e) &#123;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try &#123;
        //获取旧数组
        Object[] elements = getArray();
        int len = elements.length;
        //拷贝新的数组（这里是比较耗时的操作，但不影响其他读线程）
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        //添加新元素
        newElements[len] = e;
        //替换旧的数据
        setArray(newElements);
        return true;
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
</code></pre>
</li>
<li><p>在jdk11中使用的是synchronized，jdk8中使用的是可重入锁</p>
</li>
<li><p>其他读操作并未加锁。适合读多写少的应用场景</p>
</li>
</ul>
<p><strong>迭代器弱一致性</strong></p>
<ul>
<li><p>数据库的MVCC都是弱一致性的表现-</p>
</li>
<li><p>并发高和一致性是矛盾的需要权衡好</p>
</li>
</ul>
<h3 id="8-3第三方工具"><a href="#8-3第三方工具" class="headerlink" title="8.3第三方工具"></a>8.3第三方工具</h3><p>1.guava限流</p>
<p>应用之web服务器</p>
<h2 id="9-异步编程"><a href="#9-异步编程" class="headerlink" title="9.异步编程"></a>9.异步编程</h2><blockquote>
<p>wait&#x2F;sleep区别</p>
<ul>
<li>1.来自不同的类<ul>
<li>wait —&gt; Object</li>
<li>sleep —&gt; Thread</li>
</ul>
</li>
<li>2.关于锁的释放<ul>
<li>&#x3D;&#x3D;wait会释放锁&#x3D;&#x3D;，sleep不会释放锁</li>
</ul>
</li>
<li>3.使用的范围是不同的<ul>
<li>wait必须在同步代码块中</li>
<li>sleep是在任意地方</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-4-Lock-锁"><a href="#2-4-Lock-锁" class="headerlink" title="2..4 Lock(锁)"></a>2..4 Lock(锁)</h3><blockquote>
<p>lock三部曲：</p>
<ul>
<li>new ReentrantLock( );   &#x2F;&#x2F;创建锁对象</li>
<li>lock.lock();                    &#x2F;&#x2F;加锁</li>
<li>finally{ lock.unlock()}  &#x2F;&#x2F;解锁</li>
</ul>
</blockquote>
<blockquote>
<p>Synchronized与Lock的区别：</p>
<ul>
<li>Synchronized是内置的Java 关键字，Lock是一个关键字</li>
<li>Synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁</li>
<li>synchronized 会自动释放锁，lock必须要释放锁，如果不释放锁，会死锁</li>
<li>Synchronize 可重入锁，不可以中断的，非公平的。Lock,可重入锁，可以判断锁，非公平。（可以自己投票）</li>
<li>synchronized适合锁少量的代码同步问题，lock适合锁大量的同步代码</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="clrv2tqxo000j4hku3dvi9445" data-title="并发编程学习" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/">技术工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 13.33px;">Go</a> <a href="/tags/Hexo/" style="font-size: 13.33px;">Hexo</a> <a href="/tags/JVM/" style="font-size: 13.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 13.33px;">个人</a> <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 13.33px;">云原生</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 13.33px;">并发</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 13.33px;">快捷键</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13.33px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 16.67px;">数据库</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/27/hello-world/">Hexo使用技巧</a>
          </li>
        
          <li>
            <a href="/2024/01/27/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Mac使用技巧</a>
          </li>
        
          <li>
            <a href="/2022/12/27/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Java语言学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/">Java虚拟机学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/">LeetCode刷题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Kevin he<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>