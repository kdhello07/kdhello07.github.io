<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Go语言学习 | 侬的杂货铺</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Go语言学习0.前言Go Land使用快捷键123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#文件相关快捷键：    代码格式化：    #CTRL+ALT+T，可以把代码包在一个块内，例如if&#123;…&#125;else&#123;…&#125;。    #CTRL">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言学习">
<meta property="og:url" content="https://kdhello07.github.io/2022/05/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="侬的杂货铺">
<meta property="og:description" content="Go语言学习0.前言Go Land使用快捷键123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#文件相关快捷键：    代码格式化：    #CTRL+ALT+T，可以把代码包在一个块内，例如if&#123;…&#125;else&#123;…&#125;。    #CTRL">
<meta property="og:locale">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211011151546260.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211012095126995.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211012112204780.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211012132200454.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211021175813731.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211021175829967.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211022143543015.png">
<meta property="article:published_time" content="2022-05-26T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-26T19:50:04.403Z">
<meta property="article:author" content="Kevin he">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211011151546260.png">
  
    <link rel="alternate" href="/atom.xml" title="侬的杂货铺" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">侬的杂货铺</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术、阅读、分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kdhello07.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Go语言学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-05-26T16:00:00.000Z" itemprop="datePublished">2022-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Go语言学习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Go语言学习"><a href="#Go语言学习" class="headerlink" title="Go语言学习"></a>Go语言学习</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><h3 id="Go-Land使用快捷键"><a href="#Go-Land使用快捷键" class="headerlink" title="Go Land使用快捷键"></a>Go Land使用快捷键</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件相关快捷键：</span></span><br><span class="line">    代码格式化：</span><br><span class="line">    #CTRL+ALT+T，可以把代码包在一个块内，例如if&#123;…&#125;else&#123;…&#125;。</span><br><span class="line">    #CTRL+ALT+L，格式化代码。</span><br><span class="line">    CTRL+空格，代码提示。</span><br><span class="line">    CTRL+/，单行注释。CTRL+SHIFT+/，进行多行注释。</span><br><span class="line">    CTRL+B，快速打开光标处的结构体或方法（跳转到定义处）。</span><br><span class="line">    CTRL+“+/-”，可以将当前方法进行展开或折叠。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查找和定位：</span></span><br><span class="line">    CTRL+R，替换文本。</span><br><span class="line">    CTRL+F，查找文本。</span><br><span class="line">    CTRL+SHIFT+F，进行全局查找。</span><br><span class="line">    CTRL+G，快速定位到某行。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码编辑：</span></span><br><span class="line">    #CTRL+O，实现接口的所有方法</span><br><span class="line">    ALT+Q，可以看到当前方法的声明。</span><br><span class="line">    #SHIFT+ENTER，可以向下插入新行，即使光标在当前行的中间。</span><br><span class="line">    #CTRL+X，删除当前光标所在行。</span><br><span class="line">    #CTRL+D，复制当前光标所在行。</span><br><span class="line">    #ALT+SHIFT+UP/DOWN，可以将光标所在行的代码上下移动。</span><br><span class="line">    CTRL+SHIFT+U，可以将选中内容进行大小写转化。</span><br><span class="line">    CTRL+Backspace，按单词进行删除。</span><br><span class="line">    SHIFT+ENTER，可以向下插入新行，即使光标在当前行的中间。</span><br><span class="line">    ALT+UP可以实现方法的跳转</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其它快捷键：</span></span><br><span class="line">    ctrl + n 导航到类名</span><br><span class="line">    ctrl + shift + n 导航到文件</span><br><span class="line">    ctrl + e/ctrl + shift + e 打开到最近的文件/打开最近修改的文件</span><br><span class="line">    ctrl + shift + i 简短地查看源定义</span><br><span class="line">    ctrl + alt + m 重构表达式为函数 光标在表达式的末尾</span><br><span class="line">    ctrl + space 快速返回实现 return 字段后使用</span><br><span class="line">    ctrl+ shift+ a 工具调用 如 go tools，restful 等</span><br><span class="line">    ctrl + shift + space 智能类型推断式返回 return 字段后使用</span><br><span class="line">    ctrl + i 实现某接口</span><br><span class="line">    ctrl + p 查看 method 参数信息</span><br><span class="line">    ctrl + shift + p 查看表达式类型</span><br><span class="line">    ctrl + alt + v 自动生成表达式返回值</span><br><span class="line">    alt + j 相同单词多选 类似 sublime Ctrl + D</span><br><span class="line">    ctrl+alt+enter 在上一行重启一行</span><br><span class="line">    ctrl + i 实现某接口（在 type struct 上使用）</span><br><span class="line">    ctrl + p 查看方法参数信息（在方法括号中使用）</span><br><span class="line">    ctrl + shift + p 查看表达式类型（在表达式上或者表达式末尾使用）</span><br><span class="line">    alt + enter 会出现一些 intention的操作（比如在第三方包名上使用，可以添加 import 包别名）</span><br><span class="line">    ctrl + alt + v 生成表达式返回值（表达式末尾使用。先不要写 “resp, err :=”，按下快捷键后会自动生成。）</span><br><span class="line">    Alt + J 类似 sublime 上的 Ctrl + D 多选 （此外还有 Shift + Ctrl + Alt + J， Alt + Shift + Mouse Click，可以实现多选 ）</span><br></pre></td></tr></table></figure>



<h2 id="第一章：Go语言的环境安装与快速入门"><a href="#第一章：Go语言的环境安装与快速入门" class="headerlink" title="第一章：Go语言的环境安装与快速入门"></a>第一章：Go语言的环境安装与快速入门</h2><h3 id="1-安装SDK-软件开发工具包"><a href="#1-安装SDK-软件开发工具包" class="headerlink" title="1.安装SDK(软件开发工具包)"></a>1.安装SDK(软件开发工具包)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">包下载地址</span></span><br><span class="line">https://golang.org/doc/install</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压安装在 D:\program\Go 目录</span></span><br></pre></td></tr></table></figure>

<h3 id="2-windows环境下配置go环境变量（在任意路径下执行go程序）"><a href="#2-windows环境下配置go环境变量（在任意路径下执行go程序）" class="headerlink" title="2.windows环境下配置go环境变量（在任意路径下执行go程序）"></a>2.windows环境下配置go环境变量（在任意路径下执行go程序）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2.配置全局Path	   添加SDK的/bin目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.配置GOROOT  	指定SDK的安装路径D:\program\Go</p>
<p>2.配置全局Path	   添加SDK的&#x2F;bin目录</p>
<p>3.配置GOPATH		 工作目录，将来我们go项目的工作路径(就是以后go项目存放的路径，即工作目录)</p>
<h3 id="3-GO语言快速开发入门"><a href="#3-GO语言快速开发入门" class="headerlink" title="3.GO语言快速开发入门"></a>3.GO语言快速开发入门</h3><p>​	1.项目开发时的目录环境</p>
<p>2.go程序开发（在GoLand中开发），将go代码写到hello.go文件中来</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211011151546260.png" alt="image-20211011151546260"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意事项</span></span><br><span class="line"><span class="keyword">package</span> main 	<span class="comment">//表示该hello.go文件所在的包是main,在go中，每个文件必须归属于一个包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> 	<span class="comment">//表示引入一个包，包名 fmt,引入该包后，就可以使用fmt包的函数,比如fmt.Println()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func是一个关键字，表示一个函数</span></span><br><span class="line"><span class="comment">//main是函数名，是一个主函数，即我们程序的入口</span></span><br></pre></td></tr></table></figure>

<p>3.使用go build命令对该go文件(hello.go)进行编译，生成可执行文件(hello.exe文件)</p>
<p>4.也可以通过go run直接对hello.go文件编译运行（但不推荐，类似一个脚本文件的执行）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">两种执行流程的区别与注意事项</span></span><br><span class="line">1.hello.exe可执行文件能在没有go开发环境上运行</span><br><span class="line">2.hello.go源代码的运行需要go开发环境</span><br><span class="line">3.在编译生成可执行文件时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以可执行文件变大了很多</span><br></pre></td></tr></table></figure>

<p>5.可以指定生成的二进制文件名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定源码hello.go生成的可执行文件名为myhello.exe</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;go build -o myhello.exe hello.go</span><br><span class="line"></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;dir</span><br><span class="line"> 驱动器 D 中的卷是 软件</span><br><span class="line"> 卷的序列号是 32FB-4470</span><br><span class="line"></span><br><span class="line"> D:\program\goPath\src\go_code\project01\main 的目录</span><br><span class="line"></span><br><span class="line">2021/10/11  15:38    &lt;DIR&gt;          .</span><br><span class="line">2021/10/11  15:38    &lt;DIR&gt;          ..</span><br><span class="line">2021/10/11  15:24         2,094,592 hello.exe</span><br><span class="line">2021/10/11  15:15               151 hello.go</span><br><span class="line">2021/10/11  15:38         2,094,592 myhello.exe</span><br><span class="line">               3 个文件      4,189,335 字节</span><br><span class="line">               2 个目录 175,641,739,264 可用字节</span><br></pre></td></tr></table></figure>

<h3 id="4-go语言开发的注意事项"><a href="#4-go语言开发的注意事项" class="headerlink" title="4.go语言开发的注意事项"></a>4.go语言开发的注意事项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Go源文件以’go‘为扩展名</span><br><span class="line">2.Go应用程序的执行入口是main函数</span><br><span class="line">3.严格区分大小写</span><br><span class="line">4.Go方法由一条语句构成，每个语句后不需要加分号（会默认加分号）</span><br><span class="line">5.Go编辑器是一行行进行编译的，因此我们一行就写一行语句，如果写多行就加分号</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6.go语言定义的变量或者import的包如果没有使用到，代码不能编译通过</span></span><br><span class="line">7.大括号成对出现，缺一不可</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当要引入多个包时使用这样的方式</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="5-转义字符与java一样"><a href="#5-转义字符与java一样" class="headerlink" title="5.转义字符与java一样"></a>5.转义字符与java一样</h3><h3 id="6-go语言编程规范"><a href="#6-go语言编程规范" class="headerlink" title="6.go语言编程规范"></a>6.go语言编程规范</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.gofmt hello.go		是将hello.go源码格式化后控制台输出，而源文件本身不会有变化</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;gofmt hello.go</span><br><span class="line">//要求开发一个hello.go程序，可以输出hello,world</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">//导入一个包</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        //在go语言里面默认加分号，如果要写多行需要在一行语句后写分号</span><br><span class="line">        fmt.Println(&quot;hello,world&quot;)</span><br><span class="line">        fmt.Println(&quot;hello,world&quot;)</span><br><span class="line">        var na = 12</span><br><span class="line">        fmt.Println(na)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.gofmt -w hello.go		是将hello.go文件本身格式化 就是源文件本身会被格式化，有点类似于java格式化的快捷键的功能。</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;gofmt -w hello.go</span><br></pre></td></tr></table></figure>

<h3 id="7-go语言文档"><a href="#7-go语言文档" class="headerlink" title="7.go语言文档"></a>7.go语言文档</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">golang中文网	https://studygolang.com/pkgdoc</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">golang官方文档	https://golang.org/</span></span><br></pre></td></tr></table></figure>

<h2 id="第二章：Go语言数据类型、运算符、键盘输入语句、三种码，三种结构"><a href="#第二章：Go语言数据类型、运算符、键盘输入语句、三种码，三种结构" class="headerlink" title="第二章：Go语言数据类型、运算符、键盘输入语句、三种码，三种结构"></a>第二章：Go语言数据类型、运算符、键盘输入语句、三种码，三种结构</h2><h3 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a>1.整数类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.分为有符号和无符号之分  int和uint,大小和系统有关</span><br><span class="line">2.整数类型默认声明为int型</span><br><span class="line">3.如何在程序中查看某个变量的字节大小和数据类型（使用较多）</span><br><span class="line">4.整型变量在使用时，遵守保小不保大的原则，即在保证程序正常运行时，尽量使用空间小的数据类型。【如，年龄】</span><br><span class="line">5.bit:计算机中最小的存储单位；byte:计算机中的最小存储单元</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.整数类型默认声明为int型</span></span><br><span class="line"><span class="keyword">var</span> n1=<span class="number">100</span></span><br><span class="line"><span class="comment">//fmt.Printf() 可以用于格式化输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;na的类型 %T&quot;</span>,n1)  <span class="comment">//这里返回的是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.如何在程序中查看某个变量的字节大小和数据类型（使用较多）</span></span><br><span class="line"><span class="comment">//如何在程序中查看某个变量导的占用字节大小和数据类型（使用较多）</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int64</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">//unsafe.Sizeof(n1)  是unsafe包的一个函数，可以返回n1变量占用的字节数  答案返回的是8个字节</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n2 的类型 %T  n2的占用字节数是 %d&quot;</span>,n2,unsafe.Sizeof(n2))</span><br></pre></td></tr></table></figure>

<h3 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//float32单精度，float64是双精度</span></span><br><span class="line"><span class="keyword">var</span> salary <span class="type">float32</span>=<span class="number">1.2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;salary:&quot;</span>,salary)</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型初始化</span></span><br><span class="line">num6 := <span class="number">5.12</span></span><br><span class="line">num7 := <span class="number">.123</span>  <span class="comment">//小数中前面的0可以省略</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num6：&quot;</span>,num6)</span><br><span class="line">fmt.Println(<span class="string">&quot;num7：&quot;</span>,num7)</span><br><span class="line"></span><br><span class="line">num8 := <span class="number">5.123e2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num8：&quot;</span>,num8)</span><br><span class="line">num9 := <span class="number">5.123E2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num9：&quot;</span>,num9)</span><br><span class="line">num10 := <span class="number">5.123e-2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num10：&quot;</span>,num10)</span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">num6： <span class="number">5.12</span></span><br><span class="line">num7： <span class="number">0.123</span></span><br><span class="line">num8： <span class="number">512.34</span></span><br><span class="line">num9： <span class="number">512.34</span></span><br><span class="line">num10： <span class="number">0.051234</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.go的浮点型有固定的范围和字段长度，不受操作系统影响</span><br><span class="line">2.go的浮点型默认是float64类型</span><br><span class="line">3.通常情况下使用float64类型定义，这个比float32精确</span><br><span class="line">4.浮点型数据表示形式：</span><br><span class="line">	num6 := 5.12 	 十进制数形式	</span><br><span class="line">	num8 := 5.123e2  科学计数法形式</span><br></pre></td></tr></table></figure>

<h3 id="3-字符类型"><a href="#3-字符类型" class="headerlink" title="3.字符类型"></a>3.字符类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字符类型使用字节</span></span><br><span class="line">1.go语言中没有专门的字符类型，如果要存储单个字符（字母），一般用byte来保存</span><br><span class="line">2.官方将字符串类型归到基本数据类型中来</span><br><span class="line">3.字符串就是一串字符组成的。go的字符串是由单个字节连接起来的。而go的字符串不同，它是由字节组成的</span><br><span class="line">4.go语言中的字符使用Unicode编码，再也没有编程乱码的困扰了</span><br><span class="line">5.go中的字符可以作为整数进行运算</span><br><span class="line">6.当我们直接输出byte类型的字符时，使出的是字符对应的码值</span><br><span class="line">7.如果需要原样输出字符时，需要格式化输出（Printf）。反过来也是可以的（即根据码值求字符）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本使用</span></span><br><span class="line"><span class="keyword">var</span> c1 <span class="type">byte</span>=<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">byte</span>=<span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment">//当我们直接输出byte的字符时，使出的是字符对应的码值</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br><span class="line"><span class="comment">//如果需要原样输出字符时，需要格式化输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;c1的值 %c\n&quot;</span>,c1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;c2的值 %c&quot;</span>,c2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们保存的字符在ASCII表中，可以直接保存在byte中，当超出时，可以保存在int中，同时还可以进行格式化输出</span></span><br><span class="line"><span class="keyword">var</span> c3 <span class="type">int</span> =<span class="string">&#x27;北&#x27;</span></span><br><span class="line">fmt.Println(c3)</span><br><span class="line"><span class="comment">//可以用字符进行整数运算，因为他对应有Unicode码</span></span><br><span class="line">fmt.Println(c3+<span class="number">10</span>) </span><br><span class="line">fmt.Printf(<span class="string">&quot;c3的值 %c %d&quot;</span>,c3,c3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">49</span></span><br><span class="line">c1的值 a</span><br><span class="line">c2的值 <span class="number">1</span></span><br><span class="line"><span class="number">21271</span></span><br><span class="line"><span class="number">21281</span></span><br><span class="line">c3的值 北 <span class="number">21271</span></span><br></pre></td></tr></table></figure>

<h3 id="4-bool类型"><a href="#4-bool类型" class="headerlink" title="4.bool类型"></a>4.bool类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.bool类型只占用一个字节</span><br><span class="line">2.适合用于逻辑运算</span><br><span class="line">3.bool类型只能取true或者false,不可以用0或者非0来替用</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意flag等同于true的常量</span></span><br><span class="line"><span class="keyword">var</span> ff=<span class="literal">true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;bool的占用空间&quot;</span>,unsafe.sizeof(ff))</span><br><span class="line">fmt.Println(flag)</span><br><span class="line">fmt.Println(ff)</span><br></pre></td></tr></table></figure>

<h3 id="5-字符串类型"><a href="#5-字符串类型" class="headerlink" title="5.字符串类型"></a>5.字符串类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.go的字符串不同，它是由字节组成的</span><br><span class="line">2.字符串一旦赋值，字符串中的字符就不可修改了（通过字符数组进行修改），但是可以将字符串当作字符数组来进行输出</span><br><span class="line">3.字符串表示形式</span><br><span class="line">	1.双引号，会识别转义字符</span><br><span class="line">	2.反引号，以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击，输出源代码等效果。</span><br><span class="line">4.拼接字符串时，如果操作太长要换行写时，需要将连接符+放在上面</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例演示</span></span><br><span class="line"><span class="keyword">var</span> address <span class="type">string</span>=<span class="string">&quot;北&quot;</span></span><br><span class="line">fmt.Println(address)</span><br><span class="line">fmt.Printf(<span class="string">&quot;address 的占用空间 %d&quot;</span>,unsafe.Sizeof(address))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">&quot;abc\nabc&quot;</span></span><br><span class="line"><span class="comment">//声明加赋值</span></span><br><span class="line">str3:=<span class="string">&quot;bc\nbc&quot;</span></span><br><span class="line">fmt.Println(str2)</span><br><span class="line">fmt.Println(str2[<span class="number">1</span>])  <span class="comment">//输出内容为98，可以直接将字符串用作字符数组用，但是不能修改</span></span><br><span class="line">fmt.Println(str3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反引号的使用演示</span></span><br><span class="line">str4:=<span class="string">`var address string=&quot;北&quot;</span></span><br><span class="line"><span class="string">			fmt.Println(address)</span></span><br><span class="line"><span class="string">			fmt.Printf(&quot;address 的占用空间 %d\n&quot;,unsafe.Sizeof(address))</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string">			var str2=&quot;abc\nabc&quot;</span></span><br><span class="line"><span class="string">			//声明加赋值</span></span><br><span class="line"><span class="string">			str3:=&quot;bc\nbc&quot;</span></span><br><span class="line"><span class="string">			fmt.Println(str2)</span></span><br><span class="line"><span class="string">			fmt.Println(str3)`</span></span><br><span class="line"></span><br><span class="line">fmt.Println(str4)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当拼接有多行时，+要放在上面</span></span><br><span class="line">str5 := <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>+</span><br><span class="line">		<span class="string">&quot;hello&quot;</span></span><br><span class="line">str5+=<span class="string">&quot;你好&quot;</span></span><br><span class="line">fmt.Println(str5)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">北</span><br><span class="line">address 的占用空间 <span class="number">16</span></span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="number">98</span></span><br></pre></td></tr></table></figure>

<h3 id="6-基本数据类型默认值"><a href="#6-基本数据类型默认值" class="headerlink" title="6.基本数据类型默认值"></a>6.基本数据类型默认值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.在go中，数据类型都有一个默认值，默认值又叫零值。  注意float64的默认值或者说零值也是0</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本演示</span></span><br><span class="line"><span class="keyword">var</span> aa <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> bb <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> cc <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> dd <span class="type">string</span></span><br><span class="line">fmt.Println(<span class="string">&quot;aa的默认值：&quot;</span>,aa)</span><br><span class="line">fmt.Println(<span class="string">&quot;bb的默认值：&quot;</span>,bb)</span><br><span class="line">fmt.Println(<span class="string">&quot;cc的默认值：&quot;</span>,cc)</span><br><span class="line">fmt.Println(<span class="string">&quot;dd的默认值：&quot;</span>,dd)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">aa的默认值： <span class="number">0</span></span><br><span class="line">bb的默认值： <span class="number">0</span></span><br><span class="line">cc的默认值： <span class="literal">false</span></span><br><span class="line">dd的默认值： </span><br></pre></td></tr></table></figure>

<h3 id="7-基本数据类型的相互转换"><a href="#7-基本数据类型的相互转换" class="headerlink" title="7.基本数据类型的相互转换"></a>7.基本数据类型的相互转换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意字节</span></span><br><span class="line">1.这与java不同，go在不同数据类型之间的转换需要显示转换，不能自动转换。</span><br><span class="line">2.数据类型可以从 表示范围小-&gt;表示范围大 ，也可以表示范围大-&gt;表示范围小</span><br><span class="line">3.被转换的是变量存储的数据（即值），变量本身的数据类型并没有变化</span><br><span class="line">4.在将大数转换到表示范围小的数据时，如果超出，编译不会出错，会按照溢出处理，和我们希望的结果不一样</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">表达式T(v) 将v转换成T类型   这与java的类型转换有点不一样，java是  int a=10; long b=(long)a;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本演示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int32</span>=<span class="number">12</span></span><br><span class="line"><span class="comment">//希望将i =》 float64类型</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span>= <span class="type">float64</span>(i)</span><br><span class="line">f=<span class="number">12.3</span></span><br><span class="line"><span class="comment">//希望将f =》 int8 类型</span></span><br><span class="line"><span class="keyword">var</span> i2 <span class="type">int8</span>=<span class="type">int8</span>(f)</span><br><span class="line"><span class="comment">//希望将i =》 int64</span></span><br><span class="line"><span class="keyword">var</span> i3 <span class="type">int64</span>=<span class="type">int64</span>(i)  <span class="comment">//低精度转换到高精度也需要进行显示转换</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">fmt.Println(f)</span><br><span class="line">fmt.Println(i2)</span><br><span class="line">fmt.Println(i3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12.3</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211012095126995.png" alt="image-20211012095126995"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这个转换细节</span></span><br><span class="line"><span class="keyword">var</span> nn1 <span class="type">int32</span>=<span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> ii1 <span class="type">int8</span>=<span class="number">12</span>+<span class="number">128</span>          <span class="comment">//编译可以通过，但是运行会出错，溢出</span></span><br><span class="line"><span class="keyword">var</span> ii2 <span class="type">int8</span>=<span class="type">int8</span>(nn1)+<span class="number">127</span>	<span class="comment">//编译可以通过，运行成功，但是结果会溢出，与实际运算结果不一致</span></span><br><span class="line"><span class="keyword">var</span> ii3 <span class="type">int8</span> =<span class="type">int8</span>(nn1)+<span class="number">128</span>  <span class="comment">//编译不通过,不能将已知的数据常量（超出了要转换的数据类型）转换到要转换到的类型</span></span><br><span class="line">fmt.Println(ii2)</span><br><span class="line">fmt.Println(ii1)</span><br></pre></td></tr></table></figure>

<h3 id="8-基本数据类型与string的相互转换"><a href="#8-基本数据类型与string的相互转换" class="headerlink" title="8.基本数据类型与string的相互转换"></a>8.基本数据类型与string的相互转换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本数据类型转string</span></span><br><span class="line">1.方式1：fmt.Sprintf(&quot;%参数&quot;,表达式)  ，会返回字符串【推荐使用这个】</span><br><span class="line">    func Sprintf</span><br><span class="line">    func Sprintf(format string, a ...interface&#123;&#125;) string</span><br><span class="line">    Sprintf根据format参数生成格式化的字符串并返回该字符串。</span><br><span class="line">2.方式2：使用strconv包的函数</span><br><span class="line">	func Itoa(i int) string</span><br><span class="line">	func FormatInt(i int64, base int) string</span><br><span class="line">	func FormatBool(b bool) string</span><br><span class="line">	func FormatFloat(f float64, fmt byte, prec, bitSize int) string</span><br><span class="line">	func FormatUint(i uint64, base int) string</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">string类型转基本数据类型</span></span><br><span class="line">1.方式：使用strconv包中的函数</span><br><span class="line">	func ParseBool(str string) (value bool, err error)</span><br><span class="line">	func ParseInt(s string, base int, bitSize int) (i int64, err error)</span><br><span class="line">	func ParseUint(s string, base int, bitSize int) (n uint64, err error)</span><br><span class="line">	func ParseFloat(s string, bitSize int) (f float64, err error)</span><br><span class="line">2.注意事项：在将一个不是有效数据的字符串转换成基本数据类型时，go会直接将其转换为基本数据类型的默认值，即0或者false</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型转string，第一种方法演示</span></span><br><span class="line"><span class="keyword">var</span> num1 <span class="type">int</span>=<span class="number">99</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">float64</span>=<span class="number">12.234</span></span><br><span class="line"><span class="keyword">var</span> bool1 <span class="type">bool</span>=<span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> mychar <span class="type">byte</span>=<span class="string">&#x27;h&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span> <span class="comment">//空的str</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用第一种方式转换 fmt.Sprintf()方法</span></span><br><span class="line">str=fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,num1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">str=fmt.Sprintf(<span class="string">&quot;%f&quot;</span>,num2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">str=fmt.Sprintf(<span class="string">&quot;%t&quot;</span>,bool1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">str=fmt.Sprintf(<span class="string">&quot;%c&quot;</span>,mychar)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="number">99</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="number">12.234000</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="literal">true</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=h</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型转string,第二种方法演示</span></span><br><span class="line"><span class="keyword">var</span> num1 <span class="type">int</span>=<span class="number">99</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">float64</span>=<span class="number">12.234</span></span><br><span class="line"><span class="keyword">var</span> bool1 <span class="type">bool</span>=<span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> mychar <span class="type">byte</span>=<span class="string">&#x27;h&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span> <span class="comment">//空的str</span></span><br><span class="line"></span><br><span class="line">str=strconv.FormatInt(<span class="type">int64</span>(num1),<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//strconv.FormatFloat(num2,&#x27;f&#x27;,10,64)</span></span><br><span class="line"><span class="comment">//说明：’f‘指格式，10：表示小数点后的位数，64：表示这个小数是float64</span></span><br><span class="line">str=strconv.FormatFloat(num2,<span class="string">&#x27;f&#x27;</span>,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">str=strconv.FormatBool(bool1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="number">99</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="number">12.2340000000</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string类型转基本数据类型，实例演示</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span>=<span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="keyword">var</span> bool2 <span class="type">bool</span></span><br><span class="line"><span class="comment">//func ParseBool(str string) (value bool, err error)</span></span><br><span class="line"><span class="comment">//bool2, _ =strconv.ParseBool(str1)</span></span><br><span class="line"><span class="comment">//说明：</span></span><br><span class="line"><span class="comment">//1.函数返回两个值，(value bool, err error)</span></span><br><span class="line"><span class="comment">//2.因为我只关心第一个值value bool，所以用下划线忽略第二个值err error</span></span><br><span class="line">bool2, _ =strconv.ParseBool(str1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;bool2的类型%T,bool2=%v\n&quot;</span>,bool2,bool2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 <span class="type">string</span>=<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">var</span> num4 <span class="type">int64</span></span><br><span class="line">num4,_=strconv.ParseInt(str2,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;bool2的类型%T,bool2=%v\n&quot;</span>,num4,num4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str3 <span class="type">string</span>=<span class="string">&quot;123.456&quot;</span></span><br><span class="line"><span class="keyword">var</span> num5 <span class="type">float64</span></span><br><span class="line">num5,_=strconv.ParseFloat(str3,<span class="number">64</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;bool2的类型%T,bool2=%v\n&quot;</span>,num5,num5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">bool2的类型<span class="type">bool</span>,bool2=<span class="literal">true</span></span><br><span class="line">bool2的类型<span class="type">int64</span>,bool2=<span class="number">123</span></span><br><span class="line">bool2的类型<span class="type">float64</span>,bool2=<span class="number">123.456</span></span><br></pre></td></tr></table></figure>

<h3 id="9-指针"><a href="#9-指针" class="headerlink" title="9.指针"></a>9.指针</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.基本数据类型，变量存的是值，也叫值类型</span><br><span class="line">2.获取变量的地址，用&amp;，比如var num int,获取num的地址：&amp;num</span><br><span class="line">3.指针类型：指针变量存的是一个地址，这个地址指向的空间寸的才是值，比如var ptr *int=&amp;num</span><br><span class="line">4.获取指针类型所指向的值，使用：*，比如：var ptr *int,使用*ptr获取ptr指向的值</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意事项</span></span><br><span class="line">1.值类型都有对应的指针类型，形式为*数据类型，如*int,依次类推。</span><br><span class="line">2.值类型包括：基本数据类型int系列，，float系列，bool，string，数组和结构体struct（基本数据类型+数组+结构体）</span><br><span class="line">3.引用类型：指针，slice切片，map,管道chan,interface等都是引用类型</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>&#x3D;&#x3D;值类型和引用类型的区别&#x3D;&#x3D;<ol>
<li>值类型，变量直接存储值，内存通常在栈中分配</li>
<li>引用类型，变量存储的是一个地址，这个地址对应的空间才真正的存储数据值，内存通常在堆中分配空间，当没有变量引用这个地址时，该改地址对应的数据空间就成为一个垃圾，由GC来回收。</li>
</ol>
</li>
</ul>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211012112204780.png" alt="image-20211012112204780"></p>
<h3 id="10-标识符"><a href="#10-标识符" class="headerlink" title="10.标识符"></a>10.标识符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本概念</span></span><br><span class="line">1.go中对各种变量、方法、函数等命名时使用的字符序列</span><br><span class="line">2.凡是可以自己取名字的都叫标识符</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">标识符的命名规则</span></span><br><span class="line">1.由26个英文字母大小写，0-9，_组成</span><br><span class="line">2.数字不可以开头</span><br><span class="line">3.严格区分大小写</span><br><span class="line">4.标识符不能包含空格</span><br><span class="line">5.不能用系统关键字（一共有25个），如break,if等</span><br><span class="line">6.下划线 _ 在go中是一个特殊的标识符，成为空标识符，可以代表任何其他的标识符，但是他它对应的值会被忽略（比如：忽略某个返回值），所以仅能作为占位符来使用，不能作为标识符来使用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">标识符命名的注意事项</span></span><br><span class="line">1.包名：保持package的名字和目录保持一致，尽量采取有意义的包名，简短有意义，不要和标准库冲突。(如标准库fmt)</span><br><span class="line">2.变量名，函数名，常量名：采用驼峰法</span><br><span class="line">3.如果变量名、函数名、常量名首字母大写，则可以被其他包访问，如果首字母小写，则只能在本包中使用（首字母大写是公有的 ，首字母小写是私有的，首字母大写类似于java中的public，可以在全局访问，在不同包中可以访问）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意根据标识符的大小写来决定一个成员是公有还是私有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.go文件中的内容</span></span><br><span class="line"><span class="comment">//我们使用utils.go的heroName  包名.标识符</span></span><br><span class="line">fmt.Println(model.HeroName)</span><br><span class="line"><span class="comment">//fmt.Println(model.heroName)//不可以访问utils.go中的私有成员，私有体现在标识符的开头首字母是否大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//utils.go文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"><span class="comment">//定义了一个变量</span></span><br><span class="line"><span class="keyword">var</span> HeroName <span class="type">string</span>=<span class="string">&quot;宋江&quot;</span></span><br><span class="line"><span class="keyword">var</span> heroName <span class="type">string</span>=<span class="string">&quot;songjiang&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>引入包的方式</strong></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211012132200454.png" alt="image-20211012132200454"></p>
<h3 id="11-运算符"><a href="#11-运算符" class="headerlink" title="11.运算符"></a>11.运算符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运算符介绍</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">算术运算符注意细节</span></span><br><span class="line">1.go语言中的++，--运算符只能独立使用。如var i int=3; var j int=i++ 会编译出错。</span><br><span class="line">2.go语言中的++，--只能放在变量后面， 即i++可以，++i就不可以</span><br></pre></td></tr></table></figure>

<h3 id="12-键盘输入语句"><a href="#12-键盘输入语句" class="headerlink" title="12.键盘输入语句"></a>12.键盘输入语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取用户键盘输入的数据，你就可以使用键盘输入语句来获取，InputDemo.go</span></span><br><span class="line"> </span><br><span class="line">1.步骤:</span><br><span class="line">	1.导入fmt包</span><br><span class="line">	2.调用fmt包的fmt.Scanln()或者fmt.Scanf()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例演示</span></span><br><span class="line"><span class="comment">//要求：可以从控制台接收用户信息，【姓名，年龄，薪水，是否通过考试】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1：fmt.Scanln</span></span><br><span class="line"><span class="comment">//1.先声明需要的变量</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> salary <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> test <span class="type">bool</span></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入姓名&quot;</span>)</span><br><span class="line"><span class="comment">//当程序执行到fmt.Scanln(&amp;name),程序会停在这里，等待用户输入，并回车</span></span><br><span class="line">fmt.Scanln(&amp;name)</span><br><span class="line">fmt.Println(<span class="string">&quot;请输入年龄&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;age)</span><br><span class="line">fmt.Println(<span class="string">&quot;请输入薪水&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;salary)</span><br><span class="line">fmt.Println(<span class="string">&quot;请输入是否考试&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;test)</span><br><span class="line">fmt.Println(name)</span><br><span class="line">fmt.Println(age)</span><br><span class="line">fmt.Println(salary)</span><br><span class="line">fmt.Println(test)</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">请输入姓名</span><br><span class="line">哈哈</span><br><span class="line">请输入年龄</span><br><span class="line"><span class="number">12</span></span><br><span class="line">请输入薪水</span><br><span class="line"><span class="number">123.45</span></span><br><span class="line">请输入是否考试</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">哈哈</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">123.45</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：fmt.Scanf</span></span><br><span class="line"><span class="comment">//1.先声明需要的变量</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> salary <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> test <span class="type">bool</span></span><br><span class="line">fmt.Println(<span class="string">&quot;请输出姓名，年龄，薪水，是否通过考试，用空格隔开&quot;</span>)</span><br><span class="line"><span class="comment">//注意这里面要输入多个时，用空格分割</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%s %d %f %t&quot;</span>,&amp;name,&amp;age,&amp;salary,&amp;test)</span><br><span class="line"></span><br><span class="line">fmt.Println(name)</span><br><span class="line">fmt.Println(age)</span><br><span class="line">fmt.Println(salary)</span><br><span class="line">fmt.Println(test)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">请输出姓名，年龄，薪水，是否通过考试，用空格隔开</span><br><span class="line">哈哈 <span class="number">12</span> <span class="number">123.45</span> <span class="literal">false</span></span><br><span class="line">哈哈</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">123.45</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="13-原码，反码，补码"><a href="#13-原码，反码，补码" class="headerlink" title="13.原码，反码，补码"></a>13.原码，反码，补码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意字节</span></span><br><span class="line">1.对于有符号数而言，二进制的最高位是符号位，正数为0，负数为1</span><br><span class="line">2.正数的原码，反码，补码都一样</span><br><span class="line">3.负数的反码=它的原码符号位不变，其他位取反</span><br><span class="line">4.负数的补码=它的反码+1</span><br><span class="line">5.0的反码，补码都是0</span><br><span class="line">6.在计算机运算的时候，都是以补码的方式来运算的</span><br></pre></td></tr></table></figure>

<h3 id="14-控制流程"><a href="#14-控制流程" class="headerlink" title="14.控制流程"></a>14.控制流程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">主要有3大流程控制语句</span></span><br><span class="line">1.顺序控制</span><br><span class="line">	程序从上至下顺序执行，中间没有任何判断和跳转</span><br><span class="line">2.分支控制 if-else  switch-case</span><br><span class="line">	让程序有选择执行</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="keyword">if</span>语句基本语法  注意事项：这里面的&#123;&#125;必须写，并且<span class="keyword">else</span>不能换行</span></span><br><span class="line">		双分支</span><br><span class="line">		if 条件表达式 &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		多分支</span><br><span class="line">		if 条件表达式 &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;else if 条件表达式&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">switch基本语法</span>  </span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">注意事项：</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">1.每一个<span class="keyword">case</span>分支都是唯一的，从上到下逐一测试，直到匹配为止。</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">2.<span class="keyword">case</span>里面可以写多个表达式(即常量，变量，一个有返回值的函数都可以)，如果是常量或者字面量，不能有重复。</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">3.匹配项后面也不需要加<span class="built_in">break</span>,因为go中他是匹配执行完后，直接默认<span class="built_in">break</span>了。</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">4.不论default放置的位置是在匹配项之前还是之后，都默认先进行匹配，匹配不上之后才执行default里面的语句</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">5.default语句不是必须的</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">6.switch后也可以不带表达式，类似if-else分支来使用</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">7.switch后也可以直接声明/定义一个变量，分号结束，不推荐，如switch age:=32; &#123;...&#125;</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">8.switch穿透 fallthrough,如果在<span class="keyword">case</span>语句块后增加fallthrough,则会在该<span class="keyword">case</span>执行完后继续执行后面的<span class="keyword">case</span>语句</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">9.Type Switch:switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型</span></span><br><span class="line">		switch 表达式&#123;</span><br><span class="line">			case 表达式1,表达式2：</span><br><span class="line">				语句</span><br><span class="line">			case 表达式3：</span><br><span class="line">				语句</span><br><span class="line">			default：</span><br><span class="line">				语句</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		switch当作if-else使用语法</span><br><span class="line">		var age int=32</span><br><span class="line">		switch &#123;  #switch后也可以直接声明/定义一个变量，分号结束，不推荐，如switch age:=32; &#123;...&#125;</span><br><span class="line">			case age==30:</span><br><span class="line">				语句1</span><br><span class="line">			case age&lt;=10:</span><br><span class="line">				语句2</span><br><span class="line">			case age&gt;=40</span><br><span class="line">				语句3</span><br><span class="line">			default:</span><br><span class="line">				语句4</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">3.循环控制 for  while</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="keyword">for</span>循环基本语法</span></span><br><span class="line">        for 循环变量初始化;循环条件；循环变量迭代&#123;</span><br><span class="line">            循环操作（语句）</span><br><span class="line">        &#125;</span><br><span class="line">    #for循环注意事项</span><br><span class="line">    	1.for循环的第二种使用方式</span><br><span class="line">    		for 循环判断条件&#123;</span><br><span class="line">    			//循环执行语句</span><br><span class="line">    		&#125;</span><br><span class="line">    		这里面是将变量初始化和变量迭代放在其他位置</span><br><span class="line">    	2.for循环的第三种使用方式</span><br><span class="line">    		for &#123;</span><br><span class="line">    			//循环执行语句</span><br><span class="line">    		&#125;</span><br><span class="line">    		上面的写法等同于 for ; ;&#123;&#125;是一个无限循环，通常需要借助break语句使用</span><br><span class="line">    	3.go语言也提供for-range的方式，可以方便遍历字符串和数组，同java中的for-each方式</span><br><span class="line">  			基本语法见下面的演示</span><br><span class="line">  			for index, val := range str &#123;</span><br><span class="line">                fmt.Printf(&quot;索引%d的值是%c&quot;,index,val)</span><br><span class="line">                fmt.Println()</span><br><span class="line">            &#125;</span><br><span class="line">            如果不需要使用index时，可以用_忽略  for _, val := range str</span><br><span class="line">       	4.如果我们的字符串含有中文，那么传统的遍历字符串方式，就是错误的，会出现乱码，原因是传统的对字符串的			 遍历是按照字节来遍历，而一个汉字在utf8编码中是对应3个字节。</span><br><span class="line">       		解决的方式是：需要将str转成[]rune 切片</span><br><span class="line">       		str:=&quot;你好生活&quot;</span><br><span class="line">            str2 := []rune(str)</span><br><span class="line">            for i:=0;i&lt;len(str2);i++&#123;</span><br><span class="line">                fmt.Printf(&quot;%c&quot;,str2[i])</span><br><span class="line">                fmt.Println()</span><br><span class="line">            &#125;</span><br><span class="line">       		</span><br><span class="line">       		上面的问题也可以直接使用for-range方式，就不用处理可以正确输出。</span><br><span class="line">       		str:=&quot;你好生活&quot;</span><br><span class="line">       		for _, val := range str &#123;</span><br><span class="line">                fmt.Printf(&quot;值是%c&quot;,val)</span><br><span class="line">                fmt.Println()</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">go语言中没有<span class="keyword">while</span>循环，但是可以使用<span class="keyword">for</span>循环来实现<span class="keyword">while</span>和do...while</span></span><br><span class="line">		1.while循环实现</span><br><span class="line">			循环变量初始化</span><br><span class="line">			for&#123;</span><br><span class="line">				if 循环条件表达式&#123;</span><br><span class="line">					break;  //跳出for循环</span><br><span class="line">				&#125;</span><br><span class="line">				循环操作语句</span><br><span class="line">				循环变量迭代</span><br><span class="line">			&#125;</span><br><span class="line">		2.do-while实现</span><br><span class="line">			循环变量初始化</span><br><span class="line">			for&#123;</span><br><span class="line">				循环操作语句</span><br><span class="line">				循环变量迭代</span><br><span class="line">				if 循环条件表达式&#123;</span><br><span class="line">					break; //跳出for循环</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">4.跳转控制语句 break，continue，goto，return</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">需求：随机生成1-100的一个数，直到生成了99这个数，看看你一共用了几次？</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">分析：编写一个无限循环的控制，然后不停的随机生成数，当生成了99时，就退出这个无线循环</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">提示使用：</span></span><br><span class="line">		//time.Now().Unix():返回一个从1979 1-1 0：0：0到现在的一个秒数</span><br><span class="line">		rand.Seed(time.Now().Unix())</span><br><span class="line">		fmt.Println(&quot;n=&quot;,rand.Intn(100)+1)</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">注意事项：</span></span><br><span class="line">		1.break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块，默认终止的是最近一个</span><br><span class="line">			基本语法</span><br><span class="line">				标签名1:for ... &#123;</span><br><span class="line">					标签名2:for ...&#123;</span><br><span class="line">						if ...&#123;</span><br><span class="line">						 	break 标签名1</span><br><span class="line">						&#125;</span><br><span class="line">						if ...&#123;</span><br><span class="line">							break 标签名2</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			演示</span><br><span class="line">				hello:for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">                    hai:for j := 0; j &lt; 10; j++ &#123;</span><br><span class="line">                        fmt.Println(j)</span><br><span class="line">                        if j==5 &amp;&amp; i==2&#123;</span><br><span class="line">                            break hello</span><br><span class="line">                        &#125;</span><br><span class="line">                        if j==3 &amp;&amp; i==1&#123;</span><br><span class="line">                            break hai</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">      	</span><br><span class="line">      	2.continue语句出现在多层嵌套时，可以通过标签指明要跳过的是哪一层语句块中的此次语句，默认跳过最近一			次循环</span><br><span class="line">      	</span><br><span class="line">      	3.goto语句可以无条件的转移到程序中指定的行</span><br><span class="line">      	4.goto语句通常与条件语句配合使用，可用来实现条件转移，跳出循环体等功能</span><br><span class="line">      	5.在go程序设计中一般不主张使用goto语句，以免造成混乱</span><br><span class="line">      		基本语法：</span><br><span class="line">      			goto label</span><br><span class="line">      			...</span><br><span class="line">      			label:statement</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if结构演示</span></span><br><span class="line"><span class="comment">//输出a,b中的最大值</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出a,b中的最大值</span></span><br><span class="line"><span class="comment">//golang在if中，支持定义一个变量,效果和上面等同</span></span><br><span class="line"><span class="keyword">if</span> a,b :=<span class="number">1</span>,<span class="number">2</span>;a&gt;b &#123;   <span class="comment">//但是不能这样if var a,b int=1,2;a&gt;b &#123;  </span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//switch结构演示</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span>=<span class="number">124</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span>=<span class="number">124</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="comment">//default的位置可以写在任意位置</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;我是终章&quot;</span>)</span><br><span class="line">    <span class="comment">//case表达式后可以接多个表达式，用逗号隔开，case语句块执行完后面不用加break，默认直接跳出</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">120</span>,<span class="number">124</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;我是case1&quot;</span>)</span><br><span class="line">    	<span class="keyword">fallthrough</span>  <span class="comment">//默认只能穿透一层，即在执行的时候不用判断后面那个表达式是否匹配直接执行里面的语句</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">121</span>,<span class="number">125</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;我是case2&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">122</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;我是case3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台语句</span></span><br><span class="line">我是case1</span><br><span class="line">我是case2</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环基本演示</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span> ; i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">5</span>&#123;</span><br><span class="line">    	<span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str:=<span class="string">&quot;12345&quot;</span></span><br><span class="line"><span class="comment">//遍历str字符串</span></span><br><span class="line"><span class="comment">//for循环演示</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(str);i++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c&quot;</span>,str[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for-range方式演示</span></span><br><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> str &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;索引%d的值是%c&quot;</span>,index,val)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">索引<span class="number">0</span>的值是<span class="number">1</span></span><br><span class="line">索引<span class="number">1</span>的值是<span class="number">2</span></span><br><span class="line">索引<span class="number">2</span>的值是<span class="number">3</span></span><br><span class="line">索引<span class="number">3</span>的值是<span class="number">4</span></span><br><span class="line">索引<span class="number">4</span>的值是<span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//break演示</span></span><br><span class="line">count :=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">    <span class="comment">//提供随机化种子</span></span><br><span class="line">    <span class="comment">//time.Now().Unix()，返回一个从1970 1-1 0：0：0到现在的一个纳秒数</span></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="comment">//rand.Intn(100)，生成一个[0,n)的值</span></span><br><span class="line">    n:=rand.Intn(<span class="number">100</span>)+<span class="number">1</span></span><br><span class="line">    count++</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">99</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(count)</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="comment">//break在多层嵌套中，使用标签的演示</span></span><br><span class="line">hello:<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    hai:<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">        fmt.Println(j)</span><br><span class="line">        <span class="keyword">if</span> j==<span class="number">3</span> &amp;&amp; i==<span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">break</span> hello</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j==<span class="number">2</span> &amp;&amp; i==<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">break</span> hai</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="15-常量"><a href="#15-常量" class="headerlink" title="15.常量"></a>15.常量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">1.常量使用const修饰的</span><br><span class="line">2.常量在定义的时候必须初始化</span><br><span class="line">3.常量不能修改</span><br><span class="line">4.常量只能修饰bool,数值类型（int,float系列），string类型</span><br><span class="line">5.语法：const 常量名 类型=value  //类型可写可不写</span><br><span class="line">	举例：</span><br><span class="line">		const name string=&quot;tom&quot;</span><br><span class="line">		const a int=12</span><br><span class="line">		const b=9/3</span><br><span class="line">		const c=getVal()  //这时会报错的</span><br><span class="line">6.常量在程序中声明定义初始化了，没有使用也不报错</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意事项：</span></span><br><span class="line">1.比较简介的写法：</span><br><span class="line">	const (</span><br><span class="line">		a =1</span><br><span class="line">		b =2</span><br><span class="line">	)</span><br><span class="line">2.还有一种专业的写法</span><br><span class="line">	const (</span><br><span class="line">		a=iota  //当将iota赋给一个常量时，此时这个值就等于从0开始属于第几行的数，如a,b,f,j</span><br><span class="line">		b=iota</span><br><span class="line">		c=1</span><br><span class="line">		d  	//当没有值赋给常量时，就根据它最上面的一个数是iota还是常量值，如果是常量值，它就也等于常量值</span><br><span class="line">		e</span><br><span class="line">		f=iota  </span><br><span class="line">		g	  //如果上面是iota，则就依次递增1</span><br><span class="line">		h=1</span><br><span class="line">		i</span><br><span class="line">		j=iota</span><br><span class="line">	)</span><br><span class="line">	fmt.Println(&quot;a=&quot;,a)   //a=0</span><br><span class="line">	fmt.Println(&quot;b=&quot;,b)   //b=1</span><br><span class="line">	fmt.Println(&quot;c=&quot;,c)	  //c=1	</span><br><span class="line">	fmt.Println(&quot;d=&quot;,d)   //d=1</span><br><span class="line">	fmt.Println(&quot;e=&quot;,e)   //e=1</span><br><span class="line">	fmt.Println(&quot;f=&quot;,f)   //f=5</span><br><span class="line">	fmt.Println(&quot;g=&quot;,g)   //g=6</span><br><span class="line">	fmt.Println(&quot;h=&quot;,h)   //h=1</span><br><span class="line">	fmt.Println(&quot;i=&quot;,i)   //i=1</span><br><span class="line">	fmt.Println(&quot;j=&quot;,j)   //j=9</span><br><span class="line">3.golang中没有要常量名必须大写的规范</span><br><span class="line">4.仍然通过首字母的大小写来控制常量的访问范围</span><br></pre></td></tr></table></figure>



<h2 id="第三章：函数"><a href="#第三章：函数" class="headerlink" title="第三章：函数"></a>第三章：函数</h2><h3 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.函数分为自定义函数，系统函数（API中的那些函数）</span><br><span class="line">2.基本语法</span><br><span class="line">	func 函数名 (形参列表) (返回值类型列表) &#123;</span><br><span class="line">		执行语句</span><br><span class="line">		return 返回值列表</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的使用演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//函数的快速入门问题</span></span><br><span class="line">	a:=<span class="number">1.2</span></span><br><span class="line">	b:=<span class="number">2.3</span></span><br><span class="line">	<span class="keyword">var</span> operate <span class="type">byte</span>=<span class="string">&#x27;+&#x27;</span></span><br><span class="line">	res:=cal(a,b,operate)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的计算函数cal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a <span class="type">float64</span>,b <span class="type">float64</span>,operate <span class="type">byte</span>)</span></span> <span class="type">float64</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> res <span class="type">float64</span></span><br><span class="line">	<span class="keyword">switch</span> operate &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">		res=a+b</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">		res=a-b</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">		res=a*b</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">		res=a/b</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;操作符输入失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-包的引出和使用原理"><a href="#2-包的引出和使用原理" class="headerlink" title="2.包的引出和使用原理"></a>2.包的引出和使用原理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">    1.包的本质实际上就是创建不同的文件夹，来存放程序文件</span><br><span class="line">    2.go的每一个文件都是属于一个包的,也就是说go是以包的形式来管理文件和项目目录结构的</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">包的三大作用</span></span><br><span class="line">    1.区分相同名字的函数、变量等标识符</span><br><span class="line">    2.当程序文件很多时，可以很好的管理项目</span><br><span class="line">    3.控制函数，变量等访问范围，即作用域</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">包的相关说明</span></span><br><span class="line">    打包基本语法</span><br><span class="line">        package util</span><br><span class="line">    引入包的基本语法</span><br><span class="line">        import &quot;包的路径&quot;   //import &quot;go_code/project01/utils&quot;  是从src的下一层目录开始写</span><br><span class="line">    使用包的函数语法</span><br><span class="line">        包名.函数名( )  //注意包中的函数名要大写才能被调用，否则就不能被调用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">包的使用细节和注意事项</span></span><br><span class="line">	1.在给一个文件打包时，该包对应的一个文件夹，比如utils文件夹对应的包名就是utils,文件的包名通常和文件所在		的文件夹名保持一致。</span><br><span class="line">	2.package指令要放在文件第一行，然后是import指令</span><br><span class="line">	3.在import包时，路径从$GOPATH的src下开始，不用带src,编译器自动从src下开始引入</span><br><span class="line">	4.可以给包取别名，此时就必须用别名进行使用。原来的包名就不能使用了</span><br><span class="line">		如import &quot;go_code/project01/utils&quot; 这里使用utils来进行访问，如utils.Cal</span><br><span class="line">        别名方式：</span><br><span class="line">        	import util &quot;go_code/project01/utils&quot;  此时就是用别名进行访问 如util.Cal</span><br><span class="line">       	特殊的别名有下划线_，此时表示忽略这个包名 </span><br><span class="line">  	5.在同一包下，不能有相同的函数名，否则报重复定义</span><br><span class="line">  	6.如果你要编译一个可执行程序文件，就需要把这个包声明为main,即package main,这个就是一个语法规范，如果	  你写一个库，包名可以自定义（程序文件只有main包中，才能够进行一个编译和运行）</span><br><span class="line">  		编译的指令，在项目目录下，编译路径不需要带src,编译器会自动带</span><br><span class="line">  			如 go build go_code/project01/main</span><br><span class="line">  		编译后生成一个有默认名的可执行文件，在$GOPATH目录下，可以指定名字和目录</span><br><span class="line">  			如放在bin目录下 go build -o bin/my.exe go_code/project01/main</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="3-函数调用机制"><a href="#3-函数调用机制" class="headerlink" title="3.函数调用机制"></a>3.函数调用机制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.<span class="built_in">return</span>语句</span></span><br><span class="line">基本语法：</span><br><span class="line">	go函数支持返回多个值，这一点是其他编程语言没有的</span><br><span class="line">	fun 函数名 （形参列表） （返回值类型列表）&#123;</span><br><span class="line">		语句...</span><br><span class="line">		return 返回值列表</span><br><span class="line">	&#125;</span><br><span class="line">	1.如果返回多个值时，在接收时，希望忽略某个值时，则使用_符号表示占位忽略</span><br><span class="line">	2.如果返回值只有一个，（返回值类型列表列表），可以不用（）</span><br></pre></td></tr></table></figure>

<h3 id="4-函数注意事项和细节讨论"><a href="#4-函数注意事项和细节讨论" class="headerlink" title="4.函数注意事项和细节讨论"></a>4.函数注意事项和细节讨论</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.函数改变函数外的变量</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">		change(&amp;n)</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(n *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		*n=*n+<span class="number">13</span></span><br><span class="line">        fmt.Println(*n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.go语言不支持函数重载，会报函数重复定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*3.在go中，函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了，通过该变量可以对函数调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.函数既然是一种数据类型，因此在go中，函数可以作为形参，并且调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.为了简化数据类型定义，go支持数据类型自定义</span></span><br><span class="line">	基本语法：<span class="keyword">type</span> 自定义数据类型名 数据类型  <span class="comment">//相当于一个别名,注意这一般需要放到main函数的外面</span></span><br><span class="line">	例如：</span><br><span class="line">		<span class="keyword">type</span> myint <span class="type">int</span>  <span class="comment">//这时myint就等价int来使用了  但是注意在将myint类型的值赋给int类型的变量时，						//依然需要显示转换</span></span><br><span class="line">		<span class="keyword">type</span> mySum <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span>  <span class="comment">//这时mySum就等价一个函数类型func(int,int) int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.支持对函数返回值命名，此时必须将返回值用括号括起来，即便是一个也需要括号</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> (sum <span class="type">int</span>,sub <span class="type">int</span>)&#123;</span><br><span class="line">        sum =n1+n2   <span class="comment">//注意这里面的sum和sub在返回值中已经定义了，所以不需要使用 := 进行定义调用</span></span><br><span class="line">        sub =n1-n2</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.使用_标识符，忽略返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8.go支持可变参数</span></span><br><span class="line">	<span class="comment">//支持0到多个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args... <span class="type">int</span>)</span></span> sum <span class="type">int</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//支持1到多个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>,args... <span class="type">int</span>)</span></span> sum <span class="type">int</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//注意</span></span><br><span class="line">		<span class="number">1.</span>args是slice(切片)，通过args[index] 可以访问到各个值</span><br><span class="line">		<span class="number">2.</span>案例演示，编写一个sum，可以求出<span class="number">1</span>到多个<span class="type">int</span>的和</span><br><span class="line">		<span class="number">3.</span>如果一个函数的形参列表中有可变参数，则可变参数需要放在形参列表最后</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.函数的形参还可以这样输入,例如下面的例子，a和b就都是int类型的</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示 3,4,5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数也可以是一种数据类型，同时还可以作为值传递给变量</span></span><br><span class="line">	a:=fib</span><br><span class="line">	fmt.Printf(<span class="string">&quot;a的类型是%T,fib的类型是%T\n&quot;</span>,a,fib)</span><br><span class="line"></span><br><span class="line">	res:=a(<span class="number">5</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line"></span><br><span class="line">	myFunc(a,<span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int32</span>)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n==<span class="number">1</span>||n==<span class="number">2</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数也可以作为形参进行传递，并调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(funVar <span class="keyword">func</span>(<span class="type">int32</span>)</span></span> <span class="type">int32</span>,n <span class="type">int32</span>)  &#123;</span><br><span class="line">		res:=funVar(n)</span><br><span class="line">		fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">a的类型是<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int32</span>)</span></span> <span class="type">int32</span>,fib的类型是<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int32</span>)</span></span> <span class="type">int32</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//演示8，支持可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	res:=sumTest(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例演示，编写一个函数，求解1到多个int的和</span></span><br><span class="line"><span class="comment">//arr是一个切片类型，类似于数组的使用，len(arr)求切片的长度，arr[i]求第i+1个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumTest</span><span class="params">(n1 <span class="type">int</span>,arr... <span class="type">int</span>)</span></span> (count <span class="type">int</span>)&#123;  </span><br><span class="line">	count=n1</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		count+=val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-init函数使用"><a href="#5-init函数使用" class="headerlink" title="5.init函数使用"></a>5.init函数使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍：</span></span><br><span class="line">	每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被go运行框架调用，也就是说init函数会在main函数前被调用</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意事项和使用细节</span></span><br><span class="line">1.如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程是变量定义-&gt;init函数-&gt;main函数</span><br><span class="line">2.最主要作用完成初始化工作</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> age =test()   <span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">	<span class="keyword">return</span> <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init函数使用演示，在main函数执行前被调用</span></span><br><span class="line"><span class="comment">//作用：通常在init函数中完成初始化工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;init&quot;</span>) <span class="comment">//2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;main&quot;</span>) <span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">test</span><br><span class="line">init</span><br><span class="line">main</span><br></pre></td></tr></table></figure>

<h3 id="6-匿名函数"><a href="#6-匿名函数" class="headerlink" title="6.匿名函数"></a>6.匿名函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">go支持匿名函数，如果我们某个函数只希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匿名函数使用方式：</span></span><br><span class="line">	1.在定义匿名函数时直接使用，这种方式匿名函数只能使用一次</span><br><span class="line">	2.将匿名函数赋值给一个变量（函数变量），再通过变量来使用匿名函数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局匿名函数</span></span><br><span class="line">	1.如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示匿名函数的使用方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">//fun1就是一个全局匿名函数</span></span><br><span class="line">	fun1= <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1*n2</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//调用全局匿名函数</span></span><br><span class="line">	fmt.Println(fun1(<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在定义匿名函数直接调用,这种方式匿名函数只能使用一次，更多的时候是使用这一种</span></span><br><span class="line">	res:= <span class="function"><span class="keyword">func</span><span class="params">(n1,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1+n2</span><br><span class="line">	&#125;(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">//直接赋值</span></span><br><span class="line">	fmt.Println(res)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将匿名函数传给一个变量（函数变量），则res2的数据类型就是函数类型，此时我们可以通过res2完成调用</span></span><br><span class="line">	<span class="comment">//可以执行多次</span></span><br><span class="line">	res2:= <span class="function"><span class="keyword">func</span><span class="params">(n1,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1+n2</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(res2(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">	fmt.Println(res2(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.闭包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">闭包就是一个函数与其相关的引用环境组合的一个整体（实体）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		n=n+x</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	f:=AddUpper()</span><br><span class="line">	fmt.Println(f(<span class="number">1</span>))  <span class="comment">//11</span></span><br><span class="line">	fmt.Println(f(<span class="number">2</span>))  <span class="comment">//13</span></span><br><span class="line">	fmt.Println(f(<span class="number">3</span>))  <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对上面代码的说明</span></span><br><span class="line"><span class="number">1.</span>AddUppper是一个函数，返回的数据类型是fun(<span class="type">int</span>) <span class="type">int</span></span><br><span class="line"><span class="number">2.</span>闭包的说明：返回的是一个匿名函数，但这个匿名函数引用到函数外的n,因此这个匿名函数就和n形成一个整体，就叫闭包</span><br><span class="line"><span class="number">3.</span>可以这样理解，闭包是类，函数是操作，n是字段</span><br><span class="line"><span class="number">4.</span>当我们反复的调用f函数时，因为n时初始化一次，因此每调用一次就进行累加</span><br><span class="line"><span class="number">5.</span>闭包的关键，就是要分析出返回的函数它使用（引用）到哪些变量，因为函数和它引用到的变量共同构成闭包</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包代码练习</span></span><br><span class="line"><span class="comment">//闭包使用练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffix</span><span class="params">(suffix <span class="type">string</span>)</span></span>  <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">		<span class="comment">//strings.HasSuffix(str,suffix) bool 该函数判断字符串str的后缀是否是suffix</span></span><br><span class="line">		<span class="keyword">if</span> strings.HasSuffix(str,suffix)&#123;</span><br><span class="line">			<span class="keyword">return</span> str</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> str+suffix</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffix2</span><span class="params">(str <span class="type">string</span>,suffix <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> strings.HasSuffix(str,suffix)&#123;</span><br><span class="line">		<span class="keyword">return</span> str</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> str+suffix</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mySuffix:=makeSuffix(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">	fmt.Println(mySuffix(<span class="string">&quot;aaa&quot;</span>))</span><br><span class="line">	fmt.Println(mySuffix(<span class="string">&quot;bbb.jpg&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">aaa.jpg</span><br><span class="line">bbb.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码说明</span></span><br><span class="line"><span class="number">1.</span>返回的函数和makeSuffix(suffix <span class="type">string</span>)的suffix变量组合成为一个闭包，因为返回的函数引用到了suffix这个变量</span><br><span class="line"><span class="number">2.</span>体会一下闭包的好处，如果使用传统的方法也能实现这个功能，但是传统的方法需要每次都传入后缀名，比如.jpg.而闭包因为可以保留上次引用的某个值，所以我们传入一次就可以反复使用。</span><br></pre></td></tr></table></figure>

<h3 id="8-函数中的defer"><a href="#8-函数中的defer" class="headerlink" title="8.函数中的defer"></a>8.函数中的defer</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍 为什么需要defer</span></span><br><span class="line">在函数中，程序员经常需要创建资源（比如数据库连接，文件句柄，锁等），为了在函数执行完毕后，及时的释放资源，go语言的设计者提供defer机制（延时机制）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">defer注意事项和使用细节</span></span><br><span class="line">1.当go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入到一个栈中，然后继续执行函数下一条语句</span><br><span class="line">2.当函数执行完毕后，再执行defer栈中的语句，按照先入后出的顺序</span><br><span class="line">3.**在defer将语句放入到栈时，也会将相关的值拷贝同时入栈</span><br><span class="line">4.当函数执行完毕后，可以及时的释放函数创建的资源，有点类似于finally里面释放资源（如数据库连接，字节流）</span><br><span class="line">	func test()&#123;</span><br><span class="line">		connect =openDatabase() </span><br><span class="line">		defer connect.close()  //可以让程序员不用关心何时关闭资源而烦心，在derfer之后可以继续创建资源</span><br><span class="line">	&#125;</span><br><span class="line">5.不要在defer语句后面执行赋值或者初始化等操作。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	res:=sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">	<span class="comment">//当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈（defer栈）</span></span><br><span class="line">	<span class="comment">//当函数执行完毕后，再从defer栈中，按照先入后出的方式出栈，执行</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n1的值：&quot;</span>,n1)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n2的值:&quot;</span>,n2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//演示注意细节第三点，即便后面修改了n1为20，但是defer栈中的n1依然为当时进栈时存入的那个值10，因此后面defer中输出的还是10</span></span><br><span class="line">    n1=<span class="number">20</span></span><br><span class="line">	</span><br><span class="line">    res:=n1+n2</span><br><span class="line">	fmt.Println(<span class="string">&quot;res的值：&quot;</span>,res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">res的值： <span class="number">30</span></span><br><span class="line">n2的值: <span class="number">20</span></span><br><span class="line">n1的值： <span class="number">10</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="9-变量作用域"><a href="#9-变量作用域" class="headerlink" title="9.变量作用域"></a>9.变量作用域</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本规则</span></span><br><span class="line">1.函数内部声明/定义的变量叫局部变量，作用域仅在函数内部</span><br><span class="line">2.函数外部声明/定义的变量叫全局变量，作用域在整个包有效，如果其首字母为大写，则在整个程序有效</span><br><span class="line">3.如果变量是在一个代码块中，比如if/for中，那么这个变量的作用域就在该代码块中</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意</span></span><br><span class="line">var name string=&quot;hello&quot;</span><br><span class="line">//nameErr:=&quot;error&quot;  //等价于 var nameErr string; nameErr=&quot;error ,此处会报错，</span><br><span class="line">				 //因为nameErr=&quot;err&quot;是执行语句，不能在函数外执行</span><br><span class="line">func main()&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		n1:=100</span><br><span class="line">		fmt.Println(n1)</span><br><span class="line">	&#125;</span><br><span class="line">	n1:=10</span><br><span class="line">	n2:=20</span><br><span class="line">	res:=sum(&amp;n1,&amp;n2)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-字符串中常用的系统函数"><a href="#10-字符串中常用的系统函数" class="headerlink" title="10.字符串中常用的系统函数"></a>10.字符串中常用的系统函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字符串中常用系统函数  strings包 strconv包</span></span><br><span class="line">1.统计字符串的长度，按字节 len(str) //这是内置的函数 </span><br><span class="line">2.字符串遍历，同时处理有中文的问题， arr:=[]rune(str)</span><br><span class="line">3.字符串转整数 n,err=strconv.Atoi(&quot;12&quot;)</span><br><span class="line">4.整数转字符串 str=strconv.Itoa(12345)</span><br><span class="line">5.字符串转byte[] var bytes=[]byte(&quot;hello go&quot;)</span><br><span class="line">6.byte[]转字符串 str=string([]byte&#123;97,98,99&#125;)</span><br><span class="line">7.10进制转2，8，16进制： str=strconv.FormatInt(123,2)  //2指转换为2进制</span><br><span class="line">8.查找子串是否在指定的字符串中：strings.Contains(&quot;seafood&quot;,&quot;foo&quot;)  //结果为true</span><br><span class="line">9.统计一个字符串中有几个指定的字串：strings.Count(&quot;seafoodfootjjFoou&quot;,&quot;foo&quot;) //3</span><br><span class="line">10.不区分大小写的字符串比较（==是区分大小写的）：fmt.Println(strings.EqualFold(&quot;abc&quot;,&quot;Abc&quot;))//true</span><br><span class="line">11.返回子串在字符串中第一次出现的index值，如果没有返回-1，strings.Index(&quot;NLP_abc&quot;,&quot;abc&quot;)  //4</span><br><span class="line">12.返回子串在字符串最后一次出现的index,如没有就返回-1，strings.LastIndex(&quot;go golang&quot;,&quot;go&quot;)</span><br><span class="line">13.将指定的字符串替换成另外一个子串：strings.Replace(&quot;go go hello&quot;,&quot;go&quot;,&quot;go语言&quot;,n) n可以指定你希望替换几个，如果n=-1表示全部替换</span><br><span class="line">14.按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组，strings.Split(&quot;hello,world,ok&quot;,&quot;,&quot;) </span><br><span class="line">15.将字符串的字母进行大小写的转换：strings.ToLower(&quot;Go&quot;) //strings.ToUpeer(&quot;Go&quot;)</span><br><span class="line">16.将字符串左右两边的空格去掉，strings.TrimSpace(&quot; tn a lo her ntm   &quot;) //tn a lo her ntm</span><br><span class="line">17.将字符串左右两边指定的字符去掉，strings,Trim(&quot;!!!!Hell!!!ooo!!!&quot;,&quot;!&quot;) //hell!!!ooo</span><br><span class="line">18.将字符串左边的指定字符去掉，strings.TrimLeft(&quot;!hello!!&quot;,&quot;!&quot;)  //hello!!</span><br><span class="line">19.将字符串右边的指定字符去掉，strings.TrimRight(&quot;!hello!!&quot;,&quot;!&quot;) //！hello</span><br><span class="line">20.判断字符串是否以指定的字符串开头：strings.HasPrefix(&quot;ftp://192.168.10.1&quot;,&quot;ftp&quot;) //true</span><br><span class="line">21.判断字符串是否以指定的字符串结束：strings.HasSuffix(&quot;NLP_abc.jpg&quot;,&quot;.jpg&quot;) //true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//字符串中常用系统函数</span></span><br><span class="line">	<span class="comment">//1.统计字符串的长度，按字节 len(str) //这是内置的函数 在builtin包中</span></span><br><span class="line">	str:=<span class="string">&quot;hello&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;str的长度为&quot;</span>,<span class="built_in">len</span>(str))</span><br><span class="line">	<span class="comment">//golang的编码统一为utf-8 （ascii的字符（字母和数字）占一个字节，汉字占用3个字节）</span></span><br><span class="line">	str1:=<span class="string">&quot;hello中&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;str1长度为：&quot;</span>,<span class="built_in">len</span>(str1))</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.字符串遍历，同时处理有中文的问题， arr:=[]rune(str)</span></span><br><span class="line">	str2:=<span class="string">&quot;hello北京&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str2); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;字符%c\n&quot;</span>,str2[i])  <span class="comment">//此时中文部分会乱码</span></span><br><span class="line">	&#125;</span><br><span class="line">	str3:=[]<span class="type">rune</span>(str2)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str3); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;字符%c\n&quot;</span>,str3[i])  <span class="comment">//此时中文乱码就得到了解决</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//3.字符串转整数 n,err=strconv.Atoi(&quot;12&quot;)</span></span><br><span class="line">	n,err:=strconv.Atoi(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;  <span class="comment">//转换成功，则err接收到的就是nil</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;转换错误&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;转换而成的结果是：&quot;</span>,n)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//4.整数转字符串 str=strconv.Itoa(12345)</span></span><br><span class="line">	str4:=strconv.Itoa(<span class="number">12345</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str的类型是%T,str的值是%v\n&quot;</span>,str4,str4)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//5.字符串转byte[] var bytes=[]byte(&quot;hello go&quot;)</span></span><br><span class="line">	<span class="keyword">var</span> bytes=[]<span class="type">byte</span>(<span class="string">&quot;hello go&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;bytes=%v\n&quot;</span>,bytes)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(bytes); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;字符%c&quot;</span>,bytes[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//6.byte[]转字符串 str=string([]byte&#123;97,98,99&#125;)</span></span><br><span class="line">	str6:=<span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str6类型%T,str6值是%v\n&quot;</span>,str6,str6)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//7.10进制转2，8，16进制： str=strconv.FormatInt(123,2)  //2指转换为2进制</span></span><br><span class="line">	str7:=strconv.FormatInt(<span class="number">123</span>,<span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str7类型%T,123对应的二进制是%v\n&quot;</span>,str7,str7)</span><br><span class="line">	str8:=strconv.FormatInt(<span class="number">123</span>,<span class="number">8</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str8类型%T,123对应的八进制是%v\n&quot;</span>,str8,str8)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//8.查找子串是否存在指定的字符串中：strings.Contains(&quot;seafood&quot;,&quot;foo&quot;)  //结果为true</span></span><br><span class="line">	b:=strings.Contains(<span class="string">&quot;seafood&quot;</span>,<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//9.统计一个字符串中有几个指定的字串：strings.Count(&quot;seafoodfootjjfoou&quot;,&quot;foo&quot;) //3</span></span><br><span class="line">	count:=strings.Count(<span class="string">&quot;seafoodfootjuFooldd&quot;</span>,<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;出现foo字串的次数是:&quot;</span>,count)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//10.不区分大小写的字符串比较（==是区分大小写的）：fmt.Println(strings.EqualFold(&quot;abc&quot;,&quot;Abc&quot;))//true</span></span><br><span class="line">	fmt.Println(strings.EqualFold(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;Abc&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;abc&quot;</span>==<span class="string">&quot;Abc&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//11.返回子串在字符串中第一次出现的index值，如果没有返回-1，strings.Index(&quot;NLP_abc&quot;,&quot;abc&quot;)  //4</span></span><br><span class="line">	in:=strings.Index(<span class="string">&quot;NLP_abc&quot;</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;abc的位置在下标：&quot;</span>,in)</span><br><span class="line">	in2:=strings.Index(<span class="string">&quot;NLP中_abc&quot;</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;abc的位置在下标：&quot;</span>,in2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//12.返回子串在字符串最后一次出现的index,如没有就返回-1，strings.LastIndex(&quot;go golang&quot;,&quot;go&quot;)</span></span><br><span class="line">	in12:=strings.LastIndex(<span class="string">&quot;go golang&quot;</span>,<span class="string">&quot;go&quot;</span>)</span><br><span class="line">	fmt.Println(in12)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//13.将指定的字符串替换成另外一个子串：strings.Replace(&quot;go go hello&quot;,&quot;go&quot;,&quot;go语言&quot;,n)</span></span><br><span class="line">	<span class="comment">//,n可以指定你希望替换几个，如果n=-1表示全部替换</span></span><br><span class="line">	str13:=strings.Replace(<span class="string">&quot;go go hello&quot;</span>,<span class="string">&quot;go&quot;</span>,<span class="string">&quot;go语言&quot;</span>,<span class="number">2</span>)</span><br><span class="line">	fmt.Println(str13)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//14.按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组，strings.Split(&quot;hello,world,ok&quot;,&quot;,&quot;)</span></span><br><span class="line">	strArr:=strings.Split(<span class="string">&quot;hello,world,ok&quot;</span>,<span class="string">&quot;,&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(strArr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//15.将字符串的字母进行大小写的转换：strings.ToLower(&quot;Go&quot;) //strings.ToUpeer(&quot;Go&quot;)</span></span><br><span class="line">	str15:=strings.ToLower(<span class="string">&quot;Go&quot;</span>)</span><br><span class="line">	fmt.Println(str15)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//16.将字符串左右两边的空格去掉，strings.TrimSpace(&quot; tn a lo her ntm   &quot;) //tn a lo her ntm</span></span><br><span class="line">	str16:=strings.TrimSpace(<span class="string">&quot; tn a lo her ntm   &quot;</span>)</span><br><span class="line">	fmt.Println(str16)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//17.将字符串左右两边指定的字符去掉，strings.Trim(&quot;!!!!Hell!!!ooo!!!&quot;,&quot;!&quot;) //hell!!!ooo</span></span><br><span class="line">	str17:=strings.Trim(<span class="string">&quot;!!!!Hell!!!ooo!!!&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">	fmt.Println(str17)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//18.将字符串左边的指定字符去掉，strings.TrimLeft(&quot;!hello!!&quot;,&quot;!&quot;)  //hello!!</span></span><br><span class="line">	str18:=strings.TrimLeft(<span class="string">&quot;!hello!!&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">	fmt.Println(str18)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//19.将字符串右边的指定字符去掉，strings.TrimRight(&quot;!hello!!&quot;,&quot;!&quot;) //！hello</span></span><br><span class="line">	str19:=strings.TrimRight(<span class="string">&quot;!hello!!&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">	fmt.Println(str19)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//20.判断字符串是否以指定的字符串开头：strings.HasPrefix(&quot;ftp://192.168.10.1&quot;,&quot;ftp&quot;) //true</span></span><br><span class="line">	b20:=strings.HasPrefix(<span class="string">&quot;ftp://192.168.10.1&quot;</span>,<span class="string">&quot;ftp&quot;</span>)</span><br><span class="line">	fmt.Println(b20)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//21.判断字符串是否以指定的字符串结束：strings.HasSuffix(&quot;NLP_abc.jpg&quot;,&quot;.jpg&quot;) //true</span></span><br><span class="line">	b21:=strings.HasSuffix(<span class="string">&quot;NLP_abc.jpg&quot;</span>,<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">	fmt.Println(b21)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-时间和日期相关函数"><a href="#11-时间和日期相关函数" class="headerlink" title="11.时间和日期相关函数"></a>11.时间和日期相关函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">在编程中，程序员经常用到日期函数，比如：统计某段代码执行花费的时间</span><br><span class="line">1.时间和日期相关函数，需要导入time包</span><br><span class="line">2.time.Time类型，用于表示时间</span><br><span class="line">3.获取到当前时间的方法</span><br><span class="line">	now:=time.Now() //now的类型就是time.Time</span><br><span class="line">4.如何获取到其他的日期信息</span><br><span class="line">5.格式化 日期时间</span><br><span class="line">	格式化的第一种方式</span><br><span class="line">		now:=time.Now()</span><br><span class="line">		fmt.Printf(&quot;当前年月日 %d-%d-%d %d:%d:%d\n&quot;,</span><br><span class="line">           now.Year(),now.Month(),now.Day(),</span><br><span class="line">           now.Hour(),now.Minute(),now.Second())</span><br><span class="line">  	格式化的第二种方式</span><br><span class="line">  		fmt.Println(now.Format(&quot;2006/01/02 15:04:05&quot;))</span><br><span class="line">        fmt.Println(now.Format(&quot;2006/01/02&quot;))</span><br><span class="line">        fmt.Println(now.Format(&quot;15:04:05&quot;))</span><br><span class="line">        fmt.Println(now.Format(&quot;02 15:05&quot;))</span><br><span class="line">6.时间的常量</span><br><span class="line">	const (</span><br><span class="line">        Nanosecond  Duration = 1  //纳秒</span><br><span class="line">        Microsecond          = 1000 * Nanosecond //微秒</span><br><span class="line">        Millisecond          = 1000 * Microsecond //毫秒</span><br><span class="line">        Second               = 1000 * Millisecond //秒</span><br><span class="line">        Minute               = 60 * Second</span><br><span class="line">        Hour                 = 60 * Minute</span><br><span class="line">    )</span><br><span class="line">    常量的作用：在程序中可用于获取指定时间单位的时间，比如想得到100毫秒</span><br><span class="line">    100*time.Millisecond  </span><br><span class="line">7.休眠（结合sleep）</span><br><span class="line">	func Sleep(d Duration)</span><br><span class="line">8.获取当前Unix时间戳和unixnano时间戳（作用是可以获取随机的数字）</span><br><span class="line">	unix时间戳</span><br><span class="line">	unixnano时间戳</span><br><span class="line">	用法：</span><br><span class="line">    func (t Time) Unix() int64</span><br><span class="line">    Unix将t表示为Unix时间，即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位秒）。</span><br><span class="line">    </span><br><span class="line">    func (t Time) UnixNano() int64</span><br><span class="line">    UnixNano将t表示为Unix时间，即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位纳秒）。如果纳	秒为单位的unix时间超出了int64能表示的范围，结果是未定义的。注意这就意味着Time零值调用UnixNano方法的	话，结果是未定义的。</span><br><span class="line">9.最佳实践案例：求解函数test03执行的时间</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="comment">//看看日期和时间相关的函数和方法使用</span></span><br><span class="line"><span class="comment">//1.获取当前时间</span></span><br><span class="line">now:=time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;now类型是%T,now的值是%v\n&quot;</span>,now,now)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过now可以获取到年月日，时分秒</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;年=%v\n&quot;</span>,now.Year())</span><br><span class="line">fmt.Printf(<span class="string">&quot;月=%v\n&quot;</span>,<span class="type">int</span>(now.Month()))</span><br><span class="line">fmt.Printf(<span class="string">&quot;日=%v\n&quot;</span>,now.Day())</span><br><span class="line">fmt.Printf(<span class="string">&quot;时=%v\n&quot;</span>,now.Hour())</span><br><span class="line">fmt.Printf(<span class="string">&quot;分=%v\n&quot;</span>,now.Minute())</span><br><span class="line">fmt.Printf(<span class="string">&quot;秒=%v\n&quot;</span>,now.Second())</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化日期输出</span></span><br><span class="line"><span class="comment">//第一种方式 其中-和：可以自己定义</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;当前年月日 %d-%d-%d %d:%d:%d\n&quot;</span>,</span><br><span class="line">           now.Year(),now.Month(),now.Day(),</span><br><span class="line">           now.Hour(),now.Minute(),now.Second())</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式格式化后赋值给一个变量</span></span><br><span class="line">dateStr:=fmt.Sprintf(<span class="string">&quot;当前年月日 %d-%d-%d %d:%d:%d\n&quot;</span>,</span><br><span class="line">                     now.Year(),now.Month(),now.Day(),</span><br><span class="line">                     now.Hour(),now.Minute(),now.Second())</span><br><span class="line">fmt.Println(dateStr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种格式化方式</span></span><br><span class="line"><span class="comment">//说明： &quot;2006/01/02 15:04:05&quot;这个字符串的各个数字是固定的</span></span><br><span class="line"><span class="comment">//必须是这样写，但是这个字符串各个数字可以自由组合</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;02 15:05&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求1：每隔1秒中打印一个数字，打印到100时就退出</span></span><br><span class="line"><span class="comment">//需求2：每隔0.1秒中打印一个数字，打印到100时就退出</span></span><br><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    <span class="comment">//休眠</span></span><br><span class="line">    <span class="comment">//需求1</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="comment">//需求2</span></span><br><span class="line">    time.Sleep(<span class="number">100</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">10</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳，unix和unixnano的使用</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;unix时间戳=%v unixnano时间戳=%v&quot;</span>,now.Unix(),now.UnixNano())</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="comment">//求解函数test03执行的时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//在执行test03前，先获取到当前的unix时间戳</span></span><br><span class="line">	start:=time.Now().Unix()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;start类型%T，start值是%v\n&quot;</span>,start,start)</span><br><span class="line">	test03()</span><br><span class="line">	end:=time.Now().Unix()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;end类型%T，end值是%v\n&quot;</span>,end,end)</span><br><span class="line">	fmt.Println(<span class="string">&quot;执行test03()消耗的时间&quot;</span>,end-start)</span><br><span class="line">	fmt.Println(<span class="number">1634482665</span><span class="number">-1634482650</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test03</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	str:=<span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">		str+=<span class="string">&quot;hello&quot;</span>+strconv.Itoa(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-内置函数"><a href="#12-内置函数" class="headerlink" title="12.内置函数"></a>12.内置函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明</span></span><br><span class="line">go设计者为了编程方便，提供了一些函数，可以直接使用，不用导包，我们称之为内置函数。  主要见builtin包</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">常用内置函数</span></span><br><span class="line">1.len：用来求长度，比如string，array，slice,map,channel</span><br><span class="line">2.new：用来分配内存，主要用来分配值类型，比如int,float32,struct...返回的是指针</span><br><span class="line">3.make:用来分配内存，主要用来分配引用类型，比如chan,map,slice</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line">num1:=<span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;num1的类型=%T，num1的值=%v,num1的地址=%v\n&quot;</span>,num1,num1,&amp;num1)</span><br><span class="line">num2:= <span class="built_in">new</span>(<span class="type">int</span>)  <span class="comment">// num2的类型是 *int</span></span><br><span class="line"><span class="comment">//num2的类型=*int</span></span><br><span class="line"><span class="comment">//num2的值= 地址？0xc00000a0c0  (这个地址不能更改，由系统分配)</span></span><br><span class="line"><span class="comment">//num2的地址=地址？0xc000006030 (这个地址不能更改，由系统分配)</span></span><br><span class="line"><span class="comment">//num2指向的值 默认初始是0，后面可以通过*num2进行更改</span></span><br><span class="line">*num2=<span class="number">100</span></span><br><span class="line">fmt.Println(*num2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;num2的类型=%T，num2的值=%v,num2的地址=%v,num2指针指向的值%v&quot;</span>,num2,num2,&amp;num2,*num2)</span><br></pre></td></tr></table></figure>

<h2 id="第四章：错误处理"><a href="#第四章：错误处理" class="headerlink" title="第四章：错误处理"></a>第四章：错误处理</h2><h3 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1.错误处理"></a>1.错误处理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍 为什么引入错误处理</span></span><br><span class="line">1.在默认情况下，当发生错误（panic）后,程序就会退出</span><br><span class="line">2.如果我们希望，当发生错误后，可以捕获到错误，并进行处理，保证程序可以继续执行，还可以在捕获到错误后，给管理员一个提示</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本说明</span></span><br><span class="line">1.go语言追求简介优雅，所以，go语言不支持try,catch,finally这种处理</span><br><span class="line">2.go中引入的处理方式是：defer,panic,recover</span><br><span class="line">3.这几个异常的使用场景可以这么简单描述：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用defer+recover结合来捕获并处理异常</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误处理的演示代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	test03()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test03</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//使用defer+recover来捕获异常</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := <span class="built_in">recover</span>() <span class="comment">//recover()内置函数，可以捕获到异常</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	n1:=<span class="number">10</span></span><br><span class="line">	n2:=<span class="number">0</span></span><br><span class="line">	n3:=n1/n2</span><br><span class="line">	fmt.Println(n3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义异常"><a href="#2-自定义异常" class="headerlink" title="2.自定义异常"></a>2.自定义异常</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本说明</span></span><br><span class="line">go程序中也支持自定义错误，使用errors.New和panic内置函数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.errors.New(&quot;错误说明&quot;)，会返回一个error类型的值，表示一个错误</span><br><span class="line">2.panic内置函数，接收一个interface&#123;&#125;类型的值（也就是任何值）作为参数，可以接收error类型的变量，输出错误信息，并退出程序</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例演示</span></span><br><span class="line"><span class="comment">//函数去读取配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，我们就返回一个自定义的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;init.conf&quot;</span>&#123;</span><br><span class="line">		<span class="comment">//读取</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//返回一个自定义错误</span></span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	err:=readConf(<span class="string">&quot;init.conf2&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="comment">//如果读取文件发生错误，就输出这个错误，并终止程序</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;test02后面的代码&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//自定义代码的测试</span></span><br><span class="line">	test02()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第五章：数组和切片和map"><a href="#第五章：数组和切片和map" class="headerlink" title="第五章：数组和切片和map"></a>第五章：数组和切片和map</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.数组也是一种数据类型，在go中，数组是值类型</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组的定义</span></span><br><span class="line">	var 数组名 [数组大小]数据类型</span><br><span class="line">	var arr [5]int  //数组定义后都会有一个默认值</span><br><span class="line">	赋初值 arr[0]=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组的使用</span></span><br><span class="line">    1.访问数组元素</span><br><span class="line">        数组名[下标] 如arr[2]</span><br><span class="line">    2.四种默认初始化数组的方式</span><br><span class="line">        1.var arr [3]int=[3]int&#123;1,2,3&#125;</span><br><span class="line">        2.var arr=[3]int&#123;1,2,3&#125;</span><br><span class="line">        3.var arr=[...]int&#123;1,2,3&#125;</span><br><span class="line">        4.var arr=[3]string&#123;1:&quot;hehe&quot;,2:&quot;haha&quot;,0:&quot;xixi&quot;&#125;</span><br><span class="line">        5.arr:=[3]string&#123;1:&quot;hehe&quot;,2:&quot;haha&quot;,0:&quot;xixi&quot;&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组的遍历</span></span><br><span class="line">	1.for循环</span><br><span class="line">	2.for-range</span><br><span class="line">		基本语法：</span><br><span class="line">			for index,value := range arr&#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		说明：</span><br><span class="line">		1.第一个返回值是index,数组的下标</span><br><span class="line">		2.第二个value是在该下标位置的值</span><br><span class="line">		3.他们都是仅在for循环内部可见的局部变量</span><br><span class="line">		4.遍历数组时，如果不想使用下标index,可以直接使用_来取代index,进行省略</span><br><span class="line">		5.index和value的名称不是固定的，即程序员可以自行指定，一般命名为index,value</span><br><span class="line"><span class="meta prompt_">		</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组的使用细节和注意事项</span></span><br><span class="line">1.数组中的元素是多个相同类型数据的组合，一个数组一旦声明定义了，长度就固定了，不能动态变化</span><br><span class="line">2.var arr []int  这时arr就是一个切片，后面再讲解</span><br><span class="line">3.数组中的元素可以是任何数据类型，包括值类型和引用类型，但是不能混用</span><br><span class="line">4.go语言中的数组是值类型，在默认情况下是值传递，因此会进行值拷贝，数组间不会相互影响</span><br><span class="line">5.#如果想在其他函数中，去修改原来的数组，可以使用引用传递（指针方式） //先体验下</span><br><span class="line">6.数组类型没有进行初始化，有默认值（零值）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速入门代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.定义一个数组</span></span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">6</span>]<span class="type">float64</span></span><br><span class="line">	<span class="comment">//2.给数组的每个元素进行赋值</span></span><br><span class="line">	arr[<span class="number">0</span>]=<span class="number">3.0</span></span><br><span class="line">	arr[<span class="number">1</span>]=<span class="number">5.7</span></span><br><span class="line">	arr[<span class="number">2</span>]=<span class="number">3.0</span></span><br><span class="line">	arr[<span class="number">3</span>]=<span class="number">8.4</span></span><br><span class="line">	arr[<span class="number">4</span>]=<span class="number">6.0</span></span><br><span class="line">	arr[<span class="number">5</span>]=<span class="number">5.0</span></span><br><span class="line">	<span class="comment">//3.计算总体重</span></span><br><span class="line">	sum:=<span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		sum+=arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;总体重为&quot;</span>,sum)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.求出平均体重  %.2f保留两位小数</span></span><br><span class="line">	avg:=fmt.Sprintf(<span class="string">&quot;%.2f&quot;</span>,sum/<span class="type">float64</span>(<span class="built_in">len</span>(arr)))</span><br><span class="line">	fmt.Println(<span class="string">&quot;平均体重为&quot;</span>,avg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//理解数组内存布局</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.定义一个数组</span></span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">int</span>  <span class="comment">//int32占4个字节  int占8个字节</span></span><br><span class="line"></span><br><span class="line">	arr[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">	arr[<span class="number">1</span>]=<span class="number">20</span></span><br><span class="line">	arr[<span class="number">2</span>]=<span class="number">30</span></span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	<span class="comment">//数组的地址可以通过数组名来获取 &amp;arr</span></span><br><span class="line">	<span class="comment">//数组的地址与数组第一个元素的地址相同，后面的元素地址都是根据第一个元素地址加上元素类型所占的字节数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;arr的地址=%p arr[0]的地址=%p arr[1]的地址=%p arr[2]的地址=%p&quot;</span>,&amp;arr,&amp;arr[<span class="number">0</span>],&amp;arr[<span class="number">1</span>],&amp;arr[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br><span class="line">arr的地址=<span class="number">0xc0000ae090</span> arr[<span class="number">0</span>]的地址=<span class="number">0xc0000ae090</span> arr[<span class="number">1</span>]的地址=<span class="number">0xc0000ae098</span> arr[<span class="number">2</span>]的地址=<span class="number">0xc0000ae0a0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组值传递以及通过指针传递改变数组值得演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(arr [3]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;arr1类型=%T\n&quot;</span>,arr)</span><br><span class="line">	arr[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">	arr[<span class="number">1</span>]=<span class="number">10</span></span><br><span class="line">	arr[<span class="number">2</span>]=<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;arr2类型=%T\n&quot;</span>,arr)</span><br><span class="line">    (*arr)[<span class="number">0</span>]=<span class="number">10</span>   <span class="comment">//arr[0]=10 这也是可以的</span></span><br><span class="line">    (*arr)[<span class="number">1</span>]=<span class="number">10</span></span><br><span class="line">    (*arr)[<span class="number">2</span>]=<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//数组是值传递</span></span><br><span class="line">	<span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="type">int</span>=[<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;arr1=&quot;</span>,arr1)</span><br><span class="line">	test1(arr1)</span><br><span class="line">	fmt.Println(<span class="string">&quot;arr1=&quot;</span>,arr1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过指针传递改变数组值</span></span><br><span class="line">	<span class="keyword">var</span> arr2 [<span class="number">3</span>]<span class="type">int</span>=[<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;arr2=&quot;</span>,arr2)</span><br><span class="line">	test2(&amp;arr2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;arr2=&quot;</span>,arr2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">arr1= [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">arr1类型=[<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">arr1= [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">arr2= [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">arr2类型=*[<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">arr2= [<span class="number">10</span> <span class="number">10</span> <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2-切片"><a href="#2-切片" class="headerlink" title="2.切片"></a>2.切片</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么需要切片</span></span><br><span class="line">需要一个长度不确定的相同类型数据的结构，因此数组就不可用了，因此引入切片</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.切片的英文是slice</span><br><span class="line">2.#切片是数组的引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制</span><br><span class="line">3.切片的使用和数组类似，遍历切片，访问切片的元素和求切片长度len(slice)都一样</span><br><span class="line">4.#切片的长度是可以变化的，因此切片是一个可以动态变化数组</span><br><span class="line">5.切片定义的基本语法</span><br><span class="line">	var 变量名 []数据类型  如var arr []int</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切片在内存中的形式</span></span><br><span class="line">var intArr [5]int=[...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">slice:=intArr[1:3]</span><br><span class="line"></span><br><span class="line">1.slice是一个引用类型</span><br><span class="line">2.slice从底层来说，其实就是一个数据结构（struct结构体）</span><br><span class="line">	type slice struct&#123;</span><br><span class="line">		ptr *[2]int</span><br><span class="line">		len int</span><br><span class="line">		cap int</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切片的使用</span></span><br><span class="line">    第一种方式：定义一个切片，然后让切片去引用一个已经创建好得数组，比如前面得案例就是这样的</span><br><span class="line">        var intArr [5]int=[...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">        slice:=intArr[1:3]</span><br><span class="line">    第二种方式：通过make来创建切片</span><br><span class="line">        基本语法：</span><br><span class="line">            var 切片名 []type=make([]type,len,[cap])  //make是内置函数</span><br><span class="line">            参数说明：type：就是数据类型  len:大小  cap:指定切片容量，是可选的 ，如果有，则必须cap&gt;=len</span><br><span class="line">        说明：</span><br><span class="line">            1.通过make方式创建切片可以指定切片的大小和容量</span><br><span class="line">            2.如果没有给切片的各个元素进行赋值，那么就会使用默认值（零值）</span><br><span class="line">            3.通过make方式创建的切片对应的数组只能通过切片来访问，对外不可见</span><br><span class="line">        例如：</span><br><span class="line">            var slice []int=make([]int,2,3)</span><br><span class="line">    第三种方式：定义一个切片，直接就指定具体数组，使用原理类似make方式</span><br><span class="line">        基本语法：</span><br><span class="line">            var slice []int=[]int&#123;1,2,3,4,5&#125;</span><br><span class="line">        说明：</span><br><span class="line">            这样声明的长度len和cap就是5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切片注意事项和使用细节</span></span><br><span class="line">1.切片初始化时，var intArr [5]int=[...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">        	  slice:=intArr[1:3]</span><br><span class="line">  说明：从intArr数组下标为startIndex（即上面的1）,取到下标为endIndex的元素（3），不含intArr[3]</span><br><span class="line">2.切片初始化时，在使用下标访问时，仍然不能越界，范围在[0,len(slice))之间，但是可以动态增长（通过内置的append函数）</span><br><span class="line">3.一些简写的形式</span><br><span class="line">	1.var slice=arr[0:end]  可以简写为var slice=arr[:end]</span><br><span class="line">	2.var slice=arr[start:len(arr)]  可以简写为var slice=arr[start:]</span><br><span class="line">	3.var slice=arr[0:len(arr)] 可以简写为var slice=arr[:]</span><br><span class="line">4.cap是一个内置函数，可用于统计切片的容量，即最大可以存放多少个元素</span><br><span class="line">5.切片定义完毕后，还不能使用，因为本身是一个空的，需要让其引用到一个数组，或者make一个空间供切片来使用，否则就只能进行append操作</span><br><span class="line">6.切片可以继续切片</span><br><span class="line">	案例演示：</span><br><span class="line">		var slice []int=[]int&#123;1,2,3,4,5&#125;</span><br><span class="line">		var slice2=slice[1:3]</span><br><span class="line">	说明：</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">当改变第二个切片中的元素值时，其关联的数据也都会改变</span></span><br><span class="line">7.#用append内置函数，可以对切片进行动态追加</span><br><span class="line">	基本语法：</span><br><span class="line">		func append(slice []Type, elems ...Type) []Type</span><br><span class="line">        内建函数append将元素追加到切片的末尾。若它有足够的容量，其目标就会重新切片以容纳新的元素。否则，就		会分配一个新的基本数组。append返回更新后的切片，因此必须存储追加后的结果。</span><br><span class="line">        slice = append(slice, elem1, elem2)</span><br><span class="line">        slice = append(slice, anotherSlice...)</span><br><span class="line">	案例演示：</span><br><span class="line">		//切片在末尾添加元素</span><br><span class="line">    	slice = append(slice, 2，3)  //末尾添加元素值2，4</span><br><span class="line">    	slice = append(slice,slice2...)  //在slice后面追加一个切片slice2,slice2也可以是自												己，...是固定写法</span><br><span class="line">    说明：</span><br><span class="line">    	1.切片append操作的本质就是对数组扩容</span><br><span class="line">    	2.go底层会创建一下新的数组newArr(安装后扩容大小)</span><br><span class="line">    	3.将slice原来包含的元素拷贝到新的数组newArr</span><br><span class="line">    	4.slice重新引用到newArr</span><br><span class="line">    	5.注意newArr是在底层来维护的，程序员不可见</span><br><span class="line">8.切片的拷贝操作copy </span><br><span class="line">	基本语法：</span><br><span class="line">		func copy(dst, src []Type) int</span><br><span class="line">        内建函数copy将元素从来源切片复制到目标切片中，也能将字节从字符串复制到字节切片中。copy返回被复制的		 元素数量，它会是 len(src) 和 len(dst) 中较小的那个。来源和目标的底层内存可以重叠。</span><br><span class="line">	切片使用copy内置函数完成拷贝，举例说明</span><br><span class="line">		var arr =[5]int&#123;1,2,3,4,5&#125;</span><br><span class="line">        var slice1=arr[:]</span><br><span class="line">        var slice2=make([]int,10,10)</span><br><span class="line">        copy(slice2,slice1)   //可以从长度大的切片往小的拷贝，反着来也可以</span><br><span class="line">        fmt.Println(&quot;slice1=&quot;,slice1)</span><br><span class="line">        fmt.Println(&quot;slice2=&quot;,slice2)</span><br><span class="line">    注意：</span><br><span class="line">    	copy(para1,para2) para1和para2都是切片类型，不能是数组，拷贝时他们的内存空间是独立的.所以改变其中的一个切片内容，并不会影响另外一个切片的内容</span><br><span class="line">9.切片是引用类型，所以在传递时，遵守引用传递机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切片的演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//切片的快速入门</span></span><br><span class="line">	<span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="type">int</span>=[...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">//声明定义一个切片</span></span><br><span class="line">	<span class="comment">//slice:=intArr[1:3]</span></span><br><span class="line">	<span class="comment">//1.slice就是切片名</span></span><br><span class="line">	<span class="comment">//2.intArr[1:3]  表示slice引用到intArr这个数组</span></span><br><span class="line">	<span class="comment">//3.引用intArr数组下标为1的元素到下标为3的元素，包括下标1，但是不包括下标3</span></span><br><span class="line">	slice:=intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    <span class="comment">//在切片里面修改值，同时会直接更改掉切片引用的数组中对应的值</span></span><br><span class="line">    slice[<span class="number">1</span>]=<span class="number">100</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;intArr=&quot;</span>,intArr)</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice=&quot;</span>,slice)</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice的元素个数是&quot;</span>,<span class="built_in">len</span>(slice))</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice的容量是&quot;</span>,<span class="built_in">cap</span>(slice))  <span class="comment">//切片的容量是可以动态变化的</span></span><br><span class="line">	<span class="comment">//切片在末尾添加元素</span></span><br><span class="line">    slice = <span class="built_in">append</span>(slice, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">//遍历切片</span></span><br><span class="line">    <span class="keyword">for</span> i, i2 := <span class="keyword">range</span> slice &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;i:&quot;</span>,i,<span class="string">&quot;i2:&quot;</span>,i2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">intArr= [<span class="number">1</span> <span class="number">2</span> <span class="number">100</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">slice= [<span class="number">2</span> <span class="number">100</span>]</span><br><span class="line">slice的元素个数是 <span class="number">2</span></span><br><span class="line">slice的容量是 <span class="number">4</span></span><br><span class="line">i: <span class="number">0</span> i2: <span class="number">2</span></span><br><span class="line">i: <span class="number">1</span> i2: <span class="number">100</span></span><br><span class="line">i: <span class="number">2</span> i2: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-string和slice"><a href="#3-string和slice" class="headerlink" title="3.string和slice"></a>3.string和slice</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.string底层是一个byte数组，因此string也可以进行切片处理</span><br><span class="line">	str:=&quot;hello@world&quot;</span><br><span class="line">	slice:=str[6:]  //slice=[world]</span><br><span class="line">2.string和切片在内存的形式，以abcd画出内存形式</span><br><span class="line">3.string是不可变的，也就是说不能通过str[0]=&#x27;z&#x27;方式来修改字符串</span><br><span class="line">4.如果需要修改字符串，可以先将string-&gt;[]byte/或者[]rune -&gt; 修改 -&gt;再重写转成string  </span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> slice =<span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">	fmt.Println(slice)</span><br><span class="line">	str:=<span class="string">&quot;hello你好中国world&quot;</span></span><br><span class="line">    <span class="comment">//str[0]=&#x27;z&#x27;  //编译会出错</span></span><br><span class="line">	<span class="comment">//将字符串显示转换为切片[]int32</span></span><br><span class="line">	<span class="keyword">var</span> arr=[]<span class="type">rune</span>(str)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>,arr)</span><br><span class="line">    <span class="comment">//rune是int32的别名，  []rune(str)相当于是将字符串显示转换为rune类型的切片</span></span><br><span class="line">	<span class="comment">//for i, r := range arr &#123;   </span></span><br><span class="line">	<span class="comment">//	fmt.Printf(&quot;i=%d r=%c\n&quot;,i,r)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	fmt.Println(str)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="comment">//fmt.Println(arr[i])</span></span><br><span class="line">		<span class="comment">//通过将字符串转换为切片之后，改变切片中的元素值，再将切片转换为字符串的方式来修改字符串</span></span><br><span class="line">        arr[i]+=<span class="number">5</span></span><br><span class="line">	&#125;</span><br><span class="line">	str=<span class="type">string</span>(arr)</span><br><span class="line">	fmt.Println(str)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//细节，我们转成[]byte数组时，可以处理英文和数字，但是不能处理中文</span></span><br><span class="line">    <span class="comment">//原因是[]byte 按字节来处理，而一个汉字，是3个字节，因此会出现乱码</span></span><br><span class="line">    <span class="comment">//解决办法是将string转成[]rune 即可，因为[]rune是按字符处理，兼容汉字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[]<span class="type">int32</span></span><br><span class="line">hello你好中国world</span><br><span class="line">mjqqt佥如串圂|twqi</span><br></pre></td></tr></table></figure>

<h3 id="4-排序和查找"><a href="#4-排序和查找" class="headerlink" title="4.排序和查找"></a>4.排序和查找</h3><h4 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">排序的分类：</span><br><span class="line">1.内部排序</span><br><span class="line">	指将需要处理的所有数据都加载到内部存储器中进行排序，包括（交换式排序法，选择式排序法和插入式排序法）</span><br><span class="line">2.外部排序</span><br><span class="line">	数据量过大，无法全部加载到内存中，需要借助外部存储进行排序，包括（合并排序法和直接合并排序法）</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">交换式排序法</span></span><br><span class="line">	介绍：是运用数据值比较后，依据判断规则对数据位置进行交换，以达到排序的目的</span><br><span class="line">	交换式排序分为：</span><br><span class="line">		1.冒泡排序法（Bubble sort） (从小到大顺序)</span><br><span class="line">		2.快速排序法（Quick sort）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(arr *[5]<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(arr); i &gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">		b:=<span class="literal">true</span></span><br><span class="line">		<span class="comment">//每一轮内循环，选出数组的最大的值，相当于依次选出数组中最大元素</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (*arr)[j]&lt;(*arr)[j<span class="number">-1</span>]&#123;</span><br><span class="line">				temp:=(*arr)[j]</span><br><span class="line">				(*arr)[j]=(*arr)[j<span class="number">-1</span>]</span><br><span class="line">				(*arr)[j<span class="number">-1</span>]=temp</span><br><span class="line">				b=<span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> b&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr =[<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">24</span>,<span class="number">69</span>,<span class="number">80</span>,<span class="number">57</span>,<span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;排序前：&quot;</span>,arr)</span><br><span class="line">    BubbleSort(&amp;arr)</span><br><span class="line">	fmt.Println(<span class="string">&quot;排序后：&quot;</span>,arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">常用的查找有两种</span><br><span class="line">1.顺序查找</span><br><span class="line">2.二分查找 (该数组必须有序)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearch</span><span class="params">(arr [6]<span class="type">int</span>,res <span class="type">int</span>)</span></span> (index <span class="type">int</span>) &#123;</span><br><span class="line">	index=<span class="number">-1</span></span><br><span class="line">	left:=<span class="number">0</span></span><br><span class="line">	right:=<span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		middle:=(left+right)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> left&lt;=right&#123;</span><br><span class="line">			<span class="keyword">if</span> arr[middle]==res&#123;</span><br><span class="line">				index=middle</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> arr[middle]&gt;res&#123;</span><br><span class="line">				right=middle<span class="number">-1</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				left=middle+<span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr =[<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">1000</span>,<span class="number">1234</span>&#125;</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	n:=<span class="number">123</span></span><br><span class="line">	res:=BinarySearch(arr,n)</span><br><span class="line">	<span class="keyword">if</span> res==<span class="number">-1</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;没有找到&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d在数组下标为%d&quot;</span>,n,res)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-二维数组"><a href="#5-二维数组" class="headerlink" title="5.二维数组"></a>5.二维数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">var matrix [4][5]int=[4][5]int&#123;&#123;0,0,0,0,0&#125;,&#123;0,0,0,0,0&#125;,&#123;0,0,0,0,0&#125;,&#123;0,0,0,0,0&#125;&#125;</span><br><span class="line">基本语法：</span><br><span class="line">	var 数组名 [大小][大小]类型   如var matrix [4][5]int</span><br><span class="line">	访问：</span><br><span class="line">		数组名[i][j]</span><br><span class="line">	</span><br><span class="line">	var 数组名 [大小][大小]类型=[大小][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line">	var 数组名 [大小][大小]类型=[...][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line">	var 数组名 =[大小][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line">	var 数组名 =[...][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line">	数组名 :=[大小][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">二维数组的遍历</span></span><br><span class="line">	1.for循环</span><br><span class="line">	2.for-range循环</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> matrix [<span class="number">4</span>][<span class="number">5</span>]<span class="type">int</span>=[<span class="number">4</span>][<span class="number">5</span>]<span class="type">int</span>&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">30</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;</span><br><span class="line">	fmt.Println(matrix[<span class="number">2</span>])</span><br><span class="line">	matrix[<span class="number">1</span>]=[<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">			fmt.Print(matrix[i][j],<span class="string">&quot; &quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组的内存分布演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> matrix [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;matrix地址=%p\n&quot;</span>,&amp;matrix)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;matrix[0]地址=%p\n&quot;</span>,&amp;matrix[<span class="number">0</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;matrix[1]地址=%p\n&quot;</span>,&amp;matrix[<span class="number">1</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;matrix[0][0]地址=%p\n&quot;</span>,&amp;matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="number">0xc00013e060</span></span><br><span class="line"><span class="number">0xc00013e060</span></span><br><span class="line"><span class="number">0xc00013e078</span></span><br><span class="line"><span class="number">0xc00013e060</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-map"><a href="#6-map" class="headerlink" title="6.map"></a>6.map</h3><h4 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">	map是key-value数据结构，又称为字段或者关联数组，类似其他编程语言的集合，在编程中是经常使用到</span><br><span class="line">	基本语法：</span><br><span class="line">		var 变量名 map[key类型]value类型  如var kv map[int]string</span><br><span class="line">    说明：</span><br><span class="line">    	key的类型可以是哪些？</span><br><span class="line">    		可以是bool,数字，string，指针，channel,还可以是只包含前面几个类型的接口，结构体，数组</span><br><span class="line">    		通常为int,string</span><br><span class="line">    		注意：slice,map还有function不可以，因为这几个无法使用==来判断</span><br><span class="line">    	value可以的类型和key差不多</span><br><span class="line">    		通常为数字，string,map,struct</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">map声明</span></span><br><span class="line">	举例：</span><br><span class="line">        var a map[string]string</span><br><span class="line">        var a map[string]int</span><br><span class="line">        var a map[int]string</span><br><span class="line">        var a map[string]map[string]string</span><br><span class="line">  	说明：</span><br><span class="line">  		声明是不会分配内存的，初始化需要make,分配内存后才能赋值和使用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">map的使用方式：</span></span><br><span class="line">func main()&#123;</span><br><span class="line">	//map使用方式</span><br><span class="line">	//第一种</span><br><span class="line">	var kv map[int]string</span><br><span class="line">	kv=make(map[int]string,10)</span><br><span class="line">	kv[1]=&quot;hello&quot;</span><br><span class="line">	kv[2]=&quot;hello111&quot;</span><br><span class="line">	fmt.Printf(&quot;kv的类型=%T,kv的值=%v\n&quot;,kv,kv)</span><br><span class="line">	fmt.Printf(&quot;kv[1]的类型=%T,kv[1]的值=%v\n&quot;,kv[1],kv[1])</span><br><span class="line"></span><br><span class="line">	//第二种</span><br><span class="line">	var kv2 map[int]string =make(map[int]string)</span><br><span class="line">	kv2[1]=&quot;hello&quot;</span><br><span class="line">	kv2[2]=&quot;hello111&quot;</span><br><span class="line">	kv2[3]=&quot;hello111&quot;</span><br><span class="line">	fmt.Println(kv2)</span><br><span class="line"></span><br><span class="line">	//第三种  声明的时候直接赋值</span><br><span class="line">	var kv3 map[int]string =map[int]string&#123;1:&quot;hello&quot;,2:&quot;am&quot;&#125;</span><br><span class="line">	kv4 :=map[int]string&#123;1:&quot;hello&quot;,2:&quot;am&quot;&#125;</span><br><span class="line">	kv3[2]=&quot;www&quot;</span><br><span class="line">	fmt.Println(kv3)</span><br><span class="line">	fmt.Println(kv4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//map的声明和注意事项</span></span><br><span class="line">	<span class="keyword">var</span> kv <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">	<span class="comment">//在使用map前选哟make，make的作用就是给map分配内存空间</span></span><br><span class="line">	kv=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>,<span class="number">10</span>)</span><br><span class="line">	kv[<span class="number">1</span>]=<span class="string">&quot;hello&quot;</span></span><br><span class="line">	kv[<span class="number">1</span>]=<span class="string">&quot;hello111&quot;</span></span><br><span class="line">	kv[<span class="number">2</span>]=<span class="string">&quot;xixi&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;kv的类型=%T,kv的值=%v\n&quot;</span>,kv,kv)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;kv[1]的类型=%T,kv[1]的值=%v&quot;</span>,kv[<span class="number">1</span>],kv[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码说明</span></span><br><span class="line">	<span class="number">1.</span><span class="keyword">map</span>使用前需要<span class="built_in">make</span></span><br><span class="line">	<span class="number">2.</span><span class="keyword">map</span>的key不能重复，value可以重复，并且值以最后的为准</span><br><span class="line">	<span class="number">3.</span><span class="keyword">map</span>的key-value是无序的</span><br></pre></td></tr></table></figure>

<h4 id="2-案例分析"><a href="#2-案例分析" class="headerlink" title="2.案例分析"></a>2.案例分析</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map案例应用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//案例：一个学生有学号，学号对应有姓名和性别和地址</span></span><br><span class="line">	stu:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	stu[<span class="string">&quot;stu001&quot;</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>,<span class="number">3</span>)  <span class="comment">//这句话不可少</span></span><br><span class="line">	stu[<span class="string">&quot;stu001&quot;</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;张三&quot;</span></span><br><span class="line">	stu[<span class="string">&quot;stu001&quot;</span>][<span class="string">&quot;age&quot;</span>]=<span class="string">&quot;15&quot;</span></span><br><span class="line">	stu[<span class="string">&quot;stu001&quot;</span>][<span class="string">&quot;address&quot;</span>]=<span class="string">&quot;北京&quot;</span></span><br><span class="line"></span><br><span class="line">	stu[<span class="string">&quot;stu002&quot;</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>,<span class="number">3</span>)</span><br><span class="line">	stu[<span class="string">&quot;stu002&quot;</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;李四&quot;</span></span><br><span class="line">	stu[<span class="string">&quot;stu002&quot;</span>][<span class="string">&quot;age&quot;</span>]=<span class="string">&quot;16&quot;</span></span><br><span class="line">	stu[<span class="string">&quot;stu002&quot;</span>][<span class="string">&quot;address&quot;</span>]=<span class="string">&quot;上海&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除map中的一个key-value</span></span><br><span class="line">    <span class="built_in">delete</span>(stu,<span class="string">&quot;stu001&quot;</span>)</span><br><span class="line">    <span class="built_in">delete</span>(stu,<span class="string">&quot;stu003&quot;</span>)</span><br><span class="line">    <span class="comment">//通过for-range遍历map</span></span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> stu &#123;</span><br><span class="line">		fmt.Println(key,<span class="string">&quot; &quot;</span>,value)</span><br><span class="line">        <span class="comment">//可以逐一删除</span></span><br><span class="line">        <span class="comment">//delete(stu,key)</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//演示map的查找,</span></span><br><span class="line">	value,ok:=stu[<span class="string">&quot;stu003&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> ok&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;有stu001值&quot;</span>,value)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;没有stu001这个值&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">	fmt.Println(stu[<span class="string">&quot;stu002&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-map的增删改查（crud操作）"><a href="#3-map的增删改查（crud操作）" class="headerlink" title="3.map的增删改查（crud操作）"></a>3.map的增删改查（crud操作）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加和更新</span></span><br><span class="line">map增加和更新</span><br><span class="line">	map[key]=value //#如果key还没有，就增加，如果key存在就是修改</span><br><span class="line">map删除：</span><br><span class="line">	说明：使用delete内置函数，delete(map,&quot;key&quot;),delete是一个内置函数，如果key存在，就删除key-value,</span><br><span class="line">		如果key不存在，不操作，但是也不会报错</span><br><span class="line">	基本语法：</span><br><span class="line">		func delete(m map[Type]Type1, key Type)</span><br><span class="line">		内建函数delete按照指定的键将元素从映射中删除。若m为nil或无此元素，delete不进行操作。</span><br><span class="line">	细节说明：</span><br><span class="line">		1.如果要删除map所有的key，没有一个专门的方法一次删除，可以遍历一下key然后逐个删除</span><br><span class="line">		2.或者map=make(...) ,make一个新的，让原来的成为垃圾，被gc回收</span><br><span class="line">map查询：</span><br><span class="line">	基本语法：</span><br><span class="line">		value,ok=stu[key]  </span><br><span class="line">	案例演示：</span><br><span class="line">        value,ok:=stu[&quot;stu001&quot;]</span><br><span class="line">        if ok&#123;</span><br><span class="line">            fmt.Println(&quot;有stu001值&quot;,value)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            fmt.Println(&quot;没有stu001这个值&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">	说明：</span><br><span class="line">		1.ok是bool类型的值，如果有stu001这个key，就为true,并且value为对应的值</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h4 id="4-map的遍历"><a href="#4-map的遍历" class="headerlink" title="4.map的遍历"></a>4.map的遍历</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">map遍历</span></span><br><span class="line">map的遍历使用for-range的方式进行遍历</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例演示</span></span><br><span class="line">for key, value := range stu &#123;</span><br><span class="line">    fmt.Println(key,&quot; &quot;,value)</span><br><span class="line">    for k, v := range value &#123;</span><br><span class="line">    	fmt.Println(k,&quot; &quot;,v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台结果</span><br><span class="line">stu001   map[address:北京 age:15 name:张三]</span><br><span class="line">name   张三</span><br><span class="line">age   15</span><br><span class="line">address   北京</span><br><span class="line">stu002   map[address:上海 age:16 name:李四]</span><br><span class="line">name   李四</span><br><span class="line">age   16</span><br><span class="line">address   上海</span><br></pre></td></tr></table></figure>

<h4 id="5-map的长度"><a href="#5-map的长度" class="headerlink" title="5.map的长度"></a>5.map的长度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.使用len内置函数，求解map中有多少对键值对</span><br><span class="line">len(stu)</span><br></pre></td></tr></table></figure>

<h4 id="6-map切片"><a href="#6-map切片" class="headerlink" title="6.map切片"></a>6.map切片</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">切片的数据类型如果是map,则我们称为map切片，这样使用map个数就可以动态变化了</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最大的作用就是map的个数可以动态增加</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示 </span></span><br><span class="line"><span class="comment">//声明一个map切片</span></span><br><span class="line"><span class="keyword">var</span> slice =<span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">slice[<span class="number">1</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">slice[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;haha&quot;</span></span><br><span class="line">slice[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>]=<span class="string">&quot;15&quot;</span></span><br><span class="line">slice[<span class="number">2</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">slice[<span class="number">2</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;hehe&quot;</span></span><br><span class="line">slice[<span class="number">2</span>][<span class="string">&quot;age&quot;</span>]=<span class="string">&quot;16&quot;</span></span><br><span class="line">stu:=<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;18&quot;</span>&#125;</span><br><span class="line"><span class="comment">//通过内置函数append动态增加</span></span><br><span class="line">slice=<span class="built_in">append</span>(slice,stu)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure>

<h4 id="7-map排序"><a href="#7-map排序" class="headerlink" title="7.map排序"></a>7.map排序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//现在新版本有按字典排序的功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//map的排序</span></span><br><span class="line">	map1:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	map1[<span class="number">10</span>]=<span class="number">3</span></span><br><span class="line">	map1[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">	map1[<span class="number">1</span>]=<span class="number">6</span></span><br><span class="line">	map1[<span class="number">5</span>]=<span class="number">2</span></span><br><span class="line">	fmt.Println(map1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果按照map的key的顺序进行排序输出</span></span><br><span class="line">	<span class="comment">//1.先将map的放入到切片</span></span><br><span class="line">	<span class="comment">//2.对切片进行排序</span></span><br><span class="line">	<span class="comment">//3.遍历切片，再根据key来输出map的值</span></span><br><span class="line">	<span class="keyword">var</span> keys []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	sort.Ints(keys)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map1[%v]=%v&quot;</span>,k,map1[k])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-使用和注意细节"><a href="#8-使用和注意细节" class="headerlink" title="8.使用和注意细节"></a>8.使用和注意细节</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.map是引用类型，遵守引用类型传递的机制，在一个函数接收map，修改后，会直接修改原来的map</span><br><span class="line">2.map的容量达到后，再想map增加元素，会自动扩容，并不会发生panic,也就是说map能动态的增长键值对</span><br><span class="line">3.map的value也经常使用struct,更适合管理复杂的数据（比前面value是一个map更好）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与结构体的使用演示</span></span><br><span class="line"><span class="comment">//定义一个结构体Stu</span></span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	map1:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Stu)</span><br><span class="line">	map1[<span class="string">&quot;stu001&quot;</span>]=Stu&#123;Name:<span class="string">&quot;haha&quot;</span>,Age:<span class="number">13</span>,Address:<span class="string">&quot;北京&quot;</span>&#125;   <span class="comment">//可以以键值对的方式给出</span></span><br><span class="line">	map1[<span class="string">&quot;stu002&quot;</span>]=Stu&#123;<span class="string">&quot;hehe&quot;</span>,<span class="number">13</span>,<span class="string">&quot;上海&quot;</span>&#125;  <span class="comment">//也可以直接给</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> s, stu := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;学号：%v 姓名：%v 年龄：%v 地址：%v\n&quot;</span>,s,stu.Name,stu.Age,stu.Address)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(map1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第六章：面向对象编程（上）"><a href="#第六章：面向对象编程（上）" class="headerlink" title="第六章：面向对象编程（上）"></a>第六章：面向对象编程（上）</h2><h3 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1.结构体"></a>1.结构体</h3><h4 id="1-快速入门-1"><a href="#1-快速入门-1" class="headerlink" title="1.快速入门"></a>1.快速入门</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.golang也支持面向对象编程，但是和传统的面向对象编程有很大的不同，并不是纯粹的面向对象编程，应该说golang是支持面向对象编程的特性。</span><br><span class="line">2.golang没有类（class），golang语言的结构体与java的类有同等的地位，可以理解golang是基于struct来支持oop特性的。</span><br><span class="line">3.golang面向对象非常简洁，去掉了oop语言的继承，方法重载，构造函数和析构函数，隐藏的this指针等等</span><br><span class="line">4.golang仍然有面向对象编程的继承，封装和多态，只是实现的方式和其他oop语言不太一样</span><br><span class="line">5.golang非常的优雅，golang中面向接口编程时非常重要的特性</span><br><span class="line">6.#结构体是一个值类型。</span><br><span class="line">7.基本语法</span><br><span class="line">	type 结构体名称 struct&#123;</span><br><span class="line">		field1 type</span><br><span class="line">		field2 type</span><br><span class="line">	&#125;</span><br><span class="line">	说明：</span><br><span class="line">		字段一般是基本类型，数组，也可是引用类型。</span><br><span class="line"><span class="meta prompt_">		</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字段的使用细节和注意事项</span></span><br><span class="line">1.字段声明语法同变量，实例：字段名 字段类型  #注意这里不用加var</span><br><span class="line">2.字段类型可以为：基本类型，数组或引用类型</span><br><span class="line">3.在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值（默认值），规则同前面讲的一样</span><br><span class="line">	bool类型为false,整形是0，字符串是&quot;&quot;</span><br><span class="line">	数组类型的默认值和它的元素类型有关，比如score [3]int ，则为[0,0,0]</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">指针，slice和map的零值都是nil,即还没有分配空间，如果要使用slice和map，需要先make。指针的值为&lt;nil&gt;,slice的nil输出的值为[],map为map[]</span></span><br><span class="line">4.不同结构体变量的字段是独立，互不影响，一个结构体变量字段的更改，不影响另外一个。结构体是值类型。要想通过另一个结构体进行改变，就需要借助指针/地址进行传递</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结构体的声明方式</span></span><br><span class="line">1.直接声明 var person Person  (其中Person是结构体名称，person是结构体变量名)</span><br><span class="line">2.声明并进行初始化 （推荐使用第二种）</span><br><span class="line">	var person Person=Person&#123;&#125;</span><br><span class="line">	var person=Person&#123;&#125;</span><br><span class="line">	person:=Person&#123;Name:&quot;hehe&quot;&#125;</span><br><span class="line">3.通过new</span><br><span class="line">	var person *Person=new(Person)</span><br><span class="line">	person:=new(Person)   //此时person是一个指向结构体的指针</span><br><span class="line">	访问的方式：(*person).Name=&quot;hehe&quot;  //左边这种方式也可以写为person.Name=&quot;hehe&quot;,这是为了程序员方便</span><br><span class="line">4.通过&amp;方式</span><br><span class="line">	//下面的语句也可以直接赋初值</span><br><span class="line">	var person *Person=&amp;Person&#123;&#125;</span><br><span class="line">	访问的方式：(*person).Name=&quot;hehe&quot;  go的设计者为了使用方便，在底层进行处理，也支持person.Name=&quot;hehe&quot;这种方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体入门字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Cat结构体，将Cat的各个/字段属性，放入到Cat结构体进行管理</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Color <span class="type">string</span></span><br><span class="line">    Ptr *<span class="type">int</span></span><br><span class="line">	Map1 <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">	Slice []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个Cat的变量,并且初始化所有字段的值</span></span><br><span class="line">	cat1:=Cat&#123;</span><br><span class="line">		Name:  <span class="string">&quot;小花&quot;</span>,</span><br><span class="line">		Age:   <span class="number">0</span>,</span><br><span class="line">		Color: <span class="string">&quot;yellow&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个Cat的变量,只初始化部分字段的值</span></span><br><span class="line">	<span class="keyword">var</span> cat2=Cat&#123;</span><br><span class="line">		Color: <span class="string">&quot;Black&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> cat3=Cat&#123;&#125;</span><br><span class="line">	<span class="comment">//给结构体里面的字段进行赋值</span></span><br><span class="line">	cat3.Age=<span class="number">14</span></span><br><span class="line">	cat3.Color=<span class="string">&quot;blue&quot;</span></span><br><span class="line">	cat3.Name=<span class="string">&quot;haha&quot;</span></span><br><span class="line">    cat3.Ptr=&amp;cat3.Age</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//map和slice类型的字段需要先make，才能使用</span></span><br><span class="line">	cat3.Map1=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	cat3.Map1[<span class="number">1</span>]=<span class="number">12</span></span><br><span class="line"></span><br><span class="line">	cat3.Slice=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">	cat3.Slice[<span class="number">1</span>]=<span class="number">14</span></span><br><span class="line">	cat3.Slice[<span class="number">2</span>]=<span class="number">15</span></span><br><span class="line">    cat4:=&amp;cat3</span><br><span class="line">	fmt.Println(*(cat3.Ptr))</span><br><span class="line">	fmt.Println(*(cat4.Ptr))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat3的类型=%T，cat3值=%v\n&quot;</span>,cat3,cat3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat4的类型=%T，cat4值=%v\n&quot;</span>,cat4,cat4)</span><br><span class="line">	<span class="comment">//修改cat4的指针字段值，cat3的指针字段值也会变，但指针字段指向的那个值却没有发生变化</span></span><br><span class="line">    <span class="comment">//注意这里要将*cat4用括号括起来，因为.的优先级比*号高，不括起来则取的是这个Ptr对应的值</span></span><br><span class="line">	(*cat4).Ptr=&amp;cat1.Age</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改cat4的值类型字段</span></span><br><span class="line">	(*cat4).Age=<span class="number">18</span></span><br><span class="line">	fmt.Println(*(cat3.Ptr))</span><br><span class="line">	fmt.Println(*(cat4.Ptr))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat3的类型=%T，cat3值=%v\n&quot;</span>,cat3,cat3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat4的类型=%T，cat4值=%v\n&quot;</span>,cat4,cat4)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat1的类型=%T，cat1值=%v\n&quot;</span>,cat1,cat1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat2的类型=%T，cat2值=%v\n&quot;</span>,cat2,cat2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat3的类型=%T，cat3值=%v\n&quot;</span>,cat3,cat3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat3的姓名=%v，cat3.年龄=%v,cat3.颜色=%v\n&quot;</span>,cat3.Name,cat3.Age,cat3.Color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.结构体的使用细节和注意事项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.结构体字段的内存存放地址是连续的</span><br><span class="line">2.结构体使用户单独定义的类型，和其他类型进行转换时需要有完全相同的字段（名字，个数和类型）</span><br><span class="line">	type A struct&#123;</span><br><span class="line">		Num int</span><br><span class="line">	&#125;</span><br><span class="line">	type B struct&#123;</span><br><span class="line">		Num int</span><br><span class="line">	&#125;</span><br><span class="line">	func main()&#123;</span><br><span class="line">		var a A</span><br><span class="line">		var b B</span><br><span class="line">		a=A(b) #将b强制转换为A结构体，这样做可行的原因是两个结构体有完全相同的字段（名字，个数和类型）</span><br><span class="line">	&#125;</span><br><span class="line">3.结构体可以使用type重新定义（相当于取别名），golang认为是新的数据类型，但是相互间可以强转</span><br><span class="line">	type Student struct&#123;</span><br><span class="line">		Name string</span><br><span class="line">		Age int</span><br><span class="line">	&#125;</span><br><span class="line">	type Stu Student</span><br><span class="line">	//上面其实同type integer int</span><br><span class="line">	func main()&#123;</span><br><span class="line">		var stu1 Student</span><br><span class="line">		var stu2 Stu</span><br><span class="line">		stu2=stu1  //这是会报错的，可以进行强转stu2=Stu(stu1)  </span><br><span class="line">	&#125;</span><br><span class="line">4.struct的每个字段上，可以写上一个tag,该tag可以通过反射机制进行获取，常见的使用场景就是序列化和反序列化</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面第四点的使用方式，即为什么需要这种方式</span></span><br><span class="line"><span class="comment">//为了输出json格式字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span>   <span class="comment">//  `json:&quot;name&quot;` 就是struct tag</span></span><br><span class="line">	Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Skill <span class="type">string</span> <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.创建一个Monster变量</span></span><br><span class="line">	monster := Monster&#123;<span class="string">&quot;牛魔王&quot;</span>,<span class="number">500</span>,<span class="string">&quot;芭蕉扇&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.将monster变量序列化为字符json格式的字符串</span></span><br><span class="line">	<span class="comment">//json.Marshal函数使用到了反射，将Name转化为name</span></span><br><span class="line">	jsonMonster,err := json.Marshal(monster)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;json 处理错误&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;json:&quot;</span>,<span class="type">string</span>(jsonMonster))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-方法的使用"><a href="#2-方法的使用" class="headerlink" title="2.方法的使用"></a>2.方法的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">在某些情况下，我们需要定义（声明）方法，比如在Person结构体中，除了有一些字段外（年龄、姓名），Person结构体还有一些行为，比如说话，吃饭等，这时就要用方法才能完成</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">golang中的方法是作用在指定的数据类型上（即：和指定的数据类型绑定），因此自定义类型，都可以有方法，而不仅仅是struct。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方法的声明和调用</span></span><br><span class="line">	type A struct&#123;</span><br><span class="line">		Num int</span><br><span class="line">	&#125;</span><br><span class="line">	func (a A) test()&#123;</span><br><span class="line">		fmp(a.Num)</span><br><span class="line">	&#125;</span><br><span class="line">	func main()&#123;</span><br><span class="line">		var a=A&#123;Num:12&#125;</span><br><span class="line">		a.test()</span><br><span class="line">	&#125;</span><br><span class="line">	说明：</span><br><span class="line">		1.func (a A) test()&#123;&#125;  表示A结构体有一方法，方法名为test</span><br><span class="line">		2.(a A)体现test方法是和A类型绑定的</span><br><span class="line">		3.定义的test方法只能通过A类型的变量进行调用</span><br><span class="line">		4.func (a A) test()其中</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法声明和使用的演示</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Person这个类型绑定一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> test() &#123;</span><br><span class="line">	p.Name=<span class="string">&quot;jack&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;test():&quot;</span>,p.Name)  <span class="comment">//输出jack</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> speak()  &#123;</span><br><span class="line">	fmt.Println(p.Name,<span class="string">&quot;是一个好人&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> jisaun()  &#123;</span><br><span class="line">	sum:=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		sum+=i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(p.Name,<span class="string">&quot;计算的结果是&quot;</span>,sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> jisaun2(n <span class="type">int</span>)  &#123;</span><br><span class="line">	sum:=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		sum+=i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(p.Name,<span class="string">&quot;计算的结果是&quot;</span>,sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> getSum(n1,n2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> p =Person&#123;Name:<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">	<span class="comment">//调用结构体中的方法</span></span><br><span class="line">	p.test()</span><br><span class="line">	p.speak()</span><br><span class="line">	p.jisaun()</span><br><span class="line">	p.jisaun2(<span class="number">10</span>)</span><br><span class="line">	res:=p.getSum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	fmt.Println(p.Name)   <span class="comment">//输出Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-方法的调用和传参机制（重要）"><a href="#3-方法的调用和传参机制（重要）" class="headerlink" title="3.方法的调用和传参机制（重要）"></a>3.方法的调用和传参机制（重要）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明</span></span><br><span class="line">1.方法的调用和传参机制与函数基本一样，不一样的地方是方法在调用时，会将调用方法的变量，当作实参传递给方法（如果变量是值类型，则进行值拷贝，如果变量是引用类型，则进行地址拷贝）</span><br></pre></td></tr></table></figure>

<h3 id="4-方法的使用细节和注意事项"><a href="#4-方法的使用细节和注意事项" class="headerlink" title="4.方法的使用细节和注意事项"></a>4.方法的使用细节和注意事项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.结构体是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式</span><br><span class="line">2.如果程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理</span><br><span class="line">3.golang中的方法作用在指定的数据类型上（即和指定的数据类型绑定），因此自定义类型，都可以有方法，而不仅仅是struct,比如int，float32等也可以有方法</span><br><span class="line">4.方法的访问范围控制的规则，和函数一样，方法名首字母小写，只能在本包访问，方法首字母大写，可以在本包和其他包中访问</span><br><span class="line">5.#如果一个类型实现了String()这个方法，那么fmt.Pringln(变量名)默认会调用这个变量的String()进行输出</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法调用的演示  通常使用指针进行调用</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span>&#123;</span><br><span class="line">	Radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">	c.Radius=<span class="number">5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span>*c.Radius*c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> area2() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="comment">//return 3.14*(*c).Radius*(*c).Radius</span></span><br><span class="line"></span><br><span class="line">	c.Radius=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//理应是上面这种写法，但是go语言底层进行了优化，就也支持下面这种方式</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span>*c.Radius*c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> c Circle</span><br><span class="line">	<span class="keyword">var</span> c2 Circle</span><br><span class="line">	c.Radius=<span class="number">10</span></span><br><span class="line">	c2.Radius=<span class="number">10</span></span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(c2)</span><br><span class="line">	<span class="comment">//(&amp;c).area()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//理应是上面这种写法，go语言底层也给进行了优化，支持下面这种写法</span></span><br><span class="line">	res:=c.area()</span><br><span class="line">	res2:=c2.area2()</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(c2)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	fmt.Println(res2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第3点演示——--给自定义类型绑定方法演示</span></span><br><span class="line"><span class="keyword">type</span> floatAlias <span class="type">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n floatAlias)</span></span> getArea() <span class="type">float64</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(<span class="number">3.14</span> * n * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *floatAlias)</span></span> getArea2() <span class="type">float64</span>&#123;</span><br><span class="line">	*n=<span class="number">5.0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(<span class="number">3.14</span> * (*n) * (*n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> f floatAlias</span><br><span class="line">	f=<span class="number">10.0</span></span><br><span class="line">	res:=f.getArea()</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第5点演示  如果一个类型实现了String()这个方法，那么fmt.Pringln(变量名)默认会调用这个变量的String()进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> String()  <span class="type">string</span>&#123;</span><br><span class="line">	str:=fmt.Sprintf(<span class="string">&quot;Name=[%v],Age=[%v]&quot;</span>,stu.Name,stu.Age)</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> stu =Student&#123;Name:<span class="string">&quot;haha&quot;</span>,Age:<span class="number">12</span>&#125;</span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">	fmt.Println(&amp;stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-方法和函数区别"><a href="#5-方法和函数区别" class="headerlink" title="5.方法和函数区别"></a>5.方法和函数区别</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.调用方式不一样</span><br><span class="line">	函数的调用方式：	函数名（实参列表）</span><br><span class="line">	方法的调用方式：	变量.方法名（实参列表）</span><br><span class="line">2.对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然</span><br><span class="line">3.对于方法（如struct的方法），接收者为值类型时，可以直接使用指针类型的变量调用方法，反过来同样也可以。</span><br><span class="line">	总结：方法不论调用形式如何，真正决定是值拷贝还是地址拷贝，看这个方法是和哪个类型绑定</span><br><span class="line">		（p Person）  值拷贝</span><br><span class="line">		（p *Person） 地址拷贝</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示3.对于方法（如struct的方法），接收者为值类型时，可以直接使用指针类型的变量调用方法，反过来同样也可以。</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> String()  <span class="type">string</span>&#123;</span><br><span class="line">	str:=fmt.Sprintf(<span class="string">&quot;Name=[%v],Age=[%v]&quot;</span>,stu.Name,stu.Age)</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span></span> String2()  <span class="type">string</span>&#123;</span><br><span class="line">	str:=fmt.Sprintf(<span class="string">&quot;Name=[%v],Age=[%v]&quot;</span>,stu.Name,stu.Age)</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> stu =Student&#123;Name:<span class="string">&quot;haha&quot;</span>,Age:<span class="number">12</span>&#125;</span><br><span class="line">    <span class="comment">//看方法能不能修改外面的内容，主要看方法里面绑定的是变量值类型还是地址类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//即便是值传入，但是仍然是地址拷贝，方法里面的修改会修改外面的内容</span></span><br><span class="line">	stu.String()</span><br><span class="line">	(&amp;stu).String()</span><br><span class="line">    stu.String2()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//即便是地址传入，但是仍然是值拷贝，方法里面的修改不会修改外面的内容</span></span><br><span class="line">    (&amp;stu).String2()</span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">	fmt.Println(&amp;stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-面向对象编程应用实例"><a href="#6-面向对象编程应用实例" class="headerlink" title="6.面向对象编程应用实例"></a>6.面向对象编程应用实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">步骤</span></span><br><span class="line">1.声明（定义）结构体，确定结构体名</span><br><span class="line">2.编写结构体的字段</span><br><span class="line">3.编写结构体的方法</span><br></pre></td></tr></table></figure>

<h3 id="7-创建结构体指定字段值"><a href="#7-创建结构体指定字段值" class="headerlink" title="7.创建结构体指定字段值"></a>7.创建结构体指定字段值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type Student struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line">方式1:</span><br><span class="line">	var stu =Student&#123;&quot;hehe&quot;,12&#125;</span><br><span class="line">		stu :=Student&#123;&quot;hehe&quot;,12&#125;</span><br><span class="line">方式2：</span><br><span class="line">	var stu =Student&#123;Name:&quot;hehe&quot;,Age:12&#125;</span><br><span class="line">		stu :=Student&#123;Name:&quot;hehe&quot;,Age:12&#125;</span><br><span class="line">方式3：</span><br><span class="line">	//顺序可以颠倒</span><br><span class="line">	var stu =Student&#123;Age:12,Name:&quot;hehe&quot;&#125;</span><br><span class="line">	//可以只赋部分字段的值</span><br><span class="line">	var stu =Student&#123;Name:&quot;hehe&quot;&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式4：</span></span><br><span class="line">	var stu3 =&amp;Student&#123;Name:&quot;haha&quot;,Age:12&#125;</span><br><span class="line">    fmt.Println(stu3)  //输出结果为： &amp;&#123;haha 12&#125;  ||stu3的类型：*main.Student</span><br><span class="line">    fmt.Println(*stu3) //输出结果为： &#123;haha 12&#125;	||*stu3的类型：main.Student</span><br><span class="line">    fmt.Println(stu3.Name)  //输出结果为haha</span><br><span class="line">	fmt.Println(stu3.Age)   //输出结果为12</span><br><span class="line">	fmt.Println((*stu3).Name) //输出结果为haha</span><br><span class="line">	fmt.Println((*stu3).Age) //输出结果为12</span><br></pre></td></tr></table></figure>

<h3 id="8-工厂模式"><a href="#8-工厂模式" class="headerlink" title="8.工厂模式"></a>8.工厂模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明</span></span><br><span class="line">golang中没有构造函数，通常可以使用工厂模式来解决这个问题</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么引入工厂模式</span></span><br><span class="line">	当一个包model中的结构体type student struct&#123;&#125;中的student首字母是小写的时候，在其他包如main中需要使用student这个结构体，这个时候就需要引入工厂模式来解决</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用工厂模式实现跨包创建结构体实例（变量）的案例</span></span><br><span class="line">	1.如果model包中的student首字母大写直接引入使用没有问题</span><br><span class="line">	2.如果model包中的结构体变量首字母小写，引入后，不能直接使用，可以工厂模式解决，其中结构体字段首字母时小写时，解决方法与上面是一样的</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211021175813731.png" alt="image-20211021175813731"></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211021175829967.png" alt="image-20211021175829967"></p>
<h2 id="第七章：面向对象编程（下）"><a href="#第七章：面向对象编程（下）" class="headerlink" title="第七章：面向对象编程（下）"></a>第七章：面向对象编程（下）</h2><h3 id="1-面向对象编程三大特性"><a href="#1-面向对象编程三大特性" class="headerlink" title="1.面向对象编程三大特性"></a>1.面向对象编程三大特性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">go语言中也有封装，继承，多态三大特性，只是实现方式与其他OOP语言不太一样。</span><br></pre></td></tr></table></figure>

<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">封装介绍</span></span><br><span class="line">1.封装就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">封装的好处</span></span><br><span class="line">1.隐藏实现细节</span><br><span class="line">2.还可以对数据进行验证，保证安全</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如何体现封装</span></span><br><span class="line">1.对结构体中的属性进行封装</span><br><span class="line">2.通过方法，包实现封装</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">封装的实现步骤</span></span><br><span class="line">    1.将结构体、字段（属性）的首字母小写（不能导出了，其他包不能直接使用，类似加上private）</span><br><span class="line">    2.将结构体所在包提供一个工厂模式的函数，首字母大写，类似一个构造函数</span><br><span class="line">    3.提供一个首字母大写的Set方法（类似其他语言的public），用于对属性判断并赋值</span><br><span class="line">        func (变量v 结构体类型名) SetXxxx(参数列表) &#123;</span><br><span class="line">            //加入数据验证的业务逻辑</span><br><span class="line">            变量v.字段名=参数</span><br><span class="line">        &#125;</span><br><span class="line">    4.提供一个首字母大写的Get方法（类似其他语言的pubic），用于获取属性的值</span><br><span class="line">        func (变量v 结构体类型名) GetXxxx() （返回值列表）&#123;</span><br><span class="line">            return 变量v.字段</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta prompt_">  	#</span><span class="language-bash">特别说明：在golang开发中并没有特别强调封装，这点不像java,golang本身对面向对象的特性做了简化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例：</span></span><br><span class="line">	看一个程序person.go,不能随便查看人的年龄，工资等隐私，并对输入的年龄进行合理的验证</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例演示</span></span><br><span class="line"><span class="comment">//model person.go</span></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">	age    <span class="type">int</span></span><br><span class="line">	salary <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们通过工厂模式来让其他包使用这个person结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Person</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;person&#123;Name: name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了让其他包能获取person结构体里面的age,salary字段,我们提供Set/Get方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetAge(age <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span> &#123;</span><br><span class="line">		p.age = age</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;超出年龄范围&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> GetAge() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetSalary(salary <span class="type">float64</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> salary &gt; <span class="number">3000</span> &amp;&amp; salary &lt; <span class="number">30000</span> &#123;</span><br><span class="line">		p.salary = salary</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;超出薪资范围&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> GetSalary() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.salary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;go_code/project01/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p=model.Person(<span class="string">&quot;王五&quot;</span>)</span><br><span class="line">	p.SetAge(<span class="number">45</span>)</span><br><span class="line">	p.SetSalary(<span class="number">13000</span>)</span><br><span class="line">	fmt.Println(p.Name)</span><br><span class="line">	fmt.Println(p.GetAge())</span><br><span class="line">	fmt.Println(p.GetSalary())</span><br><span class="line">	fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么需要继承</span></span><br><span class="line">因为代码冗余，维护比较复杂，所以我们引入继承，来增加代码复用，和功能的扩展</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">当多个结构体存在相同的属性（字段）和方法时，如小学生，高中生，大学生等结构体，可以从这些结构体中抽象出结构体如学生student,在该结构体中定义这些相同的属性和方法。</span><br><span class="line">此时，在其他的结构体中不需要重新定义这些属性和方法，只需嵌套一个Student匿名结构体即可</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">总结：在golang中，如果一个struct中嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性。</span></span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	type Goods struct&#123;</span><br><span class="line">        Name string</span><br><span class="line">        Price int</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    type Book struct&#123;</span><br><span class="line">        Goods  //这里就是嵌套匿名结构体Goods</span><br><span class="line">        Writer string</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门-1"><a href="#2-快速入门-1" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示案例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Price <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(good *Goods)</span></span> Introduction()  &#123;</span><br><span class="line">	fmt.Println(good.Name,<span class="string">&quot;的价格:&quot;</span>,good.Price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span>&#123;</span><br><span class="line">	Goods  <span class="comment">//这里就是嵌套匿名结构体Goods</span></span><br><span class="line">	<span class="comment">//特有字段</span></span><br><span class="line">	Writer <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Book的特有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Book)</span></span> PrintWriter()  &#123;</span><br><span class="line">	fmt.Println(b.Name,<span class="string">&quot;的作者是&quot;</span>,b.Writer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Light <span class="keyword">struct</span>&#123;</span><br><span class="line">	Goods  <span class="comment">//这里就是嵌套匿名结构体Goods</span></span><br><span class="line">    good Goods<span class="comment">//有名结构体，在访问有名结构体的字段和方法时，就必须带上这个名字good，即 l.good.Price=12</span></span><br><span class="line">	<span class="comment">//特有字段</span></span><br><span class="line">	Owner <span class="type">string</span></span><br><span class="line">   	<span class="comment">//可以与匿名结构体有相同的字段和方法,访问时采用就近原则</span></span><br><span class="line">    <span class="comment">//Name string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Light的特有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Light)</span></span> PrintOwner()  &#123;</span><br><span class="line">	fmt.Println(l.Name,<span class="string">&quot;的发明者是&quot;</span>,l.Owner)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b Book</span><br><span class="line">	<span class="comment">//下面这两种方式都可以</span></span><br><span class="line">	b.Goods.Name=<span class="string">&quot;海底两万里&quot;</span></span><br><span class="line">	b.Name=<span class="string">&quot;海底两万里&quot;</span></span><br><span class="line">	b.Price=<span class="number">12</span></span><br><span class="line">	b.Writer=<span class="string">&quot;凡尔赛&quot;</span></span><br><span class="line">	b.Introduction()</span><br><span class="line">	b.Goods.Introduction()</span><br><span class="line">	b.PrintWriter()</span><br><span class="line">	fmt.Println(b)   <span class="comment">//&#123;&#123;海底两万里 12&#125; 凡尔赛&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> l Light</span><br><span class="line">	<span class="comment">//下面这两种方式都可以</span></span><br><span class="line">	l.Goods.Name=<span class="string">&quot;电灯泡&quot;</span></span><br><span class="line">	l.Name=<span class="string">&quot;电灯泡&quot;</span></span><br><span class="line">	l.Price=<span class="number">5</span></span><br><span class="line">	l.Owner=<span class="string">&quot;爱迪生&quot;</span></span><br><span class="line">	l.Introduction()</span><br><span class="line">	l.Goods.Introduction()</span><br><span class="line">	l.PrintOwner()</span><br><span class="line">	fmt.Println(l.Goods)  <span class="comment">//&#123;电灯泡 5&#125;</span></span><br><span class="line">	fmt.Println(l)    <span class="comment">//&#123;&#123;电灯泡 5&#125; 爱迪生&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-继承的深入讨论"><a href="#3-继承的深入讨论" class="headerlink" title="3.继承的深入讨论"></a>3.继承的深入讨论</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.结构体可以使用嵌套匿名结构体中所有的字段和方法。即：首字母大写或者小写的字段、方法，都可以使用(大小写只针对是否在同一个包中)</span><br><span class="line">2.匿名结构体字段和方法可以简化</span><br><span class="line">	如上面案例: b.Goods.Name=&quot;海底两万里&quot;可以简化为 b.Name=&quot;海底两万里&quot;</span><br><span class="line">			  b.Goods.Introdution()可以简化为b.Introduction()</span><br><span class="line">3.当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则，如希望访问匿名结构体的字段和方法时，可以通过匿名结构体名来区分</span><br><span class="line">4.结构体嵌入两个（或多个）匿名结构体，如果两个匿名结构体中有相同的字段和方法（同时结构体本身没有同名的字段和方法时），在访问时，就必须指定匿名结构体名字，否则编译出错</span><br><span class="line">5.如果一个struct嵌套了一个有名结构体，这种方式就是组合，如果是组合关系，那么在访问组合的结构体的字段和方法时，必须带上结构体的名字</span><br><span class="line">6.嵌套匿名结构体时后，也可以在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值</span><br><span class="line">	例如：下面这几种方式都可以</span><br><span class="line">	var b2 =Book&#123;Goods:Goods&#123;Name: &quot;平凡的世界&quot;,Price: 123,discount: 0.7&#125;,Writer: &quot;路遥&quot;&#125;</span><br><span class="line">	var b3 =Book&#123;Goods&#123;Name: &quot;平凡的世界&quot;,Price: 123,discount: 0.7&#125;, &quot;路遥&quot;&#125;</span><br><span class="line">	var b4 =Book&#123;Goods:Goods&#123;Name: &quot;平凡的世界&quot;,Price: 123,discount: 0.7&#125;&#125;</span><br><span class="line">	var b5 =Book&#123;Writer:&quot;路遥&quot;,Goods:Goods&#123;Name: &quot;平凡的世界&quot;,Price: 123,discount: 0.7&#125;&#125;</span><br><span class="line">7.也可以在结构体中使用匿名结构体的指针进行传入</span><br><span class="line">	如 </span><br><span class="line">	type Light struct&#123;</span><br><span class="line">		*Goods</span><br><span class="line">        Owner string</span><br><span class="line">	&#125;</span><br><span class="line">	var light =Light&#123;Goods:&amp;Goods&#123;Name: &quot;电灯泡&quot;,Price: 3,discount: 0.9&#125;,Owner: &quot;爱迪生&quot;&#125;</span><br><span class="line">	fmt.Println(*light.Goods,&quot; &quot;,light.Owner)  //&#123;电灯泡 3 0.9&#125;   爱迪生</span><br><span class="line">8.我们既可以将结构体类型作为匿名字段传给一个结构体，同时还可以将基本类型作为匿名字段传入</span><br><span class="line">	如：</span><br><span class="line">	type Light struct&#123;</span><br><span class="line">		*Goods</span><br><span class="line">		int  //匿名的基本类型</span><br><span class="line">		n int</span><br><span class="line">        Owner string</span><br><span class="line">	&#125;</span><br><span class="line">	var light Light</span><br><span class="line">	light.int=10</span><br><span class="line">	light.n=20</span><br><span class="line">	//说明一个结构体中有一个匿名的int字段时，就不能有第二个匿名int字段，如果要有，就用名字区分，如n int</span><br></pre></td></tr></table></figure>

<h4 id="4-多重继承"><a href="#4-多重继承" class="headerlink" title="4.多重继承"></a>4.多重继承</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.如果一个struct中嵌套了多个匿名结构体，那么该结构体可以直接访问所有嵌套的匿名结构体的字段和方法，从而实现了多重继承。java不支持多继承，但支持多实现</span><br><span class="line">	//如Graduate继承了Person,Student</span><br><span class="line">	type Graduate struct&#123;</span><br><span class="line">		Person</span><br><span class="line">		Student</span><br><span class="line">		Name string</span><br><span class="line">	&#125;</span><br><span class="line">2.为了代码的简洁性，建议大家尽量不使用多重继承</span><br></pre></td></tr></table></figure>

<h3 id="4-接口-interface"><a href="#4-接口-interface" class="headerlink" title="4.接口(interface)"></a>4.接口(interface)</h3><h4 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.在golang中，多态的特性主要是通过接口来体现的。</span><br><span class="line">2.interface类型可以定义一组方法，但是这些不需要实现，并且interface不能包含任何变量，到某个自定义类型（比如结构体Phone）要使用的时候，再根据实际情况把这些方法写出来</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">    type 接口名 interface&#123;</span><br><span class="line">        //声明了两个没有实现的方法</span><br><span class="line">        Method1(参数列表) 返回值列表</span><br><span class="line">        Method2(参数列表) 返回值列表</span><br><span class="line">    &#125;</span><br><span class="line">    实现接口的语法如</span><br><span class="line">    type 自定义类型 struct&#123;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //让Phone实现Usb接口的方法 注意必须是接口中的所有方法</span><br><span class="line">    func (p 自定义类型) Method1(参数列表) 返回值列表&#123;</span><br><span class="line">        //具体实现</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func (p 自定义类型) Method2(参数列表) 返回值列表&#123;</span><br><span class="line">        //具体实现</span><br><span class="line">    &#125;</span><br><span class="line">    说明：</span><br><span class="line">    	1.接口里的所有方法都没有方法体，即没有实现，体现了程序设计的多态和高内聚低耦合的思想</span><br><span class="line">    	2.#golang中的接口，不需要显示的实现，只要一个变量，含有接口类型中的所有方法，那么这个变量就实现了这个接口，因此，golang中没有implements关键字</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门-2"><a href="#2-快速入门-2" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="comment">//声明/定义一个接口</span></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span>&#123;</span><br><span class="line">	<span class="comment">//声明了两个没有实现的方法</span></span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让Phone实现Usb接口的方法 注意必须是接口中的所有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机开始工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机停止工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让Camera实现Usb接口的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机开始工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机停止工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不一定只有struct能实现接口，下面的这种类型也可以</span></span><br><span class="line"><span class="keyword">type</span> integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i integer)</span></span> Start()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;int工作了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i integer)</span></span> Stop()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;int停止了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算机</span></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个Working方法，接收一个Usb接口类型变量</span></span><br><span class="line"><span class="comment">//只要是实现了Usb接口，所谓实现Usb接口，就是指实现了接口中所有的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span></span> Working(usb Usb)&#123;</span><br><span class="line">	<span class="comment">//通过usb接口变量来调用Start和Stop方法</span></span><br><span class="line">	usb.Start()</span><br><span class="line">	usb.Stop()</span><br><span class="line">	fmt.Println(<span class="string">&quot;计算机开始工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">	<span class="comment">//先创建结构体变量</span></span><br><span class="line">	computer:=Computer&#123;&#125;</span><br><span class="line">	phone:=Phone&#123;&#125;</span><br><span class="line">	camera:=Camera&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键点</span></span><br><span class="line">	computer.Working(phone)</span><br><span class="line">	computer.Working(camera)</span><br><span class="line">    computer.Working(integer(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-接口的注意事项和使用细节"><a href="#3-接口的注意事项和使用细节" class="headerlink" title="3.接口的注意事项和使用细节"></a>3.接口的注意事项和使用细节</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1.接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量（实例）</span><br><span class="line">	如：var u Usb=camera  </span><br><span class="line">	   computer.Working(u)</span><br><span class="line">2.接口中所有的方法都没有方法体，即都是没有实现的方法</span><br><span class="line">3.一个自定义类型需要将某个接口中的所有方法都实现，就说这个自定义类型实现了这个接口</span><br><span class="line">4.一个自定义类型只有实现了某个接口，才能将该自定义类型的实例（变量）赋给接口类型</span><br><span class="line">5.只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型。如type integer int&#123;&#125;类型也可以</span><br><span class="line">6.一个自定义类型可以实现多个接口，只要实现了这些接口中的方法就可以了</span><br><span class="line">7.golang接口中不能有任何变量</span><br><span class="line">8.#一个接口（比如A接口）可以继承多个别的接口（比如B,C接口）,这时如果要实现A接口，也必须将B,C接口的方法也全部实现。同时接口只能继承接口，不能继承类</span><br><span class="line">	如：</span><br><span class="line">		type Object interface&#123;</span><br><span class="line">            Equal()</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">//Usb接口继承了Object接口</span></span><br><span class="line">        type Usb interface&#123;</span><br><span class="line">        	//Usb类型继承Object接口</span><br><span class="line">            Object</span><br><span class="line">            //声明了两个没有实现的方法</span><br><span class="line">            Start()</span><br><span class="line">            Stop()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #这时Phone结构体类型要实现Usb接口，就必须要实现Usb接口中的方法，并且还有Object接口中的方法</span><br><span class="line">        type Phone struct&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //让Phone实现Usb接口的方法 注意必须是接口中的所有方法</span><br><span class="line">        func (p Phone) Start() &#123;</span><br><span class="line">            fmt.Println(&quot;手机开始工作&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        func (p Phone) Stop() &#123;</span><br><span class="line">            fmt.Println(&quot;手机停止工作&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        func (p Phone) Equal() &#123;</span><br><span class="line">            fmt.Println(&quot;手机比较工作&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">9.interface类型默认是一个指针（引用类型），如果没有对interface初始化就使用，那么会输出nil</span><br><span class="line">10.#空接口interface&#123;&#125; 没有任何方法，所以所有类型都实现了空接口，那么空接口的变量可以接收任何类型的变量。</span><br><span class="line">	如 </span><br><span class="line">	type Object interface&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	var phone Phone</span><br><span class="line">	var obj Object=phone</span><br><span class="line">	var t2 interface&#123;&#125;=stu</span><br><span class="line">	var num float64=1.23</span><br><span class="line">    t2=num</span><br><span class="line">    obj=num</span><br><span class="line">    fmt.Println(t2,&quot; &quot;,obj)</span><br></pre></td></tr></table></figure>

<h4 id="4-易错练习"><a href="#4-易错练习" class="headerlink" title="4.易错练习"></a>4.易错练习</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="keyword">type</span> AInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Test01()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DStruct <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里是 *DStruct类型实现了AInterface接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DStruct)</span></span> Test01()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Test01&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d DStruct</span><br><span class="line">	<span class="keyword">var</span> a AInterface</span><br><span class="line">    <span class="comment">//因此在赋值给接口变量时，也只能将DStruct的指针类型赋给接口类型变量，否则报错</span></span><br><span class="line">	a=&amp;d</span><br><span class="line">	a.Test01()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-接口最佳实践"><a href="#5-接口最佳实践" class="headerlink" title="5.接口最佳实践"></a>5.接口最佳实践</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：实现Hero结构体排序</span></span><br><span class="line"><span class="comment">//1.声明Hero结构体</span></span><br><span class="line"><span class="keyword">type</span> Hero <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明一个Hero结构体的切片类型</span></span><br><span class="line"><span class="keyword">type</span> HeroSlice []Hero</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.实现Interface,即要实现下面这三个方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//type Interface interface &#123;</span></span><br><span class="line"><span class="comment">//	// Len方法返回集合中的元素个数</span></span><br><span class="line"><span class="comment">//	Len() int</span></span><br><span class="line"><span class="comment">//	// Less方法报告索引i的元素是否比索引j的元素小</span></span><br><span class="line"><span class="comment">//	Less(i, j int) bool</span></span><br><span class="line"><span class="comment">//	// Swap方法交换索引i和j的两个元素</span></span><br><span class="line"><span class="comment">//	Swap(i, j int)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs HeroSlice)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(hs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法决定了是按什么标准进行排序的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs HeroSlice)</span></span> Less(i,j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">//按照年龄进行排序</span></span><br><span class="line">	<span class="comment">//return hs[i].Age&lt;hs[j].Age</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//按照名字进行排序</span></span><br><span class="line">	<span class="keyword">return</span> hs[i].Name&lt;hs[j].Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs HeroSlice)</span></span> Swap(i,j <span class="type">int</span>)  &#123;</span><br><span class="line">	<span class="comment">//交换</span></span><br><span class="line">	<span class="comment">//temp:=hs[i]</span></span><br><span class="line">	<span class="comment">//hs[i]=hs[j]</span></span><br><span class="line">	<span class="comment">//hs[j]=temp</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面一句话等同于上面三句话</span></span><br><span class="line">	hs[i],hs[j]=hs[j],hs[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hs:=<span class="built_in">make</span>([]Hero,<span class="number">6</span>,<span class="number">6</span>)</span><br><span class="line">	hs[<span class="number">0</span>]=Hero&#123;<span class="string">&quot;hehe&quot;</span>,<span class="number">12</span>&#125;</span><br><span class="line">	hs[<span class="number">1</span>]=Hero&#123;<span class="string">&quot;haha&quot;</span>,<span class="number">32</span>&#125;</span><br><span class="line">	hs[<span class="number">2</span>]=Hero&#123;<span class="string">&quot;xixi&quot;</span>,<span class="number">2</span>&#125;</span><br><span class="line">	hs[<span class="number">3</span>]=Hero&#123;<span class="string">&quot;hiahia&quot;</span>,<span class="number">42</span>&#125;</span><br><span class="line">	hs[<span class="number">4</span>]=Hero&#123;<span class="string">&quot;haihai&quot;</span>,<span class="number">22</span>&#125;</span><br><span class="line">	hs[<span class="number">5</span>]=Hero&#123;<span class="string">&quot;heihei&quot;</span>,<span class="number">2</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;排序前：&quot;</span>,hs)</span><br><span class="line">	sort.Sort(HeroSlice(hs))</span><br><span class="line">	fmt.Println(<span class="string">&quot;排序后：&quot;</span>,hs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-接口和继承"><a href="#6-接口和继承" class="headerlink" title="6.接口和继承"></a>6.接口和继承</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.实现接口可以看作是对继承的一种补充，并且不会对原有的继承关系产生影响</span><br><span class="line">2.接口和继承解决的问题是不一样的</span><br><span class="line">	继承的价值主要在于：解决代码的复用性和可维护性</span><br><span class="line">	接口的价值主要在于：设计，设计好各种规范（方法），让其他自定义类型去实现这些方法</span><br><span class="line">3.接口比继承更灵活</span><br><span class="line">	继承是满足is-a的关系，接口只需满足like-a的关系</span><br><span class="line">4.接口在一定程度上实现代码</span><br></pre></td></tr></table></figure>

<h3 id="7-多态"><a href="#7-多态" class="headerlink" title="7.多态"></a>7.多态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">变量（实例）具有多种形态，面向对象的第三大特征，在Go语言，多态特征是通过接口实现的，可以按照统一的接口来调用不同的实现。这时接口变量就呈现不同的形态。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">快速入门</span></span><br><span class="line">在前面的Usb接口案例，Usb usb,这既可以接收手机变量，也可以接收相机变量，这时就体现了Usb接口的多态特性</span><br><span class="line">func (c Computer) Working(usb Usb)&#123;&#125;  //这里面的usb变量会根据传入的形参，来判断底层是Phone还是相机</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">接口体现多态特征</span></span><br><span class="line">1.多态参数</span><br><span class="line">	在前面的Usb接口案例中，usb Usb,既可以接收手机变量，也可以接收相机变量，就体现了Usb接口多态</span><br><span class="line">2.多态数组</span><br><span class="line">	演示一个案例：给Usb数组中，存放Phone结构体，Camera结构体，Phone还有一个特有的方法Call(),请遍历Usb数	组，如果是Phone变量，除了调用Usb接口声明的方法外，还需要调用Phone特有方法call</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多态数组以及类型断言的代码演示</span></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	Test01()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Test01()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone Test01&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Call()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone Call&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Test01()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;camera Test01&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">3</span>]Usb</span><br><span class="line">	arr[<span class="number">0</span>]=Phone&#123;<span class="string">&quot;xiaomi&quot;</span>&#125;</span><br><span class="line">	arr[<span class="number">1</span>]=Phone&#123;<span class="string">&quot;vivo&quot;</span>&#125;</span><br><span class="line">	arr[<span class="number">2</span>]=Camera&#123;<span class="string">&quot;nikang&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="comment">//需求：如果是Phone变量，就还需要调用Phone变量中的Call方法</span></span><br><span class="line">		p,ok:=arr[i].(Phone)  <span class="comment">//使用带检测的类型断言进行判断</span></span><br><span class="line">		<span class="keyword">if</span> ok&#123;</span><br><span class="line">            <span class="comment">//类型转换成功，就调用Phone中的方法</span></span><br><span class="line">			p.Call()</span><br><span class="line">		&#125;</span><br><span class="line">		arr[i].Test01()</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-类型断言"><a href="#8-类型断言" class="headerlink" title="8.类型断言"></a>8.类型断言</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">引出类型断言</span></span><br><span class="line">	func main()&#123;</span><br><span class="line">		var a interface&#123;&#125;</span><br><span class="line">        var point Phone=Phone&#123;&quot;nihao&quot;&#125;</span><br><span class="line">        a=point</span><br><span class="line">        var b Phone</span><br><span class="line">        var c Camera</span><br><span class="line">        b= a.(Phone)   #类型断言</span><br><span class="line">        c,ok:=a.(Camera)  #带检测的类型断言</span><br><span class="line">        if ok&#123;</span><br><span class="line">            fmt.Println(&quot;转换成功&quot;)</span><br><span class="line">            fmt.Printf(&quot;c的类型是%T,c的值是%v&quot;,c,c)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            fmt.Println(&quot;转换失败&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(b)</span><br><span class="line">	&#125;</span><br><span class="line">	说明：</span><br><span class="line">		b=a.(Point)是类型断言，如果可以转换就成功，否则就运行出错，因此在类型断言时，要确保类型一致。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">类型断言</span></span><br><span class="line">由于接口是一般类型，不知道具体类型，如果要转换成具体类型，就需要使用类型断言，具体的如上演示。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如何在进行断言时，带上检查机制，如果成功就ok,否则也不要报Panic</span></span><br></pre></td></tr></table></figure>

<h4 id="1-类型断言的最佳实践"><a href="#1-类型断言的最佳实践" class="headerlink" title="1.类型断言的最佳实践"></a>1.类型断言的最佳实践</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个函数，可以判断输入的参数是什么类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeJudge</span><span class="params">(item ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心注意   switch x.(type)</span></span><br><span class="line">	<span class="keyword">for</span> index,x:=<span class="keyword">range</span> item&#123;</span><br><span class="line">		<span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 bool类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> <span class="type">float32</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 float32类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 float64类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> <span class="type">int</span>,<span class="type">int32</span>,<span class="type">int64</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 整数类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 string类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">            <span class="keyword">case</span> Student:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 Student类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> *Student:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 *Student类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 类型不匹配，值是%v\n&quot;</span>,index,x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n1 <span class="type">float32</span>=<span class="number">1.1</span></span><br><span class="line">	<span class="keyword">var</span> n2 <span class="type">float64</span>=<span class="number">1.1</span></span><br><span class="line">	<span class="keyword">var</span> n3 <span class="type">int</span>=<span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> n4 <span class="type">int32</span>=<span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> n5 <span class="type">int64</span>=<span class="number">111</span></span><br><span class="line">	<span class="keyword">var</span> n6 <span class="type">string</span>=<span class="string">&quot;1111&quot;</span></span><br><span class="line">	<span class="keyword">var</span> stu=Student&#123;&#125;</span><br><span class="line">	TypeJudge(n1,n2,n3,n4,n5,n6,stu,&amp;stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第八章：项目练手"><a href="#第八章：项目练手" class="headerlink" title="第八章：项目练手"></a>第八章：项目练手</h2><h3 id="1-项目1：家庭收支记账软件"><a href="#1-项目1：家庭收支记账软件" class="headerlink" title="1.项目1：家庭收支记账软件"></a>1.项目1：家庭收支记账软件</h3><h3 id="2-项目2：客户管理系统"><a href="#2-项目2：客户管理系统" class="headerlink" title="2.项目2：客户管理系统"></a>2.项目2：客户管理系统</h3><h2 id="第九章：文件、命令行参数、json数据处理"><a href="#第九章：文件、命令行参数、json数据处理" class="headerlink" title="第九章：文件、命令行参数、json数据处理"></a>第九章：文件、命令行参数、json数据处理</h2><h3 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">文件是数据源，保存数据的的地方。文件在程序中是以流的形式来操作的。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">流：数据在数据源（文件）和程序（内存）之间经历的路径</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入流（读文件）：数据从数据源（文件）到程序（内存）的路径</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出流（写文件）：数据从程序（内存）到数据源（文件）的路径</span></span><br><span class="line"></span><br><span class="line">1.os.File封装所有文件相关操作，File是一个结构体。这个在os包中。后面会经常使用</span><br></pre></td></tr></table></figure>

<h3 id="2-常见的文件操作函数和方法"><a href="#2-常见的文件操作函数和方法" class="headerlink" title="2.常见的文件操作函数和方法"></a>2.常见的文件操作函数和方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.打开一个文件进行读操作：</span><br><span class="line">	os.Open(name string) (*File,error)</span><br><span class="line">	func Open</span><br><span class="line">    func Open(name string) (file *File, err error)</span><br><span class="line">    Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有			O_RDONLY模式。如果出错，错误底层类型是*PathError。</span><br><span class="line">2.关闭一个文件：</span><br><span class="line">	File.Close()  </span><br><span class="line">	func (*File) Close</span><br><span class="line">    func (f *File) Close() error</span><br><span class="line">    Close关闭文件f，使文件不能用于读写。它返回可能出现的错误。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开文件  输入绝对路径</span></span><br><span class="line">	file,err:=os.Open(<span class="string">&quot;d:/123.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err &quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出下文件，看看文件是什么,看出文件就是一个指针 *File</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;file=%v&quot;</span>,file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-读文件操作应用实例"><a href="#3-读文件操作应用实例" class="headerlink" title="3.读文件操作应用实例"></a>3.读文件操作应用实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.读取文件的内容并显示在终端（带缓冲区的方式），使用os.Open,file.Close,bufio.NewReader(),reader.ReadString函数和方法</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.案例演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开文件</span></span><br><span class="line">	file,err:=os.Open(<span class="string">&quot;d:/123.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err &quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出下文件，看看文件是什么,看出文件就是一个指针 *File</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;file=%v\n&quot;</span>,file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当函数退出时，要及时的关闭file文件</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()  <span class="comment">//要及时关闭file句柄，否则会有内存泄漏</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个 *Reader ,是带缓冲的</span></span><br><span class="line">	<span class="comment">//func NewReader</span></span><br><span class="line">	<span class="comment">//func NewReader(rd io.Reader) *Reader</span></span><br><span class="line">	<span class="comment">//NewReader创建一个具有默认大小缓冲、从r读取的*Reader。</span></span><br><span class="line">	<span class="comment">//const(defaultBufSize=4096)  //默认的缓冲区大小为4096</span></span><br><span class="line">	reader:=bufio.NewReader(file)</span><br><span class="line">	<span class="comment">//循环的读取文件内容</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		str,err:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)  <span class="comment">//读到一个换行就结束</span></span><br><span class="line">		<span class="keyword">if</span> err==io.EOF&#123;  <span class="comment">// io.EOF表示文件的末尾</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出内容</span></span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.读取文件的内容并显示在终端（使用ioutil一次将整个文件读入到内存中），这种方式适用于文件不大的情况，相关函数和函数（ioutil.ReadFile）</span><br><span class="line">func ReadFile</span><br><span class="line">func ReadFile(filename string) ([]byte, error)</span><br><span class="line">ReadFile 从filename指定的文件中读取数据并返回文件的内容。成功的调用返回的err为nil而非EOF。因为本函数定义为读取整个文件，它不会将读取返回的EOF视为应报告的错误。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//func ReadFile(filename string) ([]byte, error)</span></span><br><span class="line">	fileName :=<span class="string">&quot;d:/123.txt&quot;</span></span><br><span class="line">	arr,err:=ioutil.ReadFile(fileName)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;red file error &quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把读取到的内容显示到终端上</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>,<span class="type">string</span>(arr))   <span class="comment">// 将[]byte转换为string进行输出</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为，我们没有显示的Open文件，因此也不需要显式的Close文件</span></span><br><span class="line">	<span class="comment">//因为文件的Open和Close被封装到ReadFile函数内部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-写文件操作应用实例"><a href="#4-写文件操作应用实例" class="headerlink" title="4.写文件操作应用实例"></a>4.写文件操作应用实例</h3><h4 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.基本介绍，os.OpenFile函数</span><br><span class="line">func OpenFile</span><br><span class="line">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</span><br><span class="line">OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。 其中FileMode主要用于Linux系统。，其中flag可取的值如下，当要使用多个时用|隔开</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211022143543015.png" alt="image-20211022143543015"></p>
<h4 id="2-基本应用案例——方式一"><a href="#2-基本应用案例——方式一" class="headerlink" title="2.基本应用案例——方式一"></a>2.基本应用案例——方式一</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个新文件，写入内容 5句 &quot;hello,world&quot;</span><br><span class="line">2.打开一个存在的文件，将原来的内容覆盖成新的内容10句 &quot;你好，尚硅谷！&quot;</span><br><span class="line">3.打开一个存在的文件，在原来的内容中追加 &#x27;ABC!ENGLISH!&#x27;</span><br><span class="line">4.打开一个存在的文件，将原来的内容读出显示在中端，并且追加5句”hello 北京“</span><br><span class="line"></span><br><span class="line">使用os.OpenFile( ),bufio.NewWriter( )，*Writer的方法WriteString完成上面的任务</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个新文件，写入内容 5句 &quot;hello,world&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建一个新文件，写入内容 5句 &quot;hello,world&quot;</span></span><br><span class="line">	<span class="comment">//1.打开文件 d:/abc.txt</span></span><br><span class="line">	filePath:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file,err:=os.OpenFile(filePath,os.O_WRONLY | os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备写入5句 ”hello,world“</span></span><br><span class="line">	str:=<span class="string">&quot;heool,world\r\n&quot;</span></span><br><span class="line">	<span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为writer是带缓存的，因此在调用WriteString方法时，</span></span><br><span class="line">	<span class="comment">//其实内容是先写入到缓存的，因此要想写到文件，还需要调用Flush函数刷新,将缓存的数据真正写入到数据，否则文件中没有数据</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.打开一个存在的文件，将原来的内容覆盖成新的内容10句 &quot;你好，尚硅谷！&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个存在的文件，将原来的内容覆盖成新的内容10句 &quot;你好，尚硅谷！&quot;</span></span><br><span class="line">	<span class="comment">//1.打开文件 d:/abc.txt</span></span><br><span class="line">	filePath:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file,err:=os.OpenFile(filePath,os.O_WRONLY | os.O_TRUNC,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备写入10句 ”你好，尚硅谷！“</span></span><br><span class="line">	str:=<span class="string">&quot;你好，尚硅谷！\r\n&quot;</span></span><br><span class="line">	<span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为writer是带缓存的，因此在调用WriteString方法时，</span></span><br><span class="line">	<span class="comment">//其实内容是先写入到缓存的，因此要想写到文件，还需要调用Flush函数刷新,将缓存的数据真正写入到数据，否则文件中没有数据</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.打开一个存在的文件，在原来的内容中追加 &#x27;ABC!ENGLISH!&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个存在的文件，在原来的内容中追加 &#x27;ABC!ENGLISH!&#x27;</span></span><br><span class="line">	<span class="comment">//1.打开文件 d:/abc.txt</span></span><br><span class="line">	filePath:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file,err:=os.OpenFile(filePath,os.O_WRONLY | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备写入10句 ”你好，尚硅谷！“</span></span><br><span class="line">	str:=<span class="string">&quot;ABC!ENGLISH!\r\n&quot;</span></span><br><span class="line">	<span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为writer是带缓存的，因此在调用WriteString方法时，</span></span><br><span class="line">	<span class="comment">//其实内容是先写入到缓存的，因此要想写到文件，还需要调用Flush函数刷新,将缓存的数据真正写入到数据，否则文件中没有数据</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.打开一个存在的文件，将原来的内容读出显示在终端，并且追加5句”hello 北京“</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个存在的文件，将原来的内容读出显示在中端，并且追加5句”hello 北京“</span></span><br><span class="line">	<span class="comment">//1.打开文件 d:/abc.txt</span></span><br><span class="line">	filePath:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file,err:=os.OpenFile(filePath,os.O_RDWR | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先读取原来文件的内容，并显示到终端</span></span><br><span class="line">	reader:=bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str,err:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err==io.EOF&#123;  <span class="comment">//如果读取到文件的末尾</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//显示到终端</span></span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">//准备追加5句”hello 北京“</span></span><br><span class="line">	str:=<span class="string">&quot;hello 北京\r\n&quot;</span></span><br><span class="line">	<span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为writer是带缓存的，因此在调用WriteString方法时，</span></span><br><span class="line">	<span class="comment">//其实内容是先写入到缓存的，因此要想写到文件，还需要调用Flush函数刷新,将缓存的数据真正写入到数据，否则文件中没有数据</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-基本应用实例——方式二"><a href="#3-基本应用实例——方式二" class="headerlink" title="3.基本应用实例——方式二"></a>3.基本应用实例——方式二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.编写一个程序，将一个文件的内容，写入到另外一个文件，注：这两个文件已经存在了</span><br><span class="line"></span><br><span class="line">说明：使用ioutil.ReadFile / ioutil.WriteFile完成写文件的任务</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>代码演示</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//编写一个程序，将一个文件（d:/abc.txt）的内容，写入到另外一个文件d:/test/123.txt，注：这两个文件已经存在了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.首先将d:/abc.txt文件的内容读取到</span></span><br><span class="line">	<span class="comment">//2.将读取到的内容写入d:/test/123.txt</span></span><br><span class="line"></span><br><span class="line">	filePath1:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	arr,err:=ioutil.ReadFile(filePath1)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;read file err:&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filePath2:=<span class="string">&quot;d:/test/123.txt&quot;</span></span><br><span class="line">	err2:=ioutil.WriteFile(filePath2,arr, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err2!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;write file err:&quot;</span>,err2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-判断文件或者目录是否存在"><a href="#5-判断文件或者目录是否存在" class="headerlink" title="5.判断文件或者目录是否存在"></a>5.判断文件或者目录是否存在</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.golang判断文件或者文件夹是否存在的方法为使用os.Stat()函数返回的错误值进行判断</span><br><span class="line">	1）：如果返回的错误为nil,说明文件或者文件夹存在</span><br><span class="line">	2）：如果返回的错误类型使用os.IsNotExist()判断为true,说明文件或文件夹不存在</span><br><span class="line">	3）：如果返回的错误为其他类型，则不确定是否存在</span><br><span class="line">	</span><br><span class="line">//自定义一个函数来进行判断</span><br><span class="line">func PathExists(path string) (bool,error)&#123;</span><br><span class="line">	_,err:=os.Stat(path)</span><br><span class="line">	if err==nil&#123; //说明文件或者目录存在</span><br><span class="line">		return true,nil</span><br><span class="line">	&#125;</span><br><span class="line">	if os.IsNotExist(err)&#123;</span><br><span class="line">		return false,nil</span><br><span class="line">	&#125;</span><br><span class="line">	return false,err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-文件编程应用实例"><a href="#6-文件编程应用实例" class="headerlink" title="6.文件编程应用实例"></a>6.文件编程应用实例</h3><h4 id="1-拷贝文件"><a href="#1-拷贝文件" class="headerlink" title="1.拷贝文件"></a>1.拷贝文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.将一张图片/电影/mp3 拷贝到另外一个文件下 d:/test/abc.jpg  </span><br><span class="line">	</span><br><span class="line">说明：使用io包中func Copy(dst Writer,src Reader) (written int64,err error)</span><br><span class="line">	func Copy(dst Writer, src Reader) (written int64, err error)</span><br><span class="line">	将src的数据拷贝到dst，直到在src上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。</span><br><span class="line">    对成功的调用，返回值err为nil而非EOF，因为Copy定义为从src读取直到EOF，它不会将读取到EOF视为应报告的错	误。如果src实现了WriterTo接口，本函数会调用src.WriteTo(dst)进行拷贝；否则如果dst实现了ReaderFrom接口，本函数会调用dst.ReadFrom(src)进行拷贝。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.演示</span></span><br><span class="line"><span class="comment">//编写一个函数，接收两个文件路径 srcFileName  dstFileName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="type">string</span>,srcFileName <span class="type">string</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>)&#123;</span><br><span class="line">	srcFile,err:=os.Open(srcFileName)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> srcFile.Close()</span><br><span class="line">	<span class="comment">//通过srcFile这个句柄，获取到Reader</span></span><br><span class="line">	reader:=bufio.NewReader(srcFile)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开dstFileName</span></span><br><span class="line">	dstFile,err:=os.OpenFile(dstFileName, os.O_WRONLY | os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open dstfile err:&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dstFile.Close()</span><br><span class="line">	writer:=bufio.NewWriter(dstFile)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回</span></span><br><span class="line">	<span class="keyword">return</span> io.Copy(writer,reader)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//将一张图片/电影/mp3 拷贝到另外一个文件下 d:/test/abc.jpg</span></span><br><span class="line">	srcFileName:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	dstFileName:=<span class="string">&quot;d:/test/defggg.txt&quot;</span></span><br><span class="line">	_,err:=CopyFile(dstFileName,srcFileName)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;拷贝出错&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-统计英文、数字、空格和其他字符数量"><a href="#2-统计英文、数字、空格和其他字符数量" class="headerlink" title="2.统计英文、数字、空格和其他字符数量"></a>2.统计英文、数字、空格和其他字符数量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.打开一个文件，创建一个Reader,每读取一行，就去统计该行有多少英文、数字、空格和其他字符，然后将结果保存到一个结构体。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">type</span> CharCount <span class="keyword">struct</span>&#123;</span><br><span class="line">	ChCount <span class="type">int</span>  <span class="comment">//记录英文个数</span></span><br><span class="line">	NumCount <span class="type">int</span>  <span class="comment">//记录数字个数</span></span><br><span class="line">	SpaceCount <span class="type">int</span>  <span class="comment">//记录空格个数</span></span><br><span class="line">	OtherCount <span class="type">int</span>  <span class="comment">//记录其他字符个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个文件，创建一个Reader,没读取一行，就去统计该行有多少英文、数字、空格和其他字符，然后将结果保存到一个结构体。</span></span><br><span class="line">	file,err:=os.Open(<span class="string">&quot;d:/abc.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file error:&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取file的Reader</span></span><br><span class="line">	reader:=bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个CharCount结构体</span></span><br><span class="line">	ccStu:=CharCount&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始循环读取每一行,并计数</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		str,err:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err==io.EOF&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">		<span class="comment">//遍历字符串，进行统计</span></span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">			<span class="comment">//switch当作if判断</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;%v@,&quot;</span>,v)</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">				<span class="keyword">fallthrough</span></span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">				ccStu.ChCount++</span><br><span class="line">			<span class="keyword">case</span> v==<span class="string">&#x27; &#x27;</span> || v==<span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">				ccStu.SpaceCount++</span><br><span class="line">			<span class="keyword">case</span> v&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; v&lt;=<span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">				ccStu.NumCount++</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				ccStu.OtherCount++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;英文字母个数：%d,数字个数：%d,空格个数：%d,其他字符个数：%d&quot;</span>,ccStu.ChCount,ccStu.NumCount,ccStu.SpaceCount,ccStu.OtherCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-命令行参数"><a href="#7-命令行参数" class="headerlink" title="7.命令行参数"></a>7.命令行参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">看一个需求，我们希望能够获取到命令行输入的各种参数，该如何处理？</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">os.Args是一个string的切片，用来存储所有的命令行参数</span><br><span class="line">var Args []string</span><br><span class="line">Args保管了命令行参数，第一个是程序名。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用flag包用来解析命令行参数</span></span><br><span class="line">说明：前面的方式是比较原生的方式，对解析参数不是特别的方便，特别是带有指定参数形式的命令行</span><br><span class="line">比如：cmd&gt;main.exe -f c:/aaa.txt -p 200 -u root 这样形式的命令行，go设计者给我们提供了flag包，可以方便的解析命令行参数，而且参数顺序可以随意</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//os.Args获取命令行参数代码演示 </span></span><br><span class="line"><span class="comment">//hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;命令行的参数个数有：&quot;</span>,<span class="built_in">len</span>(os.Args))</span><br><span class="line">	<span class="comment">//遍历os.Args切片，就可以得到所有的命令行输入参数值</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;第%v个参数的值为%v\n&quot;</span>,i,v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令行输出的范例</span></span><br><span class="line"><span class="comment">//1.先将hello.go源文件编译为自定义的test.exe可执行文件</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;<span class="keyword">go</span> build -o test.exe hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.执行test.exe文件，并且带上了一些参数</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;test.exe tom d:/aaa/bbb/init.log</span><br><span class="line">命令行的参数个数有： <span class="number">3</span></span><br><span class="line">第<span class="number">0</span>个参数的值为test.exe第<span class="number">1</span>个参数的值为tom第<span class="number">2</span>个参数的值为d:/aaa/bbb/init.log</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag包解析命令行参数演示</span></span><br><span class="line"><span class="comment">//hello.go文件</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//flag包中的IntVar函数，StringVar函数</span></span><br><span class="line">	<span class="comment">//func (*FlagSet) IntVar</span></span><br><span class="line">	<span class="comment">//func (f *FlagSet) IntVar(p *int, name string, value int, usage string)</span></span><br><span class="line">	<span class="comment">//IntVar用指定的名称、默认值、使用信息注册一个int类型flag，并将flag的值保存到p指向的变量。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func (*FlagSet) StringVar</span></span><br><span class="line">	<span class="comment">//func (f *FlagSet) StringVar(p *string, name string, value string, usage string)</span></span><br><span class="line">	<span class="comment">//StringVar用指定的名称、默认值、使用信息注册一个string类型flag，并将flag的值保存到p指向的变量。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义几个变量，用于接收命令行的参数值</span></span><br><span class="line">	<span class="keyword">var</span> user <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> pwd <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> host <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> port <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&amp;user，就是接收用户命令行中输入的 -u 后面的参数值</span></span><br><span class="line">	<span class="comment">//&quot;u&quot;,就是 -u 指定参数</span></span><br><span class="line">	<span class="comment">//”“，默认值</span></span><br><span class="line">	<span class="comment">//&quot;用户名，默认为空&quot;,说明</span></span><br><span class="line">	flag.StringVar(&amp;user,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;用户名，默认为空&quot;</span>)</span><br><span class="line"></span><br><span class="line">	flag.StringVar(&amp;pwd,<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;密码，默认为空&quot;</span>)</span><br><span class="line"></span><br><span class="line">	flag.StringVar(&amp;host,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;主机名，默认为localhost&quot;</span>)</span><br><span class="line"></span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;端口号，默认为3306&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//func Parse</span></span><br><span class="line">	<span class="comment">//func Parse()</span></span><br><span class="line">	<span class="comment">//从os.Args[1:]中解析注册的flag。必须在所有flag都注册好而未访问其值时执行。未注册却使用flag -help时，会返回ErrHelp。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里有一个非常重要的操作，转换，必须调用该方法</span></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出结果</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;user=%v,pwd=%v,host=%v,port=%v&quot;</span>,user,pwd,host,port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令行中的输入</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;<span class="keyword">go</span> build -o test2.exe hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;test2.exe -u root -pwd <span class="number">123456</span> -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.5</span> -port <span class="number">3306</span></span><br><span class="line">user=root,pwd=<span class="number">123456</span>,host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.5</span>,port=<span class="number">3306</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;test2.exe -u root -pwd <span class="number">123456</span>  -port <span class="number">33065</span></span><br><span class="line">user=root,pwd=<span class="number">123456</span>,host=localhost,port=<span class="number">33065</span></span><br></pre></td></tr></table></figure>

<h3 id="8-json基本介绍"><a href="#8-json基本介绍" class="headerlink" title="8.json基本介绍"></a>8.json基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">概述</span></span><br><span class="line">1.json(JavaScript Object Notation)是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。并有效的提升网络传输效率，通常程序在网络传输时会先将数据（结构体，map等）序列化成json字符串，到接收方得到json字符串时，在反序列化恢复成原来的数据类型（结构体，map等）。这种方式已然成为各个语言的标准。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">json数据格式说明</span></span><br><span class="line">在js语言中，一切都是对象。因此，任何的数据类型都可以通过JSON来表示，例如字符串，数字，对象，数组，map，结构体等</span><br><span class="line"></span><br><span class="line">JSON键值对是用来保存数据的一种方式</span><br><span class="line">键/值对组合中的键名写在前面并用双引号&quot;&quot;包裹，使用冒号:分割，然后紧接着值</span><br><span class="line">比如：&#123;&quot;firstName&quot;:&quot;json&quot;&#125;  &#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18,&quot;address&quot;:[&quot;北京&quot;,&quot;上海&quot;]&#125;</span><br><span class="line">[&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18,&quot;address&quot;:[&quot;北京&quot;,&quot;上海&quot;]&#125;,&#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:20,&quot;address&quot;:[&quot;广州&quot;,&quot;深圳&quot;]&#125;]</span><br><span class="line"></span><br><span class="line">json在线解析工具：https://www.json.cn/ </span><br></pre></td></tr></table></figure>

<h4 id="1-json的序列化"><a href="#1-json的序列化" class="headerlink" title="1.json的序列化"></a>1.json的序列化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">json序列化是指，将有key-value结构的数据类型（比如：结构体，map,切片）序列化成json字符串的操作</span><br><span class="line"></span><br><span class="line">注意：这是在序列化时，使用tag标签，指定后面输出的键名,利用反射机制解决</span><br><span class="line">//&quot;encoding/json&quot;包中的Marshal函数</span><br><span class="line">//func Marshal</span><br><span class="line">//func Marshal(v interface&#123;&#125;) ([]byte, error)</span><br><span class="line">//Marshal函数返回v的json编码。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化切片，map,结构体的演示</span></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Birthday <span class="type">string</span></span><br><span class="line">	Salary <span class="type">float64</span></span><br><span class="line">	Skill <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是在序列化时，使用tag标签，指定后面输出的键名,利用反射机制解决</span></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span>   </span><br><span class="line">	Age <span class="type">int</span>	<span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span> <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Salary <span class="type">float64</span> <span class="string">`json:&quot;salary&quot;`</span></span><br><span class="line">	Skill <span class="type">string</span> <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//演示</span></span><br><span class="line">	monster:=Monster&#123;<span class="string">&quot;牛魔王&quot;</span>,<span class="number">500</span>,<span class="string">&quot;1000-02-01&quot;</span>,<span class="number">8000.0</span>,<span class="string">&quot;牛魔拳&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将monster序列化</span></span><br><span class="line">	data,err:=json.Marshal(&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;序列化之后的结果&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义一个map</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用map之前先make</span></span><br><span class="line">	a=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	a[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;红孩儿&quot;</span></span><br><span class="line">	a[<span class="string">&quot;age&quot;</span>]=<span class="number">123</span></span><br><span class="line">	a[<span class="string">&quot;birthday&quot;</span>]=<span class="string">&quot;1997-11-26&quot;</span></span><br><span class="line">	a[<span class="string">&quot;salary&quot;</span>]=<span class="number">123.4</span></span><br><span class="line">	a[<span class="string">&quot;Skill&quot;</span>]=[<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;使枪&quot;</span>,<span class="string">&quot;滑轮&quot;</span>,<span class="string">&quot;跳舞&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将a序列化</span></span><br><span class="line">	data,err:=json.Marshal(&amp;a)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;序列化之后的结果&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示对切片类型的序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSlice</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	slice=<span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">	slice[<span class="number">0</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	slice[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;红孩儿&quot;</span></span><br><span class="line">	slice[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>]=<span class="number">5</span></span><br><span class="line">	slice[<span class="number">0</span>][<span class="string">&quot;address&quot;</span>]=<span class="string">&quot;北京&quot;</span></span><br><span class="line">	slice[<span class="number">1</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	slice[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;牛魔王&quot;</span></span><br><span class="line">	slice[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>]=<span class="number">52</span></span><br><span class="line">	slice[<span class="number">1</span>][<span class="string">&quot;address&quot;</span>]=<span class="string">&quot;上海&quot;</span></span><br><span class="line">	m3:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m3[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;孙悟空&quot;</span></span><br><span class="line">	m3[<span class="string">&quot;age&quot;</span>]=<span class="number">523</span></span><br><span class="line">	m3[<span class="string">&quot;address&quot;</span>]=[<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m3)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将slice序列化</span></span><br><span class="line">	data,err:=json.Marshal(slice)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;序列化之后的结果&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试对基本类型的序列化,对基本类型序列化意义不大</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFloat64</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num1 <span class="type">float64</span>=<span class="number">1.1</span></span><br><span class="line">	<span class="comment">//将slice序列化</span></span><br><span class="line">	data,err:=json.Marshal(num1)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;序列化之后的结果&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//测试序列化结构体</span></span><br><span class="line">	testStruct()</span><br><span class="line">	<span class="comment">//测试序列化map</span></span><br><span class="line">	testMap()</span><br><span class="line">	<span class="comment">//测试序列化slice</span></span><br><span class="line">	testSlice()</span><br><span class="line">	<span class="comment">//测试基本类型序列化</span></span><br><span class="line">	testFloat64()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;牛魔王&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">500</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1000-02-01&quot;</span>,<span class="string">&quot;salary&quot;</span>:<span class="number">8000</span>,<span class="string">&quot;skill&quot;</span>:<span class="string">&quot;牛魔拳&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;Skill&quot;</span>:[<span class="string">&quot;使枪&quot;</span>,<span class="string">&quot;滑轮&quot;</span>,<span class="string">&quot;跳舞&quot;</span>],<span class="string">&quot;age&quot;</span>:<span class="number">123</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1997-11-26&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;红孩儿&quot;</span>,<span class="string">&quot;salary&quot;</span>:<span class="number">123.4</span>&#125;</span><br><span class="line">[&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">5</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;红孩儿&quot;</span>&#125;,&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">52</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;牛魔王&quot;</span>&#125;,&#123;<span class="string">&quot;address&quot;</span>:[<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>],<span class="string">&quot;age&quot;</span>:<span class="number">523</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>&#125;]</span><br><span class="line"><span class="number">1.1</span></span><br><span class="line">[<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="2-json的反序列化"><a href="#2-json的反序列化" class="headerlink" title="2.json的反序列化"></a>2.json的反序列化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">json的反序列化是指，将json字符串反序列化成对应的数据类型（比如结构体，map,切片）的操作</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">	1.在反序列化一个字符串时，要确保反序列化后的数据类型和原来序列化前的数据类型一致</span><br><span class="line">	2.如果json字符串时通过程序获取到的，则不需要在对字符串做转义处理</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span>   <span class="comment">//反射机制</span></span><br><span class="line">	Age <span class="type">int</span>	<span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span> <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Salary <span class="type">float64</span> <span class="string">`json:&quot;salary&quot;`</span></span><br><span class="line">	Skill <span class="type">string</span> <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试将json反序列化成结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//一般json字符串是通过读文件获取到的</span></span><br><span class="line">	str:=<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;牛魔王\&quot;,\&quot;age\&quot;:500,\&quot;birthday\&quot;:\&quot;1000-02-01\&quot;,\&quot;salary\&quot;:8000,\&quot;skill\&quot;:\&quot;牛魔拳\&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个Monster实例</span></span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	err:=json.Unmarshal([]<span class="type">byte</span>(str),&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;反序列化之后的结果&quot;</span>,monster)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str:=<span class="string">&quot;&#123;\&quot;Skill\&quot;:[\&quot;使枪\&quot;,\&quot;滑轮\&quot;,\&quot;跳舞\&quot;],\&quot;age\&quot;:123,\&quot;birthday\&quot;:\&quot;1997-11-26\&quot;,\&quot;name\&quot;:\&quot;红孩儿\&quot;,\&quot;salary\&quot;:123.4&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个map</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	err:=json.Unmarshal([]<span class="type">byte</span>(str),&amp;a)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;反序列化之后的结果&quot;</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示对切片类型的序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSlice</span><span class="params">()</span></span>&#123;</span><br><span class="line">	str:=<span class="string">&quot;[&#123;\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:5,\&quot;name\&quot;:\&quot;红孩儿\&quot;&#125;,&#123;\&quot;address\&quot;:\&quot;上海\&quot;,\&quot;age\&quot;:52,\&quot;name\&quot;:\&quot;牛魔王\&quot;&#125;,&#123;\&quot;address\&quot;:[\&quot;广州\&quot;,\&quot;深圳\&quot;],\&quot;age\&quot;:523,\&quot;name\&quot;:\&quot;孙悟空\&quot;&#125;]&quot;</span></span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err:=json.Unmarshal([]<span class="type">byte</span>(str),&amp;slice)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;反序列化之后的结果&quot;</span>,slice)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testArray</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	str:=<span class="string">&quot;[\&quot;上海\&quot;,\&quot;广州\&quot;,\&quot;深圳\&quot;]&quot;</span></span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">string</span></span><br><span class="line">	err:=json.Unmarshal([]<span class="type">byte</span>(str),&amp;arr)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;反序列化之后的结果&quot;</span>,arr)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//测试反序列化结构体</span></span><br><span class="line">	testStruct()</span><br><span class="line">	<span class="comment">//测试反序列化map</span></span><br><span class="line">	testMap()</span><br><span class="line">	<span class="comment">//测试反序列化slice</span></span><br><span class="line">	testSlice()</span><br><span class="line">	<span class="comment">//测试数组反序列化</span></span><br><span class="line">	testArray()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">&#123;牛魔王 <span class="number">500</span> <span class="number">1000</span><span class="number">-02</span><span class="number">-01</span> <span class="number">8000</span> 牛魔拳&#125;</span><br><span class="line"><span class="keyword">map</span>[Skill:[使枪 滑轮 跳舞] age:<span class="number">123</span> birthday:<span class="number">1997</span><span class="number">-11</span><span class="number">-26</span> name:红孩儿 salary:<span class="number">123.4</span>]</span><br><span class="line">[<span class="keyword">map</span>[address:北京 age:<span class="number">5</span> name:红孩儿] <span class="keyword">map</span>[address:上海 age:<span class="number">52</span> name:牛魔王] <span class="keyword">map</span>[address:[广州 深圳] age:<span class="number">523</span> name:孙悟空]]</span><br><span class="line">[上海 广州 深圳]</span><br></pre></td></tr></table></figure>

<h2 id="第十章：单元测试和管道，协程"><a href="#第十章：单元测试和管道，协程" class="headerlink" title="第十章：单元测试和管道，协程"></a>第十章：单元测试和管道，协程</h2><h3 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先看一个需求</span></span><br><span class="line">在工作中，我们可能需要去确认一个函数或者一个模块是否和预期的结果一致，如果一致，则说明函数正确，否则函数有错误，然后修改错误。</span><br><span class="line"></span><br><span class="line">1.传统的测试方法就是在main函数中使用，看看结果是否和预期一致</span><br><span class="line">	传统方法的缺点：</span><br><span class="line">			1.不方便，我们总需要在main函数中运行，需要在main函数中修改代码。</span><br><span class="line">			2.不利于管理。要测试多个函数都需要放在main函数中</span><br><span class="line">于是引出单元测试。testing测试框架，可以很好的解决问题</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">单元测试介绍</span></span><br><span class="line">go语言中自带有一个轻量级的测试框架testing和自带的go test命令来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，可以基于这个这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例。通过单元测试可以解决一下问题：</span><br><span class="line">	1.确保每个函数是可运行，并且运行结果是正确的</span><br><span class="line">	2.确保写出来的代码性能是好的</span><br><span class="line">	3.单元测试能及时的发现程序设计或实现的逻辑错误，，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下保持稳定。</span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门-3"><a href="#2-快速入门-3" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#快速入门</span><br><span class="line">使用go的单元测试，对addUpper和sub函数进行测试</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单元测试案例演示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  test/cal.go文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="comment">//一个被测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addUpper</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">	res:=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		res+=i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个被测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSub</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1-n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  test/cal_test.go文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个测试用例，去测试addUpper是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddUpper</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	<span class="comment">//调用</span></span><br><span class="line">	res:=addUpper(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> res!=<span class="number">45</span>&#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;addUpper(10) 执行错误，期望值=%v 实际值=%v&quot;</span>,<span class="number">55</span>,res)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果正确，输出日志</span></span><br><span class="line">	t.Logf(<span class="string">&quot;addUpper(10)执行正确&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    t.Logf(<span class="string">&quot;hello执行正确&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line"><span class="comment">// test/sub_test.go文件</span></span><br><span class="line">           </span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个测试用例，去测试addUpper是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetSub</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	<span class="comment">//调用</span></span><br><span class="line">	res:=getSub(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">if</span> res!=<span class="number">5</span>&#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;GetSub(10,5) 执行错误，期望值=%v 实际值=%v&quot;</span>,<span class="number">5</span>,res)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果正确，输出日志</span></span><br><span class="line">	t.Logf(<span class="string">&quot;GetSub(10,5)执行正确&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line"><span class="comment">//命令行的操作</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\test&gt;<span class="keyword">go</span> test -v</span><br><span class="line">=== RUN   TestAddUpper</span><br><span class="line">    cal_test.<span class="keyword">go</span>:<span class="number">15</span>: hello执行正确</span><br><span class="line">--- PASS: TestAddUpper (<span class="number">0.00</span>s)</span><br><span class="line">=== RUN   TestHello</span><br><span class="line">    cal_test.<span class="keyword">go</span>:<span class="number">19</span>: addUpper(<span class="number">10</span>)执行正确</span><br><span class="line">--- PASS: TestHello (<span class="number">0.00</span>s)</span><br><span class="line">=== RUN   TestGetSub</span><br><span class="line">    sub_test.<span class="keyword">go</span>:<span class="number">13</span>: GetSub(<span class="number">10</span>,<span class="number">5</span>)执行正确</span><br><span class="line">--- PASS: TestGetSub (<span class="number">0.00</span>s)</span><br><span class="line">PASS</span><br><span class="line">ok      go_code/project01/test  <span class="number">0.361</span>s</span><br><span class="line"></span><br><span class="line">D:\program\goPath\src\go_code\project01\test&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-单元测试使用细节和注意事项"><a href="#3-单元测试使用细节和注意事项" class="headerlink" title="3.单元测试使用细节和注意事项"></a>3.单元测试使用细节和注意事项</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.测试用例文件名必须以 _test.go结尾。比如cal_test.go，其中cal不是固定的</span><br><span class="line">2.测试用例函数必须以Test开头，一般来说就是TestXxxx,其中Xxxx就是被测试的函数名，比如TestAddUpper.</span><br><span class="line">3.TestAddUpper(t *testing.T)的形参类型必须是*testing.T</span><br><span class="line">4.一个测试用例文件中，可以有多个测试用例函数，比如 TestAddUpper,TestHello</span><br><span class="line">5.运行测试用例指令</span><br><span class="line">	1.cmd&gt;go test [如果运行正确，无日志，错误时，会输出日志]</span><br><span class="line">	2.cmd&gt;go test -v [无论运行正确与否，都输出日志]</span><br><span class="line">6.当出现错误时，可以使用t.Fatalf来格式化输出错误信息，并退出程序</span><br><span class="line">7.t.Logf方法可以输出相应的日志</span><br><span class="line">8.测试用例函数，并没有放在main函数中也执行了，这就是测试用例的方便之处</span><br><span class="line">9.PASS表示测试用例运行成功，FAIL表示测试用例运行失败</span><br><span class="line">10.测试单个文件时，一定要带上被测试的原文件(cal.go)</span><br><span class="line">	go test -v cal_test.go cal.go</span><br><span class="line">11.测试单个方法.如只测试 TestAddUpper方法</span><br><span class="line">	go test -v -test.run TestAddUpper</span><br></pre></td></tr></table></figure>

<h4 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">//exer1.go文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span>		<span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="type">int</span>			<span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Skill []<span class="type">string</span>	<span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个Monster变量序列化后保存到文件中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(monster *Monster)</span></span> Store(path <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	str,err1:=json.Marshal(monster)</span><br><span class="line">	<span class="keyword">if</span> err1!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败err1: %v\n&quot;</span>,err1)</span><br><span class="line">		<span class="keyword">return</span> err1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file,err2:=os.OpenFile(path,os.O_WRONLY | os.O_APPEND | os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err2!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;openfile失败err2: %v\n&quot;</span>,err2)</span><br><span class="line">		<span class="keyword">return</span> err2</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将json字符串写入到文件中</span></span><br><span class="line">	_,err3:=writer.WriteString(<span class="type">string</span>(str)+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err3!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;writeString失败err3: %v\n&quot;</span>,err3)</span><br><span class="line">		<span class="keyword">return</span> err3</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将写入缓存的数据进行刷新</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个序列化的monster,从文件中读取，并反序列化为Monster对象,检查反序列化的名字是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(monster *Monster)</span></span> ReStore(path <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//读取文件</span></span><br><span class="line">	file,err1:=os.OpenFile(path,os.O_RDONLY,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err1!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;openfile失败err1: %v\n&quot;</span>,err1)</span><br><span class="line">		<span class="keyword">return</span> err1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取Reader</span></span><br><span class="line">	reader:=bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">	str,err2:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	reader.ReadLine()</span><br><span class="line">	<span class="keyword">if</span> err2!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;readString失败err3: %v\n&quot;</span>,err2)</span><br><span class="line">		<span class="keyword">return</span> err2</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err3:=json.Unmarshal([]<span class="type">byte</span>(str),monster)</span><br><span class="line">	<span class="keyword">if</span> err3!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err1: %v\n&quot;</span>,err3)</span><br><span class="line">		<span class="keyword">return</span> err3</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exer1_test.go文件</span></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStore</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	monster:=Monster&#123;</span><br><span class="line">		Name:  <span class="string">&quot;牛魔王&quot;</span>,</span><br><span class="line">		Age:   <span class="number">500</span>,</span><br><span class="line">		Skill: <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	monster.Skill[<span class="number">0</span>]=<span class="string">&quot;打牛&quot;</span></span><br><span class="line">	monster.Skill[<span class="number">1</span>]=<span class="string">&quot;喝水&quot;</span></span><br><span class="line">	err:=monster.Store(<span class="string">&quot;d:/test/defgg.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;Store方法执行失败：%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Logf(<span class="string">&quot;Store方法运行成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReStore</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	err:=monster.ReStore(<span class="string">&quot;d:/test/defgg.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;ReStore方法执行失败：%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Logf(<span class="string">&quot;Store方法运行成功，monster=%v\n&quot;</span>,monster)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-goroutine协程"><a href="#2-goroutine协程" class="headerlink" title="2.goroutine协程"></a>2.goroutine协程</h3><h4 id="1-基本介绍-3"><a href="#1-基本介绍-3" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.使用并行/并发的方式，将一个大任务分配给多个goroutine进行处理,来加快处理</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进程和线程说明</span></span><br><span class="line">1.线程就是程序在操作系统中的一侧执行过程，是系统进行资源分配和调度的基本单位。</span><br><span class="line">2.线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位。</span><br><span class="line">3.一个进程可以创建多个和销毁多个进程，同一个进程中的多个线程可以并发执行。</span><br><span class="line">4.一个程序至少有一个进程，一个进程至少有一个线程</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">并发和并行</span></span><br><span class="line">1.多线程程序在单核上运行，就是并发</span><br><span class="line">2.多线程程序在多核上运行，就是并行</span><br><span class="line"></span><br><span class="line">并发：在一个cpu上，比如有10个线程，每个线程上执行10毫秒，从人的角度看，好像这10个线程同时运行，实际上在一个时间点上只执行一个线程。</span><br><span class="line">并行：在多个cpu上，多个任务执行在多个cpu上，在一个时间上，就是有多个任务或者说多个线程在同时执行</span><br><span class="line"></span><br><span class="line">说明：并行的速度比并发块</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">go协程和go主线程</span></span><br><span class="line">1.go主线程（有程序员直接称为线程/也可理解成进程）：一个go线程上，可以起多个协程，可以这样理解，协程是轻量级的线程【编译器做优化】</span><br><span class="line">2.#go协程的特点：</span><br><span class="line">	1.有独立的栈空间</span><br><span class="line">	2.共享程序堆空间</span><br><span class="line">	3.调度由用户控制</span><br><span class="line">	4.协程是轻量级的线程</span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门-4"><a href="#2-快速入门-4" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例说明：</span></span><br><span class="line">请编写一个程序，完成如下功能：</span><br><span class="line">1.在主线程（可以理解成进程）中，开启一个goroutine，该协程每隔一秒输出&quot;hello,world&quot;</span><br><span class="line">2.在主线程中也每隔一秒输出&quot;hello,golang&quot;,输出10次后，退出程序</span><br><span class="line">3.要求主线程和goroutine同时执行</span><br><span class="line">4.画出主线程和协程执行流程图</span><br><span class="line"></span><br><span class="line">下面的代码说明：</span><br><span class="line">	1.如果主线程退出了，则协程还没有执行完毕，也会退出</span><br><span class="line">	2.当然协程也可以在主协程没有退出前，就自己结束了，比如完成了自己的任务</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">快速入门小结：</span></span><br><span class="line">	1.主线程是一个物理线程，直接作用在cpu上，是重量级的，非常耗费cpu资源。</span><br><span class="line">	2.协程从主线程开始的，是轻量级的线程，是逻辑态，对资源消耗相对较小</span><br><span class="line">	3.#golang的协程机制重要的特点，可以轻松的开启上万个协程，其他编程语言的并发机制是一般基于线程的开启过多的线程，资源耗费大，这里就突显出golang在并发上的优势了.(java的多线程是内核级的，也比较消耗资源)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">//编写一个函数，每隔一秒输出&quot;hello,world&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello,world &quot;</span>+strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//test()  //这是传统的顺序执行</span></span><br><span class="line">	<span class="keyword">go</span> test()  <span class="comment">//开启了一个协程，和main线程并发交叉执行</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello,golang &quot;</span>+strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">hello,golang <span class="number">0</span></span><br><span class="line">hello,world <span class="number">0</span></span><br><span class="line">hello,world <span class="number">1</span></span><br><span class="line">hello,golang <span class="number">1</span></span><br><span class="line">hello,world <span class="number">2</span></span><br><span class="line">hello,golang <span class="number">2</span></span><br><span class="line">hello,world <span class="number">3</span></span><br><span class="line">hello,golang <span class="number">3</span></span><br><span class="line">hello,golang <span class="number">4</span></span><br><span class="line">hello,world <span class="number">4</span></span><br><span class="line">hello,golang <span class="number">5</span></span><br><span class="line">hello,world <span class="number">5</span></span><br><span class="line">hello,golang <span class="number">6</span></span><br><span class="line">hello,world <span class="number">6</span></span><br><span class="line">hello,golang <span class="number">7</span></span><br><span class="line">hello,world <span class="number">7</span></span><br><span class="line">hello,golang <span class="number">8</span></span><br><span class="line">hello,world <span class="number">8</span></span><br><span class="line">hello,world <span class="number">9</span></span><br><span class="line">hello,golang <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h4 id="3-goroutine协程的调度模型MPG"><a href="#3-goroutine协程的调度模型MPG" class="headerlink" title="3.goroutine协程的调度模型MPG"></a>3.goroutine协程的调度模型MPG</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">MPG模式基本介绍</span></span><br><span class="line">1.M：操作系统的主线程（是物理线程） Machine</span><br><span class="line">2.P：协程执行需要的上下文	Processor</span><br><span class="line">3.G：协程 goroutine</span><br></pre></td></tr></table></figure>

<h4 id="4-设置golang运行的cpu数"><a href="#4-设置golang运行的cpu数" class="headerlink" title="4.设置golang运行的cpu数"></a>4.设置golang运行的cpu数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了充分利用多cpu的优势，在golang程序中，设置运行的cpu数目</span><br><span class="line">1.go1.8后，默认就是让程序运行在多个核上，可以不用设置了</span><br><span class="line">2.go 1.8前，还是要设置一下，可以更高效的利用cpu</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	func NumCPU</span></span><br><span class="line"><span class="comment">	func NumCPU() int</span></span><br><span class="line"><span class="comment">	NumCPU返回本地机器的逻辑CPU个数。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpuNum:=runtime.NumCPU()</span><br><span class="line">	fmt.Println(cpuNum)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//可以自己设置使用多个CPU</span></span><br><span class="line">	runtime.GOMAXPROCS(cpuNum<span class="number">-1</span>)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-管道（channel）"><a href="#3-管道（channel）" class="headerlink" title="3.管道（channel）"></a>3.管道（channel）</h3><h4 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1.问题引入"></a>1.问题引入</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求:现在要计算1-200的各个数的阶乘，并且把各个数的阶乘放入到map中，最后显示出来，要求使用goroutine完成。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分析思路：</span></span><br><span class="line">	1.使用goroutine来完成，效率高，但是会出现并发/并行安全问题</span><br><span class="line">	2.这里就提出了不同goroutine如何通信的问题</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只用协程处理时会出现fatal error: concurrent map writes。（多个协程同时对map进行写操作，会引发并发问题）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码实现：</span></span><br><span class="line">	在运行某个程序时，如何知道是否存在资源竞争问题，方法就是，在编译该程序时，增加一个参数 -race即可</span><br><span class="line"><span class="meta prompt_">	cmd&gt;</span><span class="language-bash">go build -race hello.go</span></span><br><span class="line"><span class="meta prompt_">	cmd&gt;</span><span class="language-bash">hello.exe</span></span><br><span class="line">	如果存在数据竞争，就会打印WARNING: DATA RACE  ...Found 2 data race(s)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不同goroutine之间如何通讯</span></span><br><span class="line">	1.全局变量加锁同步</span><br><span class="line">	2.channel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用全局变量加锁同步改进程序</span></span><br><span class="line">	1.因为没有对全局变量m加锁，因此会出现资源争夺问题，代码会出现提示concurrent map writes</span><br><span class="line">	2.解决方案，加入互斥锁</span><br><span class="line">	3.我们数的阶乘很大，结果会越界，可以将求阶乘改成sum+=uint64(i)</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么需要channel</span></span><br><span class="line">前面使用全局变量加锁同步来解决goroutine的通讯，但不完美：</span><br><span class="line">1.主线程在等待所有goroutine全部完成的时间很难确定，我们设置的休眠时间仅仅是估算</span><br><span class="line">2.如果主线程休眠时间长了，会加长等待时间，如果等待时间短了，可能还有goroutine处于工作状态，这时也会随着主线程退出而销毁</span><br><span class="line">3.通过全局变量加锁来实现通讯，也不利于多个协程对全局变量的读写操作</span><br><span class="line">4.因此我们引入channel机制</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方法1：全局变量加锁进行解决</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	arr <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>)</span><br><span class="line">	<span class="comment">//声明一个全局的互斥锁</span></span><br><span class="line">	<span class="comment">//lock是一个全局的互斥锁</span></span><br><span class="line">	<span class="comment">//sync是包，synchornized同步</span></span><br><span class="line">	<span class="comment">//Mutex：是互斥</span></span><br><span class="line">	lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">uint64</span> =<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		sum*=<span class="type">uint64</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加锁</span></span><br><span class="line">	lock.Lock()</span><br><span class="line">	arr[n]=sum</span><br><span class="line">	<span class="comment">//解锁</span></span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		#需求:现在要计算1-200的各个数的阶乘，并且把各个数的阶乘放入到map中，最后显示出来，要求使用goroutine完成。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		#分析思路：</span></span><br><span class="line"><span class="comment">			1.使用goroutine来完成，效率高，但是会出现并发/并行安全问题</span></span><br><span class="line"><span class="comment">			2.这里就提出了不同goroutine如何通信的问题</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//go arr[i]=cal(i)  //这样写是不可以的</span></span><br><span class="line">		<span class="keyword">go</span> cal(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//休眠10秒钟等待协程的完成</span></span><br><span class="line">	time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="comment">//这里还需要加锁，虽然上面的协程在10秒钟之内能够执行完，但是主线程并不知道，</span></span><br><span class="line">	<span class="comment">//因为在输出arr的时候仍然可能会出现资源竞争的问题，所以加入互斥锁来进行解决</span></span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">for</span> i, u := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%v\n&quot;</span>,i,u)</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方法2：管道机制</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求:现在要计算1-200的各个数的阶乘，并且把各个数的阶乘放入到map中，最后显示出来，要求使用goroutine完成。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n <span class="type">int</span>,mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">uint64</span>=<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		sum *= <span class="type">uint64</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	num:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>)</span><br><span class="line">	num[n]=sum</span><br><span class="line">	mapChan&lt;-num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span></span><br><span class="line">	mapChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>,<span class="number">200</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> cal(i,mapChan)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		num:=<span class="built_in">len</span>(mapChan)</span><br><span class="line">		<span class="keyword">if</span> num==<span class="number">20</span>&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(mapChan)</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> mapChan &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-基本介绍"><a href="#2-基本介绍" class="headerlink" title="2.基本介绍"></a>2.基本介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">channel介绍</span></span><br><span class="line">1.channel本质就是一个数据结构-队列</span><br><span class="line">2.数据是先进先出</span><br><span class="line">3.线程安全，多goroutine访问时，不需要加锁，就是说channel本身就是线程安全的</span><br><span class="line">4.channel是由类型的，一个string的channel只能存放string类型数据</span><br></pre></td></tr></table></figure>

<h4 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3.快速入门"></a>3.快速入门</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义/声明channel</span></span><br><span class="line">var 变量名 chan 数据类型</span><br><span class="line">举例：</span><br><span class="line">var intChan chan int (intChan用于存放int数据)</span><br><span class="line">var mapChan chan map[int]string (mapChan用于存放map[int]string类型)</span><br><span class="line">var perChan chan Person</span><br><span class="line">var perChan2 chan *Person</span><br><span class="line">说明：</span><br><span class="line">	1.channel是引用类型</span><br><span class="line">	2.channel必须初始化才能写入数据，即make后才能使用</span><br><span class="line">	3.管道是有类型，intChan只能写入整数int</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">初始化管道：使用make进行初始化</span></span><br><span class="line">	intChan=make(chan int,3) //其中3就是指定管道的容量，初始化后就不可改变</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向channel中写入/取出数据</span></span><br><span class="line">	写数据</span><br><span class="line">	intChan &lt;- 10</span><br><span class="line">	num:=200</span><br><span class="line">	intChan&lt;-num</span><br><span class="line">	取数据</span><br><span class="line">	var num2 int</span><br><span class="line">	num2 =&lt;-intChan</span><br><span class="line">	&lt;-intChan  //也可以这样取，没有接收</span><br><span class="line">	</span><br><span class="line">	说明：在管道已满或者为空的情况下，继续存放数据或者取出数据时，就会报告-deadlock</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示 管道的初始化，写入（存取数据）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.创建一个可以存放3个int类型的管道</span></span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	intChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.看看intChan是什么</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;intChan的类型是%T,值是%v\n&quot;</span>,intChan,intChan)  <span class="comment">//intChan的类型是chan int,值是0xc000076080</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.向管道写入数据</span></span><br><span class="line">	intChan &lt;- <span class="number">10</span></span><br><span class="line">	num:=<span class="number">200</span></span><br><span class="line">	intChan&lt;-num</span><br><span class="line">	intChan&lt;-num+<span class="number">1</span></span><br><span class="line">	<span class="comment">//intChan&lt;-num+1    //当我们给管道写入数据时，不能超出其容量，容量就是make时给出的size大小，一经给出大小就固定了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.看看管道的长度和cap(容量)</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;intChan的长度len=%d,容量cap=%d\n&quot;</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))  <span class="comment">//intChan的长度len=2,容量cap=3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.从管道中取数据</span></span><br><span class="line">	<span class="keyword">var</span> num2 <span class="type">int</span></span><br><span class="line">	num2 =&lt;-intChan</span><br><span class="line">	num2 =&lt;-intChan</span><br><span class="line">	num2 =&lt;-intChan</span><br><span class="line">	fmt.Println(num2)  <span class="comment">//先进先出</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//6.在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报告-deadlock</span></span><br><span class="line">	<span class="comment">//num2 =&lt;-intChan  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-channel的遍历和关闭"><a href="#4-channel的遍历和关闭" class="headerlink" title="4.channel的遍历和关闭"></a>4.channel的遍历和关闭</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">channel的关闭</span></span><br><span class="line">使用内置函数Close可以关闭channel，当channel关闭后，就不能再向channel写数据了，但是仍然可以从该channel读取数据。如果继续写入会报panic: send on closed channel</span><br><span class="line">	close(perChan)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">channel的遍历</span></span><br><span class="line">channel支持for-range的方式进行遍历，但是要注意两个细节：</span><br><span class="line">	1.在遍历时,如果channel没有关闭，则会出现deadlock的错误</span><br><span class="line">	2.在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历,遍历的过程就是不断取出数据的过程</span><br><span class="line">//关闭管道后，对管道进行遍历，如果没有关闭管道，会遍历到数据，但是最终会报deadlock错误</span><br><span class="line">for v:= range perChan &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> perChan <span class="keyword">chan</span> Person</span><br><span class="line">	perChan=<span class="built_in">make</span>(<span class="keyword">chan</span> Person,<span class="number">10</span>)</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> s=rand.Intn(<span class="number">100</span>)</span><br><span class="line">		p:=Person&#123;Name: <span class="string">&quot;hello&quot;</span>+strconv.Itoa(s),Age:s,Address: <span class="string">&quot;hello&quot;</span>+strconv.Itoa(s)&#125;</span><br><span class="line">		<span class="comment">//fmt.Println(p)</span></span><br><span class="line">		perChan&lt;-p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不要用普通的for循环进行遍历管道，因为不容易确定管道的长度，而且管道的长度是动态变化的</span></span><br><span class="line">	<span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></span><br><span class="line">	<span class="comment">//	p:= &lt;-perChan</span></span><br><span class="line">	<span class="comment">//	fmt.Println(p)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="built_in">close</span>(perChan)  <span class="comment">//关闭管道</span></span><br><span class="line">	<span class="keyword">var</span> s=rand.Intn(<span class="number">100</span>)</span><br><span class="line">	p:=Person&#123;Name: <span class="string">&quot;hello&quot;</span>+strconv.Itoa(s),Age:s,Address: <span class="string">&quot;hello&quot;</span>+strconv.Itoa(s)&#125;</span><br><span class="line">	<span class="comment">//perChan&lt;-p  //panic: send on closed channel</span></span><br><span class="line">	p=&lt;-perChan</span><br><span class="line">	fmt.Println(p)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭管道后，对管道进行遍历，如果没有关闭管道，会遍历到数据，但是最终会报deadlock错误</span></span><br><span class="line">	<span class="comment">//在使用for-range遍历管道时，只有值，而没有索引这一变量</span></span><br><span class="line">	<span class="keyword">for</span> v:= <span class="keyword">range</span> perChan &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-goroutine和channel结合案例"><a href="#5-goroutine和channel结合案例" class="headerlink" title="5.goroutine和channel结合案例"></a>5.goroutine和channel结合案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请完成goroutine和channel协同工作的案例，具体要求：</span><br><span class="line">1.开启一个writeData协程，向管道intChan中写入50个整数</span><br><span class="line">2.开启一个readData协程，从管道intChan中读取writeData写入的数据</span><br><span class="line">3.注意writeData和readData操作的是同一个管道</span><br><span class="line">4.主线程需要等待writeData和readData协程都完成后才能退出</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">		num:=rand.Intn(<span class="number">100</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;write:&quot;</span>,num)</span><br><span class="line">		intChan&lt;-num</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭管道不影响读取数据</span></span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>,boolChan <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		v,ok:=&lt;-intChan</span><br><span class="line">        <span class="comment">//当管道关闭后，并且里面还没有数据的时候，ok就会返回false.</span></span><br><span class="line">		<span class="keyword">if</span> !ok&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;read:&quot;</span>,v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//readData读取完数据后，即任务完成</span></span><br><span class="line">	boolChan&lt;-<span class="literal">true</span></span><br><span class="line">	<span class="built_in">close</span>(boolChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	intChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">50</span>)</span><br><span class="line">	<span class="keyword">var</span> boolChan <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">	boolChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(boolChan))</span><br><span class="line">	<span class="keyword">go</span> write(intChan)</span><br><span class="line">	<span class="keyword">go</span> read(intChan,boolChan)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//time.Sleep(5*time.Second)</span></span><br><span class="line">	<span class="comment">//通过新建的boolChan来决定协程是否执行结束,来取代上面的休眠函数</span></span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		_,ok:=&lt;-boolChan</span><br><span class="line">        <span class="comment">//当管道关闭后，并且里面还没有数据的时候，ok就会返回false.</span></span><br><span class="line">		<span class="keyword">if</span> !ok&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-管道的阻塞"><a href="#6-管道的阻塞" class="headerlink" title="6.管道的阻塞"></a>6.管道的阻塞</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当管道的容量小于要写进去的数据的总数时，如果没有从管道中读取数据的操作，那么就会出现阻塞而最终deadlock.原因是intChan容量是10，而要写入50个数据，#因此会阻塞直至死锁。</span><br><span class="line">2.但是当有读取的操作时，即便读操作慢于写操作，且要写进去的数据的个数大于管道的容量，程序也只会阻塞进入等待读取的状态，等读取之后就又可以重新进行写入了，#所以程序会正常执行。</span><br></pre></td></tr></table></figure>

<h4 id="7-协程和管道的应用实例3"><a href="#7-协程和管道的应用实例3" class="headerlink" title="7.协程和管道的应用实例3"></a>7.协程和管道的应用实例3</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求</span></span><br><span class="line">要求统计1-200000的数字中，哪些是素数？【测试使用8000】</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//使用协程加管道的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">200000</span>; i++ &#123;</span><br><span class="line">		intChan&lt;-i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭通道</span></span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>,resChan <span class="keyword">chan</span> <span class="type">int</span>,exitChan <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		v,ok:=&lt;-intChan</span><br><span class="line">        <span class="comment">//当管道中有数据可以取出时，v就是取出的内容，ok等于true，当没有数据可以取出时，v就是为空，ok为false.</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;  <span class="comment">//管道中取不出数据</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		b:=<span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">2</span>; j &lt;= v/<span class="number">2</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> v%j==<span class="number">0</span>&#123;</span><br><span class="line">				b=<span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//如果b为true的话，说明从intChan 中取出的数据就是素数</span></span><br><span class="line">		<span class="keyword">if</span> b&#123;</span><br><span class="line">			resChan&lt;-v</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这是判断是否从协程中取完了数据，如果是，就关闭这个resChan</span></span><br><span class="line">		<span class="comment">//if v==8000&#123;</span></span><br><span class="line">		<span class="comment">//	close(resChan)</span></span><br><span class="line">		<span class="comment">//	exitChan&lt;-true</span></span><br><span class="line">		<span class="comment">//	close(exitChan)</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;有一个取数据判断素数的协程cal因为取不到数据，退出&quot;)</span></span><br><span class="line">	<span class="comment">//这里我们还不能关闭resChan这个管道，因为有四个这样的协程，所以我们还不能关闭</span></span><br><span class="line">	<span class="comment">//向exitChan写入true</span></span><br><span class="line">	exitChan&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//要求统计1-200000的数字中，哪些是素数？[测试数据是80000]</span></span><br><span class="line">	<span class="comment">//2、3、5、7、11、13、17、19、23、29、31、37、41、43、47、53、59、61、67、71、73、79、83、89、97。”</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//传统方法</span></span><br><span class="line">	<span class="comment">/*for i := 2; i &lt; 80000; i++ &#123;</span></span><br><span class="line"><span class="comment">		b:=true</span></span><br><span class="line"><span class="comment">		for j := 2; j &lt;= i/2; j++ &#123;</span></span><br><span class="line"><span class="comment">			if i%j==0&#123;</span></span><br><span class="line"><span class="comment">				b=false</span></span><br><span class="line"><span class="comment">				break</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		if b&#123;</span></span><br><span class="line"><span class="comment">			fmt.Println(i,&quot;是素数&quot;)</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	t1:=time.Now().Unix()</span><br><span class="line">	fmt.Println(t1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="type">int</span>=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1000</span>)</span><br><span class="line">	<span class="keyword">var</span> resChan <span class="keyword">chan</span> <span class="type">int</span>=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">100000</span>)</span><br><span class="line">	<span class="comment">//开启一个协程放入1-8000的数</span></span><br><span class="line">	<span class="keyword">go</span> insert(intChan)</span><br><span class="line">	exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">4</span>)  <span class="comment">//4个，根据协程数来决定</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启4个协程从intChan中取出数据并判断是否是素数，如果是就存进resChan中</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> cal(intChan,resChan,exitChan)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for  &#123;</span></span><br><span class="line">	<span class="comment">//	v,ok:=&lt;-resChan</span></span><br><span class="line">	<span class="comment">//	if !ok&#123;</span></span><br><span class="line">	<span class="comment">//		break</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(v,&quot;是素数&quot;)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里我们主线程，进行处理</span></span><br><span class="line">	<span class="comment">//当exitChan长度为4时就关闭resChan</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//此时说明四个协程任务均已经完成，intChan中的数据也已经取完</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(exitChan)==<span class="number">4</span>&#123;</span><br><span class="line">			<span class="built_in">close</span>(resChan)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t2:=time.Now().Unix()</span><br><span class="line">	fmt.Println(t2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;使用时间：&quot;</span>,t2-t1)</span><br><span class="line">	<span class="comment">//遍历结果</span></span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		_,ok:=&lt;-resChan</span><br><span class="line">		<span class="keyword">if</span> !ok&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//fmt.Println(v,&quot;是素数&quot;)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-channel使用细节和注意事项"><a href="#8-channel使用细节和注意事项" class="headerlink" title="8.channel使用细节和注意事项"></a>8.channel使用细节和注意事项</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.channel可以声明为只读，或者只写性质</span><br><span class="line">2.channel只读和只写的最佳案例(可以防止误操作)</span><br><span class="line">	说明：形参类型为chan&lt;- int的可以接收chan&lt;- int和chan int两种类型的数据</span><br><span class="line">3.使用select可以解决从管道取数据的阻塞问题</span><br><span class="line">4.goroutine中使用recover,解决协程中出现panic,导致程序崩溃的问题。这时如果我们goroutine中使用recover来捕获panic，进行处理，这样即使这个协程发生了问题，但是这线程仍然不受影响，可以继续执行</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二点代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(chan2 <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;chan2的类型%T,值为%v\n&quot;</span>,chan2,chan2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(chan3 &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;chan3的类型%T,值为%v\n&quot;</span>,chan3,chan3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//管道可以声明为只读或者只写</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.默认情况下声明为双向的</span></span><br><span class="line">	<span class="keyword">var</span> chan1 <span class="keyword">chan</span> <span class="type">int</span>  <span class="comment">//可读可写</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.声明为只写</span></span><br><span class="line">	<span class="keyword">var</span> chan2 <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">	chan2=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line">	chan2&lt;<span class="number">-2</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;chan2的类型%T,值为%v\n&quot;</span>,chan2,chan2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.声明为只读</span></span><br><span class="line">	<span class="keyword">var</span> chan3 &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	chan3=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;chan3的类型%T,值为%v\n&quot;</span>,chan3,chan3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//形参类型为chan&lt;- int的可以接收chan&lt;- int和chan int两种类型的数据</span></span><br><span class="line">	test1(chan1)</span><br><span class="line">	test2(chan1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三点代码演示：</span></span><br><span class="line"><span class="comment">//使用select可以解决从管道取数据的阻塞问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.定义1个管道 10个数据int</span></span><br><span class="line">	intChan :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		intChan&lt;-i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.定义1个管道 5个数据string</span></span><br><span class="line">	strChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>,<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		strChan&lt;-<span class="string">&quot;hello&quot;</span>+fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//传统的方法在遍历管道时，如果不关闭会阻塞而导致 deadlock</span></span><br><span class="line">	<span class="comment">//问题：在实际开发中我们不好确定何时去关闭管道</span></span><br><span class="line">	<span class="comment">//可以使用select进行解决</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">//注意：这里，如果intChan一直没有关闭，不会一直阻塞而deadlock</span></span><br><span class="line">		<span class="comment">//，而是会自动到下一个case匹配</span></span><br><span class="line">			<span class="keyword">case</span> v:=&lt;-intChan:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;取得数据%v\n&quot;</span>,v)</span><br><span class="line">			<span class="keyword">case</span> v:=&lt;-strChan:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;取得str数据%v\n&quot;</span>,v)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">&quot;都取不到了，不玩了，程序员可以加入&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第四点演示4.goroutine中使用recover,解决协程中出现panic,导致程序崩溃的问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//这里我们可以使用错误处理机制defer+recover</span></span><br><span class="line">	<span class="comment">//注意这里面的defer函数要写在发生错误之前，否则不起作用</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//捕获test抛出的异常</span></span><br><span class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;test发生异常,err=&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义了一个map</span></span><br><span class="line">	<span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">	myMap[<span class="number">0</span>]=<span class="string">&quot;golang&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//4.goroutine中使用recover,解决协程中出现panic,导致程序崩溃的问题</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> sayHello()</span><br><span class="line">	<span class="keyword">go</span> test()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;main ok=&quot;</span>,i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十一章：反射机制"><a href="#第十一章：反射机制" class="headerlink" title="第十一章：反射机制"></a>第十一章：反射机制</h2><h3 id="1-引出问题"><a href="#1-引出问题" class="headerlink" title="1.引出问题"></a>1.引出问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在进行json序列化和反序列化的时候，对于结构体数据的字段名使用tag进行处理时，就需要用到反射。</span><br><span class="line">2.使用反射机制，编写函数适配器</span><br></pre></td></tr></table></figure>

<h3 id="2-基本介绍-1"><a href="#2-基本介绍-1" class="headerlink" title="2.基本介绍"></a>2.基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">1.反射可以在运行时动态获取变量的各种信息，比如变量的类型（type）,类别（kind）</span><br><span class="line">2.如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段，方法）</span><br><span class="line">3.通过反射，可以修改变量的值，可以调用关联的方法</span><br><span class="line">4.使用反射，需要import (&quot;reflect&quot;)</span><br><span class="line"></span><br><span class="line">package reflect</span><br><span class="line">import &quot;reflect&quot;</span><br><span class="line">reflect包实现了运行时反射，允许程序操作任意类型的对象。典型用法是用静态类型interface&#123;&#125;保存一个值，通过调用TypeOf获取其动态类型信息，该函数返回一个Type类型值。调用ValueOf函数返回一个Value类型值，该值代表运行时的数据。Zero接受一个Type类型参数并返回一个代表该类型零值的Value类型值。</span><br><span class="line"></span><br><span class="line">func TypeOf</span><br><span class="line">func TypeOf(i interface&#123;&#125;) Type</span><br><span class="line">TypeOf返回接口中保存的值的类型，TypeOf(nil)会返回nil。</span><br><span class="line"></span><br><span class="line">func ValueOf</span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value</span><br><span class="line">ValueOf返回一个初始化为i接口保管的具体值的Value，ValueOf(nil)返回Value零值。</span><br><span class="line"></span><br><span class="line">func (Value) Interface</span><br><span class="line">func (v Value) Interface() (i interface&#123;&#125;)</span><br><span class="line">本方法返回v当前持有的值（表示为/保管在interface&#123;&#125;类型），等价于：</span><br><span class="line">var i interface&#123;&#125; = (v&#x27;s underlying value)</span><br><span class="line">如果v是通过访问非导出结构体字段获取的，会导致panic。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反射重要的函数和概念</span></span><br><span class="line">1.reflect.TypeOf(变量名)，获取变量的类型，返回reflect.Type类型，这是一个接口</span><br><span class="line">2.reflect.ValueOf(变量名)，获取变量的值，返回reflect.Value类型，这时一个结构体类型，通过reflect.Value,可以获取带关于该变量的很多信息</span><br><span class="line">3.变量，interface&#123;&#125;和reflect.Value是可以相互转换的，这点在实际开发中，会经常使用到</span><br><span class="line">	变量var num 10 --》 b interface&#123;&#125;  可以通过函数传参实现</span><br><span class="line">	b interface&#123;&#125; --》 reflect.Value  rVal:=reflect.ValueOf(b)</span><br><span class="line">    reflect.Value --》 c interface&#123;&#125;  c:=rVal.Interface()</span><br><span class="line">    interface&#123;&#125;   --&gt; 原来的变量类型int  使用类型断言 v:=c.(int)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三点代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//需求1.</span></span><br><span class="line">	<span class="comment">//	请编写一个案例，演示对（基本数据类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span></span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">	<span class="comment">//将变量转换为interface&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;=num</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将interface&#123;&#125;转换为reflect.Value</span></span><br><span class="line">	<span class="keyword">var</span> rv reflect.Value =reflect.ValueOf(i)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将reflect.Value类型转换为interface&#123;&#125;类型</span></span><br><span class="line">	<span class="keyword">var</span> ii <span class="keyword">interface</span>&#123;&#125;=rv.Interface()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将interface&#123;&#125;类型转换为原来的变量的类型</span></span><br><span class="line">	<span class="keyword">var</span> num2 <span class="type">int</span>=ii.(<span class="type">int</span>)</span><br><span class="line">	fmt.Println(num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-反射的快速入门"><a href="#3-反射的快速入门" class="headerlink" title="3.反射的快速入门"></a>3.反射的快速入门</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求1.</span></span><br><span class="line">请编写一个案例，演示对（基本数据类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求2.</span></span><br><span class="line">请编写一个案例，演示对（结构体类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求1.</span></span><br><span class="line"><span class="comment">//	请编写一个案例，演示对（基本数据类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//专门演示反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	<span class="comment">//通过反射获取的传入的变量的type,kind,值</span></span><br><span class="line">	<span class="comment">//1.先获取到reflect.Type</span></span><br><span class="line">	<span class="keyword">var</span> rType reflect.Type=reflect.TypeOf(b)</span><br><span class="line">	fmt.Println(<span class="string">&quot;rType=&quot;</span>,rType)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.获取到reflect.Value</span></span><br><span class="line">	<span class="keyword">var</span> rValue reflect.Value=reflect.ValueOf(b)</span><br><span class="line">	num:= <span class="number">2</span>+rValue.Int()  <span class="comment">//将reflect.Value值转换为int64类型值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;num=&quot;</span>,num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;rValue类型=%T,值=%v\n&quot;</span>,rValue,rValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面我们将rValue转成interface&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> iV <span class="keyword">interface</span>&#123;&#125;=rValue.Interface()</span><br><span class="line">    <span class="comment">//var num3 int=iV //会报错，运行的时候虽然这个iV是int类型，但是编译的时候并不知道</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;iV类型=%T,值=%v\n&quot;</span>,iV,iV)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将interface&#123;&#125;类型通过类型断言转换为int</span></span><br><span class="line">	<span class="keyword">var</span> num2 <span class="type">int</span>=iV.(<span class="type">int</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;num2=&quot;</span>,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">	reflectTest01(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求2.</span></span><br><span class="line"><span class="comment">//请编写一个案例，演示对（结构体类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//专门演示反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	<span class="comment">//通过反射获取的传入的变量的type,kind,值</span></span><br><span class="line">	<span class="comment">//1.先获取到reflect.Type</span></span><br><span class="line">	<span class="keyword">var</span> rType reflect.Type=reflect.TypeOf(b)</span><br><span class="line">	fmt.Println(<span class="string">&quot;rType=&quot;</span>,rType)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.获取到reflect.Value</span></span><br><span class="line">	<span class="keyword">var</span> rValue reflect.Value=reflect.ValueOf(b)</span><br><span class="line">	<span class="comment">//num:= 2+rValue.Int()  //将reflect.Value值转换为int64类型值</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;num=&quot;,num)</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;rValue类型=%T,值=%v\n&quot;</span>,rValue,rValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面我们将rValue转成interface&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> iV <span class="keyword">interface</span>&#123;&#125;=rValue.Interface()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;iV类型=%T,值=%v\n&quot;</span>,iV,iV)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将interface&#123;&#125;类型通过类型断言转换为Student</span></span><br><span class="line">	stu2,ok:=iV.(Student)</span><br><span class="line">	<span class="keyword">if</span> ok&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;stu2=&quot;</span>,stu2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> stu Student=Student&#123;Name:<span class="string">&quot;hello&quot;</span>,Age: <span class="number">15</span>&#125;</span><br><span class="line">	reflectTest01(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-反射的注意事项和使用细节"><a href="#4-反射的注意事项和使用细节" class="headerlink" title="4.反射的注意事项和使用细节"></a>4.反射的注意事项和使用细节</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.reflect.Value.Kind,获取变量的类别，返回的是一个常量。【看手册】</span><br><span class="line">2.Type是类型，Kind是类别，Type和Kind可能是相同的，也可能是不同的</span><br><span class="line">	比如：var num int=10  num的Type是int,kind也是int</span><br><span class="line">	比如：var stu Student num的Type是包名.Student,Kind是struct</span><br><span class="line">3.通过反射可以让变量、interface&#123;&#125;,reflect.Value相互转换</span><br><span class="line">4.使用反射的方式来获取变量的值（并返回对应的类型），要求数据类型匹配，比如x是int,那么就应该使用reflect.Value(x).Int(),而不能用其他的，否则报panic</span><br><span class="line">5.通过反射来修改变量，注意当使用SetXxxx方法来设置需要通过对应的指针类型来完成，这样才能改变传入的变量的值，同时需要使用到reflect.Value.Elem()方法</span><br><span class="line"></span><br><span class="line">6.reflect.Value.Elem()方法</span><br><span class="line">func (Value) Elem</span><br><span class="line">func (v Value) Elem() Value</span><br><span class="line">Elem返回v持有的接口保管的值的Value封装，或者v持有的指针指向的值的Value封装。如果v的Kind不是Interface或Ptr会panic；如果v持有的值为nil，会返回Value零值。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.代码演示</span></span><br><span class="line"><span class="comment">//通过反射，修改基本类型int,结构体类型Student的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	rValue:=reflect.ValueOf(b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;rValue的类型是：%T,值是：%v\n&quot;</span>,rValue,rValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面语句执行panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">	<span class="comment">//rValue.SetInt(20)  </span></span><br><span class="line">    <span class="comment">//注意即便这个rValue的类型就是int，执行上面这条语句也还是会报错，依然需要使用下面这种方式，虽然这样不报错但不会修改main函数里面的值，所以还是需要传入&amp;stu</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行成功  rValue.Elem()的作用类似于是取到*rValue ,但是*rValue这个操作是不可行的，所以有了这个函数</span></span><br><span class="line">	rValue.Elem().SetInt(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//var stu Student=Student&#123;Name:&quot;hello&quot;,Age: 15&#125;</span></span><br><span class="line">	<span class="keyword">var</span> stu <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;反射前：&quot;</span>,stu)</span><br><span class="line">	reflectTest01(&amp;stu)</span><br><span class="line">	fmt.Println(<span class="string">&quot;反射后：&quot;</span>,stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-反射的最佳实践"><a href="#5-反射的最佳实践" class="headerlink" title="5.反射的最佳实践"></a>5.反射的最佳实践</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践1</span></span><br><span class="line">使用反射来遍历结构体的字段，调用结构体的方法，并获取结构体标签的值</span><br><span class="line"></span><br><span class="line">func (Value) Call</span><br><span class="line">func (v Value) Call(in []Value) []Value</span><br><span class="line">Call方法使用输入的参数in调用v持有的函数。例如，如果len(in) == 3，v.Call(in)代表调用v(in[0], in[1], in[2])（其中Value值表示其持有值）。如果v的Kind不是Func会panic。它返回函数所有输出结果的Value封装的切片。和go代码一样，每一个输入实参的持有值都必须可以直接赋值给函数对应输入参数的类型。如果v持有值是可变参数函数，Call方法会自行创建一个代表可变参数的切片，将对应可变参数的值都拷贝到里面。</span><br><span class="line"></span><br><span class="line">func (Value) Method</span><br><span class="line">func (v Value) Method(i int) Value</span><br><span class="line">返回v持有值类型的第i个方法的已绑定（到v的持有值的）状态的函数形式的Value封装。返回值调用Call方法时不应包含接收者；返回值持有的函数总是使用v的持有者作为接收者（即第一个参数）。如果i出界，或者v的持有值是接口类型的零值（nil），会panic。</span><br><span class="line"></span><br><span class="line">func (Value) Field</span><br><span class="line">func (v Value) Field(i int) Value</span><br><span class="line">返回结构体的第i个字段（的Value封装）。如果v的Kind不是Struct或i出界会panic</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">值得注意的是Field()方法必须中v的kind有这个要求，v的Kind不是Struct或i出界会panic，所以遇到结构体的指针类型时需要使用Elem()方法返回，而Method()则没有这个要求</span></span><br><span class="line"></span><br><span class="line">func (Value) MethodByName</span><br><span class="line">func (v Value) MethodByName(name string) Value</span><br><span class="line">返回v的名为name的方法的已绑定（到v的持有值的）状态的函数形式的Value封装。返回值调用Call方法时不应包含接收者；返回值持有的函数总是使用v的持有者作为接收者（即第一个参数）。如果未找到该方法，会返回一个Value零值。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.实践1代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="type">int</span> <span class="string">`json:&quot;monster_age&quot;`</span></span><br><span class="line">	Score <span class="type">float32</span></span><br><span class="line">	Sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Print()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> GetSum(n1,n2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Set(name <span class="type">string</span>,age <span class="type">int</span>,score <span class="type">float32</span>,sex <span class="type">string</span>)  &#123;</span><br><span class="line">	s.Name=name</span><br><span class="line">	s.Age=age</span><br><span class="line">	s.Score=score</span><br><span class="line">	s.Sex=sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStruct</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	rType:=reflect.TypeOf(a)</span><br><span class="line">	rValue:=reflect.ValueOf(a)</span><br><span class="line">	kind:=rValue.Kind()</span><br><span class="line">	<span class="keyword">if</span> kind!=reflect.Struct&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;期待结构体类型&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取得这个类型的字段个数</span></span><br><span class="line">	num:=rValue.NumField()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d fields\n&quot;</span>,num)</span><br><span class="line">	<span class="comment">//遍历结构体的所有字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Field %d :值为：%v\n&quot;</span>,i,rValue.Field(i))</span><br><span class="line">		<span class="comment">//获取到struct标签，注意需要通过reflect.Type来获取tag标签的值</span></span><br><span class="line">		tagVal:=rType.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> tagVal!=<span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Field %d:tag为%v\n&quot;</span>,i,tagVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取和这个类型绑定的方法个数</span></span><br><span class="line">	numOfMethod:=rValue.NumMethod()  <span class="comment">//获取方法时，是使用方法名的字典顺序来排的</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d methods&quot;</span>,numOfMethod)</span><br><span class="line">	rValue.Method(<span class="number">1</span>).Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用结构体的第1个方法Method[0]</span></span><br><span class="line">	<span class="keyword">var</span> params []reflect.Value</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">40</span>))</span><br><span class="line">	res:=rValue.Method(<span class="number">0</span>).Call(params)  <span class="comment">//传入的参数是params</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>,res[<span class="number">0</span>].Int()) <span class="comment">//返回结果，返回的结果res是[]reflect.value切片</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a Monster=Monster&#123;Name:<span class="string">&quot;黄鼠狼精&quot;</span>,Age:<span class="number">300</span>,Score:<span class="number">32.0</span>&#125;</span><br><span class="line">	TestStruct(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践2</span></span><br><span class="line">2.使用反射的方式来获取结构体的tag标签,遍历字段的值，修改字段值，调用结构体方法（要求：通过传递地址的方式完成，在前面案例上修改即可）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实践2代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="type">int</span> <span class="string">`json:&quot;monster_age&quot;`</span></span><br><span class="line">	Score <span class="type">float32</span></span><br><span class="line">	Sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Print()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> GetSum(n1,n2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Set(name <span class="type">string</span>,age <span class="type">int</span>,score <span class="type">float32</span>,sex <span class="type">string</span>)  &#123;</span><br><span class="line">	s.Name=name</span><br><span class="line">	s.Age=age</span><br><span class="line">	s.Score=score</span><br><span class="line">	s.Sex=sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStruct</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	rType:=reflect.TypeOf(a)</span><br><span class="line">	rValue:=reflect.ValueOf(a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;rValue的类型%T,值=%v,kind=%v\n&quot;</span>,rValue,rValue,rValue.Kind())</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	func (v Value) Kind() Kind</span></span><br><span class="line"><span class="comment">	Kind返回v持有的值的分类，如果v是Value零值，返回值为Invalid</span></span><br><span class="line"><span class="comment">	因为此时rValue是指向结构体Monster的指针，直接用rValue.Kind()则得到的是指针ptr类别，因此要想获得指针rValue指向的值struct类别，所以需要用到rValue.Elem()。至于后面的rValue.Elem().NumField()，rValue.Elem().Field(0).SetString(&quot;白象精&quot;)，rType.Elem().Field(i).Tag.Get(&quot;json&quot;)都是一个道理</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    </span><br><span class="line">    kind:=rValue.Elem().Kind()</span><br><span class="line">	<span class="keyword">if</span> kind!=reflect.Struct&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;期待结构体类型&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取得这个类型的字段个数</span></span><br><span class="line">	num:=rValue.Elem().NumField()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d fields\n&quot;</span>,num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改字段的值</span></span><br><span class="line">	rValue.Elem().Field(<span class="number">0</span>).SetString(<span class="string">&quot;白象精&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历结构体的所有字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Field %d :值为：%v\n&quot;</span>,<span class="number">0</span>,rValue.Elem().Field(<span class="number">0</span>))</span><br><span class="line">		<span class="comment">//获取到struct标签，注意需要通过reflect.Type来获取tag标签的值</span></span><br><span class="line">		tagVal:=rType.Elem().Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> tagVal!=<span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Field %d:tag为%v\n&quot;</span>,i,tagVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取和这个类型绑定的方法个数</span></span><br><span class="line">	numOfMethod:=rValue.NumMethod()  <span class="comment">//获取方法时，是使用方法名的字典顺序来排的</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d methods\n&quot;</span>,numOfMethod)</span><br><span class="line">	rValue.Method(<span class="number">1</span>).Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用结构体的第1个方法Method[0]</span></span><br><span class="line">	<span class="keyword">var</span> params []reflect.Value</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">40</span>))</span><br><span class="line">	res:=rValue.Method(<span class="number">0</span>).Call(params)  <span class="comment">//传入的参数是params</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>,res[<span class="number">0</span>].Int()) <span class="comment">//返回结果，返回的结果res是[]reflect.value切片</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a Monster=Monster&#123;Name:<span class="string">&quot;黄鼠狼精&quot;</span>,Age:<span class="number">300</span>,Score:<span class="number">32.0</span>&#125;</span><br><span class="line">	<span class="comment">//修改前</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;修改前：&quot;</span>,a)</span><br><span class="line">    <span class="comment">//要修改字段值时，就需要传递地址进去</span></span><br><span class="line">	TestStruct(&amp;a)</span><br><span class="line">	<span class="comment">//修改后</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;修改后：&quot;</span>,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践3</span></span><br><span class="line">定义了两个函数test1和test2，定义一个适配器函数用作统一处理接口</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实践3代码</span></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectFunc</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	var call1 func(v1 int, v2 int) = func(v1 int,v2 int) &#123;</span></span><br><span class="line"><span class="comment">										t.Log(v1,&quot; &quot;,v2)</span></span><br><span class="line"><span class="comment">									  &#125;</span></span><br><span class="line"><span class="comment">	call1是一个函数类型的变量</span></span><br><span class="line"><span class="comment">	调用就是call1(1,2)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//函数类型的变量</span></span><br><span class="line">	call1:= <span class="function"><span class="keyword">func</span><span class="params">(v1 <span class="type">int</span>,v2 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		t.Log(v1,<span class="string">&quot; &quot;</span>,v2)</span><br><span class="line">	&#125;</span><br><span class="line">	call2:= <span class="function"><span class="keyword">func</span><span class="params">(v1 <span class="type">int</span>,v2 <span class="type">int</span>,s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		t.Log(v1,<span class="string">&quot; &quot;</span>,v2,<span class="string">&quot; &quot;</span>,s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		function reflect.Value</span><br><span class="line">		intValue []reflect.Value</span><br><span class="line">		n <span class="type">int</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统一适配器函数处理接口</span></span><br><span class="line">	bridge:= <span class="function"><span class="keyword">func</span><span class="params">(call <span class="keyword">interface</span>&#123;&#125;,args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		<span class="comment">//n是指该函数有多少个形参</span></span><br><span class="line">		n=<span class="built_in">len</span>(args)</span><br><span class="line">		<span class="comment">//function是指函数名</span></span><br><span class="line">		function=reflect.ValueOf(call)</span><br><span class="line">		<span class="comment">//intValue是指传入的各个形式参数的值</span></span><br><span class="line">		intValue=<span class="built_in">make</span>([]reflect.Value,n,n)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">			<span class="comment">//将每一个传入的参数转为reflect.Value</span></span><br><span class="line">			intValue[i]=reflect.ValueOf(args[i])</span><br><span class="line">		&#125;</span><br><span class="line">		function.Call(intValue)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bridge(call1,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">	bridge(call2,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;string&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践4：使用反射操作任意类型的结构体</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实践4代码</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">	UserId <span class="type">string</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectStruct</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span>(</span><br><span class="line">		model *User</span><br><span class="line">		rValue reflect.Value</span><br><span class="line">	)</span><br><span class="line">	model=&amp;User&#123;&#125;</span><br><span class="line">	rValue=reflect.ValueOf(model)</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf&quot;</span>,rValue.Kind().String())</span><br><span class="line">	rValue=rValue.Elem()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf&quot;</span>,rValue.Kind().String())</span><br><span class="line">	rValue.FieldByName(<span class="string">&quot;UserId&quot;</span>).SetString(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">	rValue.FieldByName(<span class="string">&quot;Name&quot;</span>).SetString(<span class="string">&quot;nickname&quot;</span>)</span><br><span class="line">	t.Log(<span class="string">&quot;model&quot;</span>,*model)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践5</span></span><br><span class="line">使用反射创建并操作结构体</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实践5代码</span></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">	UserId <span class="type">string</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectStruct</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span>(</span><br><span class="line">		model *User</span><br><span class="line">		rType reflect.Type</span><br><span class="line">		elem reflect.Value</span><br><span class="line">	)</span><br><span class="line">	model=&amp;User&#123;&#125;</span><br><span class="line">	rType=reflect.TypeOf(model)</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.TypeOf&quot;</span>,rType.Kind().String())</span><br><span class="line">	rType=rType.Elem()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.TypeOf.Elem&quot;</span>,rType.Kind().String())</span><br><span class="line"></span><br><span class="line">	elem=reflect.New(rType)  <span class="comment">//New返回一个Value类型值，该值持有一个指向类型为rType的新申请的零值的指针</span></span><br><span class="line">	t.Log(<span class="string">&quot;reflect.New&quot;</span>,elem.Kind().String())  <span class="comment">//ptr</span></span><br><span class="line">	t.Log(<span class="string">&quot;reflect.New.Elem&quot;</span>,elem.Elem().Kind().String())  <span class="comment">//struct</span></span><br><span class="line"> 	<span class="comment">//model就是创建的user结构体变量（实例）</span></span><br><span class="line">	model=elem.Interface().(*User)  <span class="comment">//model是*User,他的指向和elem是一样的</span></span><br><span class="line">	elem=elem.Elem() <span class="comment">//取得elem指向的值</span></span><br><span class="line">	elem.FieldByName(<span class="string">&quot;UserId&quot;</span>).SetString(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">	elem.FieldByName(<span class="string">&quot;Name&quot;</span>).SetString(<span class="string">&quot;nickname&quot;</span>)</span><br><span class="line">	t.Log(<span class="string">&quot;elem&quot;</span>,elem)</span><br><span class="line">	t.Log(<span class="string">&quot;model&quot;</span>,*model)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-练习"><a href="#6-练习" class="headerlink" title="6.练习"></a>6.练习</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cal <span class="keyword">struct</span>&#123;</span><br><span class="line">	Num1 <span class="type">int</span></span><br><span class="line">	Num2 <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cal)</span></span> GetSub2(name <span class="type">string</span>)  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v 完成了减法运行，%v-%v=%v&quot;</span>,name,c.Num1,c.Num2,c.Num1-c.Num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetSub2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Cal=Cal&#123;<span class="number">8</span>,<span class="number">3</span>&#125;</span><br><span class="line">	rType:=reflect.TypeOf(c)   <span class="comment">//获取c的类型</span></span><br><span class="line">	t.Log(<span class="string">&quot;reflect.TypeOf&quot;</span>,rType)</span><br><span class="line">	rValue:=reflect.ValueOf(c) <span class="comment">//获取c的值类型</span></span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf&quot;</span>,rValue)</span><br><span class="line">	kind:=rValue.Kind()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf.Kind&quot;</span>,kind)</span><br><span class="line"></span><br><span class="line">	n1:=rValue.FieldByName(<span class="string">&quot;Num1&quot;</span>).Int()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf.FieldByName.Int&quot;</span>,n1)</span><br><span class="line">	n2:=rValue.FieldByName(<span class="string">&quot;Num2&quot;</span>).Int()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf.FieldByName.Int&quot;</span>,n2)</span><br><span class="line"></span><br><span class="line">	function:=rValue.MethodByName(<span class="string">&quot;GetSub2&quot;</span>)</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf.MethodByName&quot;</span>,function)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	intValue:=<span class="built_in">make</span>([]reflect.Value,<span class="number">1</span>)</span><br><span class="line">	intValue[<span class="number">0</span>]=reflect.ValueOf(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">	function.Call(intValue)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十二章：tcp编程"><a href="#第十二章：tcp编程" class="headerlink" title="第十二章：tcp编程"></a>第十二章：tcp编程</h2><h3 id="1-网络编程基本介绍"><a href="#1-网络编程基本介绍" class="headerlink" title="1.网络编程基本介绍"></a>1.网络编程基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.golang的主要设计目标就是面向大规模后端服务程序，网络通信这块是服务端程序必不可少也是至关重要的一部分</span><br><span class="line"></span><br><span class="line">网络编程主要有两种：</span><br><span class="line">1.TCP socket编程，是网络编程的主流，基于tcp/ip协议</span><br><span class="line">2.b/s结构的https编程，使用浏览器去访问服务器时，使用的就是http协议，而http底层依旧是tcp socket实现的</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">cmd&gt;</span><span class="language-bash">tracert www.baidu.com  //跟踪路由</span></span><br><span class="line"><span class="meta prompt_">cmd&gt;</span><span class="language-bash">netstat -an  //可以查看本机有哪些端口被监听</span></span><br><span class="line"><span class="meta prompt_">cmd&gt;</span><span class="language-bash">netstat -anb //来产看监听端口的pid,再结合任务管理器关闭不安全的端口</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">cmd&gt;</span><span class="language-bash">telnet 127.0.0.1 8888  //来查看这个地址的端口号是否处于等待监听状态  进入之后，可以使用ctrl+]退出</span></span><br><span class="line">客户端的端口是随机给的</span><br></pre></td></tr></table></figure>

<h3 id="2-快速入门-5"><a href="#2-快速入门-5" class="headerlink" title="2.快速入门"></a>2.快速入门</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">服务器的处理流程</span></span><br><span class="line">1.监听端口</span><br><span class="line">2.接收客户端的tcp连接，建立客户端和服务器端的链接</span><br><span class="line">3.创建goroutine,处理该链接的请求（客户端通常会通过链接请求发送包）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端的处理流程</span></span><br><span class="line">1.建立和服务端的链接</span><br><span class="line">2.发送请求数据，接收服务器端返回的结果数据</span><br><span class="line">3.关闭链接</span><br><span class="line"></span><br><span class="line">func Listen ¶</span><br><span class="line">func Listen(net, laddr string) (Listener, error)</span><br><span class="line">返回在一个本地网络地址laddr上监听的Listener。网络类型参数net必须是面向流的网络：</span><br><span class="line">&quot;tcp&quot;、&quot;tcp4&quot;、&quot;tcp6&quot;、&quot;unix&quot;或&quot;unixpacket&quot;。参见Dial函数获取laddr的语法。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端代码 tcp_socket/server/main/server.go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	服务器端功能：</span></span><br><span class="line"><span class="comment">		编写一个服务器端程序，在8888端口监听</span></span><br><span class="line"><span class="comment">		可以和多个客户端创建链接</span></span><br><span class="line"><span class="comment">		链接成功后，客户端可以发送数据，服务器端接收数据，并显示在终端上</span></span><br><span class="line"><span class="comment">		先使用telnet来测试，然后编写客户端程序来测试</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	客户端功能：</span></span><br><span class="line"><span class="comment">		编写一个客户端程序，能链接到服务器端的8888端口</span></span><br><span class="line"><span class="comment">		客户端可以发送多行数据，然后就退出</span></span><br><span class="line"><span class="comment">	功能扩展：</span></span><br><span class="line"><span class="comment">		能通过终端输入数据（输入一行发送一行），并发送给服务器端</span></span><br><span class="line"><span class="comment">		在终端输入exit,表示退出程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">func Listen ¶</span></span><br><span class="line"><span class="comment">func Listen(net, laddr string) (Listener, error)</span></span><br><span class="line"><span class="comment">返回在一个本地网络地址laddr上监听的Listener。网络类型参数net必须是面向流的网络：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;tcp&quot;、&quot;tcp4&quot;、&quot;tcp6&quot;、&quot;unix&quot;或&quot;unixpacket&quot;。参见Dial函数获取laddr的语法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line">	<span class="comment">//我们循环接收客户端发来的数据</span></span><br><span class="line">	<span class="keyword">defer</span> conn.Close() <span class="comment">//延迟关闭conn</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环读取</span></span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="comment">//创建一个新的切片</span></span><br><span class="line">		buf:=<span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">1024</span>)</span><br><span class="line">		<span class="comment">//conn.Read(buf)</span></span><br><span class="line">		<span class="comment">//1.等待客户端通过conn发送信息</span></span><br><span class="line">		<span class="comment">//2.如果客户端没有write（发送）信息，那么协程就阻塞在这里了</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;服务器在等待客户端%v的发送信息\n&quot;</span>,conn.RemoteAddr().String())</span><br><span class="line">		n,err:=conn.Read(buf)  <span class="comment">//从conn读取</span></span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端退出&quot;</span>,err)</span><br><span class="line">			<span class="keyword">return</span>  <span class="comment">//重要的</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.显示客户端发送的内容到服务器的终端</span></span><br><span class="line">		fmt.Print(<span class="type">string</span>(buf[:n]))</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;服务器开始监听...&quot;</span>)</span><br><span class="line">	<span class="comment">//net.Listen(&quot;tcp&quot;,&quot;0.0.0.0:8888&quot;)</span></span><br><span class="line">	<span class="comment">//1.tcp表示使用网络协议tcp</span></span><br><span class="line">	<span class="comment">//2.0.0.0.0:8888表示监听本地地址（0.0.0.0）的8888端口号</span></span><br><span class="line">	listen,err:=net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;0.0.0.0:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;监听失败 err:&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;listen 类型=%T,值=%v\n&quot;,listen,listen)</span></span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;listen.Addr 类型=%T,值=%v\n&quot;,listen.Addr(),listen.Addr())</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> listen.Close()  <span class="comment">//延时关闭listen</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环等待客户端来连接我</span></span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="comment">//等待客户端链接</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;等待客户端链接&quot;</span>)</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// handle error</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;Accept err=&quot;</span>,err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Accept() 成功 conn=%v 客户端ip=%v &quot;</span>,conn,conn.RemoteAddr().String())</span><br><span class="line"></span><br><span class="line">		<span class="comment">//启动一个协程来为客户端服务</span></span><br><span class="line">		<span class="keyword">go</span> process(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端代码  tcp_socket/client/main/client.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//客户端发送请求</span></span><br><span class="line">	<span class="comment">//conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8888&quot;)</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;192.168.80.1:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// handle error</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;client dial err:&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;conn 成功&quot;,conn)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//功能1：客户端可以发送单行数据，然后退出</span></span><br><span class="line">	reader:=bufio.NewReader(os.Stdin)  <span class="comment">//os.Stdin 代表标准输入【终端】</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//status, err := bufio.NewReader(conn).ReadString(&#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2：从终端一行一行的读取用户输入，并准备发送给服务器，当输入exit时就退出客户端</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="comment">//2.1.从终端输入一行数据</span></span><br><span class="line">		line,err:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;readString err:&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.2.判断输入的字符是不是exit,如果是exit就退出客户端，如果不是就发送给服务器端，而且继续输入</span></span><br><span class="line">		<span class="keyword">if</span> <span class="string">&quot;exit&quot;</span>==strings.TrimRight(line,<span class="string">&quot;\n&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.再将line发送给服务器</span></span><br><span class="line">		n,err:=conn.Write([]<span class="type">byte</span>(line))</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;conn write err:&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;客户端发送了%d个字节&quot;</span>,n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十三章：经典项目：海量用户通讯系统"><a href="#第十三章：经典项目：海量用户通讯系统" class="headerlink" title="第十三章：经典项目：海量用户通讯系统"></a>第十三章：经典项目：海量用户通讯系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求分析</span></span><br><span class="line">	1.用户注册</span><br><span class="line">	2.用户登录</span><br><span class="line">	3.显示在线用户列表</span><br><span class="line">	4.群聊（广播）</span><br><span class="line">	5.点对点聊天</span><br><span class="line">	6.离线留言</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-golang操作redis"><a href="#1-golang操作redis" class="headerlink" title="1.golang操作redis"></a>1.golang操作redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装第三方开源Redis库</span><br><span class="line">1.使用第三方开源的redis库：github.com/garyburd/redigo/redis</span><br><span class="line">2.在使用Redis前，先安装第三方Redis库，在GOPATH路径下执行安装指令：</span><br><span class="line">	D:\program\goPath&gt;go get github.com/garyburd/redigo/redis</span><br><span class="line">3.安装成功后，可以看到如下包</span><br><span class="line"></span><br><span class="line">特别说明：在安装Redis库前，确保已经安装并配置了Git,因为是从github下载安装Redis库的，需要使用到Git,如果没有安装配置过Git.</span><br></pre></td></tr></table></figure>

<h2 id="第一十四章：并发编程"><a href="#第一十四章：并发编程" class="headerlink" title="第一十四章：并发编程"></a>第一十四章：并发编程</h2><h3 id="1-关于WaitGroup-的用法"><a href="#1-关于WaitGroup-的用法" class="headerlink" title="1.关于WaitGroup()的用法"></a>1.关于WaitGroup()的用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMutex</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, f *fetchState)</span></span> &#123;</span><br><span class="line">	f.mu.Lock()</span><br><span class="line">	already := f.fetched[url]</span><br><span class="line">	f.fetched[url] = <span class="literal">true</span></span><br><span class="line">	f.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> already &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> done sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		done.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">//u2 := u</span></span><br><span class="line">		<span class="comment">//go func() &#123;</span></span><br><span class="line">		<span class="comment">// defer done.Done()</span></span><br><span class="line">		<span class="comment">// ConcurrentMutex(u2, fetcher, f)</span></span><br><span class="line">		<span class="comment">//&#125;()</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> done.Done()</span><br><span class="line">			ConcurrentMutex(u, fetcher, f)</span><br><span class="line">		&#125;(u)</span><br><span class="line">	&#125;</span><br><span class="line">	done.Wait()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关于爬虫程序的三种解法"><a href="#2-关于爬虫程序的三种解法" class="headerlink" title="2.关于爬虫程序的三种解法"></a>2.关于爬虫程序的三种解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Several solutions to the crawler exercise from the Go tutorial</span></span><br><span class="line"><span class="comment">// https://tour.golang.org/concurrency/10</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性的爬虫程序的方式</span></span><br><span class="line"><span class="comment">// Serial crawler</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serial</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, fetched <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fetched[url] &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fetched[url] = <span class="literal">true</span></span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		Serial(u, fetcher, fetched)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用共享状态以及mutex锁的方式</span></span><br><span class="line"><span class="comment">// Concurrent crawler with shared state and Mutex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fetchState <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	fetched <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMutex</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, f *fetchState)</span></span> &#123;</span><br><span class="line">	f.mu.Lock()</span><br><span class="line">	already := f.fetched[url]</span><br><span class="line">	f.fetched[url] = <span class="literal">true</span></span><br><span class="line">	f.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> already &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> done sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		done.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">//u2 := u</span></span><br><span class="line">		<span class="comment">//go func() &#123;</span></span><br><span class="line">		<span class="comment">// defer done.Done()</span></span><br><span class="line">		<span class="comment">// ConcurrentMutex(u2, fetcher, f)</span></span><br><span class="line">		<span class="comment">//&#125;()</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> done.Done()</span><br><span class="line">			ConcurrentMutex(u, fetcher, f)</span><br><span class="line">		&#125;(u)</span><br><span class="line">	&#125;</span><br><span class="line">	done.Wait()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeState</span><span class="params">()</span></span> *fetchState &#123;</span><br><span class="line">	f := &amp;fetchState&#123;&#125;</span><br><span class="line">	f.fetched = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用channel的方式</span></span><br><span class="line"><span class="comment">// Concurrent crawler with channels</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(url <span class="type">string</span>, ch <span class="keyword">chan</span> []<span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ch &lt;- urls</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coordinator</span><span class="params">(ch <span class="keyword">chan</span> []<span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	n := <span class="number">1</span></span><br><span class="line">	fetched := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> urls := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">			<span class="keyword">if</span> fetched[u] == <span class="literal">false</span> &#123;</span><br><span class="line">				fetched[u] = <span class="literal">true</span></span><br><span class="line">				n += <span class="number">1</span></span><br><span class="line">				<span class="keyword">go</span> worker(u, ch, fetcher)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentChannel</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- []<span class="type">string</span>&#123;url&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	coordinator(ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;=== Serial===\n&quot;</span>)</span><br><span class="line">	Serial(<span class="string">&quot;http://golang.org/&quot;</span>, fetcher, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;=== ConcurrentMutex ===\n&quot;</span>)</span><br><span class="line">	ConcurrentMutex(<span class="string">&quot;http://golang.org/&quot;</span>, fetcher, makeState())</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;=== ConcurrentChannel ===\n&quot;</span>)</span><br><span class="line">	ConcurrentChannel(<span class="string">&quot;http://golang.org/&quot;</span>, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Fetcher</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Fetch returns a slice of URLs found on the page.</span></span><br><span class="line">	Fetch(url <span class="type">string</span>) (urls []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher is Fetcher that returns canned results.</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="type">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	body <span class="type">string</span></span><br><span class="line">	urls []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span></span> Fetch(url <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;found:   %s\n&quot;</span>, url)</span><br><span class="line">		<span class="keyword">return</span> res.urls, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;missing: %s\n&quot;</span>, url)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher is a populated fakeFetcher.</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line">	<span class="string">&quot;http://golang.org/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;The Go Programming Language&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/cmd/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;http://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Packages&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;http://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/cmd/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/fmt/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/os/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;http://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Package fmt&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;http://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;http://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Package os&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;http://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-关于rpc的简单使用"><a href="#3-关于rpc的简单使用" class="headerlink" title="3.关于rpc的简单使用"></a>3.关于rpc的简单使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Common RPC request/reply definitions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	OK       = <span class="string">&quot;OK&quot;</span></span><br><span class="line">	ErrNoKey = <span class="string">&quot;ErrNoKey&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Err <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="type">string</span></span><br><span class="line">	Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Err Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Err   Err</span><br><span class="line">	Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">()</span></span> *rpc.Client &#123;</span><br><span class="line">	<span class="comment">//客户端来进行与服务端进行连接</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;客户端来连服务端了&quot;</span>)</span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;客户端连接成功&quot;</span>,client)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	client := connect()</span><br><span class="line">	args := GetArgs&#123;<span class="string">&quot;subject&quot;</span>&#125;</span><br><span class="line">	reply := GetReply&#123;&#125;</span><br><span class="line">	err := client.Call(<span class="string">&quot;KV.Get&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	client.Close()</span><br><span class="line">	<span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(key <span class="type">string</span>, val <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;已经开始执行put()方法了&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	client := connect()</span><br><span class="line">	args := PutArgs&#123;<span class="string">&quot;subject&quot;</span>, <span class="string">&quot;6.824&quot;</span>&#125;</span><br><span class="line">	reply := PutReply&#123;&#125;</span><br><span class="line">	<span class="comment">//KV是服务端注册的一个对象，使它作为一个服务被暴露</span></span><br><span class="line">	err := client.Call(<span class="string">&quot;KV.Put&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;已经内部转向去调用KV.Put方法了&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	client.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Server</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KV <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   sync.Mutex</span><br><span class="line">	data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	kv := <span class="built_in">new</span>(KV)</span><br><span class="line">	kv.data = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">	rpcs := rpc.NewServer()</span><br><span class="line">	rpcs.Register(kv)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	l, e := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;是否已经开始监听&quot;</span>)</span><br><span class="line">			<span class="comment">//注意这里的Accept()方法是一个阻塞式方法，这是在开启的一个线程中执行，一直在等待客户端的连接，</span></span><br><span class="line">			<span class="comment">//但是如果main线程结束了，此处就也会结束。当有客户端来连接时，此时就会拿到Conn对象，从而停止了阻塞。</span></span><br><span class="line">			<span class="comment">//我们还应该注意到这个监听代码是在一个无限循环for中，所以如果在没有客户端连接错误，跳出break或者main线程结束外。</span></span><br><span class="line">			<span class="comment">//该线程将一直处于等待监听的状态。注意这里必须是用开启的线程的方式来处于等待，如果是用main线程，程序将无法再继续执行下去</span></span><br><span class="line">			conn, err := l.Accept()</span><br><span class="line">			fmt.Println(<span class="string">&quot;l已经监听到&quot;</span>,conn.LocalAddr())</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">go</span> rpcs.ServeConn(conn)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		l.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KV)</span></span> Get(args *GetArgs, reply *GetReply) <span class="type">error</span> &#123;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	val, ok := kv.data[args.Key]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		reply.Err = OK</span><br><span class="line">		reply.Value = val</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reply.Err = ErrNoKey</span><br><span class="line">		reply.Value = <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KV)</span></span> Put(args *PutArgs, reply *PutReply) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;进入了Put()方法了&quot;</span>)</span><br><span class="line"></span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	kv.data[args.Key] = args.Value</span><br><span class="line">	reply.Err = OK</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server()</span><br><span class="line">	<span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line">	put(<span class="string">&quot;subject&quot;</span>, <span class="string">&quot;6.824&quot;</span>)</span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;Put(subject, 6.824) done\n&quot;)</span></span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;get(subject) -&gt; %s\n&quot;, get(&quot;subject&quot;))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/05/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" data-id="clrv2tqxi00064hku3dg200yt" data-title="Go语言学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/27/git%E5%AD%A6%E4%B9%A0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          git学习
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/">技术工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 13.33px;">Go</a> <a href="/tags/Hexo/" style="font-size: 13.33px;">Hexo</a> <a href="/tags/JVM/" style="font-size: 13.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 13.33px;">个人</a> <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 13.33px;">云原生</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 13.33px;">并发</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 13.33px;">快捷键</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13.33px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 16.67px;">数据库</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/27/hello-world/">Hexo使用技巧</a>
          </li>
        
          <li>
            <a href="/2024/01/27/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Mac使用技巧</a>
          </li>
        
          <li>
            <a href="/2022/12/27/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Java语言学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/">Java虚拟机学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/">LeetCode刷题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Kevin he<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>