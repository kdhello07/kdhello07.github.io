<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>侬的杂货铺</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java编程思想笔记第一章：对象导论1.2 每个对象都有一个接口  类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类就是一个数据类型。如所有浮点型数字具有相同的特性和行为集合。而程序员是通过定义类来适应问题，如定义Person类。 每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。接口包含了一些操作请求（方法），接口确定了对某一特">
<meta property="og:type" content="article">
<meta property="og:title" content="侬的杂货铺">
<meta property="og:url" content="https://kdhello07.github.io/2022/06/15/typora/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="侬的杂货铺">
<meta property="og:description" content="Java编程思想笔记第一章：对象导论1.2 每个对象都有一个接口  类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类就是一个数据类型。如所有浮点型数字具有相同的特性和行为集合。而程序员是通过定义类来适应问题，如定义Person类。 每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。接口包含了一些操作请求（方法），接口确定了对某一特">
<meta property="og:locale">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211213104800721.png">
<meta property="og:image" content="c:\Users\helloworld\Desktop\java.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211216161902399.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211216162030348.png">
<meta property="article:published_time" content="2022-06-15T01:23:38.000Z">
<meta property="article:modified_time" content="2022-06-15T01:23:38.000Z">
<meta property="article:author" content="Kevin he">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211213104800721.png">
  
    <link rel="alternate" href="/atom.xml" title="侬的杂货铺" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">侬的杂货铺</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术、阅读、分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kdhello07.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-typora/Java编程思想笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java编程思想笔记"><a href="#Java编程思想笔记" class="headerlink" title="Java编程思想笔记"></a>Java编程思想笔记</h1><h2 id="第一章：对象导论"><a href="#第一章：对象导论" class="headerlink" title="第一章：对象导论"></a>第一章：对象导论</h2><h3 id="1-2-每个对象都有一个接口"><a href="#1-2-每个对象都有一个接口" class="headerlink" title="1.2 每个对象都有一个接口"></a>1.2 每个对象都有一个接口</h3><blockquote>
<ul>
<li>类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类就是一个数据类型。如所有浮点型数字具有相同的特性和行为集合。而程序员是通过定义类来适应问题，如定义Person类。</li>
<li>每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。接口包含了一些操作请求（方法），接口确定了对某一特定对象所能发出的请求</li>
</ul>
</blockquote>
<h3 id="1-4-被隐藏的具体实现"><a href="#1-4-被隐藏的具体实现" class="headerlink" title="1.4 被隐藏的具体实现"></a>1.4 被隐藏的具体实现</h3><blockquote>
<ul>
<li>访问控制的存在原因：<ol>
<li>让客户端程序员无法触及他们不应该触及的内容</li>
<li>允许类库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="1-5-复用具体实现"><a href="#1-5-复用具体实现" class="headerlink" title="1.5 复用具体实现"></a>1.5 复用具体实现</h3><blockquote>
<ul>
<li>&#x3D;&#x3D;组合（has a）&#x3D;&#x3D;：使用现有的类合成新类，如果组合是动态发生的，那么它通常被称为聚合。组合经常被视为“has a”(拥有)关系，如汽车拥有引擎一样</li>
</ul>
<p>注意：在创建新类时，应该首先考虑组合</p>
</blockquote>
<h3 id="1-6-继承（is-a）"><a href="#1-6-继承（is-a）" class="headerlink" title="1.6 继承（is a）"></a>1.6 继承（is a）</h3><blockquote>
<ul>
<li>虽然继承有时意味着在子类中添加新方法（Java中以extends表示继承），但并非总是如此，其中有一种使父类（基类、超类）和子类（导出类）之间产生差异的重要方式就是改变现有父类的方法的行为，这被称之为覆盖（overriding）</li>
<li>&#x3D;&#x3D;继承（is a）&#x3D;&#x3D;:如圆形是一个几何图形。经理是一个员工</li>
</ul>
</blockquote>
<h3 id="1-7-伴随多态的可互换对象"><a href="#1-7-伴随多态的可互换对象" class="headerlink" title="1.7 伴随多态的可互换对象"></a>1.7 伴随多态的可互换对象</h3><blockquote>
<ul>
<li>在Java中，使用动态绑定，不需要添加额外的关键字来实现多态。面向对象语言是采用<strong>后期绑定</strong>，被调用的代码只有直到运行的时候才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查，但是并不知道被执行的确切代码。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape类中有基类方法erase(),draw()</span></span><br><span class="line"><span class="comment">//Circle类，Square类继承了Shape类，并且重写了erase(),draw()方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape erase &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape erase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;circle erase &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle erase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square draw &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Square erase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Shape shape=<span class="keyword">new</span> <span class="title class_">Shape</span>();</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        Test t=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">//编译器在进行编译的时候，会判断传入的类型是否是Shape类或者是Shape类的子类,如果不是会直接报错</span></span><br><span class="line">        t.doSomething(shape);</span><br><span class="line">        <span class="comment">//运行的时候会判断该子类中是否复写了该方法，如果有就执行子类中的方法，如果没有就执行父类中的该方法</span></span><br><span class="line">        t.doSomething(circle);</span><br><span class="line">        t.doSomething(square);</span><br><span class="line">        <span class="comment">//注意：运行的时候，虽然执行的是子类中的方法，但是doSomething中的a仍然是使用的父类中的a</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">        <span class="comment">//编译器在这里会判断Shape类中是否有这样的方法，如果没有直接编译失败。</span></span><br><span class="line">        <span class="comment">//这里并不用确定这里要执行的具体代码是什么。运行时看子类中是否有这个方法，如果有就执行子类的</span></span><br><span class="line">        shape.erase();</span><br><span class="line">        shape.draw();</span><br><span class="line">        <span class="comment">//编译器会检查Shape类中是否有这样的字段,运行的时候看的就是父类中该字段</span></span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething &quot;</span>+shape.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Shape erase <span class="number">10</span></span><br><span class="line">Shape erase</span><br><span class="line">Shape draw</span><br><span class="line">doSomething <span class="number">10</span></span><br><span class="line">circle erase <span class="number">5</span></span><br><span class="line">Circle erase</span><br><span class="line">Circle draw</span><br><span class="line">doSomething <span class="number">10</span></span><br><span class="line">Square draw <span class="number">20</span></span><br><span class="line">Square erase</span><br><span class="line">Square draw</span><br><span class="line">doSomething <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8单根继承结构"><a href="#1-8单根继承结构" class="headerlink" title="1.8单根继承结构"></a>1.8单根继承结构</h3><blockquote>
<p>Java中所有的对象都继承自Object类。这样可以使垃圾回收器的实现变得容易得多，并且异常处理时也会容易很多。</p>
</blockquote>
<h3 id="1-9-容器"><a href="#1-9-容器" class="headerlink" title="1.9 容器"></a>1.9 容器</h3><blockquote>
<ul>
<li><p>容器：</p>
<ol>
<li>List</li>
<li>Set</li>
<li>Map</li>
<li>队列、栈、树等</li>
</ol>
</li>
<li><p><strong>参数化类型机制</strong>：在创建容器时，知道自己所保存的对象的类型，从而不需要向下转型以及消除错误的可能。</p>
</li>
<li><p>参数化类型就是一个编译器可以自动定制作用于特定类型上的类。</p>
</li>
<li><p>在Java中这个成为泛型。一对尖括号，中间包含类型的信息。如 ArrayList<Integer></p>
</li>
</ul>
</blockquote>
<h3 id="1-10-对象的创建和生命期"><a href="#1-10-对象的创建和生命期" class="headerlink" title="1.10 对象的创建和生命期"></a>1.10 对象的创建和生命期</h3><blockquote>
<ul>
<li>Java采用了<strong>动态内存</strong>分配。这样牺牲了一定的执行速度，但是带来了更大的灵活性。是在被称为<strong>堆</strong>的内存池中动态创建对象。对对象的声明周期一无所知，但是Java的垃圾回收机制可以自动发现不使用的对象并进行销毁。</li>
<li>c++是采用了在堆栈或静态存储期中创建对象。可以确定对象存活的时间，并且程序员自己可以去销毁它。但可能因为不正确处理带来内存泄漏。</li>
</ul>
</blockquote>
<h2 id="第二章：一切都是对象"><a href="#第二章：一切都是对象" class="headerlink" title="第二章：一切都是对象"></a>第二章：一切都是对象</h2><h3 id="2-1-用引用操作对象"><a href="#2-1-用引用操作对象" class="headerlink" title="2.1 用引用操作对象"></a>2.1 用引用操作对象</h3><blockquote>
<ul>
<li><p>引用：操作对象的标识符。可以拥有一个引用而不一定需要有一个对象与它关联。如String s;</p>
<p>其中s就是一个引用，而没有一个对象来与它关联。</p>
</li>
</ul>
</blockquote>
<h3 id="2-2-必须由你创建所有对象"><a href="#2-2-必须由你创建所有对象" class="headerlink" title="2.2 必须由你创建所有对象"></a>2.2 必须由你创建所有对象</h3><blockquote>
<p>程序运行时，对象是怎样进行放置安排的？特别是内存怎样分配的呢？</p>
<ul>
<li>寄存器：这是最快的存储区，不同于其他的存储区所在的位置，它位于存储器内部。寄存器数量有限。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（c++和c允许向变量一起建议寄存器的分配方式）</li>
<li>堆栈：位于通用RAM(随机访问存储器)中，但通过堆栈指针可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存，若向上移动，则释放那些内存。这是一种快速有效的分配存储的方法，仅次于寄存器。创建程序时，<strong>Java必须知道存储在堆栈内所有项的确切生命周期，以便上下移动指针</strong>。这限制了程序的灵活性。所以虽然<strong>某些Java数据存储于堆栈中——特别是对象引用，但是Java对象并不存于其中</strong>。</li>
<li>堆：<strong>一种通用的内存池（也位于RAM区），用于存放所有的Java对象</strong>。堆不同于堆栈的<strong>好处是：编译器不需要知道存储的数据在堆里存活多长时间</strong>。因此在堆里分配存储具有很大的灵活性。但同时也要付出一定的代价：用堆进行存储分配和清理可能要比用堆栈进行存储分配需要更多的时间。</li>
<li>常量存储：常量值通常直接存放在程序代码内部，有时在嵌入式系统中，常量本身会和其他部分隔离开，所以可以选择将其放在ROM（只读存储器）中。<strong>其中一个例子就是字符串池</strong>。所有字面常量字符串和具有字符串值得常量表达式都自动是内存限定得，并且会置于特殊得静态存储区中。</li>
<li>非RAM存储：<strong>如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子就是流对象和持久化对象。</strong>流对象中，对象被转化成字节流，通常发送给另一台机器。持久化对象中，对象存储与磁盘上。这种存储方式得技巧在于：把对象转化成可以存放在其他媒介上得事物，在需要时，可恢复成常规的，基于RAM的对象。Java提供了对轻量级持久化的支持，而诸如JDBC和Hibernate这样的机制提供了更加复杂的堆在数据库中存储和读取对象信息的支持。</li>
<li><strong>特例</strong>：基本类型。因为new是将对象存储在“堆”。<strong>对于基本类型，Java不用new来创建边练，而是创建一个并非是引用的“自动变量”。这个变量直接存储值，存储于堆栈中。</strong></li>
<li><strong>基本类型具有的包装器，使得可以在<font color='red'>堆中</font>创建一个非基本对象，用来表示对应的基本类型</strong>。</li>
<li>BigInteger和BigDecimal是两个高精度计算的类，没有对应的基本类型。</li>
</ul>
</blockquote>
<h3 id="2-4-创建新的数据类型：类"><a href="#2-4-创建新的数据类型：类" class="headerlink" title="2.4 创建新的数据类型：类"></a>2.4 创建新的数据类型：类</h3><blockquote>
<ul>
<li>类中可以设置两种类型的元素：字段（有时被称作数据成员）和方法（有时被称作成员函数）</li>
<li>类中的数据成员即使没有进行初始化，Java也会确保它获得一个默认值，即默认初始化。</li>
<li>但是如果是方法中的某个局部变量（即并非某个类的字段），并不会进行默认初始化，因此在使用前必须及进行初始化。（使用的话，会编译出错）</li>
</ul>
</blockquote>
<h3 id="2-5-方法、参数和返回值"><a href="#2-5-方法、参数和返回值" class="headerlink" title="2.5 方法、参数和返回值"></a>2.5 方法、参数和返回值</h3><blockquote>
<ul>
<li>int x&#x3D;a.f();    解释：调用方法的行为通常被称为发送消息给对象。在上面的例子中，消息是f(),对象是a。面向对象的程序设计通常简单地归纳为“向对象发送信息”</li>
<li>Java中任何传递对象的场合一样，传递的实际上也是引用，尽管传递的是对象，实际上传递的是对象的引用。</li>
</ul>
</blockquote>
<h3 id="2-6-构建一个Java程序"><a href="#2-6-构建一个Java程序" class="headerlink" title="2.6 构建一个Java程序"></a>2.6 构建一个Java程序</h3><blockquote>
<ul>
<li><font color='red'>static：使用的两种情形</font><ol>
<li>只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任和对象。</li>
<li>希望某个方法不与包含它的类的任何对象关联在一起。即即使没有创建对象，也能够调用这个方法。</li>
</ol>
</li>
<li>当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象关联在一起。所以**<font color='red'>即使从未创建某个类的任何对象，也可以调用其非static方法或者访问其static域。</font>**</li>
<li>通常，必须创建一个对象，并用它来访问数据或方法。因为非static域和方阿飞必须知道他们一起运作的特定对象。</li>
<li><strong>由于在用static 方法前不需要创建任何对象，所以对于static方法，不能简单的通过调用其他非static域或方法而没有指定某个命名对象，来直接访问非static域或方法（因为非static域或方法必须与某一特定对象关联）</strong></li>
<li>访问静态成员两种方式：<ol>
<li>通过类名来进行访问（这对于非静态成员就不行）</li>
<li>通过对象名来进行访问</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTest</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在即使创建了两个StaticTest对象，StaticTest.i也只有一份存储空间，这两个对象共享同一个i.非静态成员则是对每个对象有一个存储空间</span></span><br></pre></td></tr></table></figure>

<h2 id="第三章：操作符"><a href="#第三章：操作符" class="headerlink" title="第三章：操作符"></a>第三章：操作符</h2><h2 id="第四章：控制执行流程"><a href="#第四章：控制执行流程" class="headerlink" title="第四章：控制执行流程"></a>第四章：控制执行流程</h2><blockquote>
<p><font color='red'>switch用法</font></p>
<p>当switch后面的括号中如果是浮点数的话：会报错</p>
<p>Incompatible types. Found: ‘double’, required: ‘<font color='red'>char, byte, short, int, Character, Byte, Short, Integer, String, or an enum’</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (a)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当a为4时输出结果</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//当a为2时输出结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="第五章：初始化与清理"><a href="#第五章：初始化与清理" class="headerlink" title="第五章：初始化与清理"></a>第五章：初始化与清理</h2><h3 id="5-2-方法重载"><a href="#5-2-方法重载" class="headerlink" title="5.2 方法重载"></a>5.2 方法重载</h3><blockquote>
<ul>
<li>方法重载：这个针对的是在一个类里面，对具有相同方法名的方法，但是参数类型或个数不同的重载。（构造器也是，类名相同，里面的形式参数不同），值得注意的是参数的顺序不同也可以是一种重载</li>
<li>方法重写：是指在子类继承父类时，对父类中的方法进行重写。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>设计到基本数据类型的重载的时候<ol>
<li>如常数5作为int值传入的时候，如果有某个重载的方法接受int型参数，它就会被调用。</li>
<li>至于其他情况，如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。如int类型的实际参数类型，就会被提升至long,float,double。<font color='red'>byte类型就会被提升为short,int,long。</font></li>
<li>char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升为int型，long,float,double.</li>
<li>如果传入的实际参数大于重载方法的形式参数的话，就必须通过一个类型转换进行强转，否则编译器会报错。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="5-4-this关键字"><a href="#5-4-this关键字" class="headerlink" title="5.4 this关键字"></a>5.4 this关键字</h3><blockquote>
<ul>
<li>当希望在方法的内部获得对当前对象的引用，就可以使用this关键字。</li>
<li><font color='red'>this关键字</font>：只能在方法的内部使用，<font color='red'>表示对“调用方法的那个对象”的引用</font>。<ul>
<li>this关键字对于将当前对象传递给其他方法也很有用</li>
<li>在构造器中调用构造器（在一个构造器中调用另一个构造器），以避免重复代码<ul>
<li>一般情况下，this都是指这个对象或者当前对象。如果为this添加了参数列表，就有了不同的含义，这将产生对符合此参数列表的某个构造器的明确调用。如this(6,”hello”)。</li>
<li><font color='red'>在使用this调用构造器的时候，不能调用两次，并且调用的时候，必须将构造器调用置于最起始处（第一行），这也证实了this调用构造器语句必须在第一行，否则编译器会报错。</font></li>
<li>值得注意的是，只能在构造器方法体里面才能够调用另外一个构造器方法。在任何方法之外调用都会报错。Call to ‘this()’ must be first statement <font color='red'>in constructor body</font></li>
</ul>
</li>
<li>也可以使用this.s&#x3D;s来代表数据成员，避免与方法或者构造器中的变量产生歧义。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>static关键字</font>：static（静态）方法就是没有this的方法。在static方法的内部不能调用非静态方法，反过来是可以的（即在非静态方法中可以调用静态方法），在static方法内部，可以调用static域和static方法。static方法有时候又被称为<font color='red'>类方法</font>。</li>
</ul>
</blockquote>
<h3 id="5-5-清理：终结处理和垃圾回收"><a href="#5-5-清理：终结处理和垃圾回收" class="headerlink" title="5.5 清理：终结处理和垃圾回收"></a>5.5 清理：终结处理和垃圾回收</h3><blockquote>
<ul>
<li>Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：<font color='red'>假定你的对象（并非使用new）获得了一块特殊的内存区域。因为垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块特殊内存</font>。因此，为了应对这种情况，Java允许在类中定义一个finalize（）方法。</li>
<li><font color='red'>finalize()的工作原理</font>：<font color='red'>一旦垃圾回收器准备好释放占用的存储空间，将首先调用其finalize()方法</font>，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存</li>
<li>应该注意的以下几点：<ol>
<li>对象可能不被垃圾回收</li>
<li>垃圾回收并不等于“析构”</li>
<li>垃圾回收至于内存有关（使用垃圾回收器的唯一原因是为了回收程序不再使用的内存）</li>
</ol>
</li>
<li><font color='red'>finalize()函数的用途：</font><ul>
<li>注意：无论对象是如何创建的，垃圾回收器都会负责释放对象占据所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。（这种特殊情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式，本地方法目前只支持c和c++,如在非Java代码中，也许会调用到C的malloc()函数系列来分配存储空间，而且除了使用free()函数，否则存储空间永远将得不到释放，从而造成内存泄漏，free()是c和c++中的函数，所以需要在finalize()中用本地方法调用它）。但是要尽量避免使用finalize()函数</li>
<li>finalize()函数还可以作为终结条件验证</li>
</ul>
</li>
<li>特别注意的是：<font color='red'>无论是“垃圾回收”还是“终结（finalize）”,都不保证一定会发生，如果Java虚拟机并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以回复内存的。</font>因为finalize函数是发生在要进行垃圾回收之前执行。而垃圾回收是只有在内存濒临消耗完或者退出程序的时候才会被调用，所以也有可能不会执行。</li>
<li>System.gc()函数：用于强制进行垃圾回收和终结动作。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: initialization/TerminationCondition.java</span></span><br><span class="line"><span class="comment">// Using finalize() to detect an object that</span></span><br><span class="line"><span class="comment">// hasn&#x27;t been properly cleaned up.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">checkedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  Book(<span class="type">boolean</span> checkOut) &#123;</span><br><span class="line">    checkedOut = checkOut;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">checkIn</span><span class="params">()</span> &#123;</span><br><span class="line">    checkedOut = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//对于对终结条件的验证</span></span><br><span class="line">    <span class="keyword">if</span>(checkedOut)</span><br><span class="line">      System.out.println(<span class="string">&quot;Error: checked out&quot;</span>);</span><br><span class="line">    <span class="comment">// Normally, you&#x27;ll also do this:</span></span><br><span class="line">    <span class="comment">// super.finalize(); // Call the base-class version</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminationCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">novel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// Proper cleanup:</span></span><br><span class="line">    novel.checkIn();</span><br><span class="line">    <span class="comment">// Drop the reference, forget to clean up:</span></span><br><span class="line">    <span class="comment">//只有在没有具体声明对象的引用的时候，执行Sytem.gc()才会执行finalize()里面的方法</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// Force garbage collection &amp; finalization:</span></span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Error: checked out</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>垃圾回收机制的工作原理：<ul>
<li>其他系统中是采用引用计数的方式（计数值变为0时就释放对象）</li>
<li>在Java中是采用是更快的模式，依据这样的思想：对任何“活的对象”，一定能够追溯到其存活在堆栈或静态存储区之中的引用。由此，先在堆栈或静态存储区遍历引用，对于发现的每个引用，追踪它所引用的对象，然后是此对象的所有引用，如此反复就解决了对象自引用的问题。</li>
<li>Java虚拟机采用自适应的方式。找到活的对象的方式基于不同的虚拟机有不同方式：<ol>
<li>停止-复制。这个对于需要清理的对象（垃圾）很少的时候，就很浪费，因为复制式回收器仍然会将内存从一处复制到另一处。</li>
<li>标记-清扫。这里面不会发生复制动作，会先给对象进行标记，没有标记的对象就会被清理掉。适用于垃圾较少的情况。</li>
<li>上面这两种方式都会暂停运行程序。</li>
<li>Java虚拟机会进行监视，从而在上面这两种方式之间进行一个切换，所以称之为自适应技术。</li>
</ol>
</li>
<li>Java中还有很多附加技术用以提升速度。如即时编译器(JIT——just in time)，将程序全部或部分翻译成本地机器码，提高程序运行速度。<ol>
<li>一种方式是让即时编译器编译所有代码。存在的问题是这种加载动作会散落在整个程序生命周期，比较耗时，同时会增加可执行代码的长度（字节码文件要比即时编译器展开后的本地机器码小很多）。</li>
<li>一种方式是惰性评估。即时编译器只有在必要的时候才编译代码。从不会执行的代码压根不会被JIT所编译，其中Java HotSpot技术就采用了类似方法。代码每次被执行的时侯都会做一些优化，执行的次数越多速度也越快。</li>
</ol>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-7-构造器初始化"><a href="#5-7-构造器初始化" class="headerlink" title="5.7 构造器初始化"></a>5.7 构造器初始化</h3><blockquote>
<p>可以用构造器来进行初始化，但是这无法组织自动初始化（默认初始化）的进行，这个将在构造器被调用之前就发生了。如下面的内容，i首先会被置为0，再然后变成7.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    Test()&#123;i=<span class="number">7</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>初始化顺序</font><font color='red'>:</font></p>
<ul>
<li>在类的内部，成员变量的先后顺序决定了初始化的顺序。即使变量定义散布于成员方法之间，他们仍旧会在任何方法（包括构造器,也包括静态static方法）被调用之前得到初始化。</li>
<li>静态数据的初始化：<font color='red'>静态数据都只占用一份内存区域，static关键字不能应用于局部变量、类上，因此它只能作用于成员变量或成员方法</font>。</li>
<li><font color='red'>静态初始化只有在必要时刻才会进行</font>。如下面的如果不创建Table对象，也不引用Table.b1或Table.b2，那么静态的Bowl b1和b2用于都不会创建。<font color='red'>只有第一个Table对象创建（或者第一次访问静态数据）的时候，它们才会被初始化。此后静态对象不会再次被初始化</font>。而<font color='red'>非静态成员变量，每创建一个对象就都会被初始化一次</font>。如Cupboard类中的Bowl成员变量，每次new Cupboard()时，都会进行一次初始化。</li>
<li>初始化的顺序是<font color='red'>先静态对象</font>（前提是他们尚未因前面的对象创建而被初始化），<font color='red'>而后是非静态对象</font>。即便是在含有静态的main（）方法的类中也是如此。</li>
<li>其实构造器方法在某种意义上可以看成是静态方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bowl</span> &#123;</span><br><span class="line">  Bowl(<span class="type">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">&quot;Bowl(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">1</span>);</span><br><span class="line">  Table() &#123;</span><br><span class="line">    print(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">    bowl2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cupboard</span> &#123;</span><br><span class="line">  <span class="type">Bowl</span> <span class="variable">bowl3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">4</span>);</span><br><span class="line">  Cupboard() &#123;</span><br><span class="line">    print(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">    bowl4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInitialization</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Cupboard</span> <span class="variable">cupboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Bowl(1)</span></span><br><span class="line"><span class="comment">Bowl(2)</span></span><br><span class="line"><span class="comment">Table()</span></span><br><span class="line"><span class="comment">f1(1)</span></span><br><span class="line"><span class="comment">Bowl(4)</span></span><br><span class="line"><span class="comment">Bowl(5)</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">f2(1)</span></span><br><span class="line"><span class="comment">f3(1)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>显式的静态初始化：</font></p>
<ul>
<li>Java允许将多个静态初始化动作组织成一个特殊的“静态子句”（有时也叫静态代码块），这与其他静态初始化动作一样，这段代码只执行一次：当首次生成这个类的对象的时候，或者首次访问属于那个类的静态数据成员时（即便从未生成那个类的对象）</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spoon</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i=<span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cup</span> &#123;</span><br><span class="line">    Cup(<span class="type">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cup(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cups</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Cup cup1=<span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">        cup1 = <span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">1</span>);</span><br><span class="line">        cup2 = <span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">2</span>);  <span class="comment">//这个不会出现异常</span></span><br><span class="line">        <span class="comment">//下面这个会引起非法向前引用的编译异常</span></span><br><span class="line"><span class="comment">//        System.out.println(cup2);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Cup cup2=<span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">4</span>);</span><br><span class="line">    Cups() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cups()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExplicitStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        Cups.cup1.f(<span class="number">99</span>);  <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//static Cups cups1 = new Cups();  // (2)</span></span><br><span class="line">    <span class="comment">// static Cups cups2 = new Cups();  // (2)</span></span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Inside main()</span></span><br><span class="line"><span class="comment">Cup(3)</span></span><br><span class="line"><span class="comment">静态代码块</span></span><br><span class="line"><span class="comment">Cup(1)</span></span><br><span class="line"><span class="comment">Cup(2)</span></span><br><span class="line"><span class="comment">Cup(4)</span></span><br><span class="line"><span class="comment">f(99)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>非静态实例初始化：</p>
<ul>
<li>实例初始化子句是在构造器函数执行之前进行的。</li>
</ul>
</blockquote>
<h3 id="5-8-数组初始化"><a href="#5-8-数组初始化" class="headerlink" title="5.8 数组初始化"></a>5.8 数组初始化</h3><blockquote>
<p>如果是基本类型数组，在创建数组的时候，基本数据类型值会自动初始化成空值。</p>
<p>如：int[] arr&#x3D;new int[20];</p>
<p>​		System.out.print(arr);	&#x2F;&#x2F;输出0</p>
</blockquote>
<blockquote>
<p>如果创建了一个非基本类型的数组，那么你就创建了一个引用数组。但是这还没有完成初始化的工作。必须直到创建新的Integer对象，并把对象赋值给引用，初始化进程才算结束。</p>
<p>如：Integer[] arr&#x3D;new Integer[20];</p>
<p>​		System.out.print(arr[0]);	&#x2F;&#x2F;输出null</p>
<p>​		arr[0]&#x3D;12;     &#x2F;&#x2F;通过自动包装机制创建的</p>
</blockquote>
<h3 id="5-9-枚举类型（enum）"><a href="#5-9-枚举类型（enum）" class="headerlink" title="5.9 枚举类型（enum）"></a>5.9 枚举类型（enum）</h3><blockquote>
<p>如下面适用的形式一样：</p>
<p>在创建enum时，编译器会自动添加一些有用的特性。如</p>
<ol>
<li>创建toString()方法：方便显示某个enum实例的名字</li>
<li>创建ordinal()方法：用来表示某个特定变量的声明顺序</li>
<li>创建了static values()方法：用来按照enum常量的声明顺序，产生由这些常量值构成的数组</li>
</ol>
<ul>
<li>特别值得注意的是，enum有个特别实用的特性，即它可以在switch语句内使用</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Spiciness</span> &#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleEnumUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       	<span class="comment">//注意声明的方式</span></span><br><span class="line">        <span class="type">Spiciness</span> <span class="variable">howHot</span> <span class="operator">=</span> Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">MEDIUM</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Spiciness s : Spiciness.values())</span><br><span class="line">            System.out.println(s + <span class="string">&quot;, ordinal &quot;</span> + s.ordinal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">NOT, ordinal 0</span></span><br><span class="line"><span class="comment">MILD, ordinal 1</span></span><br><span class="line"><span class="comment">MEDIUM, ordinal 2</span></span><br><span class="line"><span class="comment">HOT, ordinal 3</span></span><br><span class="line"><span class="comment">FLAMING, ordinal 4</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在switch语句中使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Burrito</span> &#123;</span><br><span class="line">  Spiciness degree;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Burrito</span><span class="params">(Spiciness degree)</span> &#123; <span class="built_in">this</span>.degree = degree;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">      <span class="keyword">case</span> NOT:    System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> MILD:</span><br><span class="line">      <span class="keyword">case</span> MEDIUM: System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> HOT:</span><br><span class="line">      <span class="keyword">case</span> FLAMING:</span><br><span class="line">      <span class="keyword">default</span>:     System.out.println(<span class="string">&quot;maybe too hot.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Burrito</span></span><br><span class="line">      <span class="variable">plain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.NOT),</span><br><span class="line">      greenChile = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.MEDIUM),</span><br><span class="line">      jalapeno = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.HOT);</span><br><span class="line">    plain.describe();</span><br><span class="line">    greenChile.describe();</span><br><span class="line">    jalapeno.describe();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">This burrito is a little hot.</span></span><br><span class="line"><span class="comment">This burrito is maybe too hot.</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第六章：访问权限控制"><a href="#第六章：访问权限控制" class="headerlink" title="第六章：访问权限控制"></a>第六章：访问权限控制</h2><blockquote>
<ul>
<li><p>访问权限的控制的等级依次为：public、protected、包访问权限（没有关键词）、private</p>
</li>
<li><p>package关键字：将构建类库捆绑到一个内聚的类库单元中。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>控制对成员的访问权限的原因</font>:<ol>
<li>安全,让用户不要触碰到那些他们不应该触碰的部分,简化他们的理解</li>
<li>让类库设计者可以更改类的内部工作方式,而不必担心会对客户端程序员产生重大的影响.接口与实现分离</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="6-1-包：库单元"><a href="#6-1-包：库单元" class="headerlink" title="6.1 包：库单元"></a>6.1 包：库单元</h3><blockquote>
<p>当编写一个Java源代码文件的时候，此文件通常被称为编译单元（或者叫转译单元），每个编译单元都必须有一个后缀名.java。在编译单元内，只允许有一个public类。编译单元中的其他类（指的是没有修饰符的类）主要为主public类提供支持。</p>
<ul>
<li><font color='red'>细节1</font>：类只能被public，或者没有修饰符来修饰。如：<ol>
<li>public class A{}</li>
<li>class B{}</li>
</ol>
</li>
<li><font color='red'>细节2</font>：在对一个编译单元（.java文件）进行编译的时候，<font color='red'>在.java文件中的每一个类都会有一个.class文件</font>。名称都与类名称相同，只是后缀名变为.class文件</li>
</ul>
</blockquote>
<blockquote>
<p>类库实际上是一组类文件，每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字package。</p>
<ul>
<li><font color='red'>细节：如果使用package语句，它必须是文件中除注释以外的第一句程序代码</font>。在文件起始处写。如：<ul>
<li>package access;</li>
</ul>
</li>
</ul>
<p>任何想要使用某个包中的某个类时，有两种选择，即指定全类名或者结合import将该类导入。如：</p>
<ul>
<li>第一种方式：java.util.ArrayList list&#x3D;new java.util.ArrayList();</li>
<li>第二种方式：import java.util.ArrayList;        ArrayList list&#x3D;new ArrayList();</li>
</ul>
</blockquote>
<h3 id="6-2-Java访问权限修饰词"><a href="#6-2-Java访问权限修饰词" class="headerlink" title="6.2 Java访问权限修饰词"></a>6.2 Java访问权限修饰词</h3><h4 id="1-包访问权限"><a href="#1-包访问权限" class="headerlink" title="1. 包访问权限"></a>1. 包访问权限</h4><blockquote>
<ul>
<li><font color='red'>包访问权限可以修饰类，成员变量（域），成员方法，局部变量</font></li>
</ul>
<p>当前包中的所有其他类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。</p>
</blockquote>
<h4 id="2-public：接口访问权限"><a href="#2-public：接口访问权限" class="headerlink" title="2. public：接口访问权限"></a>2. public：接口访问权限</h4><blockquote>
<ul>
<li><font color='red'>public可以修饰类，成员变量，成员方法</font></li>
</ul>
</blockquote>
<h4 id="3-private-你无法访问"><a href="#3-private-你无法访问" class="headerlink" title="3. private:你无法访问"></a>3. private:你无法访问</h4><blockquote>
<ul>
<li>private可以修饰成员变量,成员方法,<font color='red'>注意不能修饰类</font></li>
<li>其中有一个用法就是单例设计模式</li>
<li>还有一个用法是,将成员变量进行私有化,通过提供共有的get&#x2F;set方法来进行修改和获取.</li>
<li><font color='red'>细节:如果基类中只有一个private修饰的构造器方法,那么该类就不允许被其他类继承</font></li>
</ul>
</blockquote>
<h4 id="4-protected-继承访问权限-包含了包访问权限"><a href="#4-protected-继承访问权限-包含了包访问权限" class="headerlink" title="4. protected:继承访问权限(包含了包访问权限)"></a>4. protected:继承访问权限(包含了包访问权限)</h4><blockquote>
<ul>
<li>protected可以修饰成员变量,成员方法,<font color='red'>注意不能修饰类</font></li>
<li>有时,基类的创建者会希望有某个特定成员,把对它的访问权限赋予派生类而不是所有类,这就需要protected来进行完成.</li>
<li><font color='red'>细节:前提是在子类与父类不在一个包中</font>,在派生类(子类)中,可以在子类的构造器方法中通过super()的方式来访问父类中用protected修饰的构造器方法.也可以通过子类的引用(实例对象)来访问父类中用protected修饰的成员变量和成员方法.但是值得注意的是,在子类中,<font color='red'>通过父类的引用</font>(实例对象并不能访问父类中的protected修饰的成员变量和成员方法.但是也不能直接使用父类的protected构造器方法,而是需要用super关键字</li>
<li>细节:如果子类和父类都在一个包中,则可以直接使用父类的protected构造器方法,也可以通过父类的引用访问父类的成员方法和成员变量</li>
</ul>
</blockquote>
<h3 id="6-3-接口和实现"><a href="#6-3-接口和实现" class="headerlink" title="6.3 接口和实现"></a>6.3 接口和实现</h3><blockquote>
<p>访问权限的控制被称为是具体实现的隐藏.把数据和方法包装进类中,以及具体实现的隐藏,常共同被称作是<font color='red'>封装,</font>其结果是一个同时带有特征和行为的数据类型.</p>
</blockquote>
<h3 id="6-4-类的访问权限"><a href="#6-4-类的访问权限" class="headerlink" title="6.4 类的访问权限"></a>6.4 类的访问权限</h3><blockquote>
<p>一个编译单元(.java文件)最多允许有一个主public类,如果有那么这个文件名就必须该主类名.如果没有主public类,都是包访问权限,那么该文件名就可以随意.</p>
</blockquote>
<p>细节:在正常情况下,类只能由public或者包访问权限修饰.但是事实上,内部类可以是由protected或者private进行修饰,这是一个特例.</p>
<blockquote>
<p>如果我们将一个类的构造器方法添加了private修饰符,那么其他类就无法创建该类的对象,但是现在别人可以该怎样使用它呢?</p>
</blockquote>
<p>方式一:通过一个公有方法返回该类的引用,该种方式允许创建多个该类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Soup1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Soup1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//通过一个公有方法返回该类的引用,该种方式允许创建多个该类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Soup1 <span class="title function_">makeSoup</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Soup1</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;方式二:单例设计模式&#x3D;&#x3D;  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Soup2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Soup2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//这里应该注意到的是,其他类只能通过类名调用下面公有的access方法才能获取到对象实例,并不能通过类名调用ps1成员变量来进行访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Soup2 ps1=<span class="keyword">new</span> <span class="title class_">Soup2</span>();</span><br><span class="line">   	<span class="comment">//这里通过提供一个共有方法返回一个私有的静态成员变量,每次调用该方法时,返回的都是同一个实例,因为该实例是一个静态成员,所以共享一份内存空间.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Soup2 <span class="title function_">access</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ps1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第七章：复用类"><a href="#第七章：复用类" class="headerlink" title="第七章：复用类"></a>第七章：复用类</h2><blockquote>
<ul>
<li>组合和继承：<ul>
<li>组合：是在一个新类中把另一个类的对象作为它的数据成员</li>
<li>继承：是新类按照现有的类的类型来进行创建，并添加自己的新代码</li>
<li>这两种方式的混用</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="7-2-继承语法"><a href="#7-2-继承语法" class="headerlink" title="7.2 继承语法"></a>7.2 继承语法</h3><blockquote>
<p>在一个编译单元（.java文件）中，可以有至多一个主public类中，可以有任意个类（包访问权限），并且<font color='red'>每个类中可以有主main方法</font>。所有一个文件中可以有多个main方法。并且这些main（）都可以作为程序主入口，看你选择哪个。即使有多个main(),在进行编译的时候也只有命令行所调用的那个类的main()方法会被调用。其他main()方法可以在被调用的main方法中被调用</p>
</blockquote>
<blockquote>
<p><font color='red'>在子类中，如果对父类中的方法进行了覆盖（overriding），那么要想在子类中访问父类中的这个方法时可以通过super关键字来进行访问，而不能通过子类的引用来进行访问</font>。当然这里也可以直接通过父类的引用来进行调用。Java用super表示超类的意思，当前类就是从超类继承来的。如super.test();</p>
</blockquote>
<blockquote>
<ul>
<li>&#x3D;&#x3D;重点关注&#x3D;&#x3D;：<ol>
<li>在一般情况下，对成员变量的初始化要先与该类中的方法（包括构造器方法）调用，所以这也是为什么先输出第一个示例先输出B(),再输出A()</li>
<li><font color='red'>在继承的情况下，创建子类对象时，会先进行执行子类构造器中的第一行，即调用基类构造器，执行完基类构造器后，再对子类中的成员变量进行初始化，再是子类构造器后面的语句了。</font></li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">###################################################################################</span><br><span class="line">一般情况下（没有继承） :注意输出顺序</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E05_SimpleInheritance</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br><span class="line"></span><br><span class="line">#####################################################################################</span><br><span class="line">在有继承的情况下：注意输出顺序</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="built_in">super</span>();</span><br><span class="line">     System.out.println(<span class="string">&quot;hello C()&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E05_SimpleInheritance</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">hello C()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在子类构造器中，必须要显式或者隐式的调用父类的构造器方法。<ol>
<li>当是显式的时候，就直接使用super()进行调用即可。可以同时传参</li>
<li><font color='red'>当是隐式的时候，则默认就会执行super()去调用父类中的无参构造函数</font>，所以此时父类中必须要有无参构造器，若没有就会报错。</li>
</ol>
</li>
<li>&#x3D;&#x3D;细节：&#x3D;&#x3D;对父类构造器的调用语句（使用super()的方式）只能写在第一行，并且只能调用一次（侧面证实了该语句只能写在第一行）。应该注意到的是，<font color='red'>即便使用了new 父类类名（）的方式，在子类中仍然还是需要使用super的方式进行调用。 </font></li>
</ul>
</blockquote>
<h3 id="7-3-代理（没太弄明白）"><a href="#7-3-代理（没太弄明白）" class="headerlink" title="7.3 代理（没太弄明白）"></a>7.3 代理（没太弄明白）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过不用继承的方式，让代理对象去操作要继承的对象</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;不用代理模式的代码：&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShipControls</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">turboBoost</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShip</span> <span class="keyword">extends</span> <span class="title class_">SpaceShipControls</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SpaceShip</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpaceShip</span> <span class="variable">protector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpaceShip</span>(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;使用代理模式的代码：&#x3D;&#x3D;</p>
<p>​	上面不使用代理模式的问题在于，SpaceshipControls的所有方法在Spaceship中都暴露了出来。而代理模式中就通过代理对象来对SpaceshipControls中的方法进行管理，所以Spaceship就不用对SpaceshipControls进行继承了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShipDelegation</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">SpaceShipControls</span> <span class="variable">controls</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SpaceShipControls</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SpaceShipDelegation</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Delegated methods:</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.back(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.down(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.forward(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.left(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.right(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turboBoost</span><span class="params">()</span> &#123;</span><br><span class="line">    controls.turboBoost();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.up(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpaceShipDelegation</span> <span class="variable">protector</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SpaceShipDelegation</span>(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<h3 id="7-7-向上转型"><a href="#7-7-向上转型" class="headerlink" title="7.7 向上转型"></a>7.7 向上转型</h3><blockquote>
<ul>
<li><font color='red'>将子类的引用转化为父类的引用我们称之为向上转型</font></li>
<li>值得注意的是：向上转型后的父类引用在进行调用方法的时候，编译的时候会先看父类中是否有该方法，如果有则编译通过，如果没有就编译失败。在运行的时候，会判断在子类中是否对该方法进行了覆盖，如果进行了覆盖，则调用的就是子类中的方法，如果子类中没有则就直接调用父类中的该方法。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Amphibian</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(Amphibian amphibian)</span>&#123;</span><br><span class="line">        System.out.println(amphibian+<span class="string">&quot;能游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;陆生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;水生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Frog</span> <span class="keyword">extends</span> <span class="title class_">Amphibian</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里通过将一个子类的引用传给父类的引用实现了向上转型</span></span><br><span class="line">        Amphibian amphibian=<span class="keyword">new</span> <span class="title class_">Frog</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//值得注意的是：向上转型后的父类引用在进行调用方法的时候，编译的时候会先看父类中是否有该方法（并且要求该方法能够被该子类继承，即如果是父类中的私有方法也不可以），如果有则编译通过，如果没有就编译失败。在运行的时候，会判断在子类中是否对该方法进行了覆盖，如果进行了覆盖，则调用的就是子类中的方法，如果子类中没有则就直接调用父类中的该方法。</span></span><br><span class="line">        amphibian.a();</span><br><span class="line">        amphibian.b();</span><br><span class="line">        Frog frog=<span class="keyword">new</span> <span class="title class_">Frog</span>();</span><br><span class="line">        swim(frog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙陆生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙水生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(Amphibian amphibian)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙能游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-8-final关键字"><a href="#7-8-final关键字" class="headerlink" title="7.8 final关键字"></a>7.8 final关键字</h3><blockquote>
<p>根据上下文环境，final关键字的含义存在细微差别，但通常都是无法改变的。一般final可以作用于数据，方法和类</p>
</blockquote>
<h4 id="1-final数据"><a href="#1-final数据" class="headerlink" title="1. final数据"></a>1. final数据</h4><blockquote>
<ul>
<li><p>基本数据类型：</p>
<ul>
<li><p>对于final修饰基本类型数据，表明这个数据是一个常量</p>
</li>
<li><p>而用static和final共同修饰得数据，表明这个数据也是一个常量，只是所有对象共享一份存储空间。</p>
</li>
</ul>
</li>
<li><p>对象引用数据：</p>
<ul>
<li>final修饰得对象引用只是表明不能再被指向另一个新的对象。但是该对象引用的值仍然可以进行改变。</li>
<li>例如：一个final修饰的数据对象引用。这个数组里面的值仍然是可以改变的，只是不能再被指向另外一个新的数组对象。</li>
</ul>
</li>
<li><p>对于final修饰的域（数据成员），必须在域的定义处或者每个构造器中用表达式对final进行赋值（显式的），这正是final域在使用前总是被初始化的原因。</p>
</li>
<li><p>final参数：Java允许在参数列表中以声明的方式将参数指明为final,这就意味着你无法在方法中更改参数的类型。可以读final参数，但是无法修改，这一特性主要用来向匿名内部类传递数据。</p>
</li>
</ul>
</blockquote>
<h4 id="2-final方法"><a href="#2-final方法" class="headerlink" title="2. final方法"></a>2. final方法</h4><blockquote>
<p>使用final修饰方法，主要是将方法进行锁定，以防任何继承类修改它的含义。<font color='red'>所以final修饰的方法不可以被覆盖，确保了方法的行为不会发生改变。</font></p>
<ul>
<li>细节：final和private关键字<ul>
<li>类中所有的private方法都隐式地指定为final的。因为无法取用private方法，所以也就无法覆盖它了。可以对private方法添加final关键字。</li>
<li>如果父类中有一个private方法，而子类中以相同的名称生成一个public、protected或包访问权限的方法，此时并没有覆盖父类中该方法，仅是生成了一个新的方法。（这里面在向上转型调用该方法时会报错，说父类与子类该方法并不匹配）</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-final类"><a href="#3-final类" class="headerlink" title="3. final类"></a>3. final类</h4><blockquote>
<ul>
<li>当用final修饰类时，表明该类不能被继承，即不希望该类有子类。</li>
<li>final类的域（成员）可以根据需要确定是否定义为final,不论类是否定义为final,相同的规则都适用域定义为final的域。然而final类禁止被继承，所以final类中的所有方法都隐式指定为final的，因为无法覆盖他们。</li>
</ul>
</blockquote>
<h3 id="7-9-继承与初始化"><a href="#7-9-继承与初始化" class="headerlink" title="7.9 继承与初始化"></a>7.9 继承与初始化</h3><blockquote>
<ol>
<li>在运行一个类文件时，加载器会去加载该类，在加载的过程中，编译器会注意它有基类，于是就对它进行继续加载，这里不管是否打算产生一个该基类的对象，这都要发生。所以&#x3D;&#x3D;根基类中的static初始化&#x3D;&#x3D;即会被执行（在本例中是Insect类），再然后就是下一个导出类，依此类推。</li>
<li>至此，必要的类加载完毕，在这里应该注意的一点是如果调用的静态方法，则会先执行静态方法中的方法体内容，再进行本类中成员对象的创建，对象就可以创建了，首先对象中所有的基本数据类型都会被设为默认值，对象引用置为null。</li>
<li>然后，基类的构造器方法就会被调用，在本例中是被自动调用的，但也可以用super来指定对构造器的调用。基类构造器和导出类的构造器一样，以相同的顺序经历相同的过程。</li>
<li>&#x3D;&#x3D;在基类构造器完成之后，实例变量（即非static成员）按其次序被初始化。&#x3D;&#x3D;<font color='red'>在每一个类中，静态成员或者静态代码块先执行，再是实例变量，再是构造器方法。</font></li>
<li>&#x3D;&#x3D;最后构造器的其余部分被执行。&#x3D;&#x3D;</li>
</ol>
</blockquote>
<blockquote>
<p><font color='red'>加载类的动作仅发生一次（所以这也是为什么静态代码块只被执行一次）</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Insect</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> j;</span><br><span class="line">  Insect() &#123;</span><br><span class="line">    print(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    j = <span class="number">39</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span></span><br><span class="line">    printInit(<span class="string">&quot;static Insect.x1 initialized&quot;</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">printInit</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    print(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beetle</span> <span class="keyword">extends</span> <span class="title class_">Insect</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> printInit(<span class="string">&quot;Beetle.k initialized&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Beetle</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;k = &quot;</span> + k);</span><br><span class="line">    print(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span></span><br><span class="line">    printInit(<span class="string">&quot;static Beetle.x2 initialized&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Beetle constructor&quot;</span>);</span><br><span class="line">    <span class="type">Beetle</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Beetle</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">static Insect.x1 initialized</span></span><br><span class="line"><span class="comment">static Beetle.x2 initialized</span></span><br><span class="line"><span class="comment">Beetle constructor</span></span><br><span class="line"><span class="comment">i = 9, j = 0</span></span><br><span class="line"><span class="comment">Beetle.k initialized</span></span><br><span class="line"><span class="comment">k = 47</span></span><br><span class="line"><span class="comment">j = 39</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第八章：多态"><a href="#第八章：多态" class="headerlink" title="第八章：多态"></a>第八章：多态</h2><blockquote>
<ul>
<li><p>多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要他们是从同一种基类到处而来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。</p>
</li>
<li><p>多态（也称作动态绑定，后期绑定或运行时绑定）</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;Instrument play&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Piano</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;Piano play&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wind</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;Wind play&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(Instrument instrument)</span>&#123;</span><br><span class="line">        instrument.play();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        play(<span class="keyword">new</span> <span class="title class_">Instrument</span>);  <span class="comment">//没有进行向上转型</span></span><br><span class="line">        play(<span class="keyword">new</span> <span class="title class_">Piano</span>());	  <span class="comment">//向上转型</span></span><br><span class="line">        play(<span class="keyword">new</span> <span class="title class_">Wind</span>());	  <span class="comment">//向上转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Instrument play</span><br><span class="line">Piano play</span><br><span class="line">Wind play</span><br></pre></td></tr></table></figure>

<h3 id="8-2-转机"><a href="#8-2-转机" class="headerlink" title="8.2 转机"></a>8.2 转机</h3><blockquote>
<ul>
<li>将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做&#x3D;&#x3D;前期绑定&#x3D;&#x3D;。在面向过程语言中默认就是这种绑定方式。如c语言就只有这一种。</li>
</ul>
</blockquote>
<blockquote>
<p>上面程序(Test类中的play方法)令人迷惑的地方在于，编译器只有一个Instrument引用，它无法知道究竟调用哪个方法。</p>
<p>解决办法：&#x3D;&#x3D;后期绑定&#x3D;&#x3D;。它的含义就是在运行时根据对象的类型进行绑定。后期绑定又叫动态绑定或运行时绑定。</p>
</blockquote>
<blockquote>
<p>在Java中，除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。这意味着在通常情况下，我们不必判定是否应该进行后期绑定—它会自动发生。</p>
</blockquote>
<blockquote>
<p><font color='red'>特例1：</font>“覆盖”私有方法</p>
</blockquote>
<p><strong>下面这个代码执行不会出错</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;private f()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">PrivateOverride</span> <span class="variable">po</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Derived</span>();		<span class="comment">//因为这里private方法不能被覆盖，但是这里也不会报错，但是执行的是父类中的private方法</span></span><br><span class="line">    po.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;public f()&quot;</span>); &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">private f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>下面这个代码执行就会出错</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test824</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        Base b=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        b.a();  <span class="comment">//编译出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>特例2：</font>域与静态方法</p>
<ul>
<li><font color='red'>当子类对象向上转型赋给父类引用时，在使用父类引用访问子类和父类都有的成员变量时，会直接从当前父类域中获取</font>。因为域操作不是多态，即子类并不会将父类的成员变量覆盖掉，所以继承后子类中实际上包含了两个该成员变量，一个是它自己的还有是从父类中得到的。</li>
<li>静态方法也不具有多态性。静态方法是与类，而并非与单个的对象相关联的。因为静态方法也不允许被重载。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Base staticGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Base dynamicGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSub</span> <span class="keyword">extends</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">  <span class="comment">//这里虽然无法覆盖父类中的staticGet()方法，但是这里的访问权限，返回类型，参数类型也还是要满足重载的要求</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Derived staticGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Derived dynamicGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticPolymorphism</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StaticSuper</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticSub</span>(); <span class="comment">// Upcast</span></span><br><span class="line">    System.out.println(sup.staticGet());			<span class="comment">//注意调用的是父类中方法，</span></span><br><span class="line">    System.out.println(sup.dynamicGet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Base staticGet()</span></span><br><span class="line"><span class="comment">Derived dynamicGet()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-构造器与多态"><a href="#8-3-构造器与多态" class="headerlink" title="8.3 构造器与多态"></a>8.3 构造器与多态</h3><blockquote>
<p>在导出类（子类）的构造器主体中，如果没有明确指定调用某个基类构造器，它就会默认地调用默认构造器（无参构造器），如果不存在无参构造器，编译器就会报错。</p>
<ul>
<li>&#x3D;&#x3D;执行顺序：&#x3D;&#x3D;<ol>
<li>先会进行从根基类到下一个导出类的static初始化。再就是调用的static里面的方法体执行，再是该类中的非static成员创建，再就是从根基类到导出类的构造器，并且具体到每一个类中构造器执行，都是先非static成员创建，然后是构造器里面的方法执行。&#x3D;&#x3D;（总结为：先执行静态变量初始化以及非static成员赋上默认值（0，‘’，null这些的），再就是基类构造器执行，再就是本类非static成员初始化，再是执行本类的构造器里面的语句）&#x3D;&#x3D;</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  Meal() &#123; print(<span class="string">&quot;Meal()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bread</span> &#123;</span><br><span class="line">  Bread() &#123; print(<span class="string">&quot;Bread()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cheese</span> &#123;</span><br><span class="line">  Cheese() &#123; print(<span class="string">&quot;Cheese()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lettuce</span> &#123;</span><br><span class="line">  Lettuce() &#123; print(<span class="string">&quot;Lettuce()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lunch</span> <span class="keyword">extends</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  Lunch() &#123; print(<span class="string">&quot;Lunch()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PortableLunch</span> <span class="keyword">extends</span> <span class="title class_">Lunch</span> &#123;</span><br><span class="line">  PortableLunch() &#123; print(<span class="string">&quot;PortableLunch()&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sandwich</span> <span class="keyword">extends</span> <span class="title class_">PortableLunch</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Bread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bread</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Cheese</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cheese</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lettuce</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lettuce</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Sandwich</span><span class="params">()</span> &#123; print(<span class="string">&quot;Sandwich()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Sandwich</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Meal()</span></span><br><span class="line"><span class="comment">Lunch()</span></span><br><span class="line"><span class="comment">PortableLunch()</span></span><br><span class="line"><span class="comment">Bread()</span></span><br><span class="line"><span class="comment">Cheese()</span></span><br><span class="line"><span class="comment">Lettuce()</span></span><br><span class="line"><span class="comment">Sandwich()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>继承和清理</strong></p>
<ul>
<li>​	对象在销毁的时候应该和初始化的顺序相反，对于字段，则应该和声明的顺序相反。</li>
<li>在对基类中的清理方法进行覆盖时，别忘了要在后面调用基类的清理方法，否则，基类的清理动作不会发生。</li>
</ul>
</blockquote>
<blockquote>
<p>构造器内部的多态方法的行为：在执行类中的方法时，调用的类中的变量还未初始化</p>
<p>所以优化的方法是：最好尽量避免在构造器中调用方法。或者在构造器中只调用基类中的final方法（也适用于private方法，他们自动属于private方法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; print(<span class="string">&quot;Glyph.draw()&quot;</span>); &#125;</span><br><span class="line">  Glyph() &#123;</span><br><span class="line">    print(<span class="string">&quot;Glyph() before draw()&quot;</span>);</span><br><span class="line">    draw();</span><br><span class="line">    print(<span class="string">&quot;Glyph() after draw()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundGlyph</span> <span class="keyword">extends</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  RoundGlyph(<span class="type">int</span> r) &#123;</span><br><span class="line">    radius = r;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.RoundGlyph(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.draw(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyConstructors</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RoundGlyph</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Glyph() before draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.draw(), radius = 0</span></span><br><span class="line"><span class="comment">Glyph() after draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.RoundGlyph(), radius = 5</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-用继承进行设计"><a href="#8-5-用继承进行设计" class="headerlink" title="8.5 用继承进行设计"></a>8.5 用继承进行设计</h3><blockquote>
<p>通用的准则是：用继承表达行为间的差异，并用字段表达状态上的变化</p>
</blockquote>
<p><strong>状态模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HappyActor</span> <span class="keyword">extends</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123; print(<span class="string">&quot;HappyActor&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SadActor</span> <span class="keyword">extends</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123; print(<span class="string">&quot;SadActor&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stage</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HappyActor</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123; actor = <span class="keyword">new</span> <span class="title class_">SadActor</span>(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performPlay</span><span class="params">()</span> &#123; actor.act(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transmogrify</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Stage</span> <span class="variable">stage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stage</span>();</span><br><span class="line">    stage.performPlay();</span><br><span class="line">    stage.change();</span><br><span class="line">    stage.performPlay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HappyActor</span></span><br><span class="line"><span class="comment">SadActor</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>is-a：是只有在基类中已经存在的方法才可以在导出类中被覆盖</p>
<p>is-like-a：除了覆盖的那些方法，他还具有额外方法实现的其他特性，即基类中没有的方法</p>
</blockquote>
<blockquote>
<p>向下转型：是不安全的，所以需要进行一个类型转换，即便这样，Java仍然会在运行期间对其进行检查，如果转换类型失败，则会报类转型异常（ClassCastException）,这个属于运行时异常。（为了防止转换失败，可以适用instanceof进行一个判断后，再进行类型强转）</p>
<p>RTTI(运行时类型识别)：在运行期间对类型进行检查的行为。</p>
</blockquote>
<h2 id="第九章：接口"><a href="#第九章：接口" class="headerlink" title="第九章：接口"></a>第九章：接口</h2><h3 id="9-1-抽象类和抽象方法"><a href="#9-1-抽象类和抽象方法" class="headerlink" title="9.1 抽象类和抽象方法"></a>9.1 抽象类和抽象方法</h3><blockquote>
<p>包含抽象方法的类是叫做抽象类。</p>
<p>抽象类也可能会没有任何抽象方法。是为了阻止创建该类的任何对象。（不允许创建抽象类对象，但是可以有抽象类的引用，例如多态时使用。）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abs</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Abs</span><span class="params">()</span>&#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test9_1</span> <span class="keyword">extends</span> <span class="title class_">Abs</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Test9_1 t=<span class="keyword">new</span> <span class="title class_">Test9_1</span>();</span><br><span class="line">        t.fun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">0</span>    <span class="comment">//此时输出的是尚未进行初始化的i,i只是被赋予零值</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>抽象方法不能用private访问修饰符来进行修饰（即private和abstract不能连用）</p>
</blockquote>
<h3 id="9-2-接口"><a href="#9-2-接口" class="headerlink" title="9.2 接口"></a>9.2 接口</h3><blockquote>
<p>接口可以用public或者包访问权限（没有修饰符）进行修饰。<font color='red'>接口也可以包含域（数据成员），但是这些域隐式地是static和final的。接口中的方法默认就都是public修饰的，</font>因此实现了一个接口的类，在覆盖该接口中定义的方法的时候，必须定义为public，否则权限就会降低，编译器就会报错。</p>
</blockquote>
<h3 id="9-3-完全解耦"><a href="#9-3-完全解耦" class="headerlink" title="9.3 完全解耦"></a>9.3 完全解耦</h3><blockquote>
<p>&#x3D;&#x3D;策略设计模式&#x3D;&#x3D;：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法</p>
<ul>
<li>如下图代码所示：Precessor对象就是一个策略。策略就是传递进去的参数对象，它包含要执行的代码。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">  &#125;</span><br><span class="line">  Object <span class="title function_">process</span><span class="params">(Object input)</span> &#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Upcase</span> <span class="keyword">extends</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  String <span class="title function_">process</span><span class="params">(Object input)</span> &#123; <span class="comment">// Covariant return</span></span><br><span class="line">    <span class="keyword">return</span> ((String)input).toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Downcase</span> <span class="keyword">extends</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  String <span class="title function_">process</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((String)input).toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Splitter</span> <span class="keyword">extends</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  String <span class="title function_">process</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="comment">// The split() argument divides a String into pieces:</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.toString(((String)input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apply</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Processor p, Object s)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Using Processor &quot;</span> + p.name());</span><br><span class="line">    print(p.process(s));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&quot;Disagreement with beliefs is by definition incorrect&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    process(<span class="keyword">new</span> <span class="title class_">Upcase</span>(), s);</span><br><span class="line">    process(<span class="keyword">new</span> <span class="title class_">Downcase</span>(), s);</span><br><span class="line">    process(<span class="keyword">new</span> <span class="title class_">Splitter</span>(), s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Using Processor Upcase</span></span><br><span class="line"><span class="comment">DISAGREEMENT WITH BELIEFS IS BY DEFINITION INCORRECT</span></span><br><span class="line"><span class="comment">Using Processor Downcase</span></span><br><span class="line"><span class="comment">disagreement with beliefs is by definition incorrect</span></span><br><span class="line"><span class="comment">Using Processor Splitter</span></span><br><span class="line"><span class="comment">[Disagreement, with, beliefs, is, by, definition, incorrect]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>&#x3D;&#x3D;适配器设计模式&#x3D;&#x3D;：在设配器中的代码将接受你所拥有的接口，并产生你所需要的接口。</li>
<li>将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器模式：使得CharacterPairSwapper类可以通过适配器类SwapperAdapter与Processor接口进行交互，而不用来自身来实现该接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    Object <span class="title function_">process</span><span class="params">(Object input)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterPairSwapper</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> String <span class="title function_">swap</span><span class="params">(String s)</span> &#123;</span><br><span class="line"> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length() - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> sb.charAt(i);</span><br><span class="line"> <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> sb.charAt(i + <span class="number">1</span>);</span><br><span class="line"> sb.setCharAt(i, c2);</span><br><span class="line"> sb.setCharAt(i + <span class="number">1</span>, c1);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sb.toString();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapperAdapter</span> <span class="keyword">implements</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> CharacterPairSwapper.class.getSimpleName();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">process</span><span class="params">(Object input)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> CharacterPairSwapper.swap((String)input);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E11_Swapper</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> Apply.process(<span class="keyword">new</span> <span class="title class_">SwapperAdapter</span>(), <span class="string">&quot;1234&quot;</span>);</span><br><span class="line"> Apply.process(<span class="keyword">new</span> <span class="title class_">SwapperAdapter</span>(), <span class="string">&quot;abcde&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Using Processor CharacterPairSwapper</span></span><br><span class="line"><span class="comment">2143</span></span><br><span class="line"><span class="comment">Using Processor CharacterPairSwapper</span></span><br><span class="line"><span class="comment">badce</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="9-4-Java中的多重继承"><a href="#9-4-Java中的多重继承" class="headerlink" title="9.4 Java中的多重继承"></a>9.4 Java中的多重继承</h3><blockquote>
<ul>
<li>在继承和多重实现一起存在的时候，继承的具体类应该写在前面，后面跟着的才是接口（否则编译器会报错）。</li>
<li>细节：当继承而来的某个方法是将要实现的某个抽象方法时，在子类中可以不用再对接口中的该方法进行实现，就相当于直接使用父类中的该方法。</li>
<li>使用接口的原因：<ol>
<li>为了能够向上转型为多个基类型（以及由此而带来的灵活性）。</li>
<li>防止客户端程序员创建该类的对象。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="9-5-通过继承来扩展接口"><a href="#9-5-通过继承来扩展接口" class="headerlink" title="9.5 通过继承来扩展接口"></a>9.5 通过继承来扩展接口</h3><blockquote>
<ul>
<li><p>可以使用extends关键字，应用于继承接口。并且extends用于接口继承时，可以继承多个。</p>
<ul>
<li>如：public class c extends interface1,interface2{}</li>
</ul>
</li>
<li><p>将extends用于类时，就只能继承一个类。</p>
</li>
</ul>
</blockquote>
<h3 id="9-6-适配接口（这里还需要再看一下）"><a href="#9-6-适配接口（这里还需要再看一下）" class="headerlink" title="9.6 适配接口（这里还需要再看一下）"></a>9.6 适配接口（这里还需要再看一下）</h3><blockquote>
<ul>
<li>接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现。在简单的情况中，他的体现形式通常是一个接受接口类型的方法，而该接口的实现和向该方法传递的对象则取决于方法的使用者。</li>
<li>因此接口一种常见用法就是前面提到的策略设计模式。</li>
<li>还有一个就是适配器设计模式</li>
<li>在这种模式中，我们可以在任何现有类之上添加新的接口，所以这就一位让方法接受接受接口类型，是一种让任何类都可以对该方法进行适配的方式，这也是使用接口而不是类的强大之处。</li>
</ul>
</blockquote>
<h3 id="9-7-接口中的域"><a href="#9-7-接口中的域" class="headerlink" title="9.7 接口中的域"></a>9.7 接口中的域</h3><blockquote>
<ul>
<li>细节：在接口中的域不能是”空final”，即接口中的域必须被显式初始化。（被非常量表达式也是可以的）</li>
</ul>
</blockquote>
<h3 id="9-8-嵌套接口（没太理解）"><a href="#9-8-嵌套接口（没太理解）" class="headerlink" title="9.8 嵌套接口（没太理解）"></a>9.8 嵌套接口（没太理解）</h3><blockquote>
<ul>
<li>可以在接口中嵌套类或接口</li>
<li>同样，也可以在类中嵌套类或接口</li>
<li>此时，在类中被嵌套的类或接口可以用private修饰</li>
<li>在接口中被嵌套的类或接口只能用public修饰，并且默认就是public的</li>
</ul>
</blockquote>
<h3 id="9-9-接口与工厂"><a href="#9-9-接口与工厂" class="headerlink" title="9.9 接口与工厂"></a>9.9 接口与工厂</h3><blockquote>
<ul>
<li>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是&#x3D;&#x3D;工厂方法设计模式&#x3D;&#x3D;。</li>
<li>这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。理论上，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明得将某个实现替换为另一个实现。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Game</span> &#123; <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GameFactory</span> &#123; Game <span class="title function_">getGame</span><span class="params">()</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Checkers</span> <span class="keyword">implements</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">moves</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Checkers move &quot;</span> + moves);</span><br><span class="line">    <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckersFactory</span> <span class="keyword">implements</span> <span class="title class_">GameFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Game <span class="title function_">getGame</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Checkers</span>(); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chess</span> <span class="keyword">implements</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">moves</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVES</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Chess move &quot;</span> + moves);</span><br><span class="line">    <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChessFactory</span> <span class="keyword">implements</span> <span class="title class_">GameFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Game <span class="title function_">getGame</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Chess</span>(); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Games</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">(GameFactory factory)</span> &#123;</span><br><span class="line">    <span class="type">Game</span> <span class="variable">s</span> <span class="operator">=</span> factory.getGame();</span><br><span class="line">    <span class="keyword">while</span>(s.move())</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    playGame(<span class="keyword">new</span> <span class="title class_">CheckersFactory</span>());</span><br><span class="line">    playGame(<span class="keyword">new</span> <span class="title class_">ChessFactory</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Checkers move 0</span></span><br><span class="line"><span class="comment">Checkers move 1</span></span><br><span class="line"><span class="comment">Checkers move 2</span></span><br><span class="line"><span class="comment">Chess move 0</span></span><br><span class="line"><span class="comment">Chess move 1</span></span><br><span class="line"><span class="comment">Chess move 2</span></span><br><span class="line"><span class="comment">Chess move 3</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第十章：内部类"><a href="#第十章：内部类" class="headerlink" title="第十章：内部类"></a>第十章：内部类</h2><blockquote>
<ul>
<li><p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。</p>
</li>
<li><p>值得注意的是内部类与组合（将一个类引用作为另一个类的数据成员）是完全不同的概念。</p>
</li>
<li><p>内部类它还了解外围类，并能与之通信。</p>
</li>
</ul>
</blockquote>
<h3 id="10-1-创建内部类"><a href="#10-1-创建内部类" class="headerlink" title="10.1 创建内部类"></a>10.1 创建内部类</h3><blockquote>
<ul>
<li><p>创建内部类的方式：将类的定义至于外围类的里面</p>
</li>
<li><p>从外围类的非静态方法中创建内部类的方式如ship()方法中这样</p>
</li>
<li><p>而如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么就必须像在main()方法中一样，具体地致命这个对象的类型：OuterClassName.InnerClassName</p>
</li>
<li><p>在某种典型情况下，外部类中会有方法返回一个指向内部类的引用，就像在to()和contents()方法中看到的那样。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>细节</font>：<ol>
<li>编译器在对含有内部类的文件进行编译时，并不会产生内部类的.java</li>
<li>可以用内部类中的类名称作为另外一个新的外部类的名称。<ol>
<li>在这种情况下创建对象时需要指明。</li>
</ol>
</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel2</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    Destination(String whereTo) &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Destination <span class="title function_">to</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ship</span><span class="params">(String dest)</span> &#123;</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> contents();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> to(dest);</span><br><span class="line">    System.out.println(d.readLabel());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel2</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel2</span>();</span><br><span class="line">    p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    <span class="type">Parcel2</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel2</span>();</span><br><span class="line">    <span class="comment">// Defining references to inner classes:</span></span><br><span class="line">    Parcel2.<span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> q.contents();</span><br><span class="line">    <span class="comment">//下面这种写法也可以</span></span><br><span class="line">    <span class="comment">//Contents c = q.contents();</span></span><br><span class="line">    Parcel2.<span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> q.to(<span class="string">&quot;Borneo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="10-2-链接到外部类"><a href="#10-2-链接到外部类" class="headerlink" title="10.2 链接到外部类"></a>10.2 链接到外部类</h3><blockquote>
<ul>
<li>当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，<font color='red'>所以它能访问其外围对象的所有成员（成员变量和成员方法），而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。</font></li>
<li>原理：<ul>
<li>当某个外围类的对象创建了一个内部类的对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后在访问此外围类的成员时，就是用那个引用来选择外围类的成员。</li>
</ul>
</li>
<li>细节：在内部类是非static类时，内部类的对象只能在与其外围类的对象相关联的情况下才能被创建。构建内部类对象时，需要一个指向其外围类对象的引用，如果没有编译器就会报错。</li>
</ul>
</blockquote>
<h3 id="10-3-使用-this与-new"><a href="#10-3-使用-this与-new" class="headerlink" title="10.3 使用.this与.new"></a>10.3 使用.this与.new</h3><blockquote>
<ul>
<li><font color='red'>.this用法</font>：如果你需要在内部类中生成对外部类对象的引用，可以使用外部类的名字紧跟圆点和this。这样产生的引用自动地具有正确的类型。</li>
<li>如果是一般的this的话，访问的则是内部类的this</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotThis</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> DotThis <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> DotThis.<span class="built_in">this</span>;</span><br><span class="line">      <span class="comment">// A plain &quot;this&quot; would be Inner&#x27;s &quot;this&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Inner <span class="title function_">inner</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DotThis</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DotThis</span>();</span><br><span class="line">    DotThis.<span class="type">Inner</span> <span class="variable">dti</span> <span class="operator">=</span> dt.inner();</span><br><span class="line">    <span class="comment">//DotThis.Inner dti = dt。new Inner();  这是使用.new的方式获取内部类对象</span></span><br><span class="line">    dti.outer().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DotThis.f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>.new用法：有时可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用。如下面所示</li>
<li>因此在有了该种用法之后，就可以在外部类中不用提供返回内部类引用的方法获取到内部类对象。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotNew</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DotNew</span> <span class="variable">dn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DotNew</span>();</span><br><span class="line">    DotNew.<span class="type">Inner</span> <span class="variable">dni</span> <span class="operator">=</span> dn.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<h3 id="10-4-内部类和向上转型"><a href="#10-4-内部类和向上转型" class="headerlink" title="10.4 内部类和向上转型"></a>10.4 内部类和向上转型</h3><blockquote>
<p>在外围类中，可以通过内部类中的对象引用来访问内部类中的private成员变量和成员方法</p>
</blockquote>
<h3 id="10-5-在方法和作用域内的内部类"><a href="#10-5-在方法和作用域内的内部类" class="headerlink" title="10.5 在方法和作用域内的内部类"></a>10.5 在方法和作用域内的内部类</h3><blockquote>
<ol>
<li>一个定义在方法中的类</li>
<li>一个定义在作用域内的类，此作用域在方法的内部</li>
<li>一个实现了接口的匿名类</li>
<li>一个匿名类，它扩展了有非默认构造器的类</li>
<li>一个匿名类，它执行字段初始化</li>
<li>一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）</li>
</ol>
</blockquote>
<blockquote>
<p>案例1：一个定义在方法中的类，这又被称作局部内部类。PDestination该类是destination（）方法中的一部分，而不是Parcel5的一部分，所以在destination（）之外不能访问PDestination。值得注意的是，虽然在destination（）方法中定义了内部类，但并不意味者该方法执行完毕，方法里的内部类就不可用了。</p>
<p>&#x3D;&#x3D;细节：局部内部类不允许用public修饰&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel5</span> &#123;</span><br><span class="line">    <span class="comment">//这是一个方法</span></span><br><span class="line">  <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    	<span class="comment">//定义在方法中的类</span></span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">PDestination</span> <span class="keyword">implements</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> String label;</span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">PDestination</span><span class="params">(String whereTo)</span> &#123;</span><br><span class="line">        label = whereTo;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PDestination</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel5</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel5</span>();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    <span class="comment">//可以调用readLabel()方法，如果PDestination覆盖了该方法，执行时会执行PDestination中的方法体</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例2：当定义在作用域内时，如if(){一个内部类定义}。在作用域之外定义内部类，会编译出错</p>
<p>&#x3D;&#x3D;细节：作用域内部类不允许用public修饰&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>通过下面这个案例体会一下使用内部类的用处</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer5</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inner</span> <span class="keyword">implements</span> <span class="title class_">SimpleInterface</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;Outer5.Inner.f&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> SimpleInterface <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line"> <span class="keyword">public</span> Inner <span class="title function_">get2</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E11_HiddenInnerClass</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"> <span class="type">Outer5</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer5</span>();</span><br><span class="line"> <span class="type">SimpleInterface</span> <span class="variable">si</span> <span class="operator">=</span> out.get();</span><br><span class="line"> si = out.get2();</span><br><span class="line"> <span class="comment">// Won&#x27;t compile -- &#x27;Inner&#x27; not visible:</span></span><br><span class="line"> <span class="comment">//! Inner i1 = out.get2();</span></span><br><span class="line"> <span class="comment">//! Inner i2 = (Inner)si;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">///:~ </span></span><br></pre></td></tr></table></figure>

<h3 id="10-6-匿名内部类"><a href="#10-6-匿名内部类" class="headerlink" title="10.6 匿名内部类"></a>10.6 匿名内部类</h3><blockquote>
<p>语法：创建一个继承自Contents的匿名类的对象，通过new表达式返回的引用被自动向上转型为对Contents的引用。</p>
<p>案例3：一个匿名内部类</p>
</blockquote>
<p>&#x3D;&#x3D;简化形式：&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel7</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contents</span>() &#123; <span class="comment">// Insert a class definition</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;; <span class="comment">// Semicolon required in this case</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel7</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel7</span>();</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> p.contents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;上述匿名内部类的语法是下述形式的简化形式&#x3D;&#x3D;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel7b</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MyContents</span> <span class="keyword">implements</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyContents</span>(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel7b</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel7b</span>();</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> p.contents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例4：扩展了非默认构造器的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapping</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Wrapping</span><span class="params">(<span class="type">int</span> x)</span> &#123; i = x; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel8</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Wrapping <span class="title function_">wrapping</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// Base constructor call:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wrapping</span>(x) &#123; <span class="comment">// Pass constructor argument.</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;; <span class="comment">// Semicolon required</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel8</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel8</span>();</span><br><span class="line">    <span class="type">Wrapping</span> <span class="variable">w</span> <span class="operator">=</span> p.wrapping(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在匿名类中定义字段时，还能够对其执行初始化动作</p>
</blockquote>
<blockquote>
<p><font color='red'>细节：如果定义了一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用时final修饰的就像在destination()的参数中看到的那样。</font></p>
<p>案例5：一个匿名内部类，字段初始化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel9</span> &#123;</span><br><span class="line">  <span class="comment">// Argument must be final to use inside</span></span><br><span class="line">  <span class="comment">// anonymous inner class:</span></span><br><span class="line">  <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(<span class="keyword">final</span> String dest)</span> &#123;  <span class="comment">//参数必须要求是final的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> dest;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel9</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel9</span>();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在此例中，不要求变量i一定是final的，因为i被传递给匿名类的基类的构造器，他并不会在匿名类内部被直接使用。(注意这个例子和上面那个用了final的例子做一个比较)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Base constructor, i = &quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title function_">getBase</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Base</span>(i) &#123;</span><br><span class="line">      &#123; print(<span class="string">&quot;Inside instance initializer&quot;</span>); &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;In anonymous f()&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> getBase(<span class="number">47</span>);</span><br><span class="line">    base.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Base constructor, i = 47</span></span><br><span class="line"><span class="comment">Inside instance initializer</span></span><br><span class="line"><span class="comment">In anonymous f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例6：一个匿名内部类，实例初始化</p>
<p>对于匿名内部类来说，实例初始化的实际效果就是构造器。当然它也受到了限制，不能重载实例初始化方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel10</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Destination</span><br><span class="line">  <span class="title function_">destination</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="type">float</span> price)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> cost;</span><br><span class="line">      <span class="comment">// Instance initialization for each object:</span></span><br><span class="line">      <span class="comment">//实例初始化对象</span></span><br><span class="line">      &#123;  </span><br><span class="line">        cost = Math.round(price);</span><br><span class="line">        <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</span><br><span class="line">          System.out.println(<span class="string">&quot;Over budget!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> dest;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel10</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel10</span>();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>, <span class="number">101.395F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Over budget!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;细节：&#x3D;&#x3D;匿名内部类与正规的继承相比有些受限，因为匿名内部类即可以扩展类，也可以实现接口，但是不能两者兼备，而且如果是实现接口，也只能实现一个接口。</p>
</blockquote>
<blockquote>
<ul>
<li>优先使用类而不是接口</li>
</ul>
</blockquote>
<h3 id="10-7-嵌套类"><a href="#10-7-嵌套类" class="headerlink" title="10.7 嵌套类"></a>10.7 嵌套类</h3><blockquote>
<p>如果不需要内部类对象与其外围类对象之间有联系（即普通的内部类对象隐式的保存了一个引用，指向创建它的外围类对象），那么可以将内部类声明为static.这通常称为嵌套类。</p>
</blockquote>
<blockquote>
<ul>
<li>嵌套类：<ol>
<li>要创建嵌套类的对象，并不需要其外围类的对象</li>
<li>不能从嵌套类的对象中访问非静态的外围类对象</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>嵌套类与普通的内部类的区别：<ol>
<li>普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含有这些东西。</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel11</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParcelContents</span> <span class="keyword">implements</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParcelDestination</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ParcelDestination</span><span class="params">(String whereTo)</span> &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;	</span><br><span class="line">    <span class="comment">// Nested classes can contain other static elements:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnotherLevel</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">      <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title function_">destination</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="comment">//在外围类的静态方法中，可以直接创建嵌套类的对象，这有点类似于在静态方法中调用静态方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ParcelDestination</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ParcelContents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> contents();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节：不论是嵌套类还是普通的内部类，都只会存在与其外围类的.java文件中。但是在编译后，每一个类都会有一个单独的.class文件。</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211213104800721.png" alt="image-20211213104800721"></p>
<blockquote>
<p>接口内部的类：正常情况下，不能在接口内部放置任何代码，但是嵌套类可以作为接口的一部分。放到接口中的类都自动是public和static的，甚至可以在内部类中实现其外围类接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassInInterface</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">howdy</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">ClassInInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">howdy</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Howdy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Test</span>().howdy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Howdy!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节：一个内部类被嵌套多少层并不重要，重要的是它能透明的访问所有它所嵌入的外围类的所有成员。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MNA</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">        g();</span><br><span class="line">        f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiNestingAccess</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MNA</span> <span class="variable">mna</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MNA</span>();</span><br><span class="line">    MNA.<span class="type">A</span> <span class="variable">mnaa</span> <span class="operator">=</span> mna.<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    MNA.A.<span class="type">B</span> <span class="variable">mnaab</span> <span class="operator">=</span> mnaa.<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    mnaab.h();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-8-为什么需要内部类"><a href="#10-8-为什么需要内部类" class="headerlink" title="10.8 为什么需要内部类"></a>10.8 为什么需要内部类</h3><blockquote>
<ol>
<li>每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</li>
<li>内部类提供了可以继承多个具体的、或抽象的类的能力，使多重继承的解决方案变得完整。（接口只是解决了部分问题）</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>使用内部类，还可以获得其他一些特性：<ol>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖与外围类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体。</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>闭包与回调</strong></p>
<ul>
<li>闭包：闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。可以看出&#x3D;&#x3D;内部类是面向对象的闭包&#x3D;&#x3D;，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。</li>
<li>回调：回调的价值在于它的灵活性———可以在运行时动态的决定需要调用什么方法。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内部类与控制框架</strong></p>
<ul>
<li>应用程序框架：就是被设计用以解决某类特定问题的一个类或一组类。</li>
</ul>
</blockquote>
<h3 id="10-9-内部类的继承"><a href="#10-9-内部类的继承" class="headerlink" title="10.9 内部类的继承"></a>10.9 内部类的继承</h3><blockquote>
<p>因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，会有点复杂。问题在于，那个指向外围类对象的“秘密的”引用必须被初始化，而在导出类中不再存在可连接的默认对象，所以需要使用特殊的语法。</p>
</blockquote>
<blockquote>
<p>这是普通的内部类继承</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner &#123;</span><br><span class="line">  <span class="comment">//! InheritInner() &#123;&#125; // Won&#x27;t compile</span></span><br><span class="line">  InheritInner(WithInner wi) &#123;</span><br><span class="line">    wi.<span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">WithInner</span> <span class="variable">wi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">    <span class="type">InheritInner</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是静态内部类的继承方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner &#123;</span><br><span class="line">  InheritInner() &#123;</span><br><span class="line">      <span class="comment">//直接使用super()就可</span></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">WithInner</span> <span class="variable">wi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">    <span class="type">InheritInner</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-10-内部类可以被覆盖吗"><a href="#10-10-内部类可以被覆盖吗" class="headerlink" title="10.10 内部类可以被覆盖吗"></a>10.10 内部类可以被覆盖吗</h3><blockquote>
<p>当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化，&#x3D;&#x3D;这两个内部类是完全独立的两个实体，各自在自己的命名空间内&#x3D;&#x3D;。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Egg</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Yolk y;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;Egg.Yolk()&quot;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">    y = <span class="keyword">new</span> <span class="title class_">Yolk</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEgg</span> <span class="keyword">extends</span> <span class="title class_">Egg</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;BigEgg.Yolk()&quot;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BigEgg</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">New Egg()</span></span><br><span class="line"><span class="comment">Egg.Yolk()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是如果明确地继承某个内部类是可以的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Egg2</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;Egg2.Yolk()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;Egg2.Yolk.f()&quot;</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Yolk</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yolk</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Egg2</span><span class="params">()</span> &#123; print(<span class="string">&quot;New Egg2()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertYolk</span><span class="params">(Yolk yy)</span> &#123; y = yy; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123; y.f(); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEgg2</span> <span class="keyword">extends</span> <span class="title class_">Egg2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> <span class="keyword">extends</span> <span class="title class_">Egg2</span>.Yolk &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;BigEgg2.Yolk()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;BigEgg2.Yolk.f()&quot;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BigEgg2</span><span class="params">()</span> &#123; insertYolk(<span class="keyword">new</span> <span class="title class_">Yolk</span>()); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Egg2</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigEgg2</span>();</span><br><span class="line">    e2.g();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Egg2.Yolk()</span></span><br><span class="line"><span class="comment">New Egg2()</span></span><br><span class="line"><span class="comment">Egg2.Yolk()</span></span><br><span class="line"><span class="comment">BigEgg2.Yolk()</span></span><br><span class="line"><span class="comment">BigEgg2.Yolk.f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="10-11-局部内部类"><a href="#10-11-局部内部类" class="headerlink" title="10.11 局部内部类"></a>10.11 局部内部类</h3><blockquote>
<ul>
<li>可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为他不是外围类的一部分；但是<font color='red'>它可以访问当前代码块内的常量，以及此外围类的所有成员</font>。</li>
<li>使用局部类而不使用匿名内部类的情况：<ol>
<li>我们需要一个命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例化。</li>
<li>另外一个就是需要不止一个该内部类的对象。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="10-12-内部类标识符"><a href="#10-12-内部类标识符" class="headerlink" title="10.12 内部类标识符"></a>10.12 内部类标识符</h3><blockquote>
<ul>
<li><p>每个类都会产生一个.class文件，内部类也必须生成一个.class文件以包含他们的Class对象信息。这些类文件的命名有严格的规则，外围类的名字，加上“$”,再加上内部类的名字。</p>
</li>
<li><p>如果内部类是匿名的，编译器会简单的生成一个数字作为其标识符。 LocalInnerClass&amp;1.class</p>
</li>
<li><p>如果内部类是嵌套在别的内部类之中，只需将他们的名字加在其外围标识符与“$”的后面 LocalInnerClass$1LocalCounter.class</p>
</li>
</ul>
<p>如：Counter.class</p>
<p>​		LocalInnerClass&amp;1.class</p>
<p>​		LocalInnerClass$1LocalCounter.class</p>
<p>​		LocalInnerClass.class</p>
</blockquote>
<h2 id="第十一章：持有对象"><a href="#第十一章：持有对象" class="headerlink" title="第十一章：持有对象"></a>第十一章：持有对象</h2><blockquote>
<p>List,Set,Queue都继承自Collection.注意，&#x3D;&#x3D;map并不是继承自Collection接口&#x3D;&#x3D;</p>
</blockquote>
<h3 id="11-4-容器的打印"><a href="#11-4-容器的打印" class="headerlink" title="11.4 容器的打印"></a>11.4 容器的打印</h3><blockquote>
<p>对于一个数组，我们必须要使用Arrays.toString()来产生数组的可打印表示，但是打印容器无需任何帮助。</p>
</blockquote>
<blockquote>
<p>Collection打印出来的内容用方括号括住，每个元素用逗号隔开。Map则用大括号括住，键与值由等号联系。</p>
</blockquote>
<p><img src="C:\Users\helloworld\Desktop\java.png" alt="java"></p>
<h3 id="11-5-List"><a href="#11-5-List" class="headerlink" title="11.5 List"></a>11.5 List</h3><blockquote>
<ul>
<li>add()、get()</li>
<li>subList()方法：subList()所产生的列表的幕后就是初始列表，&#x3D;&#x3D;因此对所返回的列表的修改都会反映到初始列表中，反之亦然。。&#x3D;&#x3D;</li>
<li>retainAll()方法：是一种有效的交集操作。</li>
</ul>
</blockquote>
<h3 id="11-6-迭代器"><a href="#11-6-迭代器" class="headerlink" title="11.6 迭代器"></a>11.6 迭代器</h3><blockquote>
<p>引入：如果原本是对着List编码的，但是后来发现如果能够把相同的代码应用于Set，将会显得非常方便，如何能保证不重写代码就可以应用于不同类型的容器？</p>
</blockquote>
<blockquote>
<p>迭代器（也是一种设计模式）可以用于完成此目的。迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代器是一个轻量级对象：创建它的代价小。</p>
<ul>
<li><p>下标是从0开始的。</p>
</li>
<li><p>Java中的Iterator只能单向移动。这个Iterator只能用来：</p>
<ol>
<li>使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。</li>
<li>使用next()获得序列中的下一个元素。</li>
<li>使用hasNext()检查序列中是否还有元素。</li>
<li>使用remove()将迭代器新近返回的元素删除。（删除最近一次next()返回的元素）</li>
</ol>
</li>
<li><p>对迭代器进行修改的操作，最终也会导致原始容器内容的修改</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">//注意这里必须要求是ArrayList的对象，</span></span><br><span class="line">    List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//获取到该容器的迭代器</span></span><br><span class="line">    Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// A simpler approach, when possible:</span></span><br><span class="line">    <span class="keyword">for</span>(Pet p : pets)</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();	</span><br><span class="line">    <span class="comment">// An Iterator can also remove elements:</span></span><br><span class="line">    it = pets.iterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">        <span class="comment">//在调用remove方法之前，必须调用next()</span></span><br><span class="line">      it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Iterator的真正威力：能够将遍历序列的操作与序列底层的结构分离，正由于此，我们有时会说：迭代器同意了对容器的访问方式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossContainerIteration</span> &#123;</span><br><span class="line">    <span class="comment">//这里才是真正体现迭代器的威力</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Pet&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Pet&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Pet&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>ListIterator</strong></p>
<blockquote>
<p>ListIterator是一个更加强大的Iterator的子类型，<font color='red'>它只能用于各种List类的访问</font>。尽管Iterator只能向前移动，但是ListIterator可以双向移动。它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后元素。你可以通过调用listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就只想列表索引为n的元素处的ListIterator.</p>
<ul>
<li>set()方法也是修改最近一次next()或者previous()返回的方法。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">    ListIterator&lt;Pet&gt; it = pets.listIterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">      System.out.print(it.next() + <span class="string">&quot;, &quot;</span> + it.nextIndex() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.previousIndex() + <span class="string">&quot;; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// Backwards:</span></span><br><span class="line">    <span class="keyword">while</span>(it.hasPrevious())</span><br><span class="line">      System.out.print(it.previous().id() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(pets);	</span><br><span class="line">    it = pets.listIterator(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.set(Pets.randomPet());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;</span></span><br><span class="line"><span class="comment">7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="11-7-LinkedList"><a href="#11-7-LinkedList" class="headerlink" title="11.7 LinkedList"></a>11.7 LinkedList</h3><blockquote>
<p>可以使用LinkedList实现队列，栈或双端队列等结构</p>
</blockquote>
<h3 id="11-9-Set"><a href="#11-9-Set" class="headerlink" title="11.9  Set"></a>11.9  Set</h3><blockquote>
<ul>
<li>HashSet：快速查找，插入的顺序没有规律，使用的是散列函数</li>
<li>TreeSet：按照插入的元素升序排序，使用的是红-黑树数据结构 <ul>
<li>TreeSet继承自SortedSet。而SortedSet继承自Set</li>
</ul>
</li>
<li>LinkedHashSet：按照插入元素的顺序排序，查询速度也很快，所以也使用了散列。（继承自HashSet）</li>
</ul>
</blockquote>
<h3 id="11-12-Collection和Iterator"><a href="#11-12-Collection和Iterator" class="headerlink" title="11.12 Collection和Iterator"></a>11.12 Collection和Iterator</h3><blockquote>
<p>实现了Collection接口的类，具备了iterator()方法，所以就也需要提供Iterator的特性。</p>
<ul>
<li>当要实现一个不是Collection的外部类时，由于让它去实现Collection接口非常麻烦，因为要实现很多可能不必要的方法。，此时实现Iterator接口就非常有吸引力。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PetSequence</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> Pet[] pets = Pets.createArray(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonCollectionSequence</span> <span class="keyword">extends</span> <span class="title class_">PetSequence</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;Pet&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Pet&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; pets.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> Pet <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> pets[index++]; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">NonCollectionSequence</span> <span class="variable">nc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonCollectionSequence</span>();</span><br><span class="line">    InterfaceVsIterator.display(nc.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="11-13-foreach与迭代器"><a href="#11-13-foreach与迭代器" class="headerlink" title="11.13 foreach与迭代器"></a>11.13 foreach与迭代器</h3><blockquote>
<p>foreach语法不仅可以用于数组，还可以应用于所有的Collection对象，因为这些对象都实现了Iterable接口，该接口包含一个能够产生Iterator的iterator()方法，并且Iterator接口被foreach用来在序列中移动了。因此如果创建了任何实现Iterable的类，都可以将它用于foreach语句。</p>
<ul>
<li>&#x3D;&#x3D;细节：&#x3D;&#x3D;<ol>
<li>实现了Iterable接口的类就具备了foreach的能力</li>
<li>而实现Iterable接口，就需要实现提供I能够产生terator引用的iterator()方法</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IterableClass</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> String[] words = (<span class="string">&quot;And that is how &quot;</span> +</span><br><span class="line">    <span class="string">&quot;we know the Earth to be banana-shaped.&quot;</span>).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;String&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;String&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; words.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> words[index++]; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="keyword">new</span> <span class="title class_">IterableClass</span>())</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">And that is how we know the Earth to be banana-shaped.</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>能够用于foreach的不一定就都实现了Iterable接口，比如普通数组，就不能将一个数组对象传给Iterable接口引用。而必须通过显示转换。</p>
</blockquote>
<blockquote>
<p>Arrays.asList()方法：该方法产生的List对象会使用底层数组作为其物理实现，因此执行修改List的操作就也会修改原有的底层数组。所以如果不想原来的数组被修改，那么就应该在另一个副本中创建一个副本。</p>
<p>如：List<Integer> list&#x3D;new ArrayList(Arrays.asList(arr));此时对list内容的修改，不会影响到数组arr的内容。</p>
<p>​		List<Integer> list&#x3D;Arrays.asList(arr); 此时对list内容的修改也会影响到数组arr的内容。</p>
</blockquote>
<h2 id="第十二章：通过异常处理错误"><a href="#第十二章：通过异常处理错误" class="headerlink" title="第十二章：通过异常处理错误"></a>第十二章：通过异常处理错误</h2><h3 id="12-2-基本异常"><a href="#12-2-基本异常" class="headerlink" title="12.2 基本异常"></a>12.2 基本异常</h3><blockquote>
<ul>
<li>所有标准异常类都有两个构造器：一个是默认构造器，另一个是接受字符串参数作为参数，以便能把相关信息放入异常对象的构造器。</li>
<li>能够抛出任意类型的Throwable对象，它是异常类型的跟类。</li>
</ul>
</blockquote>
<h3 id="12-3-捕获异常"><a href="#12-3-捕获异常" class="headerlink" title="12.3 捕获异常"></a>12.3 捕获异常</h3><blockquote>
<ul>
<li><p>注意：在try块的内部，可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。</p>
</li>
<li><p>当用catch语句要捕获多个异常时，异常类型的父类（如Exception）要放在异常类型的子类（NullPointerException）后面进行捕获，否则会编译出错。</p>
</li>
</ul>
</blockquote>
<h3 id="12-4-创建自定义异常"><a href="#12-4-创建自定义异常" class="headerlink" title="12.4 创建自定义异常"></a>12.4 创建自定义异常</h3><blockquote>
<ul>
<li>要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。建立新的异常类型最简单的方法就是让编译器为你产生默认构造器。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己定义一个新的异常类型，继承自已有的异常类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritingExceptions</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> SimpleException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throw SimpleException from f()&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SimpleException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">InheritingExceptions</span> <span class="variable">sed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritingExceptions</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      sed.f();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SimpleException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Caught it!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Throw SimpleException from f()</span></span><br><span class="line"><span class="comment">Caught it!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">  <span class="comment">//继承了现有的机场类，并且定义了两个构造器方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span> &#123; <span class="built_in">super</span>(msg); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FullConstructors</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throwing MyException from f()&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throwing MyException from g()&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;Originated in g()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      f();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(MyException e) &#123;</span><br><span class="line">      e.printStackTrace(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      g();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(MyException e) &#123;</span><br><span class="line">      e.printStackTrace(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Throwing MyException from f()</span></span><br><span class="line"><span class="comment">MyException</span></span><br><span class="line"><span class="comment">        at FullConstructors.f(FullConstructors.java:11)</span></span><br><span class="line"><span class="comment">        at FullConstructors.main(FullConstructors.java:19)</span></span><br><span class="line"><span class="comment">Throwing MyException from g()</span></span><br><span class="line"><span class="comment">MyException: Originated in g()</span></span><br><span class="line"><span class="comment">        at FullConstructors.g(FullConstructors.java:15)</span></span><br><span class="line"><span class="comment">        at FullConstructors.main(FullConstructors.java:24)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>e1.printStackTrace(System.out); 在异常处理程序中，调用了子啊Throwable类声明（Exception即从此类继承）的printStackTrace()方法。他将打印“从方法调用处直到异常抛出处”的方法调用序列。这里信息就被发送到了System.out,并自动地捕获和显示在输出中。</li>
<li>但是如果调用默认版本：e1.printStackTrace();则信息将被输出到标准错误流。</li>
</ul>
</blockquote>
<p><strong>#这是默认的打印版本：</strong></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211216161902399.png" alt="image-20211216161902399"></p>
<p>#这是使用了System.out的方式</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211216162030348.png" alt="image-20211216162030348"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">NullPointerException</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestError</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test fun()&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TestError ts=<span class="keyword">new</span> <span class="title class_">TestError</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ts.fun();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MyException e1)&#123;</span><br><span class="line">            <span class="comment">//使用与不使用System.out的输出结果在上面</span></span><br><span class="line">            e1.printStackTrace(System.out);</span><br><span class="line">            System.out.println(<span class="string">&quot;进来没&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于异常类来说，Throwable类的getMessage()方法有点类似于toString()方法，所以当在定义完自己的异常类之后，可以对继承的Throwable类或者其子类中一些方法进行覆盖。</p>
</blockquote>
<h3 id="12-5-异常说明"><a href="#12-5-异常说明" class="headerlink" title="12.5 异常说明"></a>12.5 异常说明</h3><blockquote>
<p>异常说明：就是以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行响应的处理。属于方法声明的一部分，紧跟在形式参数列表之后。</p>
<ul>
<li>异常说明使用了附加的关键字throws，后面借一个所有潜在异常类型的列表。</li>
<li>形式如：void fun(int x1,…) throws 异常1，异常2{方法体内容}</li>
<li><font color='red'>细节：运行时异常（RuntimeException）可以不用显示声明（即用throws说明），或者catch也可以。而其他异常则必须进行异常说明或者进行捕获catch</font></li>
<li>可以声明方法将抛出异常，但是方法体内并不抛出异常（非运行时异常），此时会强制使用该方法的用户要像真的抛出异常那样使用这个方法（如必须对该声明的异常进行处理，要么抛出，要么捕获）</li>
</ul>
</blockquote>
<h3 id="12-6-捕获所有异常"><a href="#12-6-捕获所有异常" class="headerlink" title="12.6 捕获所有异常"></a>12.6 捕获所有异常</h3><blockquote>
<p>可以使用抛出异常的基类来进行捕获，这样就不用每一个都要进行捕获了，但是捕获基类的语句要写在导出类的后面，否则会出错。</p>
</blockquote>
<blockquote>
<p>printStackTrace()方法：这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一帧。细节：main()方法总是第一个进栈，所以在输出时就处于最后一个。(栈是先进后出结构)</p>
</blockquote>
<p><strong>重新抛出异常</strong></p>
<blockquote>
<ul>
<li><p>如果只是把当前异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。要想更新这个信息，可以调用fillInStackTrace()方法，这将返回一个Throwable对象。它是通过把当前调用栈信息填入原来那个异常对象而建立的。那么有关原来异常发生点的信息会丢失，剩下的是与新的抛出点有关的信息。</p>
</li>
<li><p>有可能在捕获异常之后抛出另一种异常，这么做的话，得到的效果类似于使用fillInStackTrace()，有关原来异发生点的信息将会丢失，剩下的是与新的抛出点有关的信息。</p>
</li>
</ul>
</blockquote>
<h3 id="12-7-Java标准异常"><a href="#12-7-Java标准异常" class="headerlink" title="12.7 Java标准异常"></a>12.7 Java标准异常</h3><blockquote>
<ul>
<li>Throwable这个Java类表示任何可以作为异常抛出的类。Throwable对象分为两种类型（指从Throwable继承而得到的类型）：Error(用来表示编译时和系统错误，除特殊情况外，一般不用关心)，Exception(是可以被抛出的基本类型)。而Exception又主要分为运行时异常（RuntimeException）和非运行时异常。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>运行时异常：他们会自动被虚拟机抛出，所以不必在异常说明中把他们列出来。他们也被称为不受检查异常。而其他类型的异常（非运行时异常）的异常处理是由编译器强制实施的。</li>
<li>如果运行时异常没有被捕获而直达main()，那么在程序退出前将调用异常的printStackTrace()方法</li>
</ul>
</blockquote>
<blockquote>
<p>运行时异常主要常见的有：NullPointerException。ArrayIndexOutofBoundsException。</p>
</blockquote>
<h3 id="12-8-用finally进行清理"><a href="#12-8-用finally进行清理" class="headerlink" title="12.8 用finally进行清理"></a>12.8 用finally进行清理</h3><p><strong>finally用来做什么</strong></p>
<blockquote>
<p>当要把除内存之外的资源恢复到他们的初始状态，就要用到finally子句。这种需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关</p>
</blockquote>
<blockquote>
<p>细节：当涉及到break和continue语句的时候，finally子句也会得到执行。</p>
</blockquote>
<p>在return中使用finally</p>
<blockquote>
<ul>
<li>因为finally子句总是会被执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。(&#x3D;&#x3D;finally语句总是会在return语句执行前就执行了&#x3D;&#x3D;)</li>
</ul>
</blockquote>
<blockquote>
<p>缺憾：异常丢失</p>
<ul>
<li>当有多层try块时，如果提前在finally块中执行了return语句的话，则在后面的catch语句就得不到执行，但应该注意的是后面的finally块仍然会被执行。</li>
</ul>
</blockquote>
<blockquote>
<p>细节：如果在finally语句中存在return语句，那么该方法后面的语句就都得不到调用，所以如果有，编译器就会报错。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test18</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;jjjj&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-9-异常的限制"><a href="#12-9-异常的限制" class="headerlink" title="12.9 异常的限制"></a>12.9 异常的限制</h3><blockquote>
<ul>
<li>当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常（或者父类抛出的异常的子类）。这个限制很重要，因为这意味着，当基类使用的代码应用到其派生类对象的时候，一样能够工作。（这个有点类似于限制覆盖方法时对返回值类型，形参有要求一样）</li>
<li>所以如果基类如果没有抛出异常，子类就也不能抛出异常</li>
</ul>
</blockquote>
<blockquote>
<p>细节：构造器方法也可以抛出异常（异常声明）</p>
<ul>
<li>细节：覆盖方法时对异常的限制，这个限制对构造器不能起作用。因为基类构造器必须以这样或那样的方式被调用（这里默认构造器将自动被调用），</li>
<li>但是派生类构造器的异常说明必须包括基类构造器的异常说明（必须是基类的异常或者其父类，与方法恰好相反）</li>
<li>派生类构造器不能捕获基类构造器抛出的异常。（因为super()语句永远在第一行执行）</li>
<li>所以，在某种意义上，在继承和覆盖的过程中，某个特定方法的异常说明的接口不是变大了而是变小了。这恰好和类接口在继承时的情形相反。</li>
</ul>
</blockquote>
<h3 id="12-10-构造器"><a href="#12-10-构造器" class="headerlink" title="12.10 构造器"></a>12.10 构造器</h3><blockquote>
<p>对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句</p>
<p>&#x3D;&#x3D;基本规则是：在创建要清理的对象之后，立即进入一个try-finally语句块&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cleanup</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputFile</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputFile</span>(<span class="string">&quot;Cleanup.java&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((s = in.getLine()) != <span class="literal">null</span>)</span><br><span class="line">          ; <span class="comment">// Perform line-by-line processing here...</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Caught Exception in main&quot;</span>);</span><br><span class="line">        e.printStackTrace(System.out);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.dispose();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;InputFile construction failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">dispose() successful</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="12-11-异常匹配"><a href="#12-11-异常匹配" class="headerlink" title="12.11 异常匹配"></a>12.11 异常匹配</h3><blockquote>
<ul>
<li><p>抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续寻找。</p>
</li>
<li><p>查找的时候并不要求完全匹配，派生类的对象也可以匹配基类的处理程序。如Exception可以接受RuntimeException的异常</p>
</li>
<li><p>如果把捕获基类的catch子句放在最前面，以此想把派生类的异常全给屏蔽掉，编译器会报错。</p>
</li>
</ul>
</blockquote>
<h3 id="12-12-其他可选方式"><a href="#12-12-其他可选方式" class="headerlink" title="12.12 其他可选方式"></a>12.12 其他可选方式</h3><blockquote>
<p>异常处理的一个重要原则是：只有在知道如何处理的情况下才捕获异常。</p>
</blockquote>
<h2 id="第十三章：字符串"><a href="#第十三章：字符串" class="headerlink" title="第十三章：字符串"></a>第十三章：字符串</h2><h3 id="13-2-重载“-”与StringBuilder"><a href="#13-2-重载“-”与StringBuilder" class="headerlink" title="13.2 重载“+”与StringBuilder"></a>13.2 重载“+”与StringBuilder</h3><blockquote>
<ul>
<li>String字符串在进行拼接时，实际上内部还是创建StringBuilder对象，调用该对象方法。</li>
<li>因此如果在进行频繁的拼接操作时，可以显式创建一个StringBuilder对象，这样减少了创建对象的过程以及利用垃圾回收机制回收中间对象的过程。</li>
<li>细节：StringBuilder是在jdk5引入的，之前用的是StringBuffer,后者是线程安全的，因此开销也会大些。</li>
</ul>
</blockquote>
<h3 id="13-5格式化输出"><a href="#13-5格式化输出" class="headerlink" title="13.5格式化输出"></a>13.5格式化输出</h3><blockquote>
<ul>
<li>format()方法与printf()是等价的，它们只需要一个简单的格式化字符串，加上一串参数即可，每个参数对应一个格式修饰符。</li>
<li>format()方法可以用于PrintStream或PrintWriter对象，其中也包括System.out对象。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFormat</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5.332542</span>;</span><br><span class="line">    <span class="comment">// The old way:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Row 1: [&quot;</span> + x + <span class="string">&quot; &quot;</span> + y + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="comment">// The new way:</span></span><br><span class="line">    System.out.format(<span class="string">&quot;Row 1: [%d %f]\n&quot;</span>, x, y);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;Row 1: [%d %f]\n&quot;</span>, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542]</span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542]</span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>Fomatter类</strong></p>
<blockquote>
<p>在Java中，所有新的格式化功能都由java.util.Formatter类处理。可以将Fomatter看作一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。</p>
</blockquote>
<blockquote>
<p>String.format()方法，以生成格式化的String对象。这是一个static方法，它接受与Formatter.format()方法一样的参数，但返回一个String对象 。</p>
</blockquote>
<h3 id="13-6-正则表达式（需要重点关注）"><a href="#13-6-正则表达式（需要重点关注）" class="headerlink" title="13.6 正则表达式（需要重点关注）"></a>13.6 正则表达式（需要重点关注）</h3><blockquote>
<ul>
<li>在Java中，字符串操作还主要集中于String,StringBuffer和StringTokenizer类，与正则表达式相比，他们只能提供相对简单的功能。</li>
<li>正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索。一旦找到了匹配这些模式的部分，你就能够随心所欲的对他们进行处理。正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题：匹配、选择、编辑以及验证。</li>
</ul>
</blockquote>
<blockquote>
<p>应用正则表达式的最简单的途径，就是利用String类内建的功能。例如，你可以检查一个String是否匹配如上所述的正则表达式：</p>
<ul>
<li>规则：<ul>
<li>-?：表示要找一个数字，它可能有一个负号在最前面</li>
<li>-?\d+：表示“可能有一个负号，后面跟着一位或多位数字”</li>
<li>\\：表示要插入一个普通的反斜杠</li>
<li>\d：表示想表示一个数字</li>
<li>(-|\+)?：表示可能以一个加号或减号开头   （因为+在正则表达式中有特殊的意义，所以必须使用\进行转义，使之成为一个普通字符）</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerMatch</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;-1234&quot;</span>.matches(<span class="string">&quot;-?\\d+&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;5678&quot;</span>.matches(<span class="string">&quot;-?\\d+&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;+911&quot;</span>.matches(<span class="string">&quot;-?\\d+&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;+911&quot;</span>.matches(<span class="string">&quot;(-|\\+)?\\d+&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>String类还自带了一个非常有用的正则表达式工具，split()方法，其功能是将字符串从正则表达式匹配的地方切开。</p>
<ul>
<li>规则：<ul>
<li>\W：他表示是一个非单词字符（如果W小写，\w,则表示一个单词字符）</li>
<li>\W+：他表示是一个或多个非单词字符（如果W小写，\w,则表示一个单词字符）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>String类自带的最后一个正则表达式工具是替换。你可以只替换正则表示式第一个匹配的子串，或是替换所有匹配的地方。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Replacing</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Splitting.knights;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(s.replaceFirst(<span class="string">&quot;f\\w+&quot;</span>, <span class="string">&quot;located&quot;</span>));</span><br><span class="line">    print(s.replaceAll(<span class="string">&quot;shrubbery|tree|herring&quot;</span>,<span class="string">&quot;banana&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Then, when you have located the shrubbery, you must cut down the mightiest tree in the forest... with... a herring!</span></span><br><span class="line"><span class="comment">Then, when you have found the banana, you must cut down the mightiest banana in the forest... with... a banana!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;Pattern和Matcher&#x3D;&#x3D;</p>
<blockquote>
<p>下面演示了这两个类的用法</p>
<ul>
<li>find()</li>
<li>matches()</li>
<li>start()</li>
<li>end()</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRegularExpression</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      print(<span class="string">&quot;Usage:\njava TestRegularExpression &quot;</span> +</span><br><span class="line">        <span class="string">&quot;characterSequence regularExpression+&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Input: \&quot;&quot;</span> + args[<span class="number">0</span>] + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String arg : args) &#123;</span><br><span class="line">      print(<span class="string">&quot;Regular expression: \&quot;&quot;</span> + arg + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(arg);</span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(args[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">        print(<span class="string">&quot;Match \&quot;&quot;</span> + m.group() + <span class="string">&quot;\&quot; at positions &quot;</span> +</span><br><span class="line">          m.start() + <span class="string">&quot;-&quot;</span> + (m.end() - <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Input: &quot;abcabcabcdefabc&quot;</span></span><br><span class="line"><span class="comment">Regular expression: &quot;abcabcabcdefabc&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abcabcabcdefabc&quot; at positions 0-14</span></span><br><span class="line"><span class="comment">Regular expression: &quot;abc+&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 0-2</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 3-5</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 6-8</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 12-14</span></span><br><span class="line"><span class="comment">Regular expression: &quot;(abc)+&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abcabcabc&quot; at positions 0-8</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 12-14</span></span><br><span class="line"><span class="comment">Regular expression: &quot;(abc)&#123;2,&#125;&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abcabcabc&quot; at positions 0-8</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第十四章：类型信息"><a href="#第十四章：类型信息" class="headerlink" title="第十四章：类型信息"></a>第十四章：类型信息</h2><blockquote>
<p><strong>运行时类型信息使得你可以在程序运行时发现和使用类型信息</strong></p>
<ul>
<li>Java是如何让我们在运行时识别对象和类的信息的。主要有两种方式：<ol>
<li>传统的RTTI,他假定我们在编译时已经知道了所有的类型。</li>
<li>另一种是反射机制，它允许我们在运行时发现和使用类的信息</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="14-2-Class对象"><a href="#14-2-Class对象" class="headerlink" title="14.2 Class对象"></a>14.2 Class对象</h3><blockquote>
<p>要理解RTTI在Java中的工作原理，首先需要知道类型信息在运行时是如何表示的。这项工作由Class对象的特殊对象来完成，它包含了与类有关的信息。Class对象就是用来创建类的所有的常规对象的。Java使用Class对象来执行其RTTI.Class类拥有大量的使用RTTI的其他方式。</p>
</blockquote>
<blockquote>
<p>使用Class.forName()来获取到某个类的Class对象的引用</p>
<p>细节：这里name是要用到带上包名的如javase.Hello,即使用全限定类名（包含包名）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;jinlaile&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;javase.Hello&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;没有发现&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(c.getName());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果已经拥有了该类的对象，则可以通过调用继承自Object类中的getClass()方法来获取该Class对象。</p>
</blockquote>
<blockquote>
<p>getInterfaces()：确定由该对象表示的类或接口实现的接口。</p>
<p>getSuperclass()：返回 <code>类</code>表示此所表示的实体（类，接口，基本类型或void）的超类 <code>类</code></p>
<p>getSimpleName()：来产生不包含包名的类名</p>
<p>getCanonicalName()：来产生全限定类名（包含包名）</p>
<p>newInstance()：是实现虚拟构造器的一种途径。可以不用new创建对象的一种方式。（该类必须有默认构造器）</p>
<p>getDeclaredFields()：返回此类或接口上所有的字段类对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HasBatteries</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Waterproof</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shoots</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Toy</span> &#123;</span><br><span class="line">  <span class="comment">// Comment out the following default constructor</span></span><br><span class="line">  <span class="comment">// to see NoSuchMethodError from (*1*)</span></span><br><span class="line">  Toy() &#123;&#125;</span><br><span class="line">  Toy(<span class="type">int</span> i) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FancyToy</span> <span class="keyword">extends</span> <span class="title class_">Toy</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">HasBatteries</span>, Waterproof, Shoots &#123;</span><br><span class="line">  FancyToy() &#123; <span class="built_in">super</span>(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToyTest</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(Class cc)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Class name: &quot;</span> + cc.getName() +</span><br><span class="line">      <span class="string">&quot; is interface? [&quot;</span> + cc.isInterface() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    print(<span class="string">&quot;Simple name: &quot;</span> + cc.getSimpleName());</span><br><span class="line">    print(<span class="string">&quot;Canonical name : &quot;</span> + cc.getCanonicalName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      c = Class.forName(<span class="string">&quot;typeinfo.toys.FancyToy&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Can&#x27;t find FancyToy&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printInfo(c);	</span><br><span class="line">    <span class="keyword">for</span>(Class face : c.getInterfaces())</span><br><span class="line">      printInfo(face);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">up</span> <span class="operator">=</span> c.getSuperclass();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Requires default constructor:</span></span><br><span class="line">      obj = up.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InstantiationException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Cannot instantiate&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalAccessException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Cannot access&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printInfo(obj.getClass());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.FancyToy is interface? [false]</span></span><br><span class="line"><span class="comment">Simple name: FancyToy</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.FancyToy</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.HasBatteries is interface? [true]</span></span><br><span class="line"><span class="comment">Simple name: HasBatteries</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.HasBatteries</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.Waterproof is interface? [true]</span></span><br><span class="line"><span class="comment">Simple name: Waterproof</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.Waterproof</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.Shoots is interface? [true]</span></span><br><span class="line"><span class="comment">Simple name: Shoots</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.Shoots</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.Toy is interface? [false]</span></span><br><span class="line"><span class="comment">Simple name: Toy</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.Toy</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>类字面常量</strong></p>
<p>Java还提供了另一种方法生成对Class对象的引用，即使用类字面常量。将如Person.class;</p>
<ul>
<li><p>好处：</p>
<ul>
<li>这样做更简单，而且更安全，因为它在编译时就会受到检查（不需要使用try-catch进行捕获），并且根除了对forName()方法的调用，所以也更高效。</li>
<li>该常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型，另外对于基本数据类型的包装器类，还有一个标准字段TYPE.TYPE是一个引用，指向对应的基本数据类型的Class对象。</li>
</ul>
</li>
<li><p>细节：当使用.class来创建对Class对象的引用时，不会自动地初始化Class对象。初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行。</p>
</li>
<li><p>为了使用类做的&#x3D;&#x3D;准备工作步骤&#x3D;&#x3D;：</p>
<ol>
<li>加载：这是由类加载器执行的。（类加载器是JVM的一部分）该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个Class对象。</li>
<li>链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并非如果必需的话，将解析这个类创建的对其他类的所有引用。</li>
<li>初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Initable</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">staticFinal</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">staticFinal2</span> <span class="operator">=</span></span><br><span class="line">    ClassInitialization.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Initializing Initable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Initable2</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticNonFinal</span> <span class="operator">=</span> <span class="number">147</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Initializing Initable2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Initable3</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticNonFinal</span> <span class="operator">=</span> <span class="number">74</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Initializing Initable3&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitialization</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">initable</span> <span class="operator">=</span> Initable.class;</span><br><span class="line">    System.out.println(<span class="string">&quot;After creating Initable ref&quot;</span>);</span><br><span class="line">    <span class="comment">// Does not trigger initialization:</span></span><br><span class="line">    System.out.println(Initable.staticFinal);</span><br><span class="line">    <span class="comment">// Does trigger initialization:</span></span><br><span class="line">    System.out.println(Initable.staticFinal2);</span><br><span class="line">    <span class="comment">// Does trigger initialization:</span></span><br><span class="line">    System.out.println(Initable2.staticNonFinal);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">initable3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Initable3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After creating Initable3 ref&quot;</span>);</span><br><span class="line">    System.out.println(Initable3.staticNonFinal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">After creating Initable ref</span></span><br><span class="line"><span class="comment">47</span></span><br><span class="line"><span class="comment">Initializing Initable</span></span><br><span class="line"><span class="comment">258</span></span><br><span class="line"><span class="comment">Initializing Initable2</span></span><br><span class="line"><span class="comment">147</span></span><br><span class="line"><span class="comment">Initializing Initable3</span></span><br><span class="line"><span class="comment">After creating Initable3 ref</span></span><br><span class="line"><span class="comment">74</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Class<T></p>
<p>Class&lt;?&gt;优于平凡的Class,即便它们是等价的。</p>
<p>Class&lt;? extends T&gt;为了创建一个Class引用，它被限定为某种类型，或该类型的任何子类型，你需要将通配符与extends关键字结合，创建一个范围。因此这与仅仅声明Class<Number>不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedClassReferences</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; bounded = <span class="type">int</span>.class;</span><br><span class="line">    bounded = <span class="type">double</span>.class;</span><br><span class="line">    bounded = Number.class;</span><br><span class="line">    <span class="comment">// Or anything else derived from Number.</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//Class&lt;Number&gt; c2=int.class;  //该种方式会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<p>当将泛型语法用于Class对象时，会发生一件有趣的事：newInstance()将返回该对象的确切类型，而不是平凡的Class那样返回的Object.</p>
<p>Class&lt;? extends T&gt;而如果和extends结合了，则返回的则是T.   </p>
</blockquote>
<h3 id="14-3-类型转换前先做检查"><a href="#14-3-类型转换前先做检查" class="headerlink" title="14.3 类型转换前先做检查"></a>14.3 类型转换前先做检查</h3><blockquote>
<p>RTTI在Java中还有第三种形式，就是关键字instanceof,它返回一个布尔值。告诉我们对象是不是某个&#x3D;&#x3D;特定类型&#x3D;&#x3D;的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">	((Dog)x).bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>动态的instanceof.Class.isInstanceof方法提供了一种动态的测试对象的途径。该方法返回<code>true</code>如果指定<code>Object</code>参数为非空并且可以转换为通过此表示的引用类型<code>类</code>对象</p>
</blockquote>
<h3 id="14-5-instanceof与Class的等价性"><a href="#14-5-instanceof与Class的等价性" class="headerlink" title="14.5 instanceof与Class的等价性"></a>14.5 instanceof与Class的等价性</h3><blockquote>
<p>子类对象或引用 instaceof 父类时会返回真</p>
<p>instanceof和isInstance()指的是“你是这个类吗，或者你是这个类的派生类吗”</p>
<p>而equals()和&#x3D;&#x3D;则比较的是实际的Class对象，而没有考虑继承，只是指是这个确切的类型吗或者不是</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FamilyVsExactType</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Testing x of type &quot;</span> + x.getClass());</span><br><span class="line">    print(<span class="string">&quot;x instanceof Base &quot;</span> + (x <span class="keyword">instanceof</span> Base));</span><br><span class="line">    print(<span class="string">&quot;x instanceof Derived &quot;</span>+ (x <span class="keyword">instanceof</span> Derived));</span><br><span class="line">    print(<span class="string">&quot;Base.isInstance(x) &quot;</span>+ Base.class.isInstance(x));</span><br><span class="line">    print(<span class="string">&quot;Derived.isInstance(x) &quot;</span> +</span><br><span class="line">      Derived.class.isInstance(x));</span><br><span class="line">    print(<span class="string">&quot;x.getClass() == Base.class &quot;</span> +</span><br><span class="line">      (x.getClass() == Base.class));</span><br><span class="line">    print(<span class="string">&quot;x.getClass() == Derived.class &quot;</span> +</span><br><span class="line">      (x.getClass() == Derived.class));</span><br><span class="line">    print(<span class="string">&quot;x.getClass().equals(Base.class)) &quot;</span>+</span><br><span class="line">      (x.getClass().equals(Base.class)));</span><br><span class="line">    print(<span class="string">&quot;x.getClass().equals(Derived.class)) &quot;</span> +</span><br><span class="line">      (x.getClass().equals(Derived.class)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">Base</span>());</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">Derived</span>());</span><br><span class="line">  &#125;	</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Testing x of type class typeinfo.Base</span></span><br><span class="line"><span class="comment">x instanceof Base true</span></span><br><span class="line"><span class="comment">x instanceof Derived false</span></span><br><span class="line"><span class="comment">Base.isInstance(x) true</span></span><br><span class="line"><span class="comment">Derived.isInstance(x) false</span></span><br><span class="line"><span class="comment">x.getClass() == Base.class true</span></span><br><span class="line"><span class="comment">x.getClass() == Derived.class false</span></span><br><span class="line"><span class="comment">x.getClass().equals(Base.class)) true</span></span><br><span class="line"><span class="comment">x.getClass().equals(Derived.class)) false</span></span><br><span class="line"><span class="comment">Testing x of type class typeinfo.Derived</span></span><br><span class="line"><span class="comment">x instanceof Base true</span></span><br><span class="line"><span class="comment">x instanceof Derived true</span></span><br><span class="line"><span class="comment">Base.isInstance(x) true</span></span><br><span class="line"><span class="comment">Derived.isInstance(x) true</span></span><br><span class="line"><span class="comment">x.getClass() == Base.class false</span></span><br><span class="line"><span class="comment">x.getClass() == Derived.class true</span></span><br><span class="line"><span class="comment">x.getClass().equals(Base.class)) false</span></span><br><span class="line"><span class="comment">x.getClass().equals(Derived.class)) true</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="14-6-反射：运行时的类信息"><a href="#14-6-反射：运行时的类信息" class="headerlink" title="14.6 反射：运行时的类信息"></a>14.6 反射：运行时的类信息</h3><blockquote>
<ul>
<li>Class类与java.lang.reflect类库一起对反射的概念进行了支持。，该类库包含了Field,Method以及Constructor类。这些类型的对象是由jvm在运行的时候创建的，用以表示未知类里对应的成员。</li>
<li>这样就可以使用Constructor创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。</li>
<li>还可以调用getFields()和getMethods()以及getConstructors()等很便利的方法，以返回表示字段、方法以及构造器的对象的数组</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>RTTI和反射之间真正的区别在于：<ul>
<li>对于RTTI来说，编译器在编译时打开和检查.class文件，换句话说，我们可以用普通方式调用对象的所有方法。</li>
<li>而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件的。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="14-7-动态代理"><a href="#14-7-动态代理" class="headerlink" title="14.7 动态代理"></a>14.7 动态代理</h3><blockquote>
<p>代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替实际对象的对象。这些操作通常涉及与实际对象的通信，因此代理通常充当着中间人的角色。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MethodSelector</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Object proxied;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MethodSelector</span><span class="params">(Object proxied)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.proxied = proxied;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Object</span><br><span class="line">  <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">  <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;interesting&quot;</span>))</span><br><span class="line">      print(<span class="string">&quot;Proxy detected the interesting method&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SomeMethods</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">boring1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">boring2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">interesting</span><span class="params">(String arg)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">boring3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementation</span> <span class="keyword">implements</span> <span class="title class_">SomeMethods</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boring1</span><span class="params">()</span> &#123; print(<span class="string">&quot;boring1&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boring2</span><span class="params">()</span> &#123; print(<span class="string">&quot;boring2&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interesting</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;interesting &quot;</span> + arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boring3</span><span class="params">()</span> &#123; print(<span class="string">&quot;boring3&quot;</span>); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectingMethods</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SomeMethods proxy= (SomeMethods)Proxy.newProxyInstance(</span><br><span class="line">      SomeMethods.class.getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; SomeMethods.class &#125;,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MethodSelector</span>(<span class="keyword">new</span> <span class="title class_">Implementation</span>()));</span><br><span class="line">    proxy.boring1();</span><br><span class="line">    proxy.boring2();</span><br><span class="line">    proxy.interesting(<span class="string">&quot;bonobo&quot;</span>);</span><br><span class="line">    proxy.boring3();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">boring1</span></span><br><span class="line"><span class="comment">boring2</span></span><br><span class="line"><span class="comment">Proxy detected the interesting method</span></span><br><span class="line"><span class="comment">interesting bonobo</span></span><br><span class="line"><span class="comment">boring3</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第十五章：泛型"><a href="#第十五章：泛型" class="headerlink" title="第十五章：泛型"></a>第十五章：泛型</h2><h2 id="第十六章：数组"><a href="#第十六章：数组" class="headerlink" title="第十六章：数组"></a>第十六章：数组</h2><h2 id="第十七章：容器深入研究"><a href="#第十七章：容器深入研究" class="headerlink" title="第十七章：容器深入研究"></a>第十七章：容器深入研究</h2><h2 id="第十八章：Java-I-O系统"><a href="#第十八章：Java-I-O系统" class="headerlink" title="第十八章：Java I&#x2F;O系统"></a>第十八章：Java I&#x2F;O系统</h2><h2 id="第十九章：枚举类型"><a href="#第十九章：枚举类型" class="headerlink" title="第十九章：枚举类型"></a>第十九章：枚举类型</h2><h2 id="第二十章：注解"><a href="#第二十章：注解" class="headerlink" title="第二十章：注解"></a>第二十章：注解</h2><h2 id="第二十一章：并发"><a href="#第二十一章：并发" class="headerlink" title="第二十一章：并发"></a>第二十一章：并发</h2><blockquote>
<p>因为web服务器经常包含多个处理器，而并发是充分利用这些处理器的理想方式。</p>
</blockquote>
<h3 id="21-1-并发的多面性"><a href="#21-1-并发的多面性" class="headerlink" title="21.1 并发的多面性"></a>21.1 并发的多面性</h3><blockquote>
<p>并发编程令人困惑的一个主要原因是：使用并发时需要解决的问题有多个，而实现并发的方式也有多种，并且在这两者之间没有明显的映射关系（通常只有模糊的界限）</p>
</blockquote>
<blockquote>
<p>并发解决的问题大体上可以分为“速度”和“设计可管理性”两种</p>
</blockquote>
<p><strong>21.1.1 更快的执行</strong></p>
<blockquote>
<p>并发是用于多处理器编程的基本工具。速度提高是以多核处理器的形式而不是更快的芯片的形式出现的，</p>
</blockquote>
<blockquote>
<ul>
<li><p>如果你有一台多处理器的机器，那么就可以在这些处理器之间分布多个任务，从而可以极大地提高吞吐量。这是使用强有力的多处理器Web服务器的常见情况，在为每个请求分配一个线程的程序中，它可以将大量的用户请求分布到多个CPU上。</p>
</li>
<li><p>但是并发是提高运行在单处理器上的程序的性能。</p>
</li>
<li><p>事实上，从性能角度看，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。（因为在单处理器上运行并发程序开销会更大，增加了上下文切换的代价【从一个任务切换到另一个任务】）</p>
</li>
<li><p>在单处理器系统中的性能提高的常见示例是事件驱动的编程。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>实现并发最直接的方式是操作系统级别使用进程。操作系统会将进程相互隔离开，因此他们不会彼此干涉，这使得使用进程编程相对容易一些。与此相反的是，像Java使用的这种并发系统会共享诸如内存和I&#x2F;O这样的资源，因此编写多线程程序最基本的困难在于协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。</li>
</ul>
</blockquote>
<blockquote>
<p>Java采取了更加创痛的方式，在顺序语言的基础上提供对线程的支持，与在多任务操作系统中分叉外部进程不同，线程机制是在由执行程序表示的单一的进程中创建任务，这种方式产生的一个好处是操作系统的透明性。</p>
</blockquote>
<p><strong>21.1.2 改进代码设计</strong></p>
<blockquote>
<ul>
<li><p>对于线程数量不够的处理方式是协作多线程。Java的线程机制是抢占式的，这表示调度机制对周期性地终端线程，将上下文切换到i给你一个线程，从而为每个线程都提供时间片，使得每个县册灰姑娘都会分配到数量合理的时间去驱动它的任务。</p>
</li>
<li><p>通常线程使你能够创建更加松散耦合的设计。</p>
</li>
</ul>
</blockquote>
<h3 id="21-2-基本的线程机制"><a href="#21-2-基本的线程机制" class="headerlink" title="21.2 基本的线程机制"></a>21.2 基本的线程机制</h3><blockquote>
<ul>
<li>并发编程是我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务（也被称为子任务），zh哦那个的每一个都将由执行线程来驱动。一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个人物都好像有其自己的CPU一样。&#x3D;&#x3D;其底层机制是切分CPU时间。&#x3D;&#x3D;</li>
<li>线程的一大好处是代码不必知道它是运行在具有一个还是多个CPU的机器上。</li>
<li>多任务和多线程时使用多处理器系统的最合理方式</li>
</ul>
</blockquote>
<p><strong>21.2.1 定义任务</strong></p>
<blockquote>
<ul>
<li>线程可以驱动任务，因此你需要&#x3D;&#x3D;一种描述任务的方式，这可以由Runnable接口来提供，要想定义任务，只需实现Runnable接口并编写run()方法，使得该任务可以执行你的命令&#x3D;&#x3D;。例如，下面的LiftOff任务将显式发射之前的倒计时.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiftOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> countDown=<span class="number">10</span>; <span class="comment">//default</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> taskCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id=taskCount++;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiftOff</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiftOff</span><span class="params">(<span class="type">int</span> countDown)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.countDown=countDown;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">status</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id+<span class="string">&quot;(&quot;</span>+(countDown&gt;<span class="number">0</span>?countDown:<span class="string">&quot;LiftOff!&quot;</span>)+<span class="string">&quot;),&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(status());</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在run()中对&#x3D;&#x3D;静态方法Thread.yield()的调用是对线程调度器（Java线程机制的一部分，可以将CPU从一个线程转义给另一个线程）的一种建议&#x3D;&#x3D;，它在声明：“我已经执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机”。这是可选的，这是为了能够看到任务换进换出的证明。（线程切换）</p>
</li>
<li><p>下面示例中，这个任务的run()不是由单独的线程驱动的，它是在main()中直接带哦用的（实际上，这里仍旧使用了线程，即总是分配给main()的那个线程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        LiftOff launch=<span class="keyword">new</span> <span class="title class_">LiftOff</span>();</span><br><span class="line">        launch.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x3D;&#x3D;当从Runnable导出一个类是，它必须具有run()方法，但是这个方法并无特殊之处——即它不会产生任何内在的线程能力。要实现线程行为，你必须显式的将一个任务附着到线程上。&#x3D;&#x3D;</p>
</li>
</ul>
</blockquote>
<p><strong>21.2.2 Thread类</strong></p>
<blockquote>
<ul>
<li>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器，下面的示例展示了如何使用Thread来驱动LiftOff对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicThreads</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for LiftOff&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">Waiting for LiftOff</span></span><br><span class="line"><span class="comment">#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Thread构造器只需要一个Runnable对象。&#x3D;&#x3D;调用Thread对象的start()方法为该线程执行必需的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务&#x3D;&#x3D;。可以看到Wating for LiftOff消息在倒计时完成之前就出现了。这是因为LiftOff.run()是由不同的线程的执行的，因此你仍旧可以执行main()线程中的其他操作。（这种能力并不局限于main()线程，任何线程都可以启动另一个线程）</li>
<li>可以很容易的添加更多的线程去驱动更多的任务。下面，你可以看到所有任务彼此之间是如何相互呼应的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoreBasicThreads</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LiftOff</span>()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting for liftOff&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">Waiting for LiftOff</span></span><br><span class="line"><span class="comment">#0(9), #1(9), #2(9), #3(9), #4(9), #0(8), #1(8), #2(8), #3(8), #4(8), #0(7), #1(7), #2(7), #3(7), #4(7), #0(6), #1(6), #2(6), #3(6), #4(6), #0(5), #1(5), #2(5), #3(5), #4(5), #0(4), #1(4), #2(4), #3(4), #4(4), #0(3), #1(3), #2(3), #3(3), #4(3), #0(2), #1(2), #2(2), #3(2), #4(2), #0(1), #1(1), #2(1), #3(1), #4(1), #0(Liftoff!), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的输出说明不同任务的执行在线程被换进换出时混在了一起。这种交换是由线程调度器自动控制的。如果在你的机器上有多个处理器，线程调度器将会在这些处理器之间默默地分发进程。</li>
<li>当main()创建Thread对象时，它并没有捕获任何对这些对象的引用。在使用普通对象时，这对于垃圾回收来说是一场公平的游戏，但是在使用Thread时，情况就不同了。每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且&#x3D;&#x3D;在它的任务退出其run()并死亡之前，垃圾回收器无法清除它&#x3D;&#x3D;。你可以从输出中看到，这些任务确实运行到了结束，因此，&#x3D;&#x3D;一个线程会创建一个单独的执行线程，在对start()的调用完成之后，它仍旧会在继续存在。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<p><strong>21.2.3 使用Executor</strong></p>
<blockquote>
<ul>
<li>JavaSE5的java.util.concurrent包中的&#x3D;&#x3D;执行器&#x3D;&#x3D;（Executor）将为你管理Thread对象，从而简化了并发编程。Excecutor在客户端和任务执行之间提供了一个间接层；与客户端直接执行任务不同这个中介对象将执行任务。Executor在JavaSE5&#x2F;6中是启动任务的优选方法。</li>
<li>可以使用Executor来代替在MoreBasicThreads.java中显式地创建Thread对象。ListOff对象知道如何运行具体的任务，与命令设计模式一样，它暴露了要执行的单一方法。ExecutorService(具有服务生命周期的Executor,例如关闭)知道如何构建恰当的上下文来执行Runnable对象。</li>
<li>在下面的实例中，&#x3D;&#x3D;CachedThreadPool将为每个任务都创建一个线程&#x3D;&#x3D;。注意，ExecutorService对象时使用静态的Executor方法创建的，这个方法可以确定其Executor类型：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务。</li>
<li>对shutdown()方法的调用可以防止新任务被提交给这个Executor,当前线程（在本例中，即驱动main()的线程）将继续运行在shutdown()被调用之前提交的所任务。这个程序将在Executor中的所有任务完成之后尽快退出。</li>
<li>可以将前面的CachedThreadPool替换为不同类型的Executor.&#x3D;&#x3D;FixedThreadPool使用了有限的线程集来执行所提交的任务。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//构造器参数就是线程的数量</span></span><br><span class="line">        ExecutorService exec=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(itn i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有了FixedThreadPool，你就可以一次性预先执行代价高昂的线程分配，因而也就可以限制线程的数量。</li>
<li>尽管本书将使用CachedThreadPool，但是也应该考虑在产生线程的代码中使用FixedThreadPool.CachedThreadPool在程序执行过程中通常会创建于所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式会引发问题是，才需要切换到FixedThreadPool.</li>
<li>SingleThreadExecutor就像是线程数量为1的FixedThreadPool.(它提供了一种重要的并发保证，其他线程额不会被并发调用。这会改变任务的加锁需求)。如果向SinglethreadExecutor提交了多个任务，那么么这些任务将排队，每个人物都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。SingleThreadExecutor会序列化所有提交给它的任务，并会维护它自己（隐藏）的悬挂任务队列。在下面的实例中，可以看到每个任务都是按照他们被提交的顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadExecutor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ExecutorService exec=Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!), #1(9), #1(8), #1(7), #1(6), #1(5), #1(4), #1(3), #1(2), #1(1), #1(Liftoff!), #2(9), #2(8), #2(7), #2(6), #2(5), #2(4), #2(3), #2(2), #2(1), #2(Liftoff!), #3(9), #3(8), #3(7), #3(6), #3(5), #3(4), #3(3), #3(2), #3(1), #3(Liftoff!), #4(9), #4(8), #4(7), #4(6), #4(5), #4(4), #4(3), #4(2), #4(1), #4(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;可以使用SingleThreadExecutor来运行很多个线程，以确保任意时刻在任何线程中都只有唯一的任务在运行&#x3D;&#x3D;，你不需要在共享资源上处理同步。有时候更好的解决方案是在资源上处理同步（后面学习），但是SingleThreadExecutor可以让你省区只是为了维持某些事物的原型而进行的各种努力。通过序列化任务，你可以消除对序列化对象的需求。</li>
</ul>
</blockquote>
<p><strong>21.2.4 从任务中产生返回值</strong></p>
<blockquote>
<ul>
<li>Runnable是执行工作的独立任务，但是它不返回任何值。&#x3D;&#x3D;如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口&#x3D;&#x3D;。在JavaSE5中引入的Callable是一个具有类型参数的泛型，&#x3D;&#x3D;它的类型参数表示的是从方法call()（而不是run()）中返回的值，并且必须使用executorService.submit()方法调用它&#x3D;&#x3D;，下面是一个实例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskWithResult</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TaskWithResult</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;result of TaskWithResult &quot;</span> + id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    ArrayList&lt;Future&lt;String&gt;&gt; results =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      results.add(exec.submit(<span class="keyword">new</span> <span class="title class_">TaskWithResult</span>(i)));</span><br><span class="line">    <span class="keyword">for</span>(Future&lt;String&gt; fs : results)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// get() blocks until completion:</span></span><br><span class="line">        System.out.println(fs.get());</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(ExecutionException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">result of TaskWithResult 0</span></span><br><span class="line"><span class="comment">result of TaskWithResult 1</span></span><br><span class="line"><span class="comment">result of TaskWithResult 2</span></span><br><span class="line"><span class="comment">result of TaskWithResult 3</span></span><br><span class="line"><span class="comment">result of TaskWithResult 4</span></span><br><span class="line"><span class="comment">result of TaskWithResult 5</span></span><br><span class="line"><span class="comment">result of TaskWithResult 6</span></span><br><span class="line"><span class="comment">result of TaskWithResult 7</span></span><br><span class="line"><span class="comment">result of TaskWithResult 8</span></span><br><span class="line"><span class="comment">result of TaskWithResult 9</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。你可以用isDone()方法来查询Future是否已经完成。当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果。你也可以不用isDone()进行检查就直接调用get(),在这种情况下，get()将阻塞，直至结果准备就绪。</li>
</ul>
</blockquote>
<p><strong>21.2.5 休眠</strong></p>
<blockquote>
<ul>
<li>影响任务行为的一种简单方法是调用sleep(),这将使任务中止来执行给定的时间。</li>
<li>对sleep()的调用可以抛出InterruptedException异常，并且你可以看到，它在run()中被捕获。&#x3D;&#x3D;因为异常不能跨线程传播会main(),所以必须在本地处理所有在任务内部产生的异常。&#x3D;&#x3D;</li>
<li>除了使用Thread.sleep()方法。JavaSE5引入了更加显式的sleep版本，作为TimeUnit类的一部分，因此可以提供更好的可阅读性，TimeUnit还可以被用来执行转换</li>
<li>如TimeUnit.MILLISECONDS.sleep(100);效果通Thread.sleep(100);</li>
</ul>
</blockquote>
<p><strong>21.2.6 优先级</strong></p>
<blockquote>
<ul>
<li>线程的优先级将线程的重要性传递给了调度器。尽管CPU处理现有县城及的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。然而，这并不意味这优先权较低的线程将得不到执行（也就是说，优先权不会导致死锁）。优先权较低的线程仅仅是执行的频率较低。</li>
<li>在绝大数时间里，所有线程都应该以默认的优先级运行。试图操纵现车给优先级通常是一种错误。</li>
<li>下面是一个演示优先级等级的实例，&#x3D;&#x3D;你可以用getPriority()来读取现有线程的优先级，并且在任何时刻都可以通过setPriority()来修改它。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePriorities</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> d; <span class="comment">// No optimization</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimplePriorities</span><span class="params">(<span class="type">int</span> priority)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.priority = priority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread() + <span class="string">&quot;: &quot;</span> + countDown;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().setPriority(priority);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// An expensive, interruptable operation:</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        d += (Math.PI + Math.E) / (<span class="type">double</span>)i;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">          Thread.<span class="keyword">yield</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">if</span>(--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimplePriorities</span>(Thread.MIN_PRIORITY));</span><br><span class="line">    exec.execute(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimplePriorities</span>(Thread.MAX_PRIORITY));</span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (70% match)</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 4</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 3</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 2</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 1</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-3,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-2,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-1,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-5,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-4,1,main]: 5</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Thread.toString()方法来打印线程的名称、线程的优先级以及线程所属的线程组。你可以通过构造器来自己设置这个名称。这里是自动生成的名称，如ppol-1-thred-1,pool-1-thred-2等。</li>
<li>通过调用Thread.currentThread()来获得对驱动该任务的Thread对象的引用。</li>
<li>优先级是在run()的开头部分设定的，在构造器中设置他们不会有任何好处，因为executor在此刻还没有开始执行任务。</li>
<li>变量d是用volatile修饰的，以努力确保不进行任何编译器优化。</li>
<li>尽管JDK有10个优先级，但它与多数操作系统不饿能映射得很好，唯一可移植得方法是当调整优先级得时候，只是用MAX_PRIORITY、NORM_PRIORITY和MIN_PRIORITY三种级别。</li>
</ul>
</blockquote>
<p><strong>21.2.7 让步</strong></p>
<blockquote>
<p>让步是通过Thread.yield()方法来完成的，这个只是建议并不是强制，所以大体上对于重要的控制或在调整应用时，都不能依赖于yield().</p>
</blockquote>
<p><strong>21.2.8 后台线程</strong></p>
<blockquote>
<ul>
<li>所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程。并且这种线程并不属于程序中不可或缺的部分。因此，&#x3D;&#x3D;当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程&#x3D;&#x3D;。反过来说，只要有任何非后台线程还在执行，程序就不会终止。比如，执行main()的就是一个非后台线程。</li>
<li>必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        print(Thread.currentThread() + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;sleep() interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SimpleDaemons</span>());</span><br><span class="line">      daemon.setDaemon(<span class="literal">true</span>); <span class="comment">// Must call before start()</span></span><br><span class="line">      daemon.start();</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;All daemons started&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">All daemons started</span></span><br><span class="line"><span class="comment">Thread[Thread-0,5,main] SimpleDaemons@530daa</span></span><br><span class="line"><span class="comment">Thread[Thread-1,5,main] SimpleDaemons@a62fc3</span></span><br><span class="line"><span class="comment">Thread[Thread-2,5,main] SimpleDaemons@89ae9e</span></span><br><span class="line"><span class="comment">Thread[Thread-3,5,main] SimpleDaemons@1270b73</span></span><br><span class="line"><span class="comment">Thread[Thread-4,5,main] SimpleDaemons@60aeb0</span></span><br><span class="line"><span class="comment">Thread[Thread-5,5,main] SimpleDaemons@16caf43</span></span><br><span class="line"><span class="comment">Thread[Thread-6,5,main] SimpleDaemons@66848c</span></span><br><span class="line"><span class="comment">Thread[Thread-7,5,main] SimpleDaemons@8813f2</span></span><br><span class="line"><span class="comment">Thread[Thread-8,5,main] SimpleDaemons@1d58aae</span></span><br><span class="line"><span class="comment">Thread[Thread-9,5,main] SimpleDaemons@83cc67</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过调用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程。</li>
<li>你应该意识到后台进程在不执行finally子句的情况下就会终止其run()方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADaemon</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      print(<span class="string">&quot;Starting ADaemon&quot;</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via InterruptedException&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      print(<span class="string">&quot;This should always run?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonsDontRunFinally</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ADaemon</span>());</span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    t.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Starting ADaemon</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当运行这个程序时，将看到finally子句就不会执行。但是如果注释掉对setDaemon()的调用，就会看到fiinally的调用，就会看到finally的执行。</li>
<li>&#x3D;&#x3D;当最后一个非后台线程终止时，后台线程会突然终止。因此一旦main()退出，jvm就会立即关闭所有的后台进程。&#x3D;&#x3D;而不会有任何你希望出现的确认形式。因为你不能以优雅的方式来关闭后台线程，所以它们呢几乎不是一种好的思想。非后台的Executor通常是一种更好的方式，因为Executor控制的所有任务可以同时被关闭，关闭并且以有序的方式执行。</li>
</ul>
</blockquote>
<p><strong>21.2.9 编码的变体</strong></p>
<blockquote>
<ul>
<li>在前面的示例中，任务类都实现了Runnable.在非常简单的情况下，你可能会希望使用直接从Thread继承这种可替换的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> threadCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleThread</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//store the thread name</span></span><br><span class="line">        <span class="built_in">super</span>(Integer.toString(++threadCount));</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>+getName()+<span class="string">&quot;(&quot;</span>+countDown+<span class="string">&quot;),&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span>(--countDown==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SimpleThread</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过调用适当的Thread构造器为Thread对象赋予具体的名称，这个名称可以通过使用getName()从toString()中获得。</li>
<li>另一种可能会看到的管用法是自管理的Runnable:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfManaged</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SelfManaged</span><span class="params">()</span> &#123; t.start(); &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName() +</span><br><span class="line">      <span class="string">&quot;(&quot;</span> + countDown + <span class="string">&quot;), &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      System.out.print(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">if</span>(--countDown == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SelfManaged</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Thread-0(5), Thread-0(4), Thread-0(3), Thread-0(2), Thread-0(1), Thread-1(5), Thread-1(4), Thread-1(3), Thread-1(2), Thread-1(1), Thread-2(5), Thread-2(4), Thread-2(3), Thread-2(2), Thread-2(1), Thread-3(5), Thread-3(4), Thread-3(3), Thread-3(2), Thread-3(1), Thread-4(5), Thread-4(4), Thread-4(3), Thread-4(2), Thread-4(1),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这与从Thread继承并没有什么特别的差异，但是实现接口使得可以继承另一个不同的类。</li>
</ul>
</blockquote>
<p><strong>21.2.10 术语</strong></p>
<blockquote>
<ul>
<li>在Java中，Thread类自身并不执行任何操作，它只是驱动赋予它的任务，但在线程研究中总是不变得使用线程执行这项或那项动作的语言。</li>
<li>我将尝试着在描述将要执行的工作时使用术语“任务”，只有在我引用到驱动任务的具体机制时，才使用线程。</li>
</ul>
</blockquote>
<p><strong>21.2.11 加入一个线程</strong></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复&#x3D;&#x3D;。（即t.isAlive()返回为假）【如下面的Joiner这个线程在Sleeper线程t上调用t.join()】</li>
<li>也可以在调用join()时带上一个超时参数（单位可以是秒，或者毫秒，纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。</li>
<li>对join()方法的调用可以被中断，做法时在调用线程上调用interrupt()方法，这时需要用到try-catch子句</li>
<li>下面这个例子演示了所有这些操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sleeper</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> duration;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sleeper</span><span class="params">(String name,<span class="type">int</span> sleepTime)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        duration=sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//线程正常情况下处于非中断状态，即 isInterrupted()返回false</span></span><br><span class="line">            sleep(duration);   <span class="comment">//但是在执行完sleep、wait这些方法时就会进入中断状态</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            print(getName()+<span class="string">&quot; was interrupted.&quot;</span>+<span class="string">&quot;isInterrupted():&quot;</span>+isInterrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print(getName()+<span class="string">&quot; has awakened&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Joiner</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sleeper sleeper;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Joiner</span><span class="params">(String name,Sleeper sleeper)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.sleeper=sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sleeper.join();  <span class="comment">//joiner这个线程自身会被挂起，要等到 sleeper线程执行结束后太进行执行</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            print(<span class="string">&quot;Interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        print(getName()+<span class="string">&quot; join completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joining</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Sleeper sleepy=<span class="keyword">new</span> <span class="title class_">Sleeper</span>(<span class="string">&quot;Sleepy&quot;</span>,<span class="number">1500</span>),grumpy=<span class="keyword">new</span> <span class="title class_">Sleeper</span>(<span class="string">&quot;Grumpy&quot;</span>,<span class="number">1500</span>);</span><br><span class="line">        Joiner dopey=<span class="keyword">new</span> <span class="title class_">Joiner</span>(<span class="string">&quot;Dopey&quot;</span>,sleepy),doc=<span class="keyword">new</span> <span class="title class_">Joiner</span>(<span class="string">&quot;Doc&quot;</span>,grumpy);</span><br><span class="line">        <span class="comment">//打破当前线程的中断状态，并返回一个中断异常</span></span><br><span class="line">        grumpy.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**Output:</span></span><br><span class="line"><span class="comment">Grumpy was interrupted. isInterrupted():false</span></span><br><span class="line"><span class="comment">Doc join completed</span></span><br><span class="line"><span class="comment">Sleepy has awakened</span></span><br><span class="line"><span class="comment">Dopey join completed</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:/~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Sleeper是一个Thread类型，它要休眠一段时间，这段时间是通过构造器传进来的参数所指定的。在run()中,sleep()方法有可能在指定的时间期满时返回，但也有可能中断。在catch子句中，将根据isInterrupted()的返回值报告这个中断。&#x3D;&#x3D;当另一个线程在该线程上调用interrupt()时，将给该线程设定一个标志，表明该线程已经被中断。然而，异常被捕获时将清理这个标志，所以在catch子句中，在一场被捕获的时候这个标志总是为假&#x3D;&#x3D;。除异常之外，这个标志还可用于其他情况，比如线程可能会检查其中断状态。</li>
<li>JavaSE5的java.util.concurrent类库包含诸如CyclicBarrier(后面会展示)这样的工具，他们可能比最初的线程类库中的join()更加合适。</li>
</ul>
</blockquote>
<p><strong>21.2.12 建立有响应的页面</strong></p>
<p><strong>21.2.13 线程组</strong></p>
<blockquote>
<p>线程组是一个线程集合。最好把线程组看成是一次不成功的尝试，你只要忽略它就好了。</p>
</blockquote>
<p><strong>21.2.14 捕获异常</strong></p>
<blockquote>
<ul>
<li>由于线程的本质特性，使得你不能捕获从线程中逃逸的异常，一旦一场逃出任务的run()方法，它就会向外传播到控制台。除非采取特殊的步骤捕获这种错误的异常。在JavaSE5之前，可以使用i安承祖来捕获这些异常，但是有了Java SE5，就可以用Executor来解决这个问题。</li>
<li>下面的任务总是会抛出一个异常，该异常会传播到其run()方法的外部，并且main()展示了你运行它时所发生的事情。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面这个会报错。如果把main主体放入try-catch中也是没有作用的。</li>
<li>为了解决这个问题，我们要修改Executor产生线程的方式。Thread.UncaughtExceptionHandler是Java SE5中的新接口，它允许你再每个Thread对象上给附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;run() by &quot;</span> + t);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;caught &quot;</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span> + <span class="string">&quot; creating new Thread&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    System.out.println(<span class="string">&quot;created &quot;</span> + t);</span><br><span class="line">    t.setUncaughtExceptionHandler(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptureUncaughtException</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">HandlerThreadFactory</span>());</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread2</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">HandlerThreadFactory@de6ced creating new Thread</span></span><br><span class="line"><span class="comment">created Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">eh = MyUncaughtExceptionHandler@1fb8ee3</span></span><br><span class="line"><span class="comment">run() by Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">eh = MyUncaughtExceptionHandler@1fb8ee3</span></span><br><span class="line"><span class="comment">caught java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在程序中添加了额外的跟踪机制，用来验证工厂创建的线程会传递给UncaughtExceptionHandler。现在可以看到，未捕获的异常是通过uncaughtException来捕获的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方式是在Thread类中设置一个静态域，并将这个处理器设置为默认的未捕获异常处理器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t,Throwable e)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;caught &quot;</span>+e);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SettingDefaultHandler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>());</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**output:</span></span><br><span class="line"><span class="comment">caught java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">*/</span>/~</span><br></pre></td></tr></table></figure>

<ul>
<li>这个处理器只有在不存在线程专有的未捕获异常处理器的情况下才会被调用。系统会检查线程专有版本，如果没有发现，则检查线程组是否有其专有的uncaughtException()方法，如果也没有，再调用defaultUncaughtExceptionHandler.</li>
</ul>
</blockquote>
<h3 id="21-3-共享受限资源"><a href="#21-3-共享受限资源" class="headerlink" title="21.3  共享受限资源"></a>21.3  共享受限资源</h3><p><strong>21.3.1 不正确的访问资源</strong></p>
<blockquote>
<p>我们可以发现，在Java中，递增不是原子性的操作</p>
</blockquote>
<p><strong>21.3.2 解决共享资源竞争</strong></p>
<blockquote>
<ul>
<li>对于并发工作，你需要某种方式来防止两个任务访问相同的资源，至少在关键阶段不能出现这种情况。</li>
<li>防止这种冲突的方法就是当资源被一个任务使用时，在其上加上锁。</li>
<li>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。这意味着在给定时刻只允许一个任务访问共享资源。&#x3D;&#x3D;通常这是通过在代码前面加上一条锁语句来实现的。因为锁语句产生了一种相排斥的效果，所以这种机制常常称为互斥量（mutex）&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;Java以提供关键字synchronized的形式，为防止资源冲突提供了内置支持。&#x3D;&#x3D;当任务要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，然后获取锁，执行代码，释放锁。</li>
<li>共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入&#x2F;输出端口，或者是打印机。要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为synchronized。如果某个任务处于一个对标记为synchronized的方法的调用中，那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。</li>
<li>对于某个特定对象来说，其所有synchronized方法共享同一个锁，这可以用来放置多个任务同时访问被编码为对象内存。</li>
<li>注意，&#x3D;&#x3D;在使用并发时，将域设置为private是非常重要的&#x3D;&#x3D;，否则，synchronized关键字就不能放置其他任务直接访问域，这样就会产生冲突。</li>
<li>一个任务可以多次获得对象的锁。</li>
<li>针对每个类，也有一个类（作为类的Class对象的一部分），所以synchronized static方法可以在类的范围内防止对static数据的并发访问。</li>
<li>你应该什么时候同步（synchronized）呢？可以运用Brian的同步规则：<ul>
<li>如果&#x3D;&#x3D;你正在写一个变量，它可能接下来将被另一个线程读取&#x3D;&#x3D;，或者&#x3D;&#x3D;正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步&#x3D;&#x3D;，并且，&#x3D;&#x3D;读写线程都必须用相同的监视器锁同步&#x3D;&#x3D;。</li>
</ul>
</li>
<li>如果在你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。如果只同步一个方法，那么其他方法将会随意地忽略这个对象锁，并可以在无任何惩罚地情况下被调用。这是很重要地一点：每个访问临界共享资源地方法都必须被同步，否则它们就不会正确地工作。</li>
<li>示例可以见练习11</li>
</ul>
</blockquote>
<p><strong>使用显式地Lock对象</strong></p>
<blockquote>
<ul>
<li><p>JavaSE5地java.util.concurrent类库还包含有定义在java.util.concurrent.locks中地显式地互斥机制</p>
</li>
<li><p>Lock对象必须被显式地创建、锁定和释放，因此它与内建地锁形式相比，代码缺乏优雅性。但是，对于解决某些类型地问题来说，它更加灵活。</p>
</li>
<li><p>示例见：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title class_">IntGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentEvenValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      Thread.<span class="keyword">yield</span>(); <span class="comment">// Cause failure faster</span></span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    EvenChecker.test(<span class="keyword">new</span> <span class="title class_">MutexEvenGenerator</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MutexEvenGenerator添加了一个被相互调用地锁，并使用lock()和unlock()方法在next()内部创建了临界资源。当你在使用Lock对象时，将这里地惯用写法内部化非常重要：紧接着地对lock()地调用，你必须放置在finally子句中带有unlock()的try-finally语句中。注意，return语句必须在try子句中出现，以确保unlock()不会过早发生，从而将数据暴露给了第二个任务。</li>
<li>如果在使用synchronized关键字时，如果某些事务失败了，那么就会抛出一个异常。但是你没有机会去做任何清理动作，以维护系统使其处于良好状态。有了显式的Lock对象，你就可以使用finally子句将维护系统在正确的状态。</li>
<li>大体上，当你使用synchronized关键字时，需要写的代码量更少，并且用户错误出现的可能性也会降低，因此通常只有解决特殊问题时，才使用显式的Lock对象。例如，用synchronized关键字蹦年尝试和获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后放弃它，要实现这些，你必须使用concurrent类库。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttemptLocking</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">untimed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">captured</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;tryLock(): &quot;</span> + captured);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(captured)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">captured</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      captured = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;tryLock(2, TimeUnit.SECONDS): &quot;</span> +</span><br><span class="line">        captured);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(captured)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AttemptLocking</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AttemptLocking</span>();</span><br><span class="line">    al.untimed(); <span class="comment">// True -- lock is available</span></span><br><span class="line">    al.timed();   <span class="comment">// True -- lock is available</span></span><br><span class="line">    <span class="comment">// Now create a separate task to grab the lock:</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      &#123; setDaemon(<span class="literal">true</span>); &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        al.lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;acquired&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    Thread.<span class="keyword">yield</span>(); <span class="comment">// Give the 2nd task a chance</span></span><br><span class="line">    al.untimed(); <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">    al.timed();   <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">tryLock(): true</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class="line"><span class="comment">acquired</span></span><br><span class="line"><span class="comment">tryLock(): false</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): false</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显式的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁来说，还赋予了你更细粒度的控制力。这对于实现专有同步结构是很有用的，例如用于遍历链接列表中的节点的节点传递的加锁机制（也称为锁耦合），这种遍历代码必须在释放当前节点的锁之前捕获下一个节点的锁</li>
</ul>
</blockquote>
<p><strong>21.3.3 原子性与易变性</strong></p>
<blockquote>
<ul>
<li>在有关Java线程的讨论中，一个常不正确的知识是“原子操作不需要进行同步控制”。&#x3D;&#x3D;原子操作是不能被线程调度机制中断的操作；&#x3D;&#x3D;一旦操作开始，那么它一定可以在可能发生的上下文切换之前（切换到其他线程执行）执行完毕。&#x3D;&#x3D;依赖于原子性是很棘手且很危险的。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;原子性可以应用于除long和double之外的所有基本类型之上的简单操作&#x3D;&#x3D;。对于读取和写入除long和double之外的基本类型变量这样的操作，可以保证他们会被当做不可分（原子）的操作来操作内存。但是jvm可以将64位（long和double变量）的读取和写入当作两个分离的32位操作来执行，这就产生了一个读取和写入操作中间发生上下文切换，从而导致不同的任务可以看到不正确结果的可能性。&#x3D;&#x3D;但是当你定义long或double变量时，如果使用volatile关键字，就会获得（简单的赋值于返回操作的）原子性&#x3D;&#x3D;。</li>
<li>原子操作可由线程机制来保证其不可中断，但是这是一种过于简化的机制，有时看起来应该是安全的原子操作，实际上也可能不安全。&#x3D;&#x3D;因此不要尝试用原子操作来替换同步。&#x3D;&#x3D;</li>
<li>多处理器系统（现在以多核处理器的形式出现，即在单个芯片上有多个CPU），相对于单处理器系统而言，可视性问题远比原子性问题多得多。</li>
<li>一个任务做出的修改，即使在不中断的意义上讲是原子性的，对其他任务也可能是不可视的（例如修改只是暂时性地存储在本地处理器地缓存中），因此不同地任务对应用地状态有不同的视图。另一方面，&#x3D;&#x3D;同步机制强制在处理器系统中，一个任务做出的修改必须在应用中是可视的。如果没有同步机制，那么修改时可视将无法确定。&#x3D;&#x3D;</li>
<li>volatile关键字还确保了应用中的可视性。如果你讲一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。即便使用本地缓存，情况也确实如此，volatile域会立即被写入到主存中，而读取操作就大声在主存中。</li>
<li>理解原子性和易变性是不同的概念这一点很重要。在非volatile域上的操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值。如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。&#x3D;&#x3D;同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来保护，那就不必将其设置为是volatile的&#x3D;&#x3D;。</li>
<li>一个任务所作的任何写入操作对这个任务来说都是可视的，因此如果它只需要在这个任务内部可视，那么你就不需要将其设置为volatile的。</li>
<li>当一个域的值依赖于它之前的值（例如递增一个计数器），volatile就无法工作了。如果某个某个域的值受到其他域的值的限制，那么volatile也无法工作，例如Range类的lower和upper边界就必须遵循lower&lt;&#x3D;upper的限制。</li>
<li>&#x3D;&#x3D;使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域&#x3D;&#x3D;。因此我们的第一选择还应该是使用synchronized关键字，这是最安全的方式。</li>
<li>什么才是原子操作呢？<ul>
<li>对域中的值做赋值和返回操作通常都是原子性的。</li>
</ul>
</li>
<li>基本上，如果一个域可能会被多个任务同时访问，或者这些任务中至少有一个是写入任务，那么你就应该将这个域设置为volatile的。</li>
</ul>
</blockquote>
<p><strong>21.3.4 原子类</strong></p>
<blockquote>
<ul>
<li>Java SE5引入了诸如AtomicInteger,AtomicLong,AtomicReference等特殊的原子性变量类，他们提供下面形式的原子性条件更新操作：<ul>
<li>boolean compareAndSet(expectedValue,updateVaule);</li>
</ul>
</li>
<li>这些类被调整为可以使用在某些现代处理器上的而可获得的、并且是在机器级别上的原子性，，可以同时使用这些而消除了synchronized关键字。</li>
<li>应该强调的是，Atomic类被设计用来用来构建java.util.concurrent中的类，因此只有在特殊情况下才在自己的代码中使用。通常依赖于锁要更安全一些（要么是synchronized关键字，要么是显式的Lock对象）</li>
</ul>
</blockquote>
<p><strong>21.3.5 临界区</strong></p>
<blockquote>
<ul>
<li>有时，你只是希望防止多个线程同时防问方法内部的部分代码，而不是防止访问整个方法。通过这种方式分离出来的代码被称为临界区（critical section）,它也使用synchronized关键字建立。这里，synchronized被用来指定某个对象，此对象的锁被用来对花括号内代码进行同步控制：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject)&#123;   <span class="comment">//这里面一般放类对象this</span></span><br><span class="line">	<span class="comment">//This code can be accessed by only one task at a time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这也被称为同步控制快，在进入此段代码前，必须得到syncObject对象的锁。如果其他线程已经得到这个锁，那么就得等到锁被释放以后，才能进入临界区。</li>
<li>通过使用同步控制块，而不是对整个方法进行同步控制，可以使多个任务访问对象的时间性能得到显著提高，所以对象不加锁的时间更长。这也是宁愿使用同步控制快而不是整个方法进行同步控制的典型原因：使得其他线程能更多的访问（在安全的情况下尽可能多）。</li>
<li>还可以使用显式的Lock对象来创建临界区</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synchronize the entire method:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitPairManager1</span> <span class="keyword">extends</span> <span class="title class_">PairManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      p.incrementX();</span><br><span class="line">      p.incrementY();</span><br><span class="line">      store(getPair());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use a critical section:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitPairManager2</span> <span class="keyword">extends</span> <span class="title class_">PairManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    Pair temp;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      p.incrementX();</span><br><span class="line">      p.incrementY();</span><br><span class="line">      temp = getPair();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    store(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExplicitCriticalSection</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">PairManager</span></span><br><span class="line">      <span class="variable">pman1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExplicitPairManager1</span>(),</span><br><span class="line">      pman2 = <span class="keyword">new</span> <span class="title class_">ExplicitPairManager2</span>();</span><br><span class="line">    CriticalSection.testApproaches(pman1, pman2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">pm1: Pair: x: 15, y: 15 checkCounter = 174035</span></span><br><span class="line"><span class="comment">pm2: Pair: x: 16, y: 16 checkCounter = 2608588</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主要重要的点是在ExplicitPairManager2中的store()方法在临界区外</li>
</ul>
</blockquote>
<p><strong>21.3.6 在其它对象上同步</strong></p>
<blockquote>
<ul>
<li>synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象：synchronized(this),在这种方式中，如果获得了synchronized块上的锁，那么该对象其他的synchronized方法和临界区就不能被调用了。因此，如果在this上同步，临界区的效果就会直接缩小在同步的范围内。</li>
<li>有时必须在另一个对象上同步，但是如果你这么做，就必须确保所有相关的任务都是在同一个对象上同步的。下面的示例演示了两个任务可以同时进入同一个对象，只要这个对象上的方法是在不同的锁上同步的即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DualSynch</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">syncObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">      Thread.<span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(syncObject) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        print(<span class="string">&quot;g()&quot;</span>);</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncObject</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DualSynch</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DualSynch</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ds.f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    ds.g();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>DualSync.f()（通过同步整个方法）在this同步，而g()有一个在syncObject上同步的syncchronized块。因此这两个同步是相互独立的。通过在main()中创建调用f()的Thread对这一个点进行了演示，因为main()线程是被用爱调用g()的。从输出中可以看到，这两个方式在同时运行，因此任何一个方法都没有因为对另一个方法的同步而阻塞。</p>
</li>
<li><p>当使用synchronized临界区时，通过不同的syncObject对象来进行演示，这是重点。</p>
</li>
<li><p>下面这个练习是使用显式对象，来演示在其他对象上同步。重点在于使用不同的锁对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test16</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj2=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> Object obj3=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock locka=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Lock lockb=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Lock lockc=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            locka.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            locka.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lockb.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockb.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lockc.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockc.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exec16</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test16 test16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exec16</span><span class="params">(Test16 test16)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.test16=test16;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        test16.funA();</span><br><span class="line"><span class="comment">//        Thread.yield();</span></span><br><span class="line">        test16.funB();</span><br><span class="line"><span class="comment">//        Thread.yield();</span></span><br><span class="line">        test16.funC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exec16Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Test16 t=<span class="keyword">new</span> <span class="title class_">Test16</span>();</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Exec16</span>(t));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>21.3.7 线程本地存储</strong></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。&#x3D;&#x3D;因此，如果你有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储块。主要是，他们可以使得你可以将状态与线程关联起来。</li>
<li>创建和管理线程本地存储可以由java.lang.ThreadLocal类来实现，如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Accessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Accessor</span><span class="params">(<span class="type">int</span> idn)</span> &#123; id = idn; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      ThreadLocalVariableHolder.increment();</span><br><span class="line">      System.out.println(<span class="built_in">this</span>);</span><br><span class="line">      Thread.<span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">      ThreadLocalVariableHolder.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalVariableHolder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(<span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    value.set(value.get() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value.get(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">Accessor</span>(i));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);  <span class="comment">// Run for a while</span></span><br><span class="line">    exec.shutdownNow();         <span class="comment">// All Accessors will quit</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">#0: 9259</span></span><br><span class="line"><span class="comment">#1: 556</span></span><br><span class="line"><span class="comment">#2: 6694</span></span><br><span class="line"><span class="comment">#3: 1862</span></span><br><span class="line"><span class="comment">#4: 962</span></span><br><span class="line"><span class="comment">#0: 9260</span></span><br><span class="line"><span class="comment">#1: 557</span></span><br><span class="line"><span class="comment">#2: 6695</span></span><br><span class="line"><span class="comment">#3: 1863</span></span><br><span class="line"><span class="comment">#4: 963</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象的内容，其中，get()方法将返回与其线程相关联的对象的副本，而set()会将参数插入到为其线程存储的对象种，并返回存储中原有的对象。上面increment()和get()方法在ThreadLocalVariableHolder种演示了这一点。注意，increment()和get()方法都不是synchronized的，因为ThreadLocal保证不会出现竞争条件</li>
</ul>
</blockquote>
<h3 id="21-4-终结任务"><a href="#21-4-终结任务" class="headerlink" title="21.4 终结任务"></a><strong>21.4 终结任务</strong></h3><p><strong>21.4.2 在阻塞时终结</strong></p>
<blockquote>
<ul>
<li>slepp()是一种情况，它使任务从执行状态变为被阻塞状态，而有时你必须终止被阻塞的状态。</li>
</ul>
</blockquote>
<p><strong>线程状态</strong></p>
<blockquote>
<p>一个线程可以处于以下四种状态之一：</p>
<ol>
<li>&#x3D;&#x3D;新建（new）:&#x3D;&#x3D;当线程被创建时，它只会短暂的处于这种状态。此时它已经分配了必需的系统资源，并执行了初始化。此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。</li>
<li>&#x3D;&#x3D;就绪（Runnable）&#x3D;&#x3D;:在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程，它就可以运行；这不同于死亡和阻塞状态。</li>
<li>&#x3D;&#x3D;阻塞（Blocked）&#x3D;&#x3D;:线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间。直到线程重新进入了就绪状态，它才有可能执行操作。</li>
<li>&#x3D;&#x3D;死亡（Dead）&#x3D;&#x3D;:处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已结束，或不再是可运行的。任务死亡的方式通常时从run()方法返回，但是任务的线程还可以被中断，你将要看到这一点。</li>
</ol>
</blockquote>
<p><strong>进入阻塞状态</strong></p>
<blockquote>
<p>一个任务进入阻塞状态，可能有如下原因：</p>
<ol>
<li>通过调用sleep(millseconds)是任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。</li>
<li>通过调用wait()是现成挂起。直到线程得到了notify()或notifyAll()消息（或者在JavaSE5的java.util.concurrent类库中等价的signal()或signalAll()消息），线程才会进行就绪状态。</li>
<li>任务在等待某个输入&#x2F;输出完成。</li>
<li>任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。</li>
</ol>
</blockquote>
<p><strong>21.4.3 中断</strong></p>
<blockquote>
<ul>
<li>在Runable.run()方法的中间打断它，与等待该方法到达棘手的多。因为当打断被阻塞的任务时，可能需要清理资源。</li>
<li>Thread类包含interrupt()方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态。如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptException.当抛出该异常或者该任务调用Thread.interrupted()时，中断状态将被复位。所以Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SleepBlocked</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;InterruptedException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Exiting SleepBlocked.run()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOBlocked</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> InputStream in;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">IOBlocked</span><span class="params">(InputStream is)</span> &#123; in = is; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      print(<span class="string">&quot;Waiting for read():&quot;</span>);</span><br><span class="line">      in.read();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        print(<span class="string">&quot;Interrupted from blocked I/O&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Exiting IOBlocked.run()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedBlocked</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) <span class="comment">// Never releases lock</span></span><br><span class="line">      Thread.<span class="keyword">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SynchronizedBlocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        f(); <span class="comment">// Lock acquired by this thread</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Trying to call f()&quot;</span>);</span><br><span class="line">    f();</span><br><span class="line">    print(<span class="string">&quot;Exiting SynchronizedBlocked.run()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interrupting</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span></span><br><span class="line">    Executors.newCachedThreadPool();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Runnable r)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    Future&lt;?&gt; f = exec.submit(r);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    print(<span class="string">&quot;Interrupting &quot;</span> + r.getClass().getName());</span><br><span class="line">    f.cancel(<span class="literal">true</span>); <span class="comment">// Interrupts if running</span></span><br><span class="line">    print(<span class="string">&quot;Interrupt sent to &quot;</span> + r.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">SleepBlocked</span>());</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">IOBlocked</span>(System.in));</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">SynchronizedBlocked</span>());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    print(<span class="string">&quot;Aborting with System.exit(0)&quot;</span>);</span><br><span class="line">    System.exit(<span class="number">0</span>); <span class="comment">// ... since last 2 interrupts failed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (95% match)</span></span><br><span class="line"><span class="comment">Interrupting SleepBlocked</span></span><br><span class="line"><span class="comment">InterruptedException</span></span><br><span class="line"><span class="comment">Exiting SleepBlocked.run()</span></span><br><span class="line"><span class="comment">Interrupt sent to SleepBlocked</span></span><br><span class="line"><span class="comment">Waiting for read():</span></span><br><span class="line"><span class="comment">Interrupting IOBlocked</span></span><br><span class="line"><span class="comment">Interrupt sent to IOBlocked</span></span><br><span class="line"><span class="comment">Trying to call f()</span></span><br><span class="line"><span class="comment">Interrupting SynchronizedBlocked</span></span><br><span class="line"><span class="comment">Interrupt sent to SynchronizedBlocked</span></span><br><span class="line"><span class="comment">Aborting with System.exit(0)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面的每个任务都表示了一种不同类型的阻塞。SleepBlock是可终端的阻塞示例，而IOBlocked和SynchronizedBlocked是不可中断的阻塞示例。所以证明了I&#x2F;O和在synchronized块上的等待是不可中断的，但是通过浏览代码，也可以预见到这一点——无论是I&#x2F;O还是尝试调用synchronized方法，都不需要任何InterruptedException处理器。</p>
</li>
<li><p>从输出中可以看到，你能够中断对sleep()的调用（或者任何要求抛出InterruptedException的调用）。但是你不能中断正在试图获取synchronized锁或者试图执行I&#x2F;O操作的线程。这令人烦恼，特别是在创建执行I&#x2F;O的任务时，因为这意味着I&#x2F;O具有锁住你的多线程程序的潜在可能性。特别是对基于Web的程序，这更是关乎利害。</p>
</li>
<li><p>对于这类问题，有一个略显笨拙但是有时确实行之有效的解决方案，即&#x3D;&#x3D;关闭任务在其上发生阻塞的底层资源&#x3D;&#x3D;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseResource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">socketInput</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).getInputStream();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">IOBlocked</span>(socketInput));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">IOBlocked</span>(System.in));</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    print(<span class="string">&quot;Shutting down all threads&quot;</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    print(<span class="string">&quot;Closing &quot;</span> + socketInput.getClass().getName());</span><br><span class="line">    socketInput.close(); <span class="comment">// Releases blocked thread</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    print(<span class="string">&quot;Closing &quot;</span> + System.in.getClass().getName());</span><br><span class="line">    System.in.close(); <span class="comment">// Releases blocked thread</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (85% match)</span></span><br><span class="line"><span class="comment">Waiting for read():</span></span><br><span class="line"><span class="comment">Waiting for read():</span></span><br><span class="line"><span class="comment">Shutting down all threads</span></span><br><span class="line"><span class="comment">Closing java.net.SocketInputStream</span></span><br><span class="line"><span class="comment">Interrupted from blocked I/O</span></span><br><span class="line"><span class="comment">Exiting IOBlocked.run()</span></span><br><span class="line"><span class="comment">Closing java.io.BufferedInputStream</span></span><br><span class="line"><span class="comment">Exiting IOBlocked.run()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在shutdownNow()被调用之后，以及在两个输入流撒谎给你调用close()之前的延迟强调的是一旦底层资源被关闭，任务将接触阻塞。interrupt()看起来发生在关闭Socket而不是关闭System.in的时刻。这是由18章介绍的各种nio类提供了更人性化的I&#x2F;O中断。被阻塞的nio通道会自动地响应中断。</p>
</li>
<li><p>如你所见，&#x3D;&#x3D;还可以通过关闭底层资源以释放锁&#x3D;&#x3D;，尽管和种做法一般不是必需地。注意使用execute()来启动两个任务，并调用e.shutdownNow()将可以很容易地终止所有事物，而对于捕获上面实例中地Future，只有将中断发送给一个线程，同时不发送给另一个线程时才是必需地。</p>
</li>
</ul>
</blockquote>
<p><strong>被互斥所阻塞</strong></p>
<blockquote>
<ul>
<li>就像在Interrupting.java中看到地，如果你尝试着在一个对象上调用其synchronized方法，而这个对象地锁已经被其他任务所获得，那么调用任务将被挂起（阻塞），直至这个锁可获得。下面的示例说明了同一个互斥可以如何能被同一个任务多次获得：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiLock</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      print(<span class="string">&quot;f1() calling f2() with count &quot;</span> + count);</span><br><span class="line">      f2(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      print(<span class="string">&quot;f2() calling f1() with count &quot;</span> + count);</span><br><span class="line">      f1(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MultiLock</span> <span class="variable">multiLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiLock</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        multiLock.f1(<span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 9</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 8</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 7</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 6</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 5</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 4</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 3</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 2</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 1</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 0</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在main()中创建了一个调用f()地Thread,然后f1()和f2()互相调用直至count变为0.由于这个任务已经在第一个对f1()的调用中获得了multiLock对象锁，因此同一个任务将在对f2()的调用中再次获取这个锁，依次类推，这么做是有意义的，因为一个任务应该能够调用在同一个对象中的其他的synchronized方法，而这个任务已经持有锁了。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>就像前面在不可中断的I&#x2F;O中所观察到的那样，无论在任何时刻，只要任务以不可中断的方式被阻塞，那么都有潜在的会锁柱程序的可能。&#x3D;&#x3D;Java SE5并发库中添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力，这与在synchronized方法或临界区上阻塞的任务完全不同&#x3D;&#x3D;。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockedMutex</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BlockedMutex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Acquire it right away, to demonstrate interruption</span></span><br><span class="line">    <span class="comment">// of a task blocked on a ReentrantLock:</span></span><br><span class="line">    lock.lock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// This will never be available to a second task</span></span><br><span class="line">      lock.lockInterruptibly(); <span class="comment">// Special call  用来获取锁定，</span></span><br><span class="line">      print(<span class="string">&quot;lock acquired in f()&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Interrupted from lock acquisition in f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blocked2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="type">BlockedMutex</span> <span class="variable">blocked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockedMutex</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Waiting for f() in BlockedMutex&quot;</span>);</span><br><span class="line">    blocked.f();</span><br><span class="line">    print(<span class="string">&quot;Broken out of blocked call&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interrupting2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Blocked2</span>());</span><br><span class="line">    t.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Issuing t.interrupt()&quot;</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Waiting for f() in BlockedMutex</span></span><br><span class="line"><span class="comment">Issuing t.interrupt()</span></span><br><span class="line"><span class="comment">Interrupted from lock acquisition in f()</span></span><br><span class="line"><span class="comment">Broken out of blocked call</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>BlockedMutex类有一个构造器，它要获取所拆挂那件对象上自身的Lock，并且从不释放这个锁。出于这个原因，如果你试图从第二个任务中调用f()（不同于创建这个BlockedMutex的任务），那么将会总是因Mutex不可获得而被阻塞。在Blocked2中，run()方法总是总是在调用blocked.f()的地方停止。当运行这个程序时，你将会看到，与I&#x2F;O调用不同，interrupt()可以打破被互斥所阻塞的调用。</li>
</ul>
</blockquote>
<p><strong>21.4.4 检查中断</strong></p>
<blockquote>
<ul>
<li>注意：当你在线程上调用interrupt()时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时（如前面所见，除了不可中断的I&#x2F;O或被阻塞的synchronized方法之外，在其余的例外情况下，你无可事事）。因此，如果你调用interrupt()已停止某个任务，那么在run()循环碰巧没有产生任何阻塞调用的情况下，你的任务将需要第二种方式来退出。</li>
<li>这种机会是由中断状态来表示的，其状态可以通过调用interrupted()来设置。你可以通过调用interrupted来检查中断状态，这不仅可以告诉你interrupt()是否被调用过，而且还可以清除中断状态。清除中断状态可以确保并发结构不会就，某个任务被中断这个问题通知你两次，你可以经由单一的InterruptedException或单一的成功的Thread.interrupted()测试来得到这种通知。如果想要再次检查以了解是否被中断，则可以在调用Thread.interrupted()时将结果存储起来，</li>
</ul>
</blockquote>
<h3 id="21-5-线程之间的协作"><a href="#21-5-线程之间的协作" class="headerlink" title="21.5 线程之间的协作"></a>21.5 线程之间的协作</h3><blockquote>
<ul>
<li>正如前面所见到的，当使用线程来同时运行多个任务时，可以通过使用锁（互斥）来同步两个任务的行为，从而使得一个任务不会干涉另一个任务的资源。</li>
<li>接下来时&#x3D;&#x3D;学习如何使任务彼此之间可以协作，以使得任务可以一起取解决某个问题&#x3D;&#x3D;。现在的问题不是彼此之间的干涉，而是彼此之间的协调，因为这类问题中，某些部分必须在其他部分被解决之前解决。在这些任务中，某些可以并行执行，但是某些步骤需要所有的任务都结束之后才能开动。</li>
<li>当任务协作时，关键问题是这些任务之间的握手。为了实现这种握手，我们使用了相同的基础特性：互斥。在这种情况下，互斥能够确保只有一个任务可以响应某个信号。，这样就可以根除任何可能的竞争条件。在互斥之上，我们为任务添加了一种途径，可以将自身挂起，直至某些外部条件发生变化，表示是时候让这个任务向前开动了为止。</li>
<li>在本节，我们将浏览任务间的握手，这种握手可以通过Object的方法wait()和notify()来安全地实现。Java SE5并发类库换提供了具有await()和signal()方法的Condition对象。</li>
</ul>
</blockquote>
<p><strong>21.5.1 wait()与notifyAll()</strong></p>
<blockquote>
<ul>
<li><p>wait()使你可以等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。通常，这种条件由另一个任务来改变。因此wait()会在等待外部世界产生变化的时候将任务挂起，并且只有在notify()或notifyAll()发生时，即表示发生了某些感兴趣的事物。这个任务才会被唤醒并去检查所产生的变化。因此，wait()提供了一种在任务之间对活动同步的方式。</p>
</li>
<li><p>&#x3D;&#x3D;调用sleep()的时候并没有被释放，调用yield()也属于这种情况&#x3D;&#x3D;，理解这一点很重要。另一方面，当一个任务在方法里遇到了&#x3D;&#x3D;对wait()的调用的时候，线程的执行被挂起，对象上的锁被释放&#x3D;&#x3D;。因为wait()将释放锁，这就意味着另一个任务可以获得这个锁，因此在该对象（现在是未锁顶的）中的其他synchronized方法可以在wait()期间被调用。这一点至关重要，因为这些其他的方法通常将会产生改变，而这种改变正是使被挂起的任务重新唤醒所感兴趣的变化。因此，&#x3D;&#x3D;当你调用wait()时，就是在声明：“我已经刚刚做完能做的所有事情，因此我要在这里等待，但是我希望其他的synchronized操作在条件适合的情况下能够执行。”&#x3D;&#x3D;</p>
</li>
<li><p>有两种形式的wait().第一种版本接受毫秒数作为参数，含义与sleep()方法里参数的意思相同，都是指“在此期间暂停”，但是与sleep()不同的是，对于wait()而言：</p>
<ol>
<li>在wait()期间对象锁是释放的。</li>
<li>可以通过notify(),notifyAll(),或者令时间到期，从wait()中恢复执行。</li>
</ol>
</li>
<li><p>第二种，也是更常用形式的wait()不接受任何参数。这种wait()将无限等待下去，直到线程接受到notify()或者notifyAll()消息</p>
</li>
<li><p>这些方法是基类Object的一部分。因为这些方法操作的锁也是所有对象的一部分，所以，你可以把wait()放进任何同步控制方法里，而不用考虑这个类是继承自Thread还是实现了Runnable接口。实际上，只能在同步控制方法或同步控制块里调用wait()，notify(),notifyAll()（因为不用操作锁，所以sleep()可以在非同步控制方法里调用）。如果在非同步控制方法里调用这些方法，程序能通过编译，但运行的时候，将得到IllegalMonitorStateException异常，并伴随着一些含糊的消息，比如“当前线程不是拥有者”。消息的意思是，调用这个方法钱必需拥有获取（获取）对象的锁。</p>
</li>
<li><p>可以让另一个对象执行某种操作以维护其自己的锁。要这么做的话，必需首先得到对象的锁。如果要向对象x发送notifyAll()，那么就必须在能够取得x的锁的同步控制快中这么做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(x)&#123;</span><br><span class="line">	x.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面有一个讲解的示例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">waxOn</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waxed</span><span class="params">()</span> &#123;</span><br><span class="line">    waxOn = <span class="literal">true</span>; <span class="comment">// Ready to buff</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buffed</span><span class="params">()</span> &#123;</span><br><span class="line">    waxOn = <span class="literal">false</span>; <span class="comment">// Ready for another coat of wax</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForWaxing</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">while</span>(waxOn == <span class="literal">false</span>)</span><br><span class="line">      wait();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForBuffing</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">while</span>(waxOn == <span class="literal">true</span>)</span><br><span class="line">      wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOn</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOn</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        printnb(<span class="string">&quot;Wax On! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.waxed();</span><br><span class="line">        car.waitForBuffing();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax On task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOff</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        car.waitForWaxing();</span><br><span class="line">        printnb(<span class="string">&quot;Wax Off! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.buffed();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax Off task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaxOMatic</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOff</span>(car));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOn</span>(car));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// Run for a while...</span></span><br><span class="line">    exec.shutdownNow(); <span class="comment">// Interrupt all tasks</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (95% match)</span></span><br><span class="line"><span class="comment">Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax On task</span></span><br><span class="line"><span class="comment">Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax Off task</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>前面的示例强调你必须用一个检查感兴趣的条件的while循环包围wait()。这很重要，因为：<ul>
<li>你可能有多个任务出于相同的原因在等待同一个锁，而第一个唤醒任务可能会改变这种状况（即使你没有这么做，有人也会通过继承你的类去这么做）。如果属于这种情况，那么这个任务应该被再次挂起，直至感兴趣的条件发生变化。</li>
<li>在这个任务从其wait()中被唤醒的时刻，有可能会有某个其他的任务已经做出了改变，从而使得这个任务在此时不能执行，或者执行其操作已显得无关紧要。此时，应该通过再次调用wait()来将其重新挂起。</li>
<li>也有可能某些任务出于不同的原因在等待你的对象上的锁（在这种情况下必须使用notifyAll()）。在这种情况下，你需要检查是否已经由正确的原因唤醒，如果不是，就再次调用wait()</li>
</ul>
</li>
<li>因此，其本质就是要检查所感兴趣的特定条件，并在条件不满足的情况下返回到wait()中，惯用的方法就是使用while来编写这种代码。</li>
</ul>
</blockquote>
<p><strong>错失的信号</strong></p>
<blockquote>
<p>当两个线程使用notify()&#x2F;wait()或notifyAll()&#x2F;wait()进行协作时，有可能会错过某个信号。假设T1是通知T2的线程，而这两个线程都是使用下面（有缺陷的）方式实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T1:</span><br><span class="line"><span class="keyword">synchronized</span>(shareMonitor)&#123;</span><br><span class="line">	&lt;setup condition <span class="keyword">for</span> T2&gt;</span><br><span class="line">	shareMonitor.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2:</span><br><span class="line"><span class="keyword">while</span>(someCondition)&#123;</span><br><span class="line">	<span class="comment">//Point1</span></span><br><span class="line">	<span class="keyword">synchronized</span>(sharedMonitor)&#123;</span><br><span class="line">		sharedMonitor.wait();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><setup condition for T2>是防止T2调用wait()的一个操作，当然前提是T2还没有调用wait()。</li>
<li>假设T2对someCondition求值并发现其为true.在Point1里，线程调度器可能切换到了T1,而T1将执行其设置，然后调用notify()。当T2继续执行时，此时对于T2来说，时机已经太晚了，以至于不能意识到条件已经发生了变化，因此会盲目进入到wait()。此时notify()将错失，而T2也将无限的等待这个已经发送过的信号，从而产生死锁。</li>
<li>该问题的解决方案是防止在someCondition变量上产生竞争条件。下面是T2正确的执行方式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(sharedMonitor)&#123;</span><br><span class="line">	<span class="keyword">while</span>(someCondition)&#123;</span><br><span class="line">		sharedMonitor.wait();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在，如果T1首先执行，当控制返回T2时，它将发现条件发生了变化，从而不会进入wait().反过来，如果T2首先执行，那它将进入wait(),并且稍后会有T1唤醒，因此，信号不会错失。</li>
</ul>
</blockquote>
<p><strong>21.5.2 notify()与notifyAll()</strong></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;因为在技术上，可能有多个任务在单个Car对象上处于wait()状态，因此调用notifyAll()比只调用notify()要更安全&#x3D;&#x3D;。但是，上面程序的结构只会有一个任务实际处于wait()状态，因此你可以使用notify()来代替notifyAll()。</li>
<li>使用notify()而不是notifyAll()是一种优化，使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒，因此如果你希望用notify()，就必须保证唤醒的是恰当的任务。另外，为了使用notify()，所有任务必须等待相同的条件，因为如果你有多个任务在等待不同的条件，那么你就不会指代是否唤醒了恰当的任务。如果使用notify()，当条件发生变化时，必须只有一个任务从中受益。最后，这些限制对所有可能存在的子类都必须总是起作用的。如果这些规则中有任何一条不满足，那么你就必须使用notifyAll()而不是notify()。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Blocker</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitingCall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">          <span class="comment">//这里会有多个任务被挂起。</span></span><br><span class="line">        wait();</span><br><span class="line">        System.out.print(Thread.currentThread() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// OK to exit this way</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">prod</span><span class="params">()</span> &#123; notify(); &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">prodAll</span><span class="params">()</span> &#123; notifyAll(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Blocker</span> <span class="variable">blocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blocker</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; blocker.waitingCall(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="comment">// A separate Blocker object:</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Blocker</span> <span class="variable">blocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blocker</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; blocker.waitingCall(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyVsNotifyAll</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">Task2</span>());</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">prod</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prod) &#123;</span><br><span class="line">          System.out.print(<span class="string">&quot;\nnotify() &quot;</span>);</span><br><span class="line">          Task.blocker.prod();</span><br><span class="line">          prod = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.print(<span class="string">&quot;\nnotifyAll() &quot;</span>);</span><br><span class="line">          Task.blocker.prodAll();</span><br><span class="line">          prod = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">400</span>, <span class="number">400</span>); <span class="comment">// Run every .4 second</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// Run for a while...</span></span><br><span class="line">    timer.cancel();</span><br><span class="line">    System.out.println(<span class="string">&quot;\nTimer canceled&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;Task2.blocker.prodAll() &quot;</span>);</span><br><span class="line">    Task2.blocker.prodAll();</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\nShutting down&quot;</span>);</span><br><span class="line">    exec.shutdownNow(); <span class="comment">// Interrupt all tasks</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</span></span><br><span class="line"><span class="comment">Timer canceled</span></span><br><span class="line"><span class="comment">Task2.blocker.prodAll() Thread[pool-1-thread-6,5,main]</span></span><br><span class="line"><span class="comment">Shutting down</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>浏览Blocker中的prod()和prodAll()，就会发现这是有意义的。这些方法是synchronized的，这意味着他们将获取自身的锁，因此当它们调用notify()或notifyAll()时，只在这个锁上调用是符合逻辑的——因此，将脂环星在等待这个特定锁的任务。</li>
</ul>
</blockquote>
<p><strong>21.5.3 生产者与消费者</strong></p>
<blockquote>
<ul>
<li>有一个饭店，他有一个厨师和一个服务员。这个服务员必须等待厨师准备好膳食。当厨师准备好时，他会通知服务员，之后服务员上菜，然后返回继续等待。这是一个任务协作的示例：厨师代表生产者，而服务员代表消费者。两个任务必须在膳食被生产和消费时进行握手，而系统必须以有序的方式关闭。下面是对这个叙述建模的代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> orderNum;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Meal</span><span class="params">(<span class="type">int</span> orderNum)</span> &#123; <span class="built_in">this</span>.orderNum = orderNum; &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Meal &quot;</span> + orderNum; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitPerson</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaitPerson</span><span class="params">(Restaurant r)</span> &#123; restaurant = r; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(restaurant.meal == <span class="literal">null</span>)</span><br><span class="line">            wait(); <span class="comment">// ... for the chef to produce a meal</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">&quot;Waitperson got &quot;</span> + restaurant.meal);</span><br><span class="line">        <span class="keyword">synchronized</span>(restaurant.chef) &#123;</span><br><span class="line">          restaurant.meal = <span class="literal">null</span>;</span><br><span class="line">          restaurant.chef.notifyAll(); <span class="comment">// Ready for another</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;WaitPerson interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chef</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Chef</span><span class="params">(Restaurant r)</span> &#123; restaurant = r; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(restaurant.meal != <span class="literal">null</span>)</span><br><span class="line">            wait(); <span class="comment">// ... for the meal to be taken</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++count == <span class="number">10</span>) &#123;</span><br><span class="line">          print(<span class="string">&quot;Out of food, closing&quot;</span>);</span><br><span class="line">          restaurant.exec.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">        printnb(<span class="string">&quot;Order up! &quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(restaurant.waitPerson) &#123;</span><br><span class="line">          restaurant.meal = <span class="keyword">new</span> <span class="title class_">Meal</span>(count);</span><br><span class="line">          restaurant.waitPerson.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Chef interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line">  Meal meal;</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">  <span class="type">WaitPerson</span> <span class="variable">waitPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitPerson</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="type">Chef</span> <span class="variable">chef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chef</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Restaurant</span><span class="params">()</span> &#123;</span><br><span class="line">    exec.execute(chef);</span><br><span class="line">    exec.execute(waitPerson);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Restaurant</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 1</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 2</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 3</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 4</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 5</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 6</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 7</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 8</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 9</span></span><br><span class="line"><span class="comment">Out of food, closing</span></span><br><span class="line"><span class="comment">WaitPerson interrupted</span></span><br><span class="line"><span class="comment">Order up! Chef interrupted</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在前面的示例中，对于一个任务而言，只有一个单一的地点用于存放对象，从而使得另一个任务稍后可以使用这个对象。但是，在典型的生产者-消费者实现中，应使用先进先出队列来存储被生产和消费的对象。</li>
</ul>
</blockquote>
<p><strong>使用显式的Lock和Condition对象</strong></p>
<blockquote>
<ul>
<li>在Java SE5的java.util.concurrent类库中还有额外的显式工具可以用来重写WaxOMatic.java。使用互斥并允许任务挂起的基本类是Condition,你可以通过在Condition上调用await()来挂起一个任务。当外部条件发生变化，意味着某个任务应该继续执行时，你可以通过调用signal()来同这个任务，从而唤醒一个任务，或者调用signalAll()来唤醒所有在这个Condition上被其自身挂起的任务（与使用notifyAll相比，signallAll是更安全的方式）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">waxOn</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waxed</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      waxOn = <span class="literal">true</span>; <span class="comment">// Ready to buff</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buffed</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      waxOn = <span class="literal">false</span>; <span class="comment">// Ready for another coat of wax</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitForWaxing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(waxOn == <span class="literal">false</span>)</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitForBuffing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(waxOn == <span class="literal">true</span>)</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOn</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOn</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        printnb(<span class="string">&quot;Wax On! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.waxed();</span><br><span class="line">        car.waitForBuffing();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax On task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOff</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        car.waitForWaxing();</span><br><span class="line">        printnb(<span class="string">&quot;Wax Off! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.buffed();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax Off task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaxOMatic2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOff</span>(car));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOn</span>(car));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax Off task</span></span><br><span class="line"><span class="comment">Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax On task</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在Car的构造器中，单个的Lock将产生一个Condition对象，这个对象被用来管理任务间的通信。但是，这个Condition对象不包含任何有关处理状态的信息，因此你需要管理额外的表示处理状态的信息，即boolean wanOn.</li>
<li>每个对lock()的调用都必须紧跟一个try-finally子句，用来保证在所有情况下都可以释放锁。在使用内建版本时，任务在可以调用await(),signal()或signalAll()之前，必须拥有这个锁。</li>
</ul>
</blockquote>
<p><strong>21.5.4 生产者-消费者与队列</strong></p>
<blockquote>
<ul>
<li>wait()与notifyAll()方法以一种非常低级的方式解决了任务互操作问题，即每次交互时都握手。在许多情况下，可以瞄向更高的抽象级别，&#x3D;&#x3D;使用同步队列来解决任务协作问题，同步队列在任何时刻都只允许一个任务插入或移除元素。&#x3D;&#x3D;在java.util.concurrent.BlockingQueue接口中提供了这个队列，这个接口有大量的标准实现。通常可以使用LinkedBlockingQueue,它是一个无界队列，还可以使用ArrayBlockingQueue,它具有固定的尺寸，因此你可以在它被阻塞之前，向其中放置有限数量的元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LiftOffRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> BlockingQueue&lt;LiftOff&gt; rockets;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">LiftOffRunner</span><span class="params">(BlockingQueue&lt;LiftOff&gt; queue)</span> &#123;</span><br><span class="line">    rockets = queue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(LiftOff lo)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rockets.put(lo);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Interrupted during put()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="type">LiftOff</span> <span class="variable">rocket</span> <span class="operator">=</span> rockets.take();</span><br><span class="line">        rocket.run(); <span class="comment">// Use this thread</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Waking from take()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Exiting LiftOffRunner&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBlockingQueues</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getkey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Compensate for Windows/Linux difference in the</span></span><br><span class="line">      <span class="comment">// length of the result produced by the Enter key:</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)).readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(java.io.IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getkey</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    print(message);</span><br><span class="line">    getkey();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">  <span class="title function_">test</span><span class="params">(String msg, BlockingQueue&lt;LiftOff&gt; queue)</span> &#123;</span><br><span class="line">    print(msg);</span><br><span class="line">    <span class="type">LiftOffRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiftOffRunner</span>(queue);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runner);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      runner.add(<span class="keyword">new</span> <span class="title class_">LiftOff</span>(<span class="number">5</span>));</span><br><span class="line">    getkey(<span class="string">&quot;Press &#x27;Enter&#x27; (&quot;</span> + msg + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">    print(<span class="string">&quot;Finished &quot;</span> + msg + <span class="string">&quot; test&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="string">&quot;LinkedBlockingQueue&quot;</span>, <span class="comment">// Unlimited size</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;LiftOff&gt;());</span><br><span class="line">    test(<span class="string">&quot;ArrayBlockingQueue&quot;</span>, <span class="comment">// Fixed size</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;LiftOff&gt;(<span class="number">3</span>));</span><br><span class="line">    test(<span class="string">&quot;SynchronousQueue&quot;</span>, <span class="comment">// Size of 1</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;LiftOff&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>各个人物由main()放置到了BlockingQueue中，并且由LiftOffRunner从BlockingQueue中取出。注意，LiftOffRunner可以忽略同步问题，因为它们已经由BlockingQueue解决了。</li>
</ul>
</blockquote>
<p><strong>21.5.5 任务间使用管道进行输入&#x2F;输出</strong></p>
<blockquote>
<ul>
<li>通过输入&#x2F;输出在线程间进行通信通常很有用。提供县城额功能的类库以“管道”的形式对线程间的输入&#x2F;输出提供了支持。它们在Java输入&#x2F;输出类库中的对应物就是PipedWriter类（允许任务向管道写）和PipedReader类（允许不同任务从同一个管道中读取）。管道基本上是一个阻塞队列，存在于多个引入BlockingQueue之前的Java版本中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="type">PipedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">  <span class="keyword">public</span> PipedWriter <span class="title function_">getPipedWriter</span><span class="params">()</span> &#123; <span class="keyword">return</span> out; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">          out.write(c);</span><br><span class="line">          TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      print(e + <span class="string">&quot; Sender write exception&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(e + <span class="string">&quot; Sender sleep interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> PipedReader in;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Receiver</span><span class="params">(Sender sender)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    in = <span class="keyword">new</span> <span class="title class_">PipedReader</span>(sender.getPipedWriter());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// Blocks until characters are there:</span></span><br><span class="line">        printnb(<span class="string">&quot;Read: &quot;</span> + (<span class="type">char</span>)in.read() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      print(e + <span class="string">&quot; Receiver read exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipedIO</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>();</span><br><span class="line">    <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>(sender);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(sender);</span><br><span class="line">    exec.execute(receiver);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (65% match)</span></span><br><span class="line"><span class="comment">Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read: G, Read: H, Read: I, Read: J, Read: K, Read: L, Read: M, java.lang.InterruptedException: sleep interrupted Sender sleep interrupted</span></span><br><span class="line"><span class="comment">java.io.InterruptedIOException Receiver read exception</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Sender和Receiver代表了需要互相通信两个任务，Sender创建了一个PipedWriter,它是一个单独的对象。但是对于Receiver,PipedReader的建立必须在构造器中与一个PipedWriter相关联。Sender把数据放进Writer。</li>
<li>在shutdownNow()被调用时，可以看到PipedReader与普通I&#x2F;O之间最重要的差异——PipedReader是可中断的。如果你将将in.read()调用修改为System.in.read()，那么interrupt()将不能打断read()调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CharQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Character&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">CharQueue</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharQueue</span>();</span><br><span class="line">    <span class="keyword">public</span> CharQueue <span class="title function_">getQueue</span><span class="params">()</span> &#123; <span class="keyword">return</span> out; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                    out.put(c);</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e + <span class="string">&quot; Sender interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CharQueue in;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Receiver</span><span class="params">(Sender sender)</span> &#123; in = sender.getQueue(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// Blocks until characters are there:</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Read: &quot;</span> + in.take() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e + <span class="string">&quot; Reader interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E30_SendReceive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>();</span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>(sender);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(sender);</span><br><span class="line">        exec.execute(receiver);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read:</span></span><br><span class="line"><span class="comment">G, Read: H, Read: I, Read: J, Read: K, Read: L, Read: M,</span></span><br><span class="line"><span class="comment">Read: N, Read: O, Read: P, Read: Q,</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException Reader interrupted</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException: sleep interrupted Sender</span></span><br><span class="line"><span class="comment">interrupted</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="21-6-死锁"><a href="#21-6-死锁" class="headerlink" title="21.6 死锁"></a>21.6 死锁</h3><blockquote>
<ul>
<li>哲学家就餐问题。</li>
<li>当下列四个条件满足时，就会产生死锁：<ul>
<li>互斥条件。任务使用的资源中至少有一个是不能共享的。这里一根筷子一次只能欸一个哲学家使用。</li>
<li>至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源。ye就是说，要发生死锁，哲学家必须拿着一根筷子并且等待另一根</li>
<li>资源不能被任务抢占，任务必须把资源释放当作普通事件。哲学家很有礼貌，它们不会从其他哲学家那里抢筷子</li>
<li>必须有循环等待，这时一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，直到有一个任务在等待第一个任务所持有的资源，使得大家都被锁住。因为哲学家们默认都是先得到右边的筷子，然后得到左边的筷子，所以发生了循环等待。</li>
</ul>
</li>
<li>打破死锁的方法就是消除存在的循环等待问题。然而如果让最后一个哲学家是先拿左边的筷子，后拿右边的筷子就可以消除。</li>
</ul>
</blockquote>
<h3 id="21-7-新类库中的构件"><a href="#21-7-新类库中的构件" class="headerlink" title="21.7 新类库中的构件"></a>21.7 新类库中的构件</h3><blockquote>
<ul>
<li>Java SE5的java.util.concurrent引入了大量设计来解决并发问题的新类。</li>
</ul>
</blockquote>
<p><strong>21.7.1 CountDownLatch</strong></p>
<blockquote>
<ul>
<li>他被用用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。</li>
<li>可以向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()的方法都将阻塞，直至这个计数值到达0.其他任务在结束其工作时，可以在该对象上调用countDown()来减少这个计数值。&#x3D;&#x3D;CountDownLatch被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用CyclicBarrier.&#x3D;&#x3D;</li>
<li>调用countDown()的任务在产生这个调用时并没有被阻塞，只有对awit()的调用会被阻塞，直至计数值到达0.</li>
<li>CountDownLatch的典型用法是将一个程序分为n个互相独立的可解决任务，并创建值为0的CountDownLatch。当每个任务完成时，都会在这个锁存器上调用countDown()。等待问题被解决的任务在这个锁存器上调用await()，将它们自己拦住，直至锁存器计数结束。下面是演示这种奇数的一个框架示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskPortion</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> counter++;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">  TaskPortion(CountDownLatch latch) &#123;</span><br><span class="line">    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork();</span><br><span class="line">      latch.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">      <span class="comment">// Acceptable way to exit</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">2000</span>));</span><br><span class="line">    print(<span class="built_in">this</span> + <span class="string">&quot;completed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%1$-3d &quot;</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Waits on the CountDownLatch:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitingTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> counter++;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">  WaitingTask(CountDownLatch latch) &#123;</span><br><span class="line">    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      latch.await();</span><br><span class="line">      print(<span class="string">&quot;Latch barrier passed for &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">      print(<span class="built_in">this</span> + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;WaitingTask %1$-3d &quot;</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// All must share a single CountDownLatch object:</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">WaitingTask</span>(latch));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">TaskPortion</span>(latch));</span><br><span class="line">    print(<span class="string">&quot;Launched all tasks&quot;</span>);</span><br><span class="line">    exec.shutdown(); <span class="comment">// Quit when all tasks complete</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* (Execute to see output) */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>TaskPortion将随机地休眠一段时间，以模拟这部分工作地完成，而WaitingTask表示系统中必须等待地部分，它要等待到问题地初始部分完成为止。所有任务都使用了在main()种定义地同一个单一地CountDownLatch。</li>
</ul>
</blockquote>
<p><strong>21.7.2 CyclicBarrier</strong></p>
<blockquote>
<ul>
<li>CyclicBarrier适用于这样地情况：你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成（看起来有些像join()）。它使得所有的并行任务都将在栅栏处列队，因此可以一致地向前移动。&#x3D;&#x3D;这非常像CountDownLatch,只是CountDownLatch是只触发一次地事件，而CyclicBarrier可以多次重用。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<p><strong>21.7.3 DelayQueue</strong></p>
<blockquote>
<ul>
<li>这是一个无界的BlockingQueue,用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素，并且poll()将返回null(正因为这样，你不能将null放置到这种队列中)</li>
<li>下面是一个示例，其中的Delayed对象自身就是任务，而DelayedTaskConsumer将最紧急的任务（到期时间最长的任务）从队列中取出，然乎运行它。注意，&#x3D;&#x3D;这样DelayQueue就成为了优先级队列的一种变体。&#x3D;&#x3D;</li>
<li>从输出的顺序可以看到，任务创建的顺序对执行顺序没有任何影响，任务是按照所期望的延迟顺序执行的。</li>
</ul>
</blockquote>
<p><strong>21.7.4 PriorityBlockingQueue</strong></p>
<blockquote>
<ul>
<li>这是一个很基础的优先队列，它具有可阻塞的读取操作。下面是一个示例，其中在优先级队列中的对象是按照优先级顺序从队列中出现的任务。PrioritedTask被赋予了一个优先级数字，以此来提供这种顺序。</li>
<li>与前一个示例相同，PrioritizedTask对象的创建序列被记录在sequence List中，用于和实际执行顺序比较。run()方法将休眠一小段时间，然后大一i你对象信息，而EndSentinel提供了和前面相同的功能，要确保它是队列中最后一个对象。而且这种队列提供了同步的功能。因此不需要有显式的同步。</li>
</ul>
</blockquote>
<p><strong>21.7.6 Semaphore</strong></p>
<blockquote>
<ul>
<li>正常的锁（来自concurrent.locks或内建的synchronized锁）在任何时刻都只允许一个任务访问一项资源，而计数信号量允许n个任务同时访问这个资源。你还可以将信号量看作是在向外分发使用资源的“许可证”，尽管实际上没有使用任何许可证对象。</li>
<li>作为一个示例，请考虑对象池的概念，它管理着数量有限的对象，当要使用对象时可以签出它们，而在用户使用完毕时，可以将它们签回。这种功能可以封装到一个泛型类中。</li>
</ul>
</blockquote>
<p><strong>21.7.7 Exchanger</strong></p>
<blockquote>
<ul>
<li>Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，他们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。Exchanger的典型应用场景是：一个任务在创建对象，这些对象的而生产代价很高昂，二零一个任务在消费这些对象。通过这种方式，可以有更多的对象在被创建的同时被消费。</li>
</ul>
</blockquote>
<h3 id="21-8-仿真"><a href="#21-8-仿真" class="headerlink" title="21.8 仿真"></a>21.8 仿真</h3><h3 id="21-9-性能调优"><a href="#21-9-性能调优" class="headerlink" title="21.9 性能调优"></a>21.9 性能调优</h3><blockquote>
<ul>
<li>在Java SE的java.util.concurrent类库中存在着数量庞大的用于性能提高的类。当你细读concurrent类库时就会发现很难辨认哪些类适用于常规应用（例如BlockingQueue）,而哪些类只适用于提高性能。</li>
</ul>
</blockquote>
<p><strong>21.9.1 比较各类互斥技术</strong></p>
<blockquote>
<ul>
<li>既然Java包括老式的synchronized关键字和Java SE5中新的Lock和Atomic类，那么比较这些不同的方式，更多地理解它们各自的价值和适用范围，就会显得很有意义。</li>
<li>适用Lock通常会比适用synchronized要高效的多，而且synchronized的开销看起来变化范围更大，而Lock相对比较一致。但是通常，为了代码阅读的高效性，适用synchronized的方式更多一点。而Lock和Atomic则适用的更少。</li>
</ul>
</blockquote>
<p><strong>21.9.2 免锁容器</strong></p>
<blockquote>
<ul>
<li><p>容器是所有编程中的基础工具，这其中自然也包括并发编程。处于这个原因，像Vector和Hashtable这类早期容器具有许多synchronized方法，当他们用于非多线程的应用程序中时，便会导致不可接受的开销。</p>
</li>
<li><p>Java SE5特别添加了新的容器，通过使用更灵巧的技术来消除加锁，从而提高线程安全的性能。</p>
</li>
<li><p>&#x3D;&#x3D;这些免锁容器背后的通用策略是&#x3D;&#x3D;：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。修改是在容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到 这个修改了。</p>
</li>
<li><p>在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而原数组将保留在原地，使得赋值的数组在被修改时，读取操作可以安全地执行。当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改。</p>
</li>
<li><p>CopyOnWriteArrayList的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationWxception，因此不必编写特殊的代码去防范这种异常，就想你之前必须坐的那样。</p>
</li>
<li><p>CopyOnWriteArraySet将使用CopyOnWriteArrayList来实现其免锁行为。</p>
</li>
<li><p>ConcurrentHashMap和ConcurrentLinkedQueue使用了类似的技术，允许并发的读取和写入，但是容器中只有部分内容而不是整个容器可以被复制和修改。然而，任何修改在完成之前，读取者仍旧不能看到它们。ConcurrentHashMap不会抛出ConcurrentModificationWxception。</p>
</li>
</ul>
</blockquote>
<p><strong>乐观锁</strong></p>
<blockquote>
<p>只要你主要是从免锁容器中读取，那么它就会比其synchronized对应物快许多，因为获取和释放锁的开销被省掉了。如果需要向免锁容器中执行少量写入，那么情况也仍旧如此。</p>
</blockquote>
<p><strong>比较各种Map实现</strong></p>
<blockquote>
<ul>
<li>我们可以使用相同的框架来得到synchronizedHashMap和ConcurrentHashMap在性能方面的比较结果。向ConcurrentHashMap添加写入者的影响甚至还不如CopyOnWriteArrayList明显，这是因为ConcurrentHashMap使用了一种不同的技术，它可以明显地最小化写入所造成的影响。</li>
</ul>
</blockquote>
<p><strong>21.9.3 乐观加锁</strong></p>
<blockquote>
<p>在正常情况下将使用互斥（synchronized或Lock）来放置多个任务同时修改一个对象，但是这里我们是乐观的，因为我们保持数据为未锁定状态，并希望没有任何其他任务插入修改它。所有这些又都是以性能的名义执行的——通过使用Atomic来替代synchronized或Lock,可以获得性能上的好处。</p>
</blockquote>
<p><strong>21.9.4 ReadWriteLock</strong></p>
<blockquote>
<ul>
<li>ReadWriteLock对向数据结构相对不频繁的写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为主。</li>
<li>ReadWriteLock是否能够提高程序的性能是完全不可确定的，它取决于诸如数据被读取的频率与被修改的频率相比较的结果，读取和写入操作的时间，有多少线程竞争以及是否在都哦系处理机器上运行等因素。最终，唯一可以了解是否能带来好处就是通过做实验。</li>
</ul>
</blockquote>
<h3 id="21-10-活动对象"><a href="#21-10-活动对象" class="headerlink" title="21.10 活动对象"></a>21.10 活动对象</h3><blockquote>
<p>有一种可替换的方式被称为活动对象或行动者。之所以称这些对象是活动的，是因为每个对象都维护者它自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中的一个。因此有了活动对象，我们就可以串行化消息而不是方法，这意味着不再需要防备一个任务在其循环的中间被中断这种问题了。</p>
</blockquote>
<h3 id="21-11-总结"><a href="#21-11-总结" class="headerlink" title="21.11 总结"></a>21.11 总结</h3><blockquote>
<ul>
<li>线程的一个额外好处是它们提供了轻量级的执行上下文切换（大约100条指令），而不是重量级的进程上下文切换（要上千条指令）。因为一个给定进程内的所有进程共享相同的内存空间，轻量级的上下文切换只是改变了程序的执行序列和局部变量。进程切换（重量级的上下文切换）必须改变所有内存空间。</li>
<li>多线程的主要缺陷有：<ul>
<li>等待共享资源的时候性能低</li>
<li>需要处理线程的额外CPU花费</li>
<li>糟糕的程序设计导致不必要的复杂度</li>
<li>有可能产生一些病态行为，如饿死，竞争，死锁和活锁（多个运行各自任务的线程使得整体无法完成）</li>
<li>不同平台导致的不一致性</li>
</ul>
</li>
<li>因为多个线程可能共享一个资源，比如一个对象的内存，而且你必须确定多个线程不会同时读取和改变这个资源，这就是线程产生的最大难题。</li>
</ul>
</blockquote>
<blockquote>
<p>创建Java对象的五种方式：</p>
<ol>
<li>使用new关键字</li>
<li>使用Class类的newInstance方法</li>
<li>使用Constructor类的newInstance方法</li>
<li>使用clone方法</li>
<li>使用反序列化</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/" data-id="clrv16wjh000rz5ku64092n44" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/06/15/typora/leetcode%E7%AC%94%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 10px;">个人</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/27/test/">test</a>
          </li>
        
          <li>
            <a href="/2024/01/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/06/15/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/15/git%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/15/etcdRaft%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Kevin he<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>