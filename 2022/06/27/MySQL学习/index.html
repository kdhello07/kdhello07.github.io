<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MySQL学习 | 侬的杂货铺</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="MySQL学习 1.数据库概述1.RDBMS与非RDBMS 关系型数据库：  这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式） 关系型数据库以行和列的形式存储数据库，以便于用户理解，这一系列的行和列被称为表，一组表组成了一个库 表与表之间的数据记录有关系。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL学习">
<meta property="og:url" content="https://kdhello07.github.io/2022/06/27/MySQL%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="侬的杂货铺">
<meta property="og:description" content="MySQL学习 1.数据库概述1.RDBMS与非RDBMS 关系型数据库：  这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式） 关系型数据库以行和列的形式存储数据库，以便于用户理解，这一系列的行和列被称为表，一组表组成了一个库 表与表之间的数据记录有关系。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建">
<meta property="og:locale">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513100530485.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513103317152.png">
<meta property="og:image" content="https://img.php.cn/upload/image/852/939/165/1634208004776032.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220602112200974.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220603104134628.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220603112122592.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604093604533.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604093707392.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604102814977.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604102844788.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604103838143.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220605151441808.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220606200451913.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220606203721478.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220607162534461.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610115204937.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610163635853.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610182724180.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610191845121.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611084844985.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611085543880.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611085924719.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611095543560.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611101710456.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611121120360.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611121147251.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611121725487.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611122131663.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611122318517.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611123010714.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611144829782.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611144952050.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611145810881.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611150115501.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206131649527.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206131645606.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132033904.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132140291.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132149820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132155442.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132201223.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141036007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141105775.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141149469.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141203759.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141205028.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141305674.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141313717.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141316983.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141643969.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141817245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141817947.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141839419.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141847056.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141908276.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141912788.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141913528.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141923804.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141929571.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141937104.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141942787.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141945537.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141947396.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220614195652323.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206142002272.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206142014457.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206142023193.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206151500784.png">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513150552613.png">
<meta property="article:published_time" content="2022-06-26T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-26T20:04:04.041Z">
<meta property="article:author" content="Kevin he">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513100530485.png">
  
    <link rel="alternate" href="/atom.xml" title="侬的杂货铺" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">侬的杂货铺</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术、阅读、分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kdhello07.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-MySQL学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/27/MySQL%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-06-26T16:00:00.000Z" itemprop="datePublished">2022-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      MySQL学习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>MySQL学习</p>
<h2 id="1-数据库概述"><a href="#1-数据库概述" class="headerlink" title="1.数据库概述"></a>1.数据库概述</h2><h3 id="1-RDBMS与非RDBMS"><a href="#1-RDBMS与非RDBMS" class="headerlink" title="1.RDBMS与非RDBMS"></a>1.RDBMS与非RDBMS</h3><blockquote>
<p>关系型数据库：</p>
<ul>
<li>这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）</li>
<li>关系型数据库以行和列的形式存储数据库，以便于用户理解，这一系列的行和列被称为表，一组表组成了一个库</li>
<li>表与表之间的数据记录有关系。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。</li>
<li>优势：<ul>
<li>复杂查询<ul>
<li>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询</li>
</ul>
</li>
<li>事务支持<ul>
<li>使得对于安全性能很高的数据访问要求得以实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>非关系型数据库：</p>
<ul>
<li>非关系型数据库可看成传统关系型数据库的功能，基于键值对存储数据，不需要经过SQL层的解析，性能非常高。</li>
<li>NoSQL泛指非关系型数据库，包含有键值型数据库（redis）、文档型数据库(mongodb,couchdb)、搜索引擎(Elasticsearch,solr)和列存储(Hbase)，还包括图形数据库(neo4j)。</li>
</ul>
</blockquote>
<h2 id="2-逻辑架构"><a href="#2-逻辑架构" class="headerlink" title="2.逻辑架构"></a>2.逻辑架构</h2><h3 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1.逻辑架构剖析"></a>1.逻辑架构剖析</h3><h4 id="1-1-服务器处理客户端请求"><a href="#1-1-服务器处理客户端请求" class="headerlink" title="1.1 服务器处理客户端请求"></a>1.1 服务器处理客户端请求</h4><blockquote>
<ul>
<li>首先MySQL是典型的C&#x2F;S架构，即client&#x2F;server架构，&#x3D;&#x3D;服务端程序使用的是mysqld&#x3D;&#x3D;.不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。</li>
<li>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例</li>
</ul>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513100530485.png" alt="image-20220513100530485"></p>
<h4 id="1-2-Connectors"><a href="#1-2-Connectors" class="headerlink" title="1.2 Connectors"></a>1.2 Connectors</h4><blockquote>
<ul>
<li>指的是不同语言中与SQL的交互，MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL server建立TCP连接，之后按照其定义好的协议进行交互。或者比较方便的办法调用SDK,&#x3D;&#x3D;比如jdbc&#x3D;&#x3D;。但通过SDK来访问MySQL，&#x3D;&#x3D;本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互。&#x3D;&#x3D;</li>
<li>接下来的&#x3D;&#x3D;MySQL  server结构可以分为如下的三层&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h4 id="1-3-第一层：连接层"><a href="#1-3-第一层：连接层" class="headerlink" title="1.3 第一层：连接层"></a>1.3 第一层：连接层</h4><blockquote>
<ul>
<li>系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接</li>
<li>经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的&#x3D;&#x3D;账号密码做身份认证、权限获取&#x3D;&#x3D;<ul>
<li>之后的权限判断逻辑，都依赖于此时获取的权限</li>
</ul>
</li>
<li>MySQL 服务器有专门的tcp连接池，来控制连接数。同时还有一个线程池。</li>
<li>所以连接管理的职责是负责认证、管理链接、获取权限信息</li>
</ul>
</blockquote>
<h4 id="1-4-第二层：服务层"><a href="#1-4-第二层：服务层" class="headerlink" title="1.4 第二层：服务层"></a>1.4 第二层：服务层</h4><blockquote>
<p>主要完成大多数的核心服务功能。如sql接口，并完成缓存的查询，SQL的分析和优化以及部分内置函数的执行。</p>
</blockquote>
<h4 id="1-5-第三层：引擎层"><a href="#1-5-第三层：引擎层" class="headerlink" title="1.5 第三层：引擎层"></a>1.5 第三层：引擎层</h4><blockquote>
<p>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作。</p>
</blockquote>
<h4 id="1-6-存储层"><a href="#1-6-存储层" class="headerlink" title="1.6 存储层"></a>1.6 存储层</h4><blockquote>
<p>所有的数据，数据库，表的定义，表的每一行内容，索引，都是存储在文件系统上，以文件的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB,也支持不适用文件系统直接管理设备。</p>
</blockquote>
<h4 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h4><blockquote>
<p>连接层：客户端与服务器端建立连接，客户端发送SQL至服务器端</p>
<p>SQL层（服务层）：对SQL语句进行查询处理，与数据库文件的存储方式无关</p>
<p>存储引擎层：与数据库文件打交道，负责数据的存储和读取</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513103317152.png" alt="image-20220513103317152"></p>
<h3 id="2-SQL执行流程"><a href="#2-SQL执行流程" class="headerlink" title="2.SQL执行流程"></a>2.SQL执行流程</h3><h4 id="2-1MySQL中的SQL执行流程"><a href="#2-1MySQL中的SQL执行流程" class="headerlink" title="2.1MySQL中的SQL执行流程"></a>2.1MySQL中的SQL执行流程</h4><img src="https://img.php.cn/upload/image/852/939/165/1634208004776032.png" alt="3.png" style="zoom: 67%;" />

<blockquote>
<ol>
<li><p>查询缓存：server如果在查询缓存中发现了这条SQL语句，就会直接将结果返回给客户端，如果没有，就进入到解析器阶段，需要注意的是，因为查询缓存往往效率不高，所以在mysql8.0之后就抛弃了这个功能。【之前执行过的SQL语句及其执行结果，以key-value的形式存储】【去除的原因是查询缓存命中率不高】</p>
</li>
<li><pre><code class="mysql">mysql&gt; show global variables like &quot;%query_cache_type%&quot;;
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_type | OFF   |
+------------------+-------+
1 row in set (3.16 sec)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 解析器：在解析器中对SQL语句进行语法分析、语义分析。【判断输入MySQL语句是否满足MySQL语法，满足生成语法树】</span><br><span class="line"></span><br><span class="line">4. 优化器：在优化器中会确定SQL语句的执行路径，比如是根据全表检索还是索引检索等。==一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。==</span><br><span class="line"></span><br><span class="line">4. 执行器：此时就会进入执行器阶段。在执行需要判断该用户是否具备权限。如果不具备就返回错误。如果具备权限，就执行SQL查询并返回结果。如果设置了查询缓存，就将查询结果进行缓存。后面会调用存储引擎，在存储引擎层会去调用底层的文件系统，从而对数据进行增删改查操作</span><br><span class="line"></span><br><span class="line">#### 2.2MySQL中SQL执行原理</span><br><span class="line"></span><br><span class="line">**1.确认profiling是否开启**</span><br><span class="line"></span><br><span class="line">了解查询语句底层执行的过程：select  @@profiling;  或者 show variables like &#x27;%profiling%&#x27;;  查看是否开启计划。开启它可以让MySQL手机在SQL执行时所需要的资源情况，命令如下</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql&gt; select  @@profiling;</span><br><span class="line">+-------------+</span><br><span class="line">| @@profiling |</span><br><span class="line">+-------------+</span><br><span class="line">|           0 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;show variables like &#x27;%profiling%&#x27;;</span><br><span class="line"></span><br><span class="line">--- 暂时开启profiling功能。没开启时为0</span><br><span class="line">mysql&gt; set profiling=1;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;%profiling%&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | ON    |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+----------+------------+-----------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                             |</span><br><span class="line">+----------+------------+-----------------------------------+</span><br><span class="line">|        1 | 0.01186325 | show variables like &#x27;%profiling%&#x27; |</span><br><span class="line">|        2 | 0.00930475 | SELECT DATABASE()                 |</span><br><span class="line">|        3 | 0.00115075 | SELECT DATABASE()                 |</span><br><span class="line">|        4 | 0.00158900 | show databases                    |</span><br><span class="line">|        5 | 0.00338675 | show tables                       |</span><br><span class="line">|        6 | 0.00810150 | show tables                       |</span><br><span class="line">|        7 | 0.01930125 | select * from employees           |</span><br><span class="line">|        8 | 0.00282050 | select * from employees           |</span><br><span class="line">+----------+------------+-----------------------------------+</span><br><span class="line">8 rows in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 7对应的是上面query_ID为7的语句执行时间和流程</span><br><span class="line">mysql&gt; show profile for query 7;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.000159 |</span><br><span class="line">| checking permissions | 0.000761 |</span><br><span class="line">| Opening tables       | 0.000109 |</span><br><span class="line">| init                 | 0.000083 |</span><br><span class="line">| System lock          | 0.000186 |</span><br><span class="line">| optimizing           | 0.000550 |</span><br><span class="line">| statistics           | 0.000082 |</span><br><span class="line">| preparing            | 0.000066 |</span><br><span class="line">| executing            | 0.000051 |</span><br><span class="line">| Sending data         | 0.016321 |</span><br><span class="line">| end                  | 0.000067 |</span><br><span class="line">| query end            | 0.000479 |</span><br><span class="line">| closing tables       | 0.000069 |</span><br><span class="line">| freeing items        | 0.000167 |</span><br><span class="line">| cleaning up          | 0.000152 |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">15 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;可以在MySQL5.7中开启查询缓存 【注意：在MySQL8.0及以上不存在查询缓存】&#x3D;&#x3D;</p>
<ul>
<li><p>使用vim命令打开  &#x2F;etc&#x2F;my.cnf 文件，将query_cache_type &#x3D; 1 添加进去。并重启mysql服务&#x3D;&#x3D;systemctl restart mysqld&#x3D;&#x3D;</p>
</li>
<li><pre><code class="bash">[root@dmtsai ~]# vim /etc/my.cnf
#重启MySQL服务
[root@dmtsai ~]# systemctl restart mysqld
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在添加完查询缓存后</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  mysql&gt; show profiles;</span><br><span class="line">  +----------+------------+---------------------------+</span><br><span class="line">  | Query_ID | Duration   | Query                     |</span><br><span class="line">  +----------+------------+---------------------------+</span><br><span class="line">  |        1 | 0.00352875 | select @@profiling        |</span><br><span class="line">  |        2 | 0.00404500 | select * from departments |</span><br><span class="line">  |        3 | 0.00067225 | select * from departments |</span><br><span class="line">  +----------+------------+---------------------------+</span><br><span class="line">  3 rows in set, 1 warning (0.00 sec)</span><br><span class="line">      </span><br><span class="line">  mysql&gt; show profile for query 2;</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  | Status                         | Duration |</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  | starting                       | 0.000111 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000061 |</span><br><span class="line">  | starting                       | 0.000056 |</span><br><span class="line">  | checking query cache for query | 0.000130 |</span><br><span class="line">  | checking permissions           | 0.000378 |</span><br><span class="line">  | Opening tables                 | 0.000110 |</span><br><span class="line">  | init                           | 0.000077 |</span><br><span class="line">  | System lock                    | 0.000138 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000057 |</span><br><span class="line">  | System lock                    | 0.000079 |</span><br><span class="line">  | optimizing                     | 0.000058 |</span><br><span class="line">  | statistics                     | 0.000074 |</span><br><span class="line">  | preparing                      | 0.000518 |</span><br><span class="line">  | executing                      | 0.000060 |</span><br><span class="line">  | Sending data                   | 0.000271 |</span><br><span class="line">  | end                            | 0.000066 |</span><br><span class="line">  | query end                      | 0.000067 |</span><br><span class="line">  | closing tables                 | 0.000474 |</span><br><span class="line">  | freeing items                  | 0.000090 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000051 |</span><br><span class="line">  | freeing items                  | 0.000096 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000806 |</span><br><span class="line">  | freeing items                  | 0.000057 |</span><br><span class="line">  | storing result in query cache  | 0.000056 |</span><br><span class="line">  | cleaning up                    | 0.000107 |</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  25 rows in set, 1 warning (0.00 sec)</span><br><span class="line">      </span><br><span class="line">  mysql&gt; show profile for query 3;</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  | Status                         | Duration |</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  | starting                       | 0.000085 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000043 |</span><br><span class="line">  | starting                       | 0.000040 |</span><br><span class="line">  | checking query cache for query | 0.000045 |</span><br><span class="line">  | checking privileges on cached  | 0.000055 |</span><br><span class="line">  | checking permissions           | 0.000071 |</span><br><span class="line">  | sending cached result to clien | 0.000164 |</span><br><span class="line">  | cleaning up                    | 0.000171 |</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  8 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>还可以使用show profile查询其他内容 例如</p>
</li>
<li><pre><code class="mysql">mysql&gt; show profile cpu,block io for query 2;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.数据库缓冲池（buffer pool）[了解即可]</span><br><span class="line"></span><br><span class="line">&gt; - ==InnoDB 存储引擎==是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页</span><br><span class="line">&gt;   面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操</span><br><span class="line">&gt;   作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 ==占用内存来作为数据缓冲池== ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访</span><br><span class="line">&gt;   问。</span><br><span class="line">&gt; - 这样做的好处是可以让磁盘活动最小化，从而 ==减少与磁盘直接进行 I/O 的时间== 。要知道，这种策略对提</span><br><span class="line">&gt;   升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。  </span><br><span class="line"></span><br><span class="line">#### 3.1缓冲池 VS 查询缓存</span><br><span class="line"></span><br><span class="line">**缓冲池和查询缓存是一个东西吗？不是**</span><br><span class="line"></span><br><span class="line">##### **1.缓冲池**</span><br><span class="line"></span><br><span class="line">- 首先我们需要了解在InnoDB存储引擎中，缓冲池都包括了哪些。</span><br><span class="line"></span><br><span class="line">- 在InnoDB存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存</span><br><span class="line"></span><br><span class="line">![image-20220602103847544](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220602103847544.png)</span><br><span class="line"></span><br><span class="line">**缓存池的重要性**</span><br><span class="line"></span><br><span class="line">- 将整个页加载到内存中后就可以进行读写访问了，在进行完读写操作之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。</span><br><span class="line">- 帮我们消除了CPU和磁盘之间的鸿沟</span><br><span class="line"></span><br><span class="line">**缓存原则**：</span><br><span class="line"></span><br><span class="line">- 位置*频次原则，可以帮我们对I/O访问效率进行优化</span><br><span class="line"></span><br><span class="line">- 首先位置决定效率，提供缓存就是为了在内存中可以直接访问数据</span><br><span class="line">- 其次，频次决定优先级顺序，因为缓冲池的大小是有限的，比如磁盘200G，但是内存只有16G，缓冲池大小只有1G，因此需要优先对使用频次高的数据加载到缓冲池</span><br><span class="line"></span><br><span class="line">**缓冲池的预读特性：**</span><br><span class="line"></span><br><span class="line">了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：预读</span><br><span class="line"></span><br><span class="line">缓冲池的作用就是提升I/O效率，而我们进行读取数据的时候存在一个局部性原理，也就是说我们使用了一些数据，大概率还回使用它周围的一些数据，因此采用预读的机制提前加载。可以较少未来可能的磁盘I/O操作</span><br><span class="line"></span><br><span class="line">##### **2.查询缓存**</span><br><span class="line"></span><br><span class="line">- 查询缓存是提前把查询结果缓存起来，不是缓存查询计划，而是查询对应的结果。</span><br><span class="line">- 因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</span><br><span class="line">- 缓存池服务于数据库整体的I/O操作，他们的共同点都是通过缓存的机制来提升效率</span><br><span class="line"></span><br><span class="line">#### 3.2 缓冲池如何读取数据</span><br><span class="line"></span><br><span class="line">&gt; 缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面</span><br><span class="line">&gt; 是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进</span><br><span class="line">&gt; 行读取。  </span><br><span class="line"></span><br><span class="line">![image-20220602105502773](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220602105502773.png)</span><br><span class="line"></span><br><span class="line">**如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？**</span><br><span class="line"></span><br><span class="line">- 当对数据库中的记录进行修改时，首先会修改缓冲池中页面里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。缓冲池会用一种checkpoint机制将数据回写到磁盘上，提升数据库整体性能。</span><br><span class="line"></span><br><span class="line">#### 3.3查看/设置缓冲池的大小</span><br><span class="line"></span><br><span class="line">&gt; - 如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大小。命令如下：  </span><br><span class="line">&gt;</span><br><span class="line">&gt; ```mysql</span><br><span class="line">&gt; mysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br><span class="line">&gt; +-------------------------+-----------+</span><br><span class="line">&gt; | Variable_name           | Value     |</span><br><span class="line">&gt; +-------------------------+-----------+</span><br><span class="line">&gt; | innodb_buffer_pool_size | 134217728 |</span><br><span class="line">&gt; +-------------------------+-----------+</span><br><span class="line">&gt; 1 row in set (0.03 sec)</span><br><span class="line">&gt; </span><br><span class="line">&gt; mysql&gt; set global innodb_buffer_pool_size = 268435456;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="3-4多个buffer-pool实例"><a href="#3-4多个buffer-pool实例" class="headerlink" title="3.4多个buffer pool实例"></a>3.4多个buffer pool实例</h4><ul>
<li><p>为了提高并发度，在多线程环境下，只有单个实例加锁影响性能</p>
</li>
<li><p>我们看下如何查看缓冲池的个数，使用命令：  </p>
</li>
<li><pre><code class="mysql">show variables like &#39;innodb_buffer_pool_instances&#39;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的：</span><br><span class="line">- 也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。  </span><br><span class="line"></span><br><span class="line">注意：实例个数也不是越多越好，因为管理实例需要一定的开销</span><br><span class="line"></span><br><span class="line">#### 3.5引申问题</span><br><span class="line"></span><br><span class="line">如果在将数据写回到磁盘时，发生了故障，此时应该怎么办，即使用回滚.利用redo log、undo log</span><br><span class="line"></span><br><span class="line">## 3.存储引擎</span><br><span class="line"></span><br><span class="line">&gt; - 为了管理方便，人们把 连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</span><br><span class="line">&gt; - MySQL中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型。其实存储引擎以前叫做表处理器，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作</span><br><span class="line"></span><br><span class="line">### 1.查看存储引擎</span><br><span class="line"></span><br><span class="line">查看mysql提供什么引擎</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql&gt;show engines;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220602112200974.png" alt="image-20220602112200974"></p>
<h3 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2.设置系统默认的存储引擎"></a>2.设置系统默认的存储引擎</h3><p>查看默认的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%storage_engine%&quot;;</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| Variable_name                    | Value  |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| default_storage_engine           | InnoDB |</span><br><span class="line">| default_tmp_storage_engine       | InnoDB |</span><br><span class="line">| disabled_storage_engines         |        |</span><br><span class="line">| internal_tmp_disk_storage_engine | InnoDB |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">4 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;%storage_engine%&quot;;</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| Variable_name                    | Value  |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| default_storage_engine           | InnoDB |</span><br><span class="line">| default_tmp_storage_engine       | InnoDB |</span><br><span class="line">| disabled_storage_engines         |        |</span><br><span class="line">| internal_tmp_disk_storage_engine | InnoDB |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">4 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改默认的存储引擎，暂时生效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set default_storage_engine=MyISAM;</span><br></pre></td></tr></table></figure>

<p>或者修改 &#x2F;etc&#x2F;my.cnf文件，永久更改</p>
<h3 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3.设置表的存储引擎"></a>3.设置表的存储引擎</h3><blockquote>
<p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 不同的表设置不同的存储引擎 ，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。  </p>
</blockquote>
<h3 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4.引擎介绍"></a>4.引擎介绍</h3><h4 id="4-1-InnoDB引擎：具备外键支持功能的事务存储引擎"><a href="#4-1-InnoDB引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB引擎：具备外键支持功能的事务存储引擎"></a>4.1 InnoDB引擎：具备外键支持功能的事务存储引擎</h4><ul>
<li>MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。</li>
<li>InnoDB是MySQL的 <strong>默认事务型引擎</strong> ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务<br>的完整提交(Commit)和回滚(Rollback)。</li>
<li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li>
<li>&#x3D;&#x3D;除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。&#x3D;&#x3D;  </li>
<li>InnoDB是 为&#x3D;&#x3D;处理巨大数据量的最大性能设计&#x3D;&#x3D;   </li>
<li>数据文件结构：（在《第02章_MySQL数据目录》章节已讲）<ul>
<li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li>
<li>表名.ibd 存储数据和索引</li>
</ul>
</li>
<li>对比MyISAM的存储引擎， &#x3D;&#x3D;InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和&#x3D;&#x3D;<br>&#x3D;&#x3D;索引。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据&#x3D;&#x3D;， 对内存要求较<br>高 ，而且内存大小对性能有决定性的影响。</li>
</ul>
<h4 id="4-2-MyISAM引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM引擎：主要的非事务处理存储引擎"></a>4.2 MyISAM引擎：主要的非事务处理存储引擎</h4><ul>
<li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但&#x3D;&#x3D;MyISAM 不支持事务、行级锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。&#x3D;&#x3D;</li>
<li>5.5之前默认的存储引擎</li>
<li>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li>
<li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高  </li>
<li>数据文件结构：（在《第02章_MySQL数据目录》章节已讲）【数据与索引分开存储】<ul>
<li>表名.frm 存储表结构</li>
<li>表名.MYD 存储数据 (MYData)</li>
<li>表名.MYI 存储索引 (MYIndex)</li>
</ul>
</li>
<li>应用场景：只读应用或者以读为主的业务</li>
</ul>
<h4 id="4-3InnoDB与MyISAM对比"><a href="#4-3InnoDB与MyISAM对比" class="headerlink" title="4.3InnoDB与MyISAM对比"></a>4.3InnoDB与MyISAM对比</h4><table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发操作</td>
<td>行锁，操作时只锁一行，不对其他行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>自带系统表使用</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>关注点</td>
<td>性能：节省资源，消耗少，简单业务</td>
<td>事务：并发写、事务、更大资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>默认使用</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody></table>
<h4 id="4-4Archive-引擎：用于数据存档"><a href="#4-4Archive-引擎：用于数据存档" class="headerlink" title="4.4Archive 引擎：用于数据存档"></a>4.4Archive 引擎：用于数据存档</h4><h4 id="4-5Blackhole引擎：不会保存写入的操作"><a href="#4-5Blackhole引擎：不会保存写入的操作" class="headerlink" title="4.5Blackhole引擎：不会保存写入的操作"></a>4.5Blackhole引擎：不会保存写入的操作</h4><h4 id="4-6-CSV引擎：存储数据时，以逗号分割各个数据项-可以作为数据交换使用"><a href="#4-6-CSV引擎：存储数据时，以逗号分割各个数据项-可以作为数据交换使用" class="headerlink" title="4.6 CSV引擎：存储数据时，以逗号分割各个数据项.可以作为数据交换使用"></a>4.6 CSV引擎：存储数据时，以逗号分割各个数据项.可以作为数据交换使用</h4><h4 id="4-7Memory引擎"><a href="#4-7Memory引擎" class="headerlink" title="4.7Memory引擎"></a>4.7Memory引擎</h4><p><strong>概述：</strong></p>
<ul>
<li>Memory采用的逻辑介质是 内存 ， 响应速度很快 ，但是当mysqld守护进程崩溃的时候 数据会丢失 。另<br>外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。</li>
</ul>
<p><strong>主要特征：</strong></p>
<ul>
<li>Memory同时 支持哈希（HASH）索引 和 B+树索引 。</li>
<li>Memory表至少比MyISAM表要 快一个数量级 。</li>
<li>MEMORY 表的大小是受到限制 的。表的大小主要取决于两个参数，分别是 max_rows 和max_heap_table_size 。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默<br>认为16MB，可以按需要进行扩大。</li>
<li>数据文件与索引文件分开存储。</li>
<li>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。</li>
</ul>
<h2 id="4-索引的数据结构"><a href="#4-索引的数据结构" class="headerlink" title="4.索引的数据结构"></a>4.索引的数据结构</h2><h3 id="1-为什么要使用索引"><a href="#1-为什么要使用索引" class="headerlink" title="1.为什么要使用索引"></a>1.为什么要使用索引</h3><ul>
<li>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的号码，便可快速定位到需要的文章。MySQL中也是一样，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。</li>
<li>建索引的目的是为了减少磁盘I&#x2F;O的次数，加快查询速率</li>
</ul>
<h3 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2.索引及其优缺点"></a>2.索引及其优缺点</h3><h4 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h4><ul>
<li><p>索引（Index）是帮助MySQL高效获取数据的数据结构</p>
</li>
<li><p><strong>索引的本质：</strong>索引是数据结构。可以简单理解为排好序的快速查找数据结构。满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现<strong>高级查找算法</strong></p>
</li>
<li><p>索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256个字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
</li>
</ul>
<h4 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h4><ul>
<li>提高数据检索的效率，<strong>降低数据库的I&#x2F;O成本</strong>，这是最主要的原因</li>
<li>通过创建唯一索引，可以保证数据库表中每一行<strong>数据的唯一性</strong></li>
<li><strong>可以加速表和表之间的连接</strong>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</li>
<li>在使用分组和排序子句进行数据查询时，可以<strong>显著减少查询中分组和排序的时间</strong>，降低了CPU的消耗。</li>
</ul>
<h4 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h4><ul>
<li>创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加</li>
<li>索引需要占据磁盘空间，除了数据表需要占数据空间之外，每一个索引还要占一定的物理空间</li>
<li>虽然索引大大提高了查询速度，同时也会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
<li>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</li>
</ul>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
</blockquote>
<h3 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3.InnoDB中索引的推演"></a>3.InnoDB中索引的推演</h3><h4 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h4><p>先来看一个精确匹配的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 where 列名 = XXX</span><br></pre></td></tr></table></figure>

<p><strong>1.在一个页中的查找</strong></p>
<p>由于目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li>以主键为搜索条件<ul>
<li>可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li>
</ul>
</li>
<li>以其他列作为搜索条件<ul>
<li>因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种请开给你下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。这种查找的效率是非常低的。</li>
</ul>
</li>
</ul>
<p><strong>2.在很多页中查找</strong></p>
<ul>
<li>在很多页中查找记录的话可以分为两个步骤：<ul>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ul>
</li>
</ul>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页 沿着 双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。  </p>
<h4 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h4><p>建一个表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">-&gt; c1 INT,</span><br><span class="line">-&gt; c2 INT,</span><br><span class="line">-&gt; c3 CHAR(1),</span><br><span class="line">-&gt; PRIMARY KEY(c1)</span><br><span class="line">-&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure>

<ul>
<li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。目录项记录</li>
<li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li>
<li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li>
<li>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p><strong>B+Tree</strong></p>
<ul>
<li>一般情况下，我们 用到的B+树都不会超过4层 ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速定位记录。</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220603104134628.png" alt="image-20220603104134628"></p>
<h4 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h4><p>索引按照物理实现方式，索引可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或辅助索引</p>
<p><strong>1.聚簇索引</strong></p>
<p>聚簇索引并不是一种单独的索引类型，而是一种&#x3D;&#x3D;数据存储方式（所有的用户记录都存储在了叶子节点）&#x3D;&#x3D;，也就是所谓的&#x3D;&#x3D;索引即数据，数据即索引。&#x3D;&#x3D;</p>
<blockquote>
<p>术语聚簇表示数据行和相邻的键值聚簇的存储在一起。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：<ul>
<li>页内 的记录是按照主键的大小顺序排成一个 单向链表 。</li>
<li>各个存放 <strong>用户记录的页</strong> 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。</li>
<li>存放 <strong>目录项记录的页</strong> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键<br>大小顺序排成一个 双向链表 。</li>
</ul>
</li>
<li>B+树的 <strong>叶子节点</strong> 存储的是完整的用户记录。</li>
<li>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</li>
</ul>
<blockquote>
<p>我们把具有上面这两种特性的B+树称为<strong>聚簇索引</strong>，所有完整的用户记录都存放在这个<strong>聚簇索引</strong>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用<strong>INDEX</strong>语句去创建，<strong>InnoDB</strong>存储引擎会<strong>自动</strong>的为我们创建聚簇索引。</p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li><strong>数据访问更快</strong> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于<strong>主键的 排序查找 和 范围查找 速度</strong>非常快</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 <strong>节省了大量的io操作 。</strong></li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>插入速度严重依赖于插入顺序</strong> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，<strong>我们一般都会定义一个自增的ID列为主键</strong></li>
<li><strong>更新主键的代价很高</strong> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新</li>
<li><strong>二级索引访问需要两次索引查找</strong> ，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而myIsam并不支持聚簇索引</li>
<li>由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键</li>
<li>如果没有定义主键，Inoodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引</li>
<li>为了充分利用聚簇索引的聚簇的特性，所以Innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id,比如UUID,MD5,HASH，字符串列作为主键无法保证数据的顺序增长。</li>
</ul>
<p><strong>2.二级索引（辅助索引、非聚簇索引）</strong></p>
<p>上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果想以别的列作为搜索条件该怎么半呢？肯定不能从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以多建几颗B+树，不同的B+树种的数据采用不同的排序规则。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220603112122592.png" alt="image-20220603112122592"></p>
<p><strong>概念：回表</strong> </p>
<ul>
<li><p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值（c1列的值），所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 <strong>聚簇索引</strong> 中再查一遍，这个过程称为 回表 。也就是根据c2列的值查询一条完整的用户记录需要使用到 <strong>2 棵</strong>B+树！</p>
</li>
<li><p>问题：为什么我们还需要<strong>一次 回表 操作</strong>呢？直接把完整的用户记录放到叶子节点不OK吗？  </p>
</li>
<li><p>回答：</p>
<ul>
<li>如果把完整的用户记录放到叶子节点是可以不用回表。但是太占地方了，相当于每建立一颗B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费时间了</li>
</ul>
</li>
<li><p>因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（secondary index）,或者辅助索引。由于我们使用的是C2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引</p>
</li>
<li><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p>
</li>
</ul>
<p><strong>小结</strong>：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<ul>
<li>聚簇索引的<strong>叶子节点存储的是我们的数据记录</strong>，<strong>非聚簇索引的叶子节点存储的是数据位置（主键值，根据主键值回到聚簇索引中来查找数据）</strong>。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li><strong>一个表只能有一个聚簇索引</strong>，因为只能有一种排序存储的方式，但可以有多个<strong>非聚簇索引</strong>，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的<strong>查询效率高</strong>，但如果对数据进行插入、删除、更新等操作，效率就会比非聚簇索引低。</li>
</ul>
<p><strong>3.联合索引</strong></p>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：</p>
<ul>
<li><p>先把各个记录和页按照c2列进行排序</p>
</li>
<li><p>在记录的c2列相同的情况下，采用c3列进行排序</p>
</li>
<li><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立 联合索引 只会建立如上图一样的1棵B+树。</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
</li>
</ul>
<h4 id="3-4-InnoDB的B-树索引的注意事项"><a href="#3-4-InnoDB的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB的B+树索引的注意事项"></a>3.4 InnoDB的B+树索引的注意事项</h4><p><strong>1.根页面位置万年不动</strong></p>
<p>实际上B+树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个B+树索引（聚簇索引不是认为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个根节点中</li>
<li>当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页</li>
</ul>
<p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会在移动，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<p><strong>2.内节点【非叶子节点】中目录项记录的唯一性</strong></p>
<p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分组成的。</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号【对应的是数据项记录的页号 &#x2F;第一层的目录项记录的页号】</li>
</ul>
<p><strong>3.一个页面最少存储2条记录</strong> </p>
<ul>
<li>这是因为B+树的本质就是一个多层级目录，没经过一个目录会过滤掉很多无效的子目录，直到最后访问到存储真实数据的目录。如果一个页面只存储一条记录，这样子建目录过滤没有意义。</li>
</ul>
<h3 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4.MyISAM中的索引方案"></a>4.MyISAM中的索引方案</h3><ul>
<li>即使Innodb和MyISAM支持的默认索引是B+tree索引。但是Memory引擎支持的默认索引是Hash索引，</li>
<li>其中MyISAM引擎使用B+tree作为索引结构，叶子节点的data域存放的是数据记录的地址</li>
</ul>
<p><strong>4.1MyISAM中的原理</strong></p>
<ul>
<li>我们知道InnoDB中索引即数据，也就是聚簇索引的那颗B+树的叶子节点中已经把所有完整用户记录都包含了，而MyISAM的索引方案虽然也是使用树形结构，但是却将索引和数据分开存储。<ul>
<li>将表中的记录按照记录的插入顺序单独存放在一个文件中，称之为数据文件，这个文件并不划分为若干个数据页，有多少巨鹿就往这个文件中塞多少记录就成了，由于在插入数据的时候并没有可以按照主键排序，所以我们并不能在这些数据上进行二分查找。</li>
<li>使用MyISAM存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中，MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值+数据记录地址的组合。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在col1上建立索引</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604093604533.png" alt="image-20220604093604533"></p>
<blockquote>
<p>在col2上建立索引</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604093707392.png" alt="image-20220604093707392"></p>
<blockquote>
<p>从上面两张图可以看出来，MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主键索引和二级索引在结构上几乎没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。</p>
</blockquote>
<p><strong>4.3 MyISAM与InnoDB对比</strong></p>
<p>MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的，小结两种引擎中索引的区别：</p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。</p>
<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数据记录的地址。</p>
<p>③ InnoDB的非聚簇索引data域存储相应记录 <strong>主键的值</strong> ，而MyISAM索引记录的是 <strong>地址</strong> 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p>
<p>④ MyISAM的回表操作是十分 <strong>快速</strong> 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后<strong>再去聚簇索引里找记录</strong>，虽然说也不慢，但还是比不上直接用地址去访问。</p>
<p>⑤ InnoDB要求表 <strong>必须有主键</strong> （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。  </p>
<p><strong>小结</strong></p>
<p>知道索引结构后对于正确使用和优化索引都非常有帮助，例如</p>
<ul>
<li>知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有的二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</li>
<li>用非单调的字段作为主键在InnoDB中不是好主意，因为InnoDB数据文件本身是一颗B+tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+树的特性而频繁的分裂调整，十分低效，而是用自增字段为主键是一个非常好的选择。</li>
</ul>
<h3 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5.索引的代价"></a>5.索引的代价</h3><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li>空间上的代价<ul>
<li>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</li>
</ul>
</li>
<li>时间上的代价<br>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</li>
</ul>
<blockquote>
<p>一个表上索引建的越多，就会占用越多的存储空间，在增删改查记录的时候性能就越差，为了能建立又好又少的索引，我们得学学这些索引在哪些条件下不起作用的。</p>
</blockquote>
<h3 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6.MySQL数据结构选择的合理性"></a>6.MySQL数据结构选择的合理性</h3><ul>
<li>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更大，为了较少索引在内存的占用，数据库索引是存储在外部磁盘上的，当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只嗯呢逐一加载，那么MySQL衡量查询效率的标准就是磁盘I&#x2F;O次数。</li>
</ul>
<h4 id="6-1hash结构"><a href="#6-1hash结构" class="headerlink" title="6.1hash结构"></a>6.1hash结构</h4><ul>
<li><p>Hash结构效率高，那为什么索引结构要设计成树型呢？  </p>
<ul>
<li>Hash索引仅能满足（&#x3D;） 和（&lt;&gt;）和IN查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为O(n)，而树型的有序特性，依然能够保持O(log2N)的高效率</li>
<li>Hash索引还有一个缺陷，数据的存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新弄排序</li>
<li>对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询</li>
<li>对于等值查询来说，通常hash索引的效率高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。例如对于性别列。</li>
</ul>
</li>
<li><p>hash索引只支持在Memory引擎。</p>
</li>
<li><p>另外InnoDB本身不支持hash索引，但是提供自适应hash索引，如果一个数据经常被访问，那么可以将这个数据页的地址存放到hash表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#可以查看是否开启了自适应hash</span><br><span class="line">mysql&gt; show variables like &quot;%adaptive_hash_index%&quot;;</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">| Variable_name                    | Value |</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">| innodb_adaptive_hash_index       | ON    |</span><br><span class="line">| innodb_adaptive_hash_index_parts | 8     |</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">2 rows in set (0.60 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-2平衡二叉树（AVL）"><a href="#6-2平衡二叉树（AVL）" class="headerlink" title="6.2平衡二叉树（AVL）"></a>6.2平衡二叉树（AVL）</h4><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604102814977.png" alt="image-20220604102814977"></p>
<p>我们能够发现，当数据量大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度（M&gt;2）。所以我们需要把树从瘦高变成矮胖</p>
<h4 id="6-3-B-Tree"><a href="#6-3-B-Tree" class="headerlink" title="6.3 B-Tree"></a>6.3 B-Tree</h4><p>B树的英文是Balance Tree，也就是多路平衡二叉树。简写为B-Tree，它的高度远小于平衡二叉树的高度。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604102844788.png" alt="image-20220604102844788"></p>
<p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，M称为B树的阶，每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包括了x个关键字，那么指针数就是x+1。对于大量的索引数据来说，采用B树的结构是非常合适的。</p>
<p><strong>小结：</strong></p>
<ol>
<li>B树的插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li><strong>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据</strong>，搜索有可能在非叶子节点结束</li>
<li>其搜索性能等价于在关键字全集内作一次二分查找</li>
</ol>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604103838143.png" alt="image-20220604103838143"></p>
<h4 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h4><p>B+树也是一种多路搜索树，基于B树做出了改进，主流的DBMS都支持B+树的索引方式。比如MySQL，相比于B-Tree，B+Tree适合文件索引系统。</p>
<p>B+Tree和B-Tree的差异：</p>
<ul>
<li>B+树有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数+1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <strong>非叶子节点既保存索引，也保存数据记录 。</strong></li>
<li>B+Tree<strong>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接</strong></li>
</ul>
<blockquote>
<p>B+树的中间节点并不直接存储数据，这样的好处有哪些呢？</p>
<ul>
<li><strong>B+树的查询效率更稳定</strong>，因为每次都需要查找到叶子节点才结束，而对于B-Tree结构来说，有时候查询到非叶子节点就结束了</li>
<li><strong>B+树的查询效率更高</strong>，这是因为通常B+树比B树更矮胖（阶数更大，深度更低，查询所需的磁盘I&#x2F;O会更少，同样的磁盘页大小，B+树可以存放更多的节点关键字（因为B树的非叶子节点中也会存储数据，所以能够容纳的叉就会少一些，也就是子节点会更少一些，所以也就比B+tree更高一些）。</li>
<li>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B+树高</strong>，这是因为所有关键字都出现B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树种则需要通过中序遍历才能完成查询范围的查找</li>
</ul>
</blockquote>
<ul>
<li>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</li>
<li>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</li>
</ul>
<p>&#x3D;&#x3D;思考题：为了减少I&#x2F;O，索引树会一次性加载吗？&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小页会很大，超过几个G</li>
<li>当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页（块），因为磁盘页对应着索引树的节点。</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;思考题：B+树的存储能力如何？为何说一般查找记录，最多只需1-3次磁盘I&#x2F;O&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中一个节点）中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值也就是说一个深度为3的B+Tree索引可以存储 1000 * 1000 * 1000 &#x3D; 10亿条记录（这里也假定一个数据页也存储了1000条记录）</li>
<li>实际情况中每个节点可能不能填充满，因此在数据库中 B+Tree的高度一般都在2-4层，MySQL的InnoDB存储引擎在设计是将根节点常驻在内存的，也就是说查找某一键值的行记录最多只需要1-3次磁盘I&#x2F;O操作</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>B+树的磁盘读写代价更低</li>
<li>B+树的查询效率更加稳定</li>
<li>B+树的查询速度更快</li>
<li>针对查询范围，B+树的速度更快</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;思考题：Hash 索引与 B+ 树索引的区别&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>Hash索引不支持范围查询，而B+树可以，这是因俄日hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表</li>
<li>hash索引不支持联合索引的最左侧原则。如针对两个列进行建立索引时，hash索引是将索引键合并后在一起计算hash值，所以不会针对每个索引单独计算hash值，因此如果用到联合索引的一个或几个索引时，联合索引无法使用</li>
<li>hash索引不支持order by排序。同理hash索引也不支持模糊查询。</li>
<li>InnoDB不支持hash索引</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？&#x3D;&#x3D;  </p>
<p>针对InnoDB和MyISAM存储引擎，都会默认采用B+树索引，无法使用Hash索引。InnoDB提供的自适应Hash是不需要手动指定的。如果时Memory&#x2F;heap和NDB存储引擎，是可以进行选择Hash索引的。</p>
<h4 id="6-7-R树"><a href="#6-7-R树" class="headerlink" title="6.7 R树"></a>6.7 R树</h4><p>仅支持geometry数据类型，解决了这种高维空间搜索问题</p>
<h4 id="6-8-小结"><a href="#6-8-小结" class="headerlink" title="6.8 小结"></a>6.8 小结</h4><ul>
<li>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间，降低数据库写操作的性能，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利（提升查询效率）和弊（维护索引所需的代价）</li>
<li>在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但是数据量大的时候不使用索引是不可想象的，毕竟索引的本质是帮助我们提升数据检索的效率。</li>
</ul>
<h2 id="5-InnoDB数据存储结构"><a href="#5-InnoDB数据存储结构" class="headerlink" title="5.InnoDB数据存储结构"></a>5.InnoDB数据存储结构</h2><h3 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1.数据库的存储结构：页"></a>1.数据库的存储结构：页</h3><ul>
<li>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。不过不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如Merory都不用磁盘来存储数据</li>
<li>由于<strong>InnoDB是MySQL的默认存储引擎</strong>，所以主要剖析InnoDB存储引擎的数据存储结构。</li>
</ul>
<h4 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h4><ul>
<li>InnoDB将数据分为若干个页，InnoDB中页的大小默认为16KB.</li>
<li>以页作为磁盘和内存之间交互的基本单位，也就是说一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中，也就是说，在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page）,数据库I&#x2F;O操作的最小单位是页，一个页中可以存储多个行记录。</li>
</ul>
<blockquote>
<p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I&#x2F;O操作）只能处理一行数据，效率会非常低。</p>
</blockquote>
<h4 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h4><p>各个页之间可以&#x3D;&#x3D;不通过物理结构上相连&#x3D;&#x3D;，只要通过&#x3D;&#x3D;双向链表相关联&#x3D;&#x3D;即可。每个数据页中的记录会按照&#x3D;&#x3D;主键值从小到大的顺序组成一个单向链表&#x3D;&#x3D;，每个数据页都会为存储在它里边的记录生成一个&#x3D;&#x3D;页目录&#x3D;&#x3D;，在通过主键查找某条记录的时候可以在&#x3D;&#x3D;页目录中使用二分法&#x3D;&#x3D;快速定位到槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<h4 id="1-3-页的大小"><a href="#1-3-页的大小" class="headerlink" title="1.3 页的大小"></a>1.3 页的大小</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%innodb_page_size%&quot;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| innodb_page_size | 16384 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.60 sec)</span><br></pre></td></tr></table></figure>

<h4 id="1-4-页的上层结构"><a href="#1-4-页的上层结构" class="headerlink" title="1.4 页的上层结构"></a>1.4 页的上层结构</h4><p>另外在数据库中，缓存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示</p>
<p>区：是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页，因为InnoDB中的页大小默认是16KB，所以一个区的大小是64 * 16KB&#x3D; 1MB</p>
<p>段：有一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会创建相应的段，</p>
<p>表空间：是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间。</p>
<h3 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2.页的内部结构"></a>2.页的内部结构</h3><ul>
<li>页如果按类型划分的话，常见的有数据页（保存B+树节点），系统页，undo页和事务数据页等。数据页是我们最常使用的页。</li>
<li>数据页的16KB大小的存储空间被划分为7个部分，<ul>
<li>文件头：38字节，描述页的信息</li>
<li>页头：56字节，页的状态信息</li>
<li>最大和最小记录：26字节，这是两个虚拟的行记录</li>
<li>用户记录：不确定，存储行记录内容</li>
<li>空闲记录：不确定页中还没有被使用的空间</li>
<li>页目录：不确定，存储用户记录的相对位置</li>
<li>文件尾：8字节，检验页是否完整</li>
</ul>
</li>
</ul>
<p>第一部分：文件头和文件尾</p>
<ul>
<li><p>&#x3D;&#x3D;被删除的记录为什么还在页中存储呢？&#x3D;&#x3D;</p>
<ul>
<li>是利用了属性标记【在行记录头中】，标记着当前记录是否删除，占用一个二进制位。你以为他删除了，可它还在真是的磁盘上，这些被删除的记录之所以不立即从从磁盘上溢出，是因为移除他们之后，其他的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新纪录插入到表中的话，可能把这些记录被删除的记录占用的存储空间覆盖掉。</li>
</ul>
</li>
<li><h2 id="使用页目录，二分法查找-将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为已删除的记录-第一组，也就是最小记录所在的分组只有一个记录-最后一组，就是最大记录所在的分组，会有1-8记录-其余的组记录数量在4-8条之间"><a href="#使用页目录，二分法查找-将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为已删除的记录-第一组，也就是最小记录所在的分组只有一个记录-最后一组，就是最大记录所在的分组，会有1-8记录-其余的组记录数量在4-8条之间" class="headerlink" title="使用页目录，二分法查找- 将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为已删除的记录- 第一组，也就是最小记录所在的分组只有一个记录- 最后一组，就是最大记录所在的分组，会有1-8记录- 其余的组记录数量在4-8条之间"></a>使用页目录，二分法查找<br>- 将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为已删除的记录<br>- 第一组，也就是最小记录所在的分组只有一个记录<br>- 最后一组，就是最大记录所在的分组，会有1-8记录<br>- 其余的组记录数量在4-8条之间</h2><ul>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的偏移量也被称之为槽，每个槽相当于指针指向了不同组的最后一条记录。</li>
</ul>
</li>
</ul>
<h2 id="6-索引的创建与设计原则"><a href="#6-索引的创建与设计原则" class="headerlink" title="6.索引的创建与设计原则"></a>6.索引的创建与设计原则</h2><h3 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1.索引的声明与使用"></a>1.索引的声明与使用</h3><h4 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h4><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。这些索引的结构都是B+Tree数据结构</p>
<ul>
<li>从&#x3D;&#x3D;功能逻辑上&#x3D;&#x3D;来说，索引主要有4种，分别是普通索引、唯一索引、主键索引、全文索引</li>
<li>按照&#x3D;&#x3D;物理实现&#x3D;&#x3D;方式，索引可以分为2种：聚簇索引和非聚簇索引</li>
<li>按照&#x3D;&#x3D;作用字段个数&#x3D;&#x3D;进行划分，分成单列索引和联合索引</li>
</ul>
<p><strong>1.普通索引</strong></p>
<p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在<strong>任何数据类型</strong>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p>
<p><strong>2.唯一性索引</strong></p>
<p>使用UNIQUE可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。</p>
<p>例如，在student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的，通过唯一性索引可以更快速地确定某条记录。</p>
<p><strong>3.主键索引</strong></p>
<p>主键索引就是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE，一张表里&#x3D;&#x3D;最多只有一个&#x3D;&#x3D;主键索引。</p>
<p>&#x3D;&#x3D;why?&#x3D;&#x3D;这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p>
<p><strong>4.单列索引</strong></p>
<p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引，只要保证该索引只对应一个字段即可。一个表可以有&#x3D;&#x3D;多个单列索引。&#x3D;&#x3D;</p>
<p><strong>5.多列（联合，组合）索引</strong></p>
<p>多列索引是在表的&#x3D;&#x3D;多个字段组合&#x3D;&#x3D;上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用这些字段中的第一个字段时才会被使用。例如，在表中的字段id,name和gender上建立一个多列索引idx_id_name_gender,只有查询条件中使用了字段id时该索引才会被使用。使用组合索引时&#x3D;&#x3D;遵循最左前缀集合&#x3D;&#x3D;。</p>
<p><strong>6.全文索引</strong></p>
<p>全文索引（也称全文检索）是目前搜索引擎中使用的一种关键技术。它能够利用【分词技术】等多种算法只能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<p>使用参数FULLTEXT可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在CHAR.VARCHAR或TEXT类型及其系列类型的字段上，&#x3D;&#x3D;查询数据量比较大的字符串类型的字段时，使用全文索引可以提高查询速度。&#x3D;&#x3D;</p>
<p>全文索引典型的有两种类型：自然语言的全文索引 和 布尔全文索引。</p>
<p><strong>7.补充：空间索引</strong></p>
<p>使用参数SPATIAL可以设置索引为空间索引。空间索引只能建立在空间数据类型上。这样可以提高系统获取空间数据的效率。MySQL的空间数据类型包括：GEOMETRY,POINT,POLYGON等目前只有MyISAM引擎支持空间检索，而且索引的字段不能为空值。</p>
<p><strong>小结：不同的存储引擎支持的索引类型也不一样</strong> </p>
<ul>
<li>InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash索引； </li>
<li>MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引； </li>
<li>Memory ：支持 B-tree、Hash 等索引，不支持 Full-text 索引； </li>
<li>NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引；</li>
<li>Archive ：不支持 B-tree、Hash、Full-text 等索引；</li>
</ul>
<h4 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h4><p>MySQL支持多种方法在单个或多个列上创建索引，在创建表的定义语句CREATE TABLE中指定索引，使用ALTER TABLE语句在存在的表上创建索引，或者使用CREATE INDEX语句在已存在的表上添加索引</p>
<p><strong>1.创建表的时候创建索引</strong></p>
<p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束，外键约束或唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 隐式的方式创建索引。在声明有主键约束、唯一性约束、外键约束的字段上，会自动地添加相关地索引</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">dept_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dept_name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">emp_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">emp_name VARCHAR(20) UNIQUE,</span><br><span class="line">dept_id INT,</span><br><span class="line">CONSTRAINT emp_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果显式创建表时创建索引的话，基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br><span class="line"></span><br><span class="line"># KEY 也表达的索引的意思</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">-- 显式创建索引</span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line"># 1.创建普通的索引</span><br><span class="line">CREATE TABLE book(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明索引 【普通索引】</span><br><span class="line">INDEX idx_bname(book_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#通过命令查看索引</span><br><span class="line"># 方式1：</span><br><span class="line">SHOW CREATE TABLE book;</span><br><span class="line"></span><br><span class="line"># 方式2：</span><br><span class="line">SHOW INDEX FROM book;</span><br><span class="line"></span><br><span class="line">-- 性能分析工具：EXPLAIN.看是否使用了索引</span><br><span class="line">EXPLAIN SELECT * FROM book where book_name = &#x27;mysql&#x27;;</span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2.创建唯一索引</span><br><span class="line">CREATE TABLE book1(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明索引</span><br><span class="line">UNIQUE INDEX uk_idx_cmt(COMMENT)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查看索引</span><br><span class="line">SHOW INDEX FROM book1;</span><br><span class="line"></span><br><span class="line">INSERT INTO book1(book_id,book_name,COMMENT) VALUES(1,&#x27;mysql high&#x27;,&quot;welcome study&quot;);</span><br><span class="line"></span><br><span class="line">&gt; 1062 - Duplicate entry &#x27;welcome study&#x27; for key &#x27;uk_idx_cmt&#x27;INSERT INTO </span><br><span class="line"># 下面语句执行会报上面的错误，不满足唯一索引的要求</span><br><span class="line"></span><br><span class="line"># 注意在添加数据时，要保证唯一性，但是可以添加null值</span><br><span class="line">INSERT INTO book1(book_id,book_name,COMMENT) VALUES(2,&#x27;mysql high&#x27;,&quot;welcome study&quot;);</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line">-- 3.创建唯一索引</span><br><span class="line">-- 通过定义主键约束的方式定义主键索引</span><br><span class="line"></span><br><span class="line">CREATE TABLE book2(</span><br><span class="line">book_id INT PRIMARY KEY,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SHOW INDEX from book2;</span><br><span class="line"></span><br><span class="line"># 通过删除主键约束的方式删除主键索引</span><br><span class="line">ALTER TABLE book2 DROP PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line">-- 4.创建单列索引</span><br><span class="line">CREATE TABLE book3(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明单列索引</span><br><span class="line">UNIQUE INDEX idx_bname(book_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查询索引 如果是单列索引的话 其中Seq_in_index的值为1</span><br><span class="line">SHOW INDEX from book3;</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line">-- 5.创建联合索引</span><br><span class="line">CREATE TABLE book4(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明联合索引</span><br><span class="line">INDEX mul_idx_bname(book_id,book_name,info)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查询索引 如果是单列索引的话 其中Seq_in_index的值为1</span><br><span class="line">SHOW INDEX from book4;</span><br><span class="line"></span><br><span class="line"># 此时就会用到建立的联合索引，这里必须要遵循最左前缀原则</span><br><span class="line">EXPLAIN SELECT * from book4 WHERE book_id = 1001 AND book_name = &#x27;mysql&#x27;;</span><br><span class="line"></span><br><span class="line"># 此时这种查询就不会用到索引，因为必须要从Seq_in_index小的字段进行查询</span><br><span class="line">EXPLAIN SELECT * from book4 WHERE info = &quot;hello&quot; AND book_name = &#x27;mysql&#x27;;</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line">-- 6.创建全文索引</span><br><span class="line">CREATE TABLE book5(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明全文索引</span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查询索引</span><br><span class="line">SHOW INDEX from book5;</span><br><span class="line"></span><br><span class="line">-- 建立全文索引后的查询就不同于like查询</span><br><span class="line">EXPLAIN SELECT * FROM book5 WHERE info like &quot;%mysql%&quot;;</span><br><span class="line"></span><br><span class="line">-- 全文索引用match + against方式查询  下面这种方式的查询效率比上面哪种方式要快很多</span><br><span class="line">EXPLAIN SELECT * FROM book5 WHERE MATCH(info) AGAINST (&quot;mysql&quot;);</span><br><span class="line"></span><br><span class="line">-- 注意</span><br><span class="line">1. 使用全文索引前，搞清楚版本支持情况</span><br><span class="line">2. 全文索引比like+%快N倍，但是可能存在精度问题</span><br><span class="line">3. 如果需要全文索引的大量数据，建议先添加数据，再创建索引</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line">-- 7.创建空间索引</span><br><span class="line">CREATE TABLE book6(</span><br><span class="line">geo GEOMETRY NOT NULL,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">)ENGINE=MyISAM;</span><br><span class="line"></span><br><span class="line">CREATE TABLE book7(</span><br><span class="line">geo GEOMETRY NOT NULL,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX from book6;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>查看联合索引的结果图，主要是Seq_in_index的值</li>
<li>Seq_in_index主要是优先按照Seq_in_index小的进行匹配</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220605151441808.png" alt="image-20220605151441808"></p>
<p><strong>2.在已经创建的表上创建索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-- 在已经拆挂那件的表上创建索引</span><br><span class="line">CREATE TABLE book8(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX from book8;</span><br><span class="line"></span><br><span class="line"># 1.alter table  ... ADD INDEX...    添加普通索引</span><br><span class="line">ALTER TABLE book8 ADD INDEX idx_cmt(COMMENT);</span><br><span class="line"></span><br><span class="line"># 添加唯一索引</span><br><span class="line">ALTER TABLE book8 ADD UNIQUE INDEX uk_idx_bname(book_name);</span><br><span class="line"></span><br><span class="line"># 添加联合索引</span><br><span class="line">ALTER TABLE book8 ADD INDEX mul_bid_idx_bname_info(book_id,book_name,info);</span><br><span class="line"></span><br><span class="line">CREATE TABLE book9(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX from book9;</span><br><span class="line"># 2. CREATE INDEX ... ON ... 添加普通索引</span><br><span class="line">CREATE INDEX idx_cmt ON book9(COMMENT);</span><br><span class="line"></span><br><span class="line"># 添加唯一索引</span><br><span class="line">CREATE UNIQUE INDEX uk_idx_bname ON book9(book_name);</span><br><span class="line"></span><br><span class="line"># 添加联合索引</span><br><span class="line">CREATE INDEX mul_bid_idx_bname_info ON book9(book_id,book_name,info);</span><br></pre></td></tr></table></figure>

<p><strong>3.删除索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1.ALTER TABLE ... DROP INDEX ...索引的删除</span><br><span class="line"># 注意这种方式与alter table添加索引的方式相对</span><br><span class="line">ALTER TABLE book9 DROP INDEX idx_cmt;</span><br><span class="line"></span><br><span class="line"># 2.DROP INDEX ... ON ...  </span><br><span class="line">DROP INDEX uk_idx_bname ON book9;</span><br><span class="line"></span><br><span class="line"># 删除表中的某一个列，列中对应的索引也会有相应变化</span><br><span class="line">ALTER TABLE book9 DROP COLUMN book_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<p>添加AUTO_INCREMENT约束字段的唯一索引不能被删除</p>
</blockquote>
<blockquote>
<p>提示：</p>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h3 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2.MySQL8.0索引新特性"></a>2.MySQL8.0索引新特性</h3><h4 id="2-1支持降序索引"><a href="#2-1支持降序索引" class="headerlink" title="2.1支持降序索引"></a>2.1支持降序索引</h4><ul>
<li>在MySQL8.0以前，索引默认都是升序。8.0之后开始支持降序索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line">INDEX idx_a_b(a ASC,b DESC)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h4><ul>
<li>在MySQL8.0版本之前，只能通过显式的方式删除索引。有时需要多次的索引的创建与删除，数据量过大，会消耗系统过多的资源。</li>
<li>从MySQL8.0之后开始支持隐藏索引，只需要将待删除的索引设置为隐藏索引，是查询优化器不在使用这个索引（即使使用force index(强制使用索引)，优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。&#x3D;&#x3D;这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。&#x3D;&#x3D;</li>
<li>同时，如果你想&#x3D;&#x3D;验证某个索引删除之后的查询性能影响&#x3D;&#x3D;，就可以按时先隐藏该索引</li>
</ul>
<blockquote>
<p>注意：主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引</p>
</blockquote>
<p>索引默认是可见的，在使用CREATE TABLE,CREATE INDEX或者ALTER TABLE 等语句时可以通过VISIABLE或者INVISIABLE关键词设置索引的可见性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line"># 创建不可见索引</span><br><span class="line">INDEX idx_a_b(a,b) INVISIABLE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 2.创建不可见索引</span><br><span class="line">ALTER TABLE book7 ADD UNIQUE INDEX uk_idx_bname(book_name) invisiable;</span><br><span class="line"></span><br><span class="line"># 3. 创建不可见索引</span><br><span class="line">CREATE INDEX idx_year_pub ON book7(year_publication) invisiable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改索引的可见性</span><br><span class="line">ALTER TABLE book7 Alter INDEX idx_year_pub visiable;  -- 由不可见——》可见</span><br><span class="line">ALTER TABLE book7 Alter INDEX idx_year_pub invisiable;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>当索引被隐藏时，它的内容仍然适合正常索引一样实时更新的。如果一个索引需要长期背影仓，那么可以将其删除，因为索引的存在会影响插入，更新和删除的性能</p>
</blockquote>
<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助</p>
<p>使隐藏索引对查询优化器可见</p>
<h3 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3.索引的设计原则"></a>3.索引的设计原则</h3><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上拆挂那件索引和创建什么类型的索引。&#x3D;&#x3D;索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍&#x3D;&#x3D;。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p>
<h4 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a><strong>3.1 数据准备</strong></h4><p>第1步：创建数据库、创建表</p>
<p>第2步：数据的准备。创建存储函数、存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">-- 执行sql文件</span><br><span class="line">/*</span><br><span class="line"> Navicat Premium Data Transfer</span><br><span class="line"></span><br><span class="line"> Source Server         : vmware</span><br><span class="line"> Source Server Type    : MySQL</span><br><span class="line"> Source Server Version : 50737</span><br><span class="line"> Source Host           : 192.168.1.128:3306</span><br><span class="line"> Source Schema         : atguigudb1</span><br><span class="line"></span><br><span class="line"> Target Server Type    : MySQL</span><br><span class="line"> Target Server Version : 50737</span><br><span class="line"> File Encoding         : 65001</span><br><span class="line"></span><br><span class="line"> Date: 05/06/2022 19:41:24</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for course</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `course`;</span><br><span class="line">CREATE TABLE `course`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `course_id` int(11) NOT NULL,</span><br><span class="line">  `course_name` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 101 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of course</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `course` VALUES (1, 10065, &#x27;XQkCgb&#x27;);</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for student_info</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `student_info`;</span><br><span class="line">CREATE TABLE `student_info`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `student_id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `course_id` int(11) NOT NULL,</span><br><span class="line">  `class_id` int(11) NULL DEFAULT NULL,</span><br><span class="line">  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 67599 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of student_info</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `student_info` VALUES (50300, 197628, &#x27;pCRzZz&#x27;, 10036, 10042, &#x27;2022-06-05 19:34:50&#x27;);</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Procedure structure for insert_course</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP PROCEDURE IF EXISTS `insert_course`;</span><br><span class="line">delimiter ;;</span><br><span class="line">CREATE PROCEDURE `insert_course`(IN `max_num` int)</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE i INT DEFAULT 0;   </span><br><span class="line"> SET autocommit = 0;    #设置手动提交事务</span><br><span class="line"> REPEAT  #循环</span><br><span class="line"> SET i = i + 1;  #赋值</span><br><span class="line"> INSERT INTO course (course_id, course_name ) VALUES (rand_num(10000,10100),rand_string(6));  </span><br><span class="line"> UNTIL i = max_num  </span><br><span class="line"> END REPEAT;  </span><br><span class="line"> COMMIT;  #提交事务</span><br><span class="line">END</span><br><span class="line">;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Procedure structure for insert_stu</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP PROCEDURE IF EXISTS `insert_stu`;</span><br><span class="line">delimiter ;;</span><br><span class="line">CREATE PROCEDURE `insert_stu`(IN `max_num` int)</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE i INT DEFAULT 0;   </span><br><span class="line">	 SET autocommit = 0;    #设置手动提交事务</span><br><span class="line">	 REPEAT  #循环</span><br><span class="line">	 SET i = i + 1;  #赋值</span><br><span class="line">	 INSERT INTO student_info (course_id, class_id ,student_id ,name ) VALUES (rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));  </span><br><span class="line">	 UNTIL i = max_num  </span><br><span class="line">	 END REPEAT;  </span><br><span class="line">	 COMMIT;  #提交事务</span><br><span class="line">END</span><br><span class="line">;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Function structure for rand_num</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP FUNCTION IF EXISTS `rand_num`;</span><br><span class="line">delimiter ;;</span><br><span class="line">CREATE FUNCTION `rand_num`(`from_num` int,`to_num` int)</span><br><span class="line"> RETURNS int(11)</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE i INT DEFAULT 0;  </span><br><span class="line">	SET i = FLOOR(from_num +RAND()*(to_num - from_num+1))   ;</span><br><span class="line">	RETURN i;  </span><br><span class="line">END</span><br><span class="line">;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Function structure for rand_string</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP FUNCTION IF EXISTS `rand_string`;</span><br><span class="line">delimiter ;;</span><br><span class="line">CREATE FUNCTION `rand_string`(`n` int)</span><br><span class="line"> RETURNS varchar(255) CHARSET utf8mb4</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE chars_str VARCHAR(100) DEFAULT &#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">	DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	WHILE i &lt; n DO </span><br><span class="line">       SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">       SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END</span><br><span class="line">;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第3步：执行存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_course(100);</span><br><span class="line">CALL insert_stu(1000000);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a><strong>3.2 哪些情况适合创建索引</strong></h4><p><strong>1.字段的数值有唯一性的限制</strong></p>
<ul>
<li><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果某个字段时唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。</p>
</li>
<li><p>例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p>
</li>
</ul>
<blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p>
<p>说明：不要意味唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的</p>
</blockquote>
<p><strong>2.频繁作为WHERE查询条件的字段</strong></p>
<p>某个字段在select语句的where条件中经常出现，就可以添加索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># student_id字段上没有索引的</span><br><span class="line">SELECT course_id, class_id, NAME, create_time, student_id</span><br><span class="line">FROM student_info</span><br><span class="line">WHERE student_id = 67602;  #查询耗时 0.547s  547ms</span><br><span class="line"></span><br><span class="line">#给student_id添加索引</span><br><span class="line">CREATE INDEX idx_stu_id ON student_info(student_id);</span><br><span class="line"></span><br><span class="line"># student_id字段上添加索引后</span><br><span class="line">SELECT course_id, class_id, NAME, create_time, student_id</span><br><span class="line">FROM student_info</span><br><span class="line">WHERE student_id = 67604;  #查询耗时 0.051s  51ms</span><br></pre></td></tr></table></figure>



<p><strong>3.经常GROUP BY和ORDER BY的列</strong></p>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。  </p>
<p>比如，按照student_id对学生选修的课程进行分组，显示不同的student_id和课程数量，显示100个即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># student_id字段上添加索引后</span><br><span class="line">SELECT student_id,count(*) AS num FROM student_info GROUP BY student_id LIMIT 100; # 0.046s</span><br><span class="line"></span><br><span class="line">#删除索引后</span><br><span class="line">-- ALTER TABLE student_info DROP INDEX idx_stu_id;</span><br><span class="line">DROP INDEX idx_stu_id ON student_info;</span><br><span class="line"></span><br><span class="line"># student_id字段上添加索引后</span><br><span class="line">SELECT student_id,count(*) AS num FROM student_info GROUP BY student_id LIMIT 100; # 1.114s</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 先添加两个单列索引</span><br><span class="line">ALTER TABLE student_info ADD INDEX idx_sid(student_id); </span><br><span class="line"></span><br><span class="line">ALTER TABLE student_info ADD INDEX idx_cre_time(create_time); </span><br><span class="line"></span><br><span class="line"># 在查询时会优先进行group by操作，再进行order by。因此在匹配索引时，也是优先匹配froup by对应的列的索引。</span><br><span class="line">SELECT student_id,count(*) AS num FROM student_info GROUP BY student_id ORDER BY create_time DESC LIMIT 100;</span><br><span class="line"></span><br><span class="line">-- 对于下面的联合索引，在进行上面的查询操作会生效。</span><br><span class="line">#添加联合索引</span><br><span class="line">ALTER TABLE student_info</span><br><span class="line">ADD INDEX idx_sid_cre_time(student_id,create_time DESC);</span><br><span class="line"></span><br><span class="line">#在删除上面那个联合索引后，添加下面这个联合索引，再进行查询时，匹配的索引就是上面的单列索引 idx_sid。这与联合索引中的Seq_in_index有关</span><br><span class="line">ALTER TABLE student_info</span><br><span class="line">ADD INDEX idx_sid_cre_time(create_time desc，student_id);</span><br></pre></td></tr></table></figure>



<p><strong>4.UPDATE、DELETE的WHERE条件列</strong></p>
<p>当我们对某条数据进行UPDATE或者DELETE操作的时候，是否也需要对WHERE的条件列创建索引呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#name列上没有索引</span><br><span class="line">UPDATE student_info SET student_id = 10002</span><br><span class="line">WHERE NAME = &#x27;48932483749832hihhffd&#x27;;  # 1.01s</span><br><span class="line"></span><br><span class="line">#添加索引</span><br><span class="line">ALTER TABLE student_info ADD INDEX idx_name(NAME);</span><br><span class="line"></span><br><span class="line">UPDATE student_info SET student_id = 10003</span><br><span class="line">WHERE NAME = &#x27;48932483749832hihhffd&#x27;;  # 0.001s</span><br></pre></td></tr></table></figure>

<p>对数据按照某个条件进行查询后再进行UPDATE或DELETE的操作，如果对WHERE字段创建了索引，就能大幅提升效率。&#x3D;&#x3D;原理是因为我们需要先根据WHERE条件检索出来这条记录，然后再对它进行更新或删除。&#x3D;&#x3D;如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p>
<p><strong>5.DISTINCT字段需要创建索引</strong></p>
<ul>
<li><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>
</li>
<li><p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多   。</p>
</li>
</ul>
<p><strong>6.多表JOIN连接操作时，创建索引注意事项</strong></p>
<ul>
<li>首先， 连接表的数量尽量不要超过 3 张 ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</li>
<li>其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</li>
<li>最后， 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在<br>student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。  </li>
<li></li>
</ul>
<p><strong>7.使用列的类型小的创建索引</strong></p>
<p>这里所说的类型大小指的就是该类型表示的数据范围的大小。</p>
<p>这个建议对于主键来说更为适用。因为不仅聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。</p>
<p><strong>8.使用字符串前缀创建索引</strong></p>
<p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引的时候，那就意味着在对应的B+树中有那么两个问题，</p>
<ul>
<li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引占用的存储空间越大</li>
<li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间</li>
</ul>
<p>我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。即节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table shop(address varchar(120) not null);</span><br><span class="line"></span><br><span class="line">alter table shop add index(address(12));</span><br></pre></td></tr></table></figure>

<p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？  </p>
<p>先看一下字段在全部数据中的选择度  ？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct address) / count(*) from shop;</span><br></pre></td></tr></table></figure>

<p>通过不同长度去计算，与全表的选择性对比  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度</span><br><span class="line">count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度</span><br><span class="line">count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度</span><br><span class="line">count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度</span><br><span class="line">from shop;</span><br></pre></td></tr></table></figure>

<p>引申另一个问题：索引前缀对排序的影响</p>
<blockquote>
<p>如果使用了索引列前缀，比方说前边只把address列的前12个字符放到了二级索引中，下边的这个查询可能就有点尴尬</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from shop</span><br><span class="line">order by address</span><br><span class="line">limit 12;</span><br></pre></td></tr></table></figure>

<p>因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，&#x3D;&#x3D;也就是使用索引列前缀的方式无法支持使用索引排序&#x3D;&#x3D;，只能使用文件排序。</p>
</blockquote>
<p><strong>拓展：Alibaba《Java开发手册》</strong></p>
<ul>
<li>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</li>
<li>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达90% 以上 ，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</li>
</ul>
<p><strong>9.区分度高（散列性高）的列适合作为索引</strong></p>
<ul>
<li>列的基数指的是某一列中不重复数据的个数</li>
<li>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</li>
<li>最好为列的基数大的列建立索引，为计数太小列的建立索引效果可能不好。</li>
</ul>
<p>拓展：联合索引把区分度高的列放在前面</p>
<p><strong>10.使用最频繁的列放到联合索引的左侧</strong></p>
<p>最左前缀匹配原则，可以增加联合索引的使用率</p>
<p><strong>11.在多个字段都要创建索引的情况下，联合索引由于单值索引</strong></p>
<h4 id="3-3-限制索引的数目"><a href="#3-3-限制索引的数目" class="headerlink" title="3.3 限制索引的数目"></a>3.3 限制索引的数目</h4><ul>
<li>因为每个索引都需要占用磁盘空间</li>
<li>索引会影响DML的性能，数据的变更，索引也会进行调整和更新，会造成负担</li>
<li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生出一个最好的执行计划，如果同时有多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li>
</ul>
<h4 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h4><p><strong>1.在where中使用不到的字段，不要设置索引</strong></p>
<ul>
<li>索引的价值是快速定位，如果起不到定位的作用是不需要创建索引的</li>
</ul>
<p><strong>2.数据量小的表最好不要使用索引</strong></p>
<p><strong>3.有大量重复数据的列上不要建立索引</strong></p>
<p>例如对于性别这样的列，因为它的区分度低。</p>
<ul>
<li>索引的价值是帮助快速定位。如果想要定位的数据有很多，那么索引就失去了它的使用价值。</li>
</ul>
<blockquote>
<p>结论：当数据重复度大，比如高于10%的时候，也不需要对这个字段使用索引</p>
</blockquote>
<p><strong>4.避免对经常更新的表创建过多的索引</strong></p>
<ul>
<li>虽然提高了查询速度，同时却会降低更新表的速度</li>
</ul>
<p><strong>5.不建议用无序的值作为索引</strong></p>
<p>例如身份证，UUID（在索引比较时需要转为ASCII，并且插入时可能造成页分裂），MD5,HASH,无序长字符串</p>
<p><strong>6.删除不再使用或者很少使用的索引</strong></p>
<p>为了减少索引对更新操作的影响</p>
<p><strong>7.不要定义冗余或重复的索引</strong></p>
<ul>
<li>冗余索引<ul>
<li>比如 index(a,b,c)相当于 index(a),index(a,b),index(a,b,c)</li>
<li>维护冗余索引只会增加维护的成本</li>
</ul>
</li>
<li>重复索引<ul>
<li>例如 unique index(a) 与index(a)</li>
</ul>
</li>
</ul>
<h4 id="3-5小结"><a href="#3-5小结" class="headerlink" title="3.5小结"></a>3.5小结</h4><ul>
<li>索引是一把双刃剑，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。</li>
<li>所以要实际情况选择索引</li>
</ul>
<h2 id="7-性能分析工具的使用"><a href="#7-性能分析工具的使用" class="headerlink" title="7.性能分析工具的使用"></a>7.性能分析工具的使用</h2><p>在数据库调优中，我们的目标就是响应时间快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p>
<h3 id="1-数据库服务器的优化步骤"><a href="#1-数据库服务器的优化步骤" class="headerlink" title="1.数据库服务器的优化步骤"></a>1.数据库服务器的优化步骤</h3><ul>
<li>当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。</li>
<li>整个流程划分成了 观察（Show status） 和 行动（Action） 两个部分。字母 S 的部分代表观察（会使<br>用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</li>
</ul>
<h3 id="2-查看系统性能参数"><a href="#2-查看系统性能参数" class="headerlink" title="2.查看系统性能参数"></a>2.查看系统性能参数</h3><p>在MySQL中，可以使用SHOW STATUS语句查询一些MySQL数据库服务器的性能参数、执行频率。</p>
<p>SHOW STATUS语句语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL | SESSION] STATUS LIKE &#x27;参数&#x27;</span><br></pre></td></tr></table></figure>

<p>一些常用的性能常数如下：</p>
<p>一些常用的性能参数如下：</p>
<ul>
<li>Connections：连接MySQL服务器的次数。 </li>
<li>Uptime：MySQL服务器的上线时间。</li>
<li>Slow_queries：慢查询的次数。 </li>
<li>Innodb_rows_read：Select查询返回的行数 </li>
<li>Innodb_rows_inserted：执行INSERT操作插入的行数 </li>
<li>Innodb_rows_updated：执行UPDATE操作更新的行数 </li>
<li>Innodb_rows_deleted：执行DELETE操作删除的行数</li>
<li>Com_select：查询操作的次数。 </li>
<li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 </li>
<li>Com_update：更新操作的次数。 </li>
<li>Com_delete：删除操作的次数。</li>
</ul>
<p>若查询MySQL服务器的连接次数，则可执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHOW STTUS LIKE &#x27;Connections&#x27;;</span><br><span class="line"></span><br><span class="line">SHOW STTUS LIKE &#x27;Slow_queries&#x27;;</span><br><span class="line">其他的参数类似</span><br></pre></td></tr></table></figure>

<h3 id="3-统计SQL的查询成本：last-query-cost"><a href="#3-统计SQL的查询成本：last-query-cost" class="headerlink" title="3.统计SQL的查询成本：last_query_cost"></a>3.统计SQL的查询成本：last_query_cost</h3><ul>
<li>一条SQL查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择成本最小的一个作为最终执行的执行计划。</li>
<li>如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的&#x3D;&#x3D;last_query_cost&#x3D;&#x3D;变量值来得到当前查询的成本。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本对应的是SQL语句所&#x3D;&#x3D;需要读取的页的数量。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student_info where student_id &gt; 199000</span><br><span class="line">mysql&gt; show status like &quot;last_query_cost&quot;;</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Last_query_cost | 6915.609000 |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student_info where student_id &gt; 199900;</span><br><span class="line">mysql&gt; show status like &quot;last_query_cost&quot;;</span><br><span class="line">+-----------------+------------+</span><br><span class="line">| Variable_name   | Value      |</span><br><span class="line">+-----------------+------------+</span><br><span class="line">| Last_query_cost | 712.209000 |</span><br><span class="line">+-----------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们发现页的数量是刚才差不多10倍左右，但是查询的效率并没有明显的变化，实际上这两个SQL查询的时间基本上一样，就是因为采用了&#x3D;&#x3D;顺序读取的方式将页面一次性加载到缓冲池中&#x3D;&#x3D;，然后再进行查找。虽然页数量（last_query_cost）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。</p>
<p><strong>适用场景：</strong>它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候</p>
<blockquote>
<p>SQL查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p>
<ul>
<li>&#x3D;&#x3D;位置决定效率。&#x3D;&#x3D;如果页就在数据库&#x3D;&#x3D;缓冲池&#x3D;&#x3D;中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li>&#x3D;&#x3D;批量决定效率&#x3D;&#x3D;。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms）,而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存的随机读取。</li>
</ul>
<p>遇到I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到&#x3D;&#x3D;缓冲池&#x3D;&#x3D;中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
</blockquote>
<h3 id="4-定位执行慢的SQL：慢查询日志"><a href="#4-定位执行慢的SQL：慢查询日志" class="headerlink" title="4.定位执行慢的SQL：慢查询日志"></a>4.定位执行慢的SQL：慢查询日志</h3><ul>
<li>MySQL的慢查询日志，用来记录在MySQL中响应时间超过阈值的语句，具体指执行时间超过long_query_time值得SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</li>
<li>它的主要作用是，帮助我们发现哪些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统地整体效率。当我们地数据库服务器发生阻塞，运行变慢地时候，检查一下慢查询日志，找到哪些慢查询，对解决问日很有帮助。</li>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要地话，一般不建议启动该参数。。因为开启慢查询日志或多或少地会影响性能。</li>
<li>慢查询日志支持将日志记录写入文件</li>
</ul>
<h4 id="4-1-开启慢查询日志参数"><a href="#4-1-开启慢查询日志参数" class="headerlink" title="4.1.开启慢查询日志参数"></a>4.1.开启慢查询日志参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 默认是关闭的</span><br><span class="line">mysql&gt; show variables like &quot;%slow_query_log%&quot;;</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                                                               |</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                                                                 |</span><br><span class="line">| slow_query_log_file | D:\program\mysql-5.7.37-winx64\mysql-5.7.37-winx64\sqlData\DESKTOP-CB9TIM0-slow.log |</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 将慢查询日志进行开启</span><br><span class="line">mysql&gt; set global slow_query_log = on;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;%slow_query_log%&quot;;</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                                                               |</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">| slow_query_log      | ON                                                                                  |</span><br><span class="line">| slow_query_log_file | D:\program\mysql-5.7.37-winx64\mysql-5.7.37-winx64\sqlData\DESKTOP-CB9TIM0-slow.log |</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>2.修改long_query_time的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;long_query_time&quot;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改long_query_time的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global long_query_time = 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;long_query_time&quot;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set long_query_time = 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;long_query_time&quot;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>也可以在配置文件 my.cnf文件 中修改这些内容  </p>
<h4 id="4-2-查看慢查询数目"><a href="#4-2-查看慢查询数目" class="headerlink" title="4.2 查看慢查询数目"></a>4.2 查看慢查询数目</h4><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status like &quot;%slow_queries%&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-案例演示"><a href="#4-3-案例演示" class="headerlink" title="4.3 案例演示"></a>4.3 案例演示</h4><p><strong>1.建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`stuno` INT NOT NULL,</span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`age` INT(3) DEFAULT NULL,</span><br><span class="line">`classId` INT(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY(`id`)</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>2.创建函数（这个同上面两个存储函数）</p>
<p><strong>3.创建存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `insert_stu1`(IN `START` int,IN `max_num` int)</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	SET autocommit = 0; # 设置手动提交事务</span><br><span class="line">	REPEAT</span><br><span class="line">	SET i = i + 1;</span><br><span class="line">	INSERT INTO student (stuno,NAME,age,classId) values((START + i),rand_string(6),rand_num(10,100),rand_num(10,1000));</span><br><span class="line">	UNTIL i = max_num</span><br><span class="line">	END REPEAT;</span><br><span class="line">	COMMIT;  # 提交事务</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>4.调用存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#调用刚刚创建的存储过程生成数据,4000000条记录，从100001号开始</span><br><span class="line">CALL insert_stu1(100001,4000000);</span><br></pre></td></tr></table></figure>

<p><strong>5.分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &quot;slow_queries&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>除了上述变量之外，控制慢查询日志的还有一个系统变量：min_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过long_query_time的值，那么，这个查询就被记录到慢查询日志中。</li>
<li>这个值默认是0。这样只要查询的执行时间超过10秒钟，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中来。，也可以根据需要到 my.ini文件中修改。</li>
</ul>
<h4 id="4-5-慢查询日志分析工具：mysqldumpslow"><a href="#4-5-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="4.5 慢查询日志分析工具：mysqldumpslow"></a>4.5 慢查询日志分析工具：mysqldumpslow</h4><ul>
<li><p>在生产环境中，如果要手工分析，显然是个体力活，MySQL提供了日志分析工具 mysqldumpslow</p>
</li>
<li><p>查看mysqldumpslow的帮助信息</p>
</li>
<li><pre><code class="bash"># 这是在windows环境下查看mysqldumpslow的方法
$ perl mysqldumpslow.pl -help

# 这是使用mysqldumpslow工具来定位慢查询SQL
# 举例：我们想要按照查询时间排序，查看前五条 SQL 语句
D:\program\mysql-5.7.37-winx64\mysql-5.7.37-winx64\bin&gt;perl mysqldumpslow.pl -s t -t 5 D:\program\mysql-5.7.37-winx64\mysql-5.7.37-winx64\sqlData\DESKTOP-CB9TIM0-slow.log
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysqldumpslow 命令的具体参数如下：</span><br><span class="line"></span><br><span class="line">- -a: 不将数字抽象成N，字符串抽象成S</span><br><span class="line">- -s: 是表示按照何种方式排序：</span><br><span class="line">- c: 访问次数</span><br><span class="line">- l: 锁定时间</span><br><span class="line">- r: 返回记录</span><br><span class="line">- t: 查询时间</span><br><span class="line">- al:平均锁定时间</span><br><span class="line">- ar:平均返回记录数</span><br><span class="line">- at:平均查询时间 （默认方式）</span><br><span class="line">- ac:平均查询次数</span><br><span class="line">- -t: 即为返回前面多少条的数据；、</span><br><span class="line">- -g: 后边搭配一个正则匹配模式，大小写不敏感的；  </span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">#得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="4-6-关闭慢查询日志"><a href="#4-6-关闭慢查询日志" class="headerlink" title="4.6 关闭慢查询日志"></a>4.6 关闭慢查询日志</h4><p>MySQL服务器停止慢查询日志功能有两种方法</p>
<p><strong>方式1：永久性方式</strong></p>
<p>修改my.cnf或my.ini文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=OFF</span><br><span class="line">或者，把slow_query_log一项注释掉 或 删除</span><br><span class="line">#slow_query_log =OFF</span><br><span class="line"></span><br><span class="line"># 再重启MySQL服务，执行如下语句查询慢日志功能。</span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;; #查询慢查询日志所在目录</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;; #查询超时时长</span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<p>使用set语句来设置</p>
<p>1）停止MySQL慢查询日志功能，具体SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=off;</span><br></pre></td></tr></table></figure>

<p>2）重启MySQL服务，使用show语句查询慢查询日志 功能信息，具体sql如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%slow&quot;;</span><br><span class="line"># 以及</span><br><span class="line">show variables like &quot;%long_query_time%&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linux重启mysql服务命令</span></span><br><span class="line">$ systemctl restart mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows重启  注意要在管理员身份下操作</span></span><br><span class="line">C:\Windows\system32&gt;net stop mysql</span><br><span class="line">MySQL 服务正在停止..</span><br><span class="line">MySQL 服务已成功停止。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;net start mysql</span><br><span class="line">MySQL 服务正在启动 .</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure>

<h4 id="4-7-删除慢查询日志"><a href="#4-7-删除慢查询日志" class="headerlink" title="4.7 删除慢查询日志"></a>4.7 删除慢查询日志</h4><ul>
<li><p>可以手动删除慢查询日志文件</p>
</li>
<li><p>使用命令mysqladmin flush-logs来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件</p>
</li>
<li><pre><code class="bash">$ mysqladmin -uroot -p flush-logs slow
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 注意新建的日志文件只包括在这之后的慢查询日志内容，如果需要之前的必须要进行备份</span><br><span class="line"></span><br><span class="line">### 5.查看SQL执行成本：SHOW  PROFILE</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql&gt; show profils;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;profils&#x27; at line 1</span><br><span class="line"></span><br><span class="line">#显式查询执行成本</span><br><span class="line">mysql&gt; show profiles;</span><br><span class="line">+----------+------------+---------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                       |</span><br><span class="line">+----------+------------+---------------------------------------------+</span><br><span class="line">|        1 | 0.00416575 | show variables like &quot;profiling&quot;             |</span><br><span class="line">|        2 | 2.40017375 | select * from student where name = &quot;JnoEfp&quot; |</span><br><span class="line">|        3 | 0.00058675 | show profils                                |</span><br><span class="line">+----------+------------+---------------------------------------------+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 查询特定子句的执行情况</span><br><span class="line">mysql&gt; show profile for query 2;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.004304 |</span><br><span class="line">| checking permissions | 0.000082 |</span><br><span class="line">| Opening tables       | 0.007239 |</span><br><span class="line">| init                 | 0.000542 |</span><br><span class="line">| System lock          | 0.000016 |</span><br><span class="line">| optimizing           | 0.000012 |</span><br><span class="line">| statistics           | 0.000012 |</span><br><span class="line">| preparing            | 0.000008 |</span><br><span class="line">| executing            | 0.000002 |</span><br><span class="line">| Sending data         | 2.387753 |</span><br><span class="line">| end                  | 0.000011 |</span><br><span class="line">| query end            | 0.000011 |</span><br><span class="line">| closing tables       | 0.000009 |</span><br><span class="line">| freeing items        | 0.000147 |</span><br><span class="line">| cleaning up          | 0.000027 |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">15 rows in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 查询带cpu,io这些指标的情况</span><br><span class="line">mysql&gt; show profile cpu,block io for query 2;</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| starting             | 0.004304 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| checking permissions | 0.000082 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| Opening tables       | 0.007239 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| init                 | 0.000542 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| System lock          | 0.000016 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| optimizing           | 0.000012 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| statistics           | 0.000012 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| preparing            | 0.000008 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| executing            | 0.000002 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| Sending data         | 2.387753 | 2.203125 |   0.390625 |         NULL |          NULL |</span><br><span class="line">| end                  | 0.000011 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| query end            | 0.000011 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| closing tables       | 0.000009 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| freeing items        | 0.000147 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| cleaning up          | 0.000027 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">15 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>日常开发需注意的结论：</p>
<ul>
<li>converting  HEAP to MyISAM; 查询结果太大，内存不够，数据往磁盘上搬了</li>
<li>creating temp table：创建临时表，先拷贝数据到临时表，用完后再删除临时表</li>
<li>copying  to  tmp table  on disk：把内存中临时表复制到磁盘上</li>
<li>locked</li>
</ul>
<p>如果show profile诊断结果中出现了以上4条结果中的任何一条，则需要进行优化</p>
<h3 id="6-分析查询工具：EXPLAIN"><a href="#6-分析查询工具：EXPLAIN" class="headerlink" title="6.分析查询工具：EXPLAIN"></a>6.分析查询工具：EXPLAIN</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><ul>
<li><p>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。这两个工具分析结果是一样的。</p>
</li>
<li><p>MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为最优的，这部分最耗费时间）</p>
</li>
<li><p>这个执行计划展示了接下来具体执行查询的方式，比如夺标连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，看懂EXPLAIN语句的各个输出项，可以有针对性的提升我们查询语句的性能。</p>
</li>
</ul>
<p>1.能做什么？</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>那些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<h4 id="6-2-基本语法"><a href="#6-2-基本语法" class="headerlink" title="6.2 基本语法"></a>6.2 基本语法</h4><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT select_options</span><br><span class="line">或者</span><br><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>

<p>在执行的时候，只是去查询了执行计划，数据库里面并没有真正的执行，例如执行删除，数据仍然在数据库里面</p>
<p>如果我们想看某个查询的执行计划的话，可以在具体的查询语句前边加一个EXPLAIN，就像这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220606200451913.png" alt="image-20220606200451913"></p>
<h4 id="6-3-数据准备"><a href="#6-3-数据准备" class="headerlink" title="6.3 数据准备"></a>6.3 数据准备</h4><p><strong>1.建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE s1 (</span><br><span class="line">id INT AUTO_INCREMENT,</span><br><span class="line">key1 VARCHAR(100),</span><br><span class="line">key2 INT,</span><br><span class="line">key3 VARCHAR(100),</span><br><span class="line">key_part1 VARCHAR(100),</span><br><span class="line">key_part2 VARCHAR(100),</span><br><span class="line">key_part3 VARCHAR(100),</span><br><span class="line">common_field VARCHAR(100),</span><br><span class="line">PRIMARY KEY (id),</span><br><span class="line">INDEX idx_key1 (key1),</span><br><span class="line">UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">INDEX idx_key3 (key3),</span><br><span class="line">INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE s2 (</span><br><span class="line">id INT AUTO_INCREMENT,</span><br><span class="line">key1 VARCHAR(100),</span><br><span class="line">key2 INT,</span><br><span class="line">key3 VARCHAR(100),</span><br><span class="line">key_part1 VARCHAR(100),</span><br><span class="line">key_part2 VARCHAR(100),</span><br><span class="line">key_part3 VARCHAR(100),</span><br><span class="line">common_field VARCHAR(100),</span><br><span class="line">PRIMARY KEY (id),</span><br><span class="line">INDEX idx_key1 (key1),</span><br><span class="line">UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">INDEX idx_key3 (key3),</span><br><span class="line">INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p><strong>2.创建存储函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` FUNCTION `rand_string1`(n INT) RETURNS varchar(255) CHARSET utf8mb4</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">WHILE i &lt; n DO</span><br><span class="line">SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN return_str;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>如果不允许创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global log_bin_trust_function_creators=1;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `insert_s1`(IN min_num INT (10),IN max_num INT (10))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i = i + 1;</span><br><span class="line">INSERT INTO s1 VALUES(</span><br><span class="line">(min_num + i),</span><br><span class="line">rand_string1(6),</span><br><span class="line">(min_num + 30 * i + 5),</span><br><span class="line">rand_string1(6),</span><br><span class="line">rand_string1(10),</span><br><span class="line">rand_string1(5),</span><br><span class="line">rand_string1(10),</span><br><span class="line">rand_string1(10));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `insert_s2`(IN min_num INT (10),IN max_num INT (10))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i = i + 1;</span><br><span class="line">INSERT INTO s2 VALUES(</span><br><span class="line">(min_num + i),</span><br><span class="line">rand_string1(6),</span><br><span class="line">(min_num + 30 * i + 5),</span><br><span class="line">rand_string1(6),</span><br><span class="line">rand_string1(10),</span><br><span class="line">rand_string1(5),</span><br><span class="line">rand_string1(10),</span><br><span class="line">rand_string1(10));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>4.调用存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 调用存储过程往表中添加数据</span><br><span class="line"># 往两张表中各添加10000条数据</span><br><span class="line">CALL insert_s1(10001,10000);</span><br><span class="line"></span><br><span class="line">CALL insert_s2(10001,10000);</span><br></pre></td></tr></table></figure>

<h4 id="6-4-EXPLAIN各列作用"><a href="#6-4-EXPLAIN各列作用" class="headerlink" title="6.4 EXPLAIN各列作用"></a>6.4 EXPLAIN各列作用</h4><h5 id="1-table"><a href="#1-table" class="headerlink" title="1.table"></a><strong>1.table</strong></h5><p>不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）  </p>
<h5 id="2-id"><a href="#2-id" class="headerlink" title="2.id"></a><strong>2.id</strong></h5><p>我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比如下边这个查询语句  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">######查询优化器可能对涉及子查询的查询语句进行重写,转变为多表查询的操作########</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">#Union去重</span><br><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br><span class="line"></span><br><span class="line"># UNION ALL不用去重,所以不会生成临时表</span><br><span class="line">EXPLAIN SELECT * FROM s1  UNION ALL SELECT * FROM s2;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ul>
<h5 id="3-select-type"><a href="#3-select-type" class="headerlink" title="3.select_type"></a><strong>3.select_type</strong></h5><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220606203721478.png" alt="image-20220606203721478"></p>
<h5 id="4-partition"><a href="#4-partition" class="headerlink" title="4.partition"></a>4.partition</h5><p><strong>5.type</strong> *</p>
<p>执行计划的一条记录就代表着MySQL对某个表的执行查询时的访问方法，又称访问类型，其中的type列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到type列的值是ref，表明MySQL即将使用ref访问方法来执行对s1表的查询。</p>
<p>&#x3D;&#x3D;完整的访问方法如下：system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ，index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL 。&#x3D;&#x3D;  </p>
<p>性能分析工具的使用：待看</p>
<h2 id="8-索引优化与查询优化"><a href="#8-索引优化与查询优化" class="headerlink" title="8.索引优化与查询优化"></a>8.索引优化与查询优化</h2><p>都有哪些维度可以进行数据库调优？简言之：</p>
<ul>
<li>索引失效，没有充分利用到索引——索引建立</li>
<li>关联查询太多join(设计缺陷或不得已的需求)——SQL优化</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li>
<li>数据过多——分库分表</li>
</ul>
<p>SQL查询优化主要可以分为物理查询优化和逻辑查询优化两大块</p>
<ul>
<li>物理查询优化是通过&#x3D;&#x3D;索引和表连接方式&#x3D;&#x3D;等技术来进行优化，这里重点掌握索引的使用</li>
<li>逻辑查询优化就是通过&#x3D;&#x3D;SQL等价变换&#x3D;&#x3D;提升查询效率，直白点说就是换一种查询写法执行效率可能更高</li>
</ul>
<h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1.数据准备"></a>1.数据准备</h3><h3 id="2-索引失效案例"><a href="#2-索引失效案例" class="headerlink" title="2.索引失效案例"></a>2.索引失效案例</h3><p>MySQL中提高性能的一个最有效的方式就是对数据表设计合理的索引。其实用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销，它不是基于规则，也不是基于语义。怎么样开销小就怎么来。另外SQL语句是否使用索引，跟数据库版本、数据量、数据选择都都有关系。</p>
<h4 id="1-全值匹配"><a href="#1-全值匹配" class="headerlink" title="1.全值匹配"></a><strong>1.全值匹配</strong></h4><ul>
<li>不要写不加查询条件地查询语句</li>
</ul>
<h4 id="2-最佳左前缀匹配规则"><a href="#2-最佳左前缀匹配规则" class="headerlink" title="2.最佳左前缀匹配规则"></a><strong>2.最佳左前缀匹配规则</strong></h4><ul>
<li>这个主要针对的是联合索引，是从左至右开始进行匹配的，如果最左边没有则直接没有。</li>
<li>注意这与我们选择的顺序没有关系，即语句中写的旁边的name与age的顺序没有关系。<ul>
<li>比如 select * from student where age &#x3D; 1 and  name&#x3D;’hello’;</li>
</ul>
</li>
<li>必须要从左至右进行匹配，如果有一个不匹配，则只使用了前面匹配到的部分（只会使用到联合索引的一部分）</li>
</ul>
<h4 id="3-主键插入顺序"><a href="#3-主键插入顺序" class="headerlink" title="3.主键插入顺序"></a><strong>3.主键插入顺序</strong></h4><ul>
<li>尽可能地让主键值依次递增，例如 让主键列具备auto_increment。</li>
</ul>
<h4 id="4-计算、函数、类型转换（自动或手动）导致索引失败"><a href="#4-计算、函数、类型转换（自动或手动）导致索引失败" class="headerlink" title="4.计算、函数、类型转换（自动或手动）导致索引失败"></a><strong>4.计算、函数、类型转换（自动或手动）导致索引失败</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 此语句比下一条语句 能够使用上索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br><span class="line"></span><br><span class="line"># 因为使用了函数，所以就用不上索引了，在执行时是从数据库中一条一条地拿数据去进行比较</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br><span class="line"></span><br><span class="line"># 索引会失效，因为会先逐条拿数据进行计算后再进行比较</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;</span><br><span class="line"></span><br><span class="line"># 会用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno = 900000;</span><br><span class="line"></span><br><span class="line"># 未使用到索引   name=123发生类型转换，索引失效。</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;</span><br><span class="line"></span><br><span class="line"># 使用到索引 </span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="5-范围条件右边的列索引失效"><a href="#5-范围条件右边的列索引失效" class="headerlink" title="5.范围条件右边的列索引失效"></a><strong>5.范围条件右边的列索引失效</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 范围条件右边的列索引失效，指的是name字段，注意classId这个列的索引用上了。这主要是针对一个拥有（age,classId,name）这个联合索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student</span><br><span class="line">WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ;</span><br><span class="line"></span><br><span class="line">#如果我们要使三个字段的索引全部生效，可以把联合索引的位置建成（age,name,classId）,将范围条件的列放在最右边，这样就能全部起作用了</span><br></pre></td></tr></table></figure>

<h4 id="6-不等于（-或者）索引失效"><a href="#6-不等于（-或者）索引失效" class="headerlink" title="6.不等于（!&#x3D;或者&lt;&gt;）索引失效"></a><strong>6.不等于（!&#x3D;或者&lt;&gt;）索引失效</strong></h4><ul>
<li>在8.0失效了</li>
</ul>
<h4 id="7-is-null可以使用索引，is-not-null无法使用索引"><a href="#7-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="7.is null可以使用索引，is not null无法使用索引"></a><strong>7.is null可以使用索引，is not null无法使用索引</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注意使用count时 索引就不失效了</span><br><span class="line"></span><br><span class="line"># 索引不失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE count(*) from student WHERE age IS NOT NULL;</span><br><span class="line"></span><br><span class="line"># 索引失效了</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * from student WHERE age IS NOT NULL;</span><br></pre></td></tr></table></figure>



<ul>
<li>结论：最好在设计数据表的时候就将字段设置为NOT NULL约束，比如你可以将INT类型的字段，默认设置为0，将字符类型的默认设置为空字符串（’ ‘）</li>
<li>拓展：同理，在查询中使用not like也无法使用索引，导致全表扫描</li>
</ul>
<h4 id="8-like以通配符-开头索引失效"><a href="#8-like以通配符-开头索引失效" class="headerlink" title="8.like以通配符%开头索引失效"></a><strong>8.like以通配符%开头索引失效</strong></h4><ul>
<li>因此页面搜索引擎中严禁左模糊或全模糊</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#索引失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * from student WHERE NAME LIKE &#x27;%abc&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#不失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * from student WHERE NAME LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="9-OR-前后存在非索引的列，索引失效"><a href="#9-OR-前后存在非索引的列，索引失效" class="headerlink" title="9.OR 前后存在非索引的列，索引失效"></a><strong>9.OR 前后存在非索引的列，索引失效</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br></pre></td></tr></table></figure>

<h4 id="10-数据库和表的字符集统计使用utf8mb4"><a href="#10-数据库和表的字符集统计使用utf8mb4" class="headerlink" title="10.数据库和表的字符集统计使用utf8mb4"></a><strong>10.数据库和表的字符集统计使用utf8mb4</strong></h4><p>统一使用utf8mb4(5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较浅需要进行转换会造成索引失效。</p>
<p>一般性建议：</p>
<ul>
<li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前query中过滤性更好的字段在索引字段顺序中，位置越靠前越好</li>
<li>在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引</li>
<li>在选择组合索引的时候，如果某个字段可能出现范围查询的时候，尽量把这个字段放在索引次序的最后面</li>
</ul>
<h3 id="3-关联查询优化"><a href="#3-关联查询优化" class="headerlink" title="3.关联查询优化"></a>3.关联查询优化</h3><h4 id="3-1左外连接"><a href="#3-1左外连接" class="headerlink" title="3.1左外连接"></a>3.1左外连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># type表是驱动表，book表是被驱动表</span><br><span class="line"># 左外连接</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br><span class="line"></span><br><span class="line">#给被驱动表添加索引，可以避免全表扫描</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from student LEFT JOIN class ON student.name = class.className;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                                              |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499126 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | class   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   9952 |   100.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220607162534461.png" alt="image-20220607162534461"></p>
<h4 id="3-2内连接"><a href="#3-2内连接" class="headerlink" title="3.2内连接"></a>3.2内连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在进行内连接的时候，优化器有权利来决定谁是驱动表与谁是被驱动表。这个主要取决于谁的数据量大。</span><br><span class="line"># 数据量小的作为驱动表</span><br><span class="line">EXPLAIN SELECT * from student INNER JOIN class ON student.name = class.className;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对于内连接来讲，如果表的连接条件中只能由一个字段有索引，则有索引的字段所在的表会被作为被驱动表出现。</li>
<li>在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表，也就是小表驱动大表。</li>
</ul>
<h4 id="3-3-join语句原理"><a href="#3-3-join语句原理" class="headerlink" title="3.3 join语句原理"></a>3.3 join语句原理</h4><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环（nested Loop Join）。如果关联表的数据量很大，则join关联的执行时间会非常长。在MySQL5.5以后的版本中，&#x3D;&#x3D;MySQL通过引入BNLJ算法来优化嵌套执行&#x3D;&#x3D;</p>
<p><strong>1.驱动表和被驱动表</strong></p>
<p>驱动表就是主表，被驱动表就是从表，非驱动表</p>
<ul>
<li>对于内连接来说</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  *  FROM  A  JOIN B  ON ...</span><br></pre></td></tr></table></figure>

<p>A一定是驱动表吗？不一定，优化器会根据你查询语句做优化，决定先查哪张表，先查询的那张表就是驱动表，反之就是被驱动表。通过EXPLAIN关键字来查看。</p>
<ul>
<li>对于外连接来说</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT  *  FROM  A  LEFT  JOIN B  ON ...</span><br><span class="line"></span><br><span class="line">SELECT  *  FROM  B  RIGHT  JOIN A  ON ...</span><br></pre></td></tr></table></figure>

<p>通常大家会认为A就是驱动表，B就是被驱动表，但也未必，测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE a(</span><br><span class="line">f1 INT,</span><br><span class="line">f2 INT,</span><br><span class="line">INDEX(f1)</span><br><span class="line">)ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE b(</span><br><span class="line">f1 INT,</span><br><span class="line">f2 INT</span><br><span class="line">)ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO a VALUES(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);</span><br><span class="line">INSERT INTO b VALUES(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试1  因为后面的where语句的原因，这里面的驱动表是b,被驱动表是a。因为a有索引。【主要是查询后的结果集a更小】</span><br><span class="line"># 查询优化器是帮我们把这个左外连接转化为了内连接 </span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON (a.f1 = b.f1) WHERE (a.f2 = b.f2);</span><br><span class="line"></span><br><span class="line">#测试2  此时索引会失效a还是作为驱动表</span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON (a.f1 = b.f1) AND (a.f2 = b.f2);</span><br><span class="line"></span><br><span class="line"># 测试3  内连接 默认都是内连接  此时也是a为被驱动表</span><br><span class="line">EXPLAIN SELECT * FROM a JOIN b ON (a.f1 = b.f1) WHERE (a.f2 = b.f2);</span><br></pre></td></tr></table></figure>

<p><strong>2.Simple Nested-Loop join(简单嵌套循环连接)</strong></p>
<ul>
<li>算法相当简单，从表A中取出一条数据1，遍历表B,将匹配到的数据放到result，以此类推，驱动表A中的每一条记录与被驱动表中的记录进行判断</li>
<li>可以看到这种方式效率还是比较低的，所以就出现了后面的两种对Nested-Loop Join优化算法</li>
</ul>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表【A,驱动表】扫描次数</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A(A表中的记录数)</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A+A*B</td>
</tr>
<tr>
<td>JOIN比较次数</td>
<td>B*A</td>
</tr>
<tr>
<td>回表读取记录数</td>
<td>0 【因为没有索引，所以不涉及到回表操作】</td>
</tr>
</tbody></table>
<p><strong>3.Index Nested_Loop Join(索引嵌套循环连接)</strong></p>
<ul>
<li>Index Nested——Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大地减少了对内层表的匹配次数</li>
<li>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）</li>
</ul>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表【A,驱动表】扫描次数</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A(A表中的记录数)</td>
<td>0</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A+A*B</td>
<td>A+B(match)</td>
</tr>
<tr>
<td>JOIN比较次数</td>
<td>B*A</td>
<td>A*Index(Height)【索引扫描的层数】</td>
</tr>
<tr>
<td>回表读取记录数</td>
<td>0 【因为没有索引，所以不涉及到回表操作】</td>
<td>B(match) [如果需要的话]</td>
</tr>
</tbody></table>
<ul>
<li>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行依次回表查询，相比，被驱动表的索引是主键索引，效率会更高</li>
</ul>
<p><strong>4.Block Nested-Loop Join(块嵌套循环连接)</strong></p>
<ul>
<li>如果存在索引，那么会使用index的方式进行join，如果join的列没有所有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的数据都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载中匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested_Loop Join的方式</li>
<li>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了&#x3D;&#x3D;join buffer缓冲区&#x3D;&#x3D;，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的&#x3D;&#x3D;每一条记录一次性和join buffer中的所有驱动表记录&#x3D;&#x3D;进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>这里缓存的不只是关联表的列，select后面的列也会缓存起来</p>
<p>在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列</p>
</blockquote>
<p>参数设置：</p>
<ul>
<li>block_nested_loop：通过查看block_nested_loop状态。默认是开启的</li>
<li>join_buffer_size:驱动表的数据能不能一次性加载完，要看join buffer能不能存储所有的数据，默认情况下join_buffer_size&#x3D;256K..</li>
</ul>
<p><strong>5.join小结</strong></p>
<p>&#x3D;&#x3D;1.整体效率比较：INLJ&gt;BNLJ&gt;SNLJ&#x3D;&#x3D;</p>
<p>2.永远用小&#x3D;&#x3D;结果集&#x3D;&#x3D;驱动大结果集（其本质是减少&#x3D;&#x3D;外层循环&#x3D;&#x3D;的数据数量）（小的度量单位指的是表行数*每行大小）</p>
<p>3.为被驱动表匹配的条件增加索引（减少内存表的循环匹配次数）</p>
<p>4.增加join buffer size的大小（一次缓存的数据越多，那么内存包的扫描次数就越少）</p>
<p>5.减少驱动表不必要的字段查询（字段越少，join  buffer所缓存的数据就越多）</p>
<p><strong>6.Hash Join</strong></p>
<ul>
<li><p>这是MySQL8.0新特性</p>
</li>
<li><p>从MySQL8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash  join</p>
</li>
<li><p>Nested Loop：对于被连接的数据子集较小的情况，Nested Loop是一个较好的选择</p>
</li>
<li><p>Hash Join是做&#x3D;&#x3D;大数据集连接&#x3D;&#x3D;时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立&#x3D;&#x3D;散列表&#x3D;&#x3D;，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p>
<ul>
<li>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I&#x2F;O的性能</li>
<li>它能够很好的工作于没有索引的达标和并行查询的环境中，并提高最好的性能。大多数人都说它是join的重型升降机。&#x3D;&#x3D;Hash Join只能应用于等值连接&#x3D;&#x3D;（如where A.col1 &#x3D; B.COL2），这是由Hash的特点决定的</li>
</ul>
</li>
</ul>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li>保证被驱动表的JOIN字段已经创建了索引</li>
<li>需要JOIN 的字段，数据类型保持绝对一致。</li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
<h3 id="4-子查询优化"><a href="#4-子查询优化" class="headerlink" title="4.子查询优化"></a>4.子查询优化</h3><ul>
<li><p>MySQL从4.1版本开始支持子查询，使用子查询可以继续宁select语句的嵌套查询，即一个select查询的结果作为另一个select语句的条件。&#x3D;&#x3D;子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作&#x3D;&#x3D;。</p>
</li>
<li><p>子查询虽然可以帮助我们通过一个SQL语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：</p>
<ul>
<li>执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表<br>中查询记录。查询完毕后，再 撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</li>
<li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会<br>受到一定的影响。</li>
<li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li>
</ul>
</li>
<li><p>在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询 不需要建立临时表 ，其 速度比子查询要快 ，如果查询中使用索引的话，性能就会更好。</p>
</li>
</ul>
<blockquote>
<p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#不推荐使用</span><br><span class="line">EXPLAIN SELECT * FROM student stu1</span><br><span class="line">WHERE stu1.stuno IN (</span><br><span class="line">	SELECT monitor</span><br><span class="line">	FROM class c</span><br><span class="line">	WHERE monitor IS NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#将上面语句改造成多表查询</span><br><span class="line">EXPLAIN SELECT * FROM student stu1 JOIN class c ON stu1.stuno = c.monitor WHERE c.monitor IS NOT NULL; </span><br></pre></td></tr></table></figure>

<h3 id="5-排序索引"><a href="#5-排序索引" class="headerlink" title="5.排序索引"></a>5.排序索引</h3><ul>
<li>问题：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</li>
<li>回答：<ul>
<li>在MySQL中，支持两种排序方式，分别是FileSort和Index排序<ul>
<li>Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高</li>
<li>FileSort排序则一般在&#x3D;&#x3D;内存中&#x3D;&#x3D;进行排序，&#x3D;&#x3D;占用CPU较多&#x3D;&#x3D;。如果待排结果较大，会产生临时文件IO到磁盘进行排列的情况，频率较低。</li>
</ul>
</li>
</ul>
</li>
<li>优化建议：<ul>
<li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，&#x3D;&#x3D;&#x3D;&#x3D;目的是在 WHERE 子句中 避免全表扫<br>描&#x3D;&#x3D; ，在 ORDER BY 子句 避免使用 FileSort 排序 。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 删除除主键之外的索引</span><br><span class="line">CALL proc_drop_index(&quot;atguigudb2&quot;,&quot;student&quot;);</span><br><span class="line">CALL proc_drop_index(&quot;atguigudb2&quot;,&quot;class&quot;);</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM student;</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM class;</span><br><span class="line"></span><br><span class="line"># 过程1 </span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classId;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classId  LIMIT 10;</span><br><span class="line"></span><br><span class="line"># 创建索引</span><br><span class="line">CREATE INDEX idx_age_classId_name ON student (age,classId,NAME);</span><br><span class="line"></span><br><span class="line"># 不限制 索引失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classId;</span><br><span class="line"></span><br><span class="line"># 加上 limit限制，会使用索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classId  LIMIT 10;</span><br></pre></td></tr></table></figure>

<ul>
<li>order by时规则不一致，索引失效（顺序错【最左前缀匹配】不索引：方向反，不索引【这里的方向指的是字段是升序还是降序，要不排序的字段全降序或者全升序】）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line">order by 能使用索引最左前缀</span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a,b</span><br><span class="line">- ORDER BY a,b,c</span><br><span class="line">- ORDER BY a DESC,b DESC,c DESC</span><br><span class="line">如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br><span class="line">不能使用索引进行排序</span><br><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>案例实战</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt; 101000 ORDER BY NAME;</span><br><span class="line"></span><br><span class="line"># 方案1：为了去掉filesort我们可以把索引建成</span><br><span class="line">CREATE INDEX idx_age_name ON student(age,NAME);</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt; 101000 ORDER BY NAME;</span><br><span class="line"></span><br><span class="line">#方案2：</span><br><span class="line">CREATE INDEX idx_age_stuno_name ON student(age,stuno,NAME);</span><br><span class="line"># 再次执行，虽然使用filesort进行排序，但是查询效果比上面不用filesort的效果好。这是因为where条件已经过滤掉了大部分数据，所以就不用在order by字段上再进行索引，可以直接通过filesort就行</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt; 101000 ORDER BY NAME;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：</p>
<ul>
<li>两个索引同时存在，mysql自动选择最优的方案。（对于这个例子，mysql选择idx_age_stuno_name）。但是， 随着数据量的变化，选择的索引也会随之变化的 。</li>
<li>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li>
</ul>
</blockquote>
<p>思考：这里我们使用如下索引，是否可行？  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_age_stuno_name ON student;</span><br><span class="line"># 针对上面的例子，使用下面的索引也是可以的，与上面那个联合索引效果一样</span><br><span class="line">CREATE INDEX idx_age_stuno ON student(age,stuno);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Filesort算法，双路排序和单路排序</strong></li>
</ul>
<p>排序的字段若不在索引列上，则filesort会有两种算法：双路排序和单路排序</p>
<p>&#x3D;&#x3D;双路排序（慢）&#x3D;&#x3D;</p>
<ul>
<li>&#x3D;&#x3D;MySQL 4.1之前是使用双路排序&#x3D;&#x3D; ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和&#x3D;&#x3D;order by列&#x3D;&#x3D; ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li>
<li>从磁盘取排序字段，在buffer进行排序，再从 磁盘取其他字段 。</li>
</ul>
<p>取一批数据，要对&#x3D;&#x3D;磁盘进行两次扫描&#x3D;&#x3D;，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。  </p>
<p>&#x3D;&#x3D;单路排序（快）&#x3D;&#x3D;</p>
<p>从磁盘读取查询需要的 &#x3D;&#x3D;所有列&#x3D;&#x3D; ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输<br>出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空<br>间， 因为它把每一行都保存在内存中了。  </p>
<p><strong>结论及引申出的问题：</strong></p>
<ul>
<li>由于单路是后出的，总体而言好过双路</li>
<li>但是用单路有问题：<ul>
<li>在sort_buffer中，单路比多路多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次IO</li>
<li>单路本来想省一次IO操作，反而导致了大量的IO操作反而得不偿失。</li>
</ul>
</li>
</ul>
<p><strong>优化策略：</strong></p>
<p>1.尝试提高sort_buffer_size，默认是1M</p>
<ul>
<li><pre><code class="mysql">show variables like &quot;%sort_buffer_size&quot;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.尝试提高max_length_for_sort_data</span><br><span class="line"></span><br><span class="line">- 默认大小也是1M,.提高这个参数，会增加用改进算法的概率。</span><br><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  show variables like &quot;%max_length_for_sort_data%&quot;;  #默认是1024字节</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>但是如果设的太高，数据总容量超出sort_buffer_size就会增大，从而导致一个低的CPU利用率。ruguo 超过了就使用双路的。</p>
</li>
</ul>
<p>3.Order by 时select * 是一个大忌。最好只Query需要的字段。  </p>
<ul>
<li>两种算法的数据都有可能超出sort_buffer_size的容量，超出之后，会创建tmp文件进行合并排序，导致多次io,但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size.</li>
</ul>
<h3 id="6-group-by优化"><a href="#6-group-by优化" class="headerlink" title="6.group by优化"></a>6.group by优化</h3><ul>
<li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则。</li>
<li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</li>
<li>where效率高于having，能写在where限定的条件就不要写在having中了</li>
<li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li>
</ul>
<h3 id="7-优化分页查询"><a href="#7-优化分页查询" class="headerlink" title="7.优化分页查询"></a>7.优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头痛的问题就是limit 2000000,10，此时需要MySQL排序前2000010记录，仅仅返回2000000-2000010条的记录，其他记录丢弃，查询排序的代价非常大</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student LIMIT 2000000,10;</span><br><span class="line"></span><br><span class="line"># 优化思路1</span><br><span class="line"># 在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</span><br><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a where t.id = a.id;</span><br><span class="line"></span><br><span class="line"># 优化思路2</span><br><span class="line"># 该方案适用于主键自增的表，可以把limit查询转换成某个位置的查询</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure>

<h3 id="8-优先覆盖索引"><a href="#8-优先覆盖索引" class="headerlink" title="8.优先覆盖索引"></a>8.优先覆盖索引</h3><h4 id="8-1-什么是覆盖索引？"><a href="#8-1-什么是覆盖索引？" class="headerlink" title="8.1 什么是覆盖索引？"></a>8.1 什么是覆盖索引？</h4><ul>
<li>理解方式一：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。&#x3D;&#x3D;一个索引包含了满足查询结果的数据就叫做覆盖索引。&#x3D;&#x3D;</li>
<li>理解方式二：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</li>
<li>简单说就是， &#x3D;&#x3D;索引列+主键 包含 SELECT 到 FROM之间查询的列 。&#x3D;&#x3D;</li>
</ul>
<h4 id="8-2-覆盖索引的利弊"><a href="#8-2-覆盖索引的利弊" class="headerlink" title="8.2 覆盖索引的利弊"></a>8.2 覆盖索引的利弊</h4><p><strong>好处：</strong></p>
<ul>
<li>&#x3D;&#x3D;避免Innodb表进行索引的二 次查询（回表）&#x3D;&#x3D;<ul>
<li>innodb是以聚簇索引的顺序来存储的，对于innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需要通过主键进行二次查询才能获取我们真实所需要的数据</li>
<li>在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率。</li>
</ul>
</li>
<li>可以把随机IO变成顺序IO加快查询效率<ul>
<li>因为回表后的主键存储的记录在聚簇索引中，所以在回表时是一种随机读取的IO.</li>
<li>由于覆盖索引是按键值的顺序存储的，所以是顺序IO</li>
<li>由于覆盖索引可以减少树的搜索次数，显著提升查询性能。</li>
</ul>
</li>
</ul>
<p><strong>弊端：</strong></p>
<ul>
<li>索引字段的维护 总是有代价的。因此，在建立多余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</li>
</ul>
<h3 id="9-如何给字符串加索引"><a href="#9-如何给字符串加索引" class="headerlink" title="9.如何给字符串加索引"></a>9.如何给字符串加索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 普通索引，不加前缀索引，就是整个字符串长度</span><br><span class="line">mysql&gt; alter table teacher add index index1(email);</span><br><span class="line"># 前缀索引</span><br><span class="line">mysql&gt; alter table teacher add index index2(email(6));</span><br></pre></td></tr></table></figure>

<p>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。前面已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。  </p>
<blockquote>
<p>结论：</p>
<p>使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。  </p>
</blockquote>
<h3 id="10-索引下推"><a href="#10-索引下推" class="headerlink" title="10.索引下推"></a>10.索引下推</h3><h4 id="10-1-使用前后对比"><a href="#10-1-使用前后对比" class="headerlink" title="10.1 使用前后对比"></a>10.1 使用前后对比</h4><p>Index Condition Pushdown(ICP)是MySQL5.6中的新特性，是一种在存储引擎层使用索引过滤数据的优化方式。</p>
<ul>
<li>如果没有ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给MySQL服务器，由服务器评估where后面的条件是否保留行</li>
<li>启用ICP后，如果部分where条件可以仅使用索引中的列进行筛选，则MySQL服务器会把这部分where条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有满足这一条件时才从表中读取行。<ul>
<li>好处：ICP可以减少存储引擎必须访问基表的次数和MySQL服务器必须访问存储引擎的次数</li>
<li>但是，ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 举例2</span><br><span class="line">CREATE INDEX idx_zip_last_first ON people(zipcode,lastname,firstname);</span><br><span class="line"></span><br><span class="line"># 在没有索引下推的情况下，就只有使用联合索引中的zipcode字段进行查询后，其中lastname LIKE &quot;%张%&quot;不符合索引的情况，以及address也不符合，所以假设查询出10000条数据后就进行回表操作</span><br><span class="line"></span><br><span class="line"># 但是在有索引下推的情况下，虽然对于这个%张%这个过滤条件用不到索引，但是在索引下推的情况下，就可以zipcode过滤完后的结果里面使用lastname=&quot;%张%&quot;这个过滤条件后再去进行回表</span><br><span class="line">EXPLAIN SELECT * FROM people WHERE zipcode = &#x27;100001&#x27; AND lastname LIKE &quot;%张%&quot; AND address LIKE &quot;%北京市%&quot;；</span><br></pre></td></tr></table></figure>

<h4 id="10-2-ICP的开启和关闭"><a href="#10-2-ICP的开启和关闭" class="headerlink" title="10.2  ICP的开启和关闭"></a>10.2  ICP的开启和关闭</h4><ul>
<li><p>默认情况下启用索引条件下推，可以通过系统变量 optimizer——switch控制：index_condition_pushdown</p>
</li>
<li><pre><code class="mysql">#关闭索引下推
set optimizer_switch = &#39;index_condition_pushdown=off&#39;;

# 打开索引下推
set optimizer_switch = &#39;index_condition_pushdown=on&#39;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用了，在extra里面就会有 use index condition</span><br><span class="line"></span><br><span class="line">#### 10.3 ICP的使用条件</span><br><span class="line"></span><br><span class="line">- 如果表访问的类型为range，ref，eq_ref和ref_or_null可以使用ICP</span><br><span class="line"></span><br><span class="line">- ICP可以用于InnoDB和MyISAM表</span><br><span class="line"></span><br><span class="line">- 只能用于二级索引(secondary index)</span><br><span class="line">- 并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录</span><br><span class="line">  到server端做where过滤。</span><br><span class="line">-  MySQL 5.6版本的不支持分区表的ICP功能，5.7版本的开始支持。</span><br><span class="line">- 当SQL使用覆盖索引时，不支持ICP优化方法。  </span><br><span class="line"></span><br><span class="line">### 11.普通索引 VS 唯一索引</span><br><span class="line"></span><br><span class="line">#### 11.1 查询过程</span><br><span class="line"></span><br><span class="line">假设，执行查询的语句是 select id from test where k=5。</span><br><span class="line"></span><br><span class="line">- 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</span><br><span class="line"></span><br><span class="line">- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</span><br><span class="line"></span><br><span class="line">那么，这个不同带来的性能差距会有多少呢？答案是， 微乎其微 。  </span><br><span class="line"></span><br><span class="line">#### 11.2 更新过程</span><br><span class="line"></span><br><span class="line">- 为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下==change buffer==。</span><br><span class="line">- 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下， **InooDB会将这些更新操作缓存在change buffer中 ，这样就不需要从磁盘中读入这个数据页了**。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</span><br><span class="line">- 将change buffer中的操作应用到原数据页，得到最新结果的过程称为 ==merge== 。除了 ==访问这个数据页 会触发merge==外，系统有 ==后台线程会定期 merge==。在 数据库==正常关闭==（shutdown） 的过程中，也会执行merge操作。</span><br><span class="line">- 如果能够将更新操作先记录在change buffer， ==减少读磁盘== ，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 ==避免占用内存== ，提高内存利用率。</span><br><span class="line">- ==唯一索引的更新就不能使用change buffer ，实际上也只有普通索引可以使用==。  </span><br><span class="line"></span><br><span class="line">#### 11.3 change buffer的使用场景</span><br><span class="line"></span><br><span class="line">- 普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是对 ==更新性能 的影响==。所以，==建议你 尽量选择普通索引== 。</span><br><span class="line">- 在实际使用中会发现， ==普通索引 和 change buffer 的配合使用==，对于 数据量大 的表的更新优化还是很明显的。</span><br><span class="line">-  如果**所有的更新后面，都马上 伴随着对这个记录的查询** ，那么你应该 关闭change buffer 。而在其他情况下，change buffer都能提升更新性能。</span><br><span class="line">- 由于唯一索引用不上change buffer的优化机制，因此如果 业务可以接受 ，从性能角度出发建议优先考虑非唯一索引。但是如果&quot;业务可能无法确保&quot;的情况下，怎么处理呢？</span><br><span class="line">- 首先， **业务正确性优先** 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能问题。如果业务不能保证，或者**业务就是要求数据库来做约束，那么没得选，必须创建唯一索引**。</span><br><span class="line">- 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一个排查思路。</span><br><span class="line">- 然后，在一些**“ 归档库 ”**的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。**要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。**  </span><br><span class="line"></span><br><span class="line">### 12.其他查询优化策略</span><br><span class="line"></span><br><span class="line">#### 12.1 EXISTS 和 IN的区分</span><br><span class="line"></span><br><span class="line">**问题：**</span><br><span class="line"></span><br><span class="line">不太理解那种情况下应该使用EXISTS，那种情况下应该用IN，选择的标准是看能否使用表的索引吗？</span><br><span class="line"></span><br><span class="line">**回答：**</span><br><span class="line"></span><br><span class="line">索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</span><br><span class="line"></span><br><span class="line">比如下面这样：</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">select * from A where cc IN (select cc from B);</span><br><span class="line"></span><br><span class="line">select * from A where exists (select * from B where B.cc = A.cc);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>当A小于B时，用EXISTS。因为exists的实现，相当于外表循环，实现的逻辑类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in A</span><br><span class="line">	<span class="keyword">for</span>	j in B</span><br><span class="line">		<span class="keyword">if</span> j.cc == i.cc then</span><br></pre></td></tr></table></figure>

<p>当B小于A时用IN,因为实现的逻辑类似于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in B</span><br><span class="line">	<span class="keyword">for</span>	j in A</span><br><span class="line">		<span class="keyword">if</span> j.cc == i.cc then</span><br></pre></td></tr></table></figure>

<p>哪个表小就用哪个表来驱动，A表小就用EXISTS,B表小就用IN.</p>
<h4 id="12-2-COUNT-与COUNT-具体字段-效率"><a href="#12-2-COUNT-与COUNT-具体字段-效率" class="headerlink" title="12.2 COUNT(*)与COUNT(具体字段)效率"></a>12.2 COUNT(*)与COUNT(具体字段)效率</h4><p>问题：在 MySQL 中统计数据表的行数，可以使用三种方式： SELECT COUNT(*) 、 SELECT COUNT(1) 和<br>SELECT COUNT(具体字段) ，使用这三者之间的查询效率是怎样的？  </p>
<p><strong>环节1：</strong>count(* )和count(1)都是对所有结果进行COUNT，COUNT(*) 和count(1)本质上没有区别（可能执行时间上有细微差别，但差不多）。如果有where子句，则是对所有符合筛选条件的数据进行统计。如果没有where子句，则是对数据表的数据行数进行 统计。</p>
<p><strong>环节2：</strong>如果是myisam引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张myisam的数据表都有一个meta信息存储了row_count的值，而一致性则由&#x3D;&#x3D;表级锁&#x3D;&#x3D;来保证。</p>
<p>如果是Innodb存储引擎，因为Innodb支持事务，采用&#x3D;&#x3D;行级锁和MVCC机制&#x3D;&#x3D;，所以无法像myisam一样，维护一个row_count变量，因此需要采用扫描全表，是O(n)的复杂度，进行循环+计数的方式来完成统计</p>
<p><strong>环节3：</strong>在innodb引擎中，&#x3D;&#x3D;如果采用count(具体字段)来统计数据行数，要尽量采用二级索引&#x3D;&#x3D;。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于count(*)和count(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。</p>
<p>如果有多个二级索引，会使用key_length小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引，来进行统计。</p>
<h4 id="12-3-关于select"><a href="#12-3-关于select" class="headerlink" title="12.3  关于select *"></a>12.3  关于select *</h4><ul>
<li>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因:<ul>
<li>MySQL 在解析的过程中，会通过 查询数据字典 将”*”按序转换成所有列名，这会大大的耗费资源和时<br>间。</li>
<li>无法使用 &#x3D;&#x3D;覆盖索引&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h4 id="12-4-LIMIT-1对优化的影响"><a href="#12-4-LIMIT-1对优化的影响" class="headerlink" title="12.4 LIMIT 1对优化的影响"></a>12.4 LIMIT 1对优化的影响</h4><ul>
<li>针对的是会扫描全表的SQL语句，如果你可以确定结果只有一条，那么加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，这样就会加快查询速度</li>
<li>如数据表已对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上limit 1了</li>
</ul>
<h4 id="12-5-多使用commit"><a href="#12-5-多使用commit" class="headerlink" title="12.5 多使用commit"></a>12.5 多使用commit</h4><ul>
<li>只要有可能，在程序中尽量多使用commit，这样程序的性能得到提高，需求也会因为所释放的资源而减少。</li>
<li>COMMIT所释放的资源：<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo&#x2F;undo log buffer中的空间</li>
<li>管理上述3种资源中的内部花费</li>
</ul>
</li>
</ul>
<h3 id="13-淘宝数据库，主键如何设计的？"><a href="#13-淘宝数据库，主键如何设计的？" class="headerlink" title="13.淘宝数据库，主键如何设计的？"></a>13.淘宝数据库，主键如何设计的？</h3><p>聊一个实际问题：淘宝的数据库，主键是如何设计的？</p>
<p>某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的MySQL军规。其中，一个最明显的错误就是关于MySQL的主键设计。</p>
<p>大部分人的回答如此自信：用8字节的 BIGINT 做主键，而不要用INT。 错 ！  </p>
<p>这样的回答，只站在了数据库这一层，而没有 &#x3D;&#x3D;从业务的角度&#x3D;&#x3D; 思考主键。主键就是一个自增ID吗？站在2022年的新年档口，用自增做主键，架构设计上可能 连及格都拿不到 。  </p>
<h4 id="13-1-自增ID的问题"><a href="#13-1-自增ID的问题" class="headerlink" title="13.1 自增ID的问题"></a>13.1 自增ID的问题</h4><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点，总体来看存在以下几方面的问题：</p>
<p><strong>1.可靠性不高</strong></p>
<p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL8.0才修复。</p>
<p><strong>2.安全性不高</strong></p>
<p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;user&#x2F;1&#x2F;这样的接口，可以非常容易猜测用户ID的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p>
<p><strong>3.性能差</strong></p>
<p>自增ID的性能较差，需要在数据库服务器端生成。</p>
<p><strong>4.交互多</strong></p>
<p>业务还需要额外执行一次类似 last_insert_id( )的函数才能直到刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多一条SQL，就多一次性能上的开销</p>
<p><strong>5.局部唯一性</strong></p>
<p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直是噩梦。</p>
<h4 id="13-2-业务字段做主键"><a href="#13-2-业务字段做主键" class="headerlink" title="13.2 业务字段做主键"></a>13.2 业务字段做主键</h4><p>为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键，那么，怎么为这个表设置主键，才能达到我们理想的目标呢？这里我们考虑业务字段做主键。</p>
<p>但是因为种种原因，业务字段尽量用作主键，毕竟作为项目设计的计数人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现</p>
<blockquote>
<p>注意：刚开始的时候，很容易犯这样的错误。</p>
</blockquote>
<h4 id="13-3-淘宝的主键设计"><a href="#13-3-淘宝的主键设计" class="headerlink" title="13.3 淘宝的主键设计"></a>13.3 淘宝的主键设计</h4><p>例如订单号，作为订单表的主键。</p>
<p>订单号是19位的长度，且订单的最后5位都是一样的，都是08113。且订单号的千米那14位部分都是单调递增的。</p>
<p>大胆猜测，淘宝的订单ID设计应该是：</p>
<p>订单ID &#x3D; 时间 + 去重字段 + 用户ID后6位尾号</p>
<p>这样的设计能做到全局唯一，且对分布式系统查询极其友好。</p>
<h4 id="13-4-推荐的主键设计"><a href="#13-4-推荐的主键设计" class="headerlink" title="13.4 推荐的主键设计"></a>13.4 推荐的主键设计</h4><p>非核心业务：对应表的主键自增ID，如告警，日志，监控等信息</p>
<p>核心业务：主键设计至少应该是全局唯一且单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能</p>
<p>这里推荐最简单的一种主键设计：UUID</p>
<p>&#x3D;&#x3D;UUID的特点：&#x3D;&#x3D;</p>
<p>全局唯一，占用36字节，数据无序，插入性能差</p>
<p>认识UUID:</p>
<ul>
<li>为什么UUID是全局唯一的？</li>
<li>为什么UUID占用36个字节？</li>
<li>为什么UUID是无序的？</li>
</ul>
<p>MySQL数据库的UUID组成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID = 时间 + UUID版本(16字节)-时钟序列（4字节）-MAC地址（12字节）</span><br></pre></td></tr></table></figure>

<p>为什么UUID是全局唯一的？</p>
<ul>
<li><p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降低到1&#x2F;100ns。  </p>
</li>
<li><p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p>
</li>
</ul>
<p>为什么UUID占用36个字节？</p>
<ul>
<li>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</li>
</ul>
<p>为什么UUID是随机无序的呢？</p>
<ul>
<li>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</li>
</ul>
<p><strong>改造UUID</strong></p>
<p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p>
<p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p>
<p>可以通过MySQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MySQL也提供了bin_to_uuid函数进行<br>转化：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @uuid = UUID();</span><br><span class="line">SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意上面的操作要放在MySQL8.0版本中进行</li>
<li>通过函数uuid_to_bin(@uuid,true)将UUID转化位有序UUID了。全局唯一 + 单调递增，这不就是我们想要的主键。</li>
</ul>
<p><strong>4.有序UUID性能测试</strong></p>
<blockquote>
<p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局唯一的实现</p>
<p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等，这样的主键设计就更为考验架构师的水平了</p>
</blockquote>
<p>如果不是MySQL8.0怎么办？</p>
<ul>
<li>手动赋值字段做主键！</li>
<li>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</li>
<li>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</li>
<li>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当 前会员编号的最大值。</li>
<li>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进 行操作，就解决了各门店添加会员时会员编号冲突的问题。</li>
</ul>
<h2 id="9-数据库的设计规范"><a href="#9-数据库的设计规范" class="headerlink" title="9.数据库的设计规范"></a>9.数据库的设计规范</h2><h3 id="1-为什么需要数据库设计"><a href="#1-为什么需要数据库设计" class="headerlink" title="1.为什么需要数据库设计"></a>1.为什么需要数据库设计</h3><p>我们在设计数据表的时候，要考虑很多问题。比如：</p>
<ul>
<li>用户都需要什么数据？需要在数据表中保存哪些数据？</li>
<li>如何保证数据表中数据的正确性，当插入、删除、更新的时候该进行怎样的约束检查？</li>
<li>如何降低数据表的数据冗余度，保证数据表不会因为用户量的增长而迅速扩张？</li>
<li>如何让负责数据库维护人员更方便地使用数据库</li>
<li>使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能千差万别</li>
</ul>
<p>现实情况中，面临的场景：</p>
<ul>
<li>当数据库运行了一段时间之后，我们才发现数据表设计的有问题，重新调整数据表的结构，就需要做数据迁移，还有可能影响程序的业务逻辑，以及网站正常的访问。</li>
</ul>
<p>如果是糟糕的数据库设计可能会造成以下问题：</p>
<ul>
<li>数据冗余，信息重复，存储空间浪费</li>
<li>数据更新、插入、删除的异常</li>
<li>无法正确表示信息</li>
<li>丢失有效信息</li>
<li>程序性能差</li>
</ul>
<p>良好的数据设计原则有以下特点：</p>
<ul>
<li>节省数据的存储空间</li>
<li>能够保证数据的完整性</li>
<li>方便进行数据库应用系统的开发</li>
</ul>
<p>总之，开始设置数据库的时候，我们就是需要重视数据表的设计。为了建立冗余较小，结构合理的数据库，设计数据库时必须遵循一定的准则。</p>
<h3 id="2-范式"><a href="#2-范式" class="headerlink" title="2.范式"></a>2.范式</h3><h4 id="2-1范式简介"><a href="#2-1范式简介" class="headerlink" title="2.1范式简介"></a>2.1范式简介</h4><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。  </p>
<p>范式的英文名称是Normal Form，简称NF,范式是关系数据库理论的基础</p>
<h4 id="2-2-范式都包括哪些"><a href="#2-2-范式都包括哪些" class="headerlink" title="2.2 范式都包括哪些"></a>2.2 范式都包括哪些</h4><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。  </p>
<p>数据库的范式设计越高阶，冗余度越低，同时高阶的范式一定符合低阶范式的要求。</p>
<p>一般来说，在关系型数据库设计中，最高也就遵循到BCNF，普遍还是3NF。但也不绝对，有时候为了提高某些性能，我们还需要破坏范式规则，也就是反规范化。</p>
<h4 id="2-3-键和相关属性的概念"><a href="#2-3-键和相关属性的概念" class="headerlink" title="2.3 键和相关属性的概念"></a>2.3 键和相关属性的概念</h4><p>范式的定义会使用到主键和候选键，数据库中的键（key）由一个或者多个属性组成。数据库中常用的几种键和属性的定义：</p>
<ul>
<li>超键：能唯一标识元组的属性集叫做超键</li>
<li>候选键：如果超键不包括多余的属性，那么这个超键就是候选键</li>
<li>主键：用户可以从候选键中选择一个作为主键</li>
<li>外键：如果数据表R1中的某个属性不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键</li>
<li>主属性：包含在任意候选键中的属性成为主属性</li>
<li>非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性</li>
</ul>
<p>通常，我们也将候选键称之为“码”，把主键也称为主码，因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分</p>
<p><strong>举例：</strong></p>
<ul>
<li>这里有两个表：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</span><br><span class="line">球队表(team) ：球队编号 | 主教练 | 球队所在地 </span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;超键 ：&#x3D;&#x3D;对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</p>
<p>&#x3D;&#x3D;候选键 ：&#x3D;&#x3D;就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</p>
<p>&#x3D;&#x3D;主键 ：&#x3D;&#x3D;我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</p>
<p>&#x3D;&#x3D;外键 ：&#x3D;&#x3D;球员表中的球队编号。</p>
<p>&#x3D;&#x3D;主属性 、 非主属性 ：&#x3D;&#x3D;在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性  </p>
<h4 id="2-4-第一范式（1NF）"><a href="#2-4-第一范式（1NF）" class="headerlink" title="2.4 第一范式（1NF）"></a>2.4 第一范式（1NF）</h4><p>第一范式主要是确保数据表中每个字段的值必须具有&#x3D;&#x3D;原子性&#x3D;&#x3D;，也就是说数据表中每个字段的值为不可再次拆分的最小数据单元。</p>
<p>我们在设计某个字段的时候，对于字段X来说，不能把字段X字段拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求</p>
<p>属性的原子性是主观的。【根据实际需求来进行决定】</p>
<h4 id="2-5第二范式（2NF）"><a href="#2-5第二范式（2NF）" class="headerlink" title="2.5第二范式（2NF）"></a>2.5第二范式（2NF）</h4><p>第二范式要求，在满足第一范式的基础上，还要&#x3D;&#x3D;满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段都必须完全依赖主键，不能只依赖主键的一部分&#x3D;&#x3D;。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以拓展替换为候选键）【非主属性完全依赖于主键】，【解决了部分函数依赖的问题】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</span><br></pre></td></tr></table></figure>

<p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(球员编号) → (姓名，年龄)</span><br><span class="line">(比赛编号) → (比赛时间, 比赛场地)</span><br></pre></td></tr></table></figure>

<p>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？  </p>
<ul>
<li>数据冗余 ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</li>
<li>插入异常 ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。</li>
<li>删除异常 ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。</li>
<li>更新异常 ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况。</li>
</ul>
<blockquote>
<p>1NF告诉我们字段属性是需要原子性的，而1NF告诉我们一张表就是一个独立的对象，一张表指标大一个意思。</p>
</blockquote>
<blockquote>
<p>小结：第二范式（2NF）要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离形成一个新的实体，新的实体与原实体之间是一对多的关系。</p>
</blockquote>
<h4 id="2-6第三范式（3NF）"><a href="#2-6第三范式（3NF）" class="headerlink" title="2.6第三范式（3NF）"></a>2.6第三范式（3NF）</h4><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，&#x3D;&#x3D;要求数据表中的所有非主键字段不能依赖于其他非主键字段。&#x3D;&#x3D;（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在A-&gt;B-&gt;C的决定关系），通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。 【解决了传递函数依赖的问题】</p>
<p>这里的主键可以拓展为候选键。</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>是否是主键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT</td>
<td>是</td>
<td>商品主键id （主键）</td>
</tr>
<tr>
<td>category_id</td>
<td>INT</td>
<td>否</td>
<td>商品类别id</td>
</tr>
<tr>
<td>category_name</td>
<td>VARCHAR(30)</td>
<td>否</td>
<td>商品类别名称</td>
</tr>
<tr>
<td>goods_name</td>
<td>VARCHAR(30)</td>
<td>否</td>
<td>商品名称</td>
</tr>
<tr>
<td>price</td>
<td>DECIMAL(10,2)</td>
<td>否</td>
<td>商品价格</td>
</tr>
</tbody></table>
<p>商品类别名称依赖于商品类别编号，不符合第三范式。  </p>
<blockquote>
<p>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于键，依赖于整个键，并且除了键别无他物”  </p>
</blockquote>
<h4 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h4><p>关于数据表的设计，有三个范式要遵循</p>
<ul>
<li>第一范式，确保每列保持原子性<ul>
<li>数据库的每一列都是不可分割的源自数据项，不可再分的最小数据单元，而不能是集合，数组，记录等非原子数据项</li>
</ul>
</li>
<li>第二范式，确保每列都和主键完全依赖<ul>
<li>尤其在复合主键的情况下，非主键部分不应该依赖于部分主键</li>
</ul>
</li>
<li>第三范式，确保每列都和主键列直接相关，而不是间接相关</li>
</ul>
<p><strong>范式的优点：</strong>数据的标准化有助于消除数据库中的数据冗余，第三范式（3NF）通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡</p>
<p><strong>范式的缺点：</strong>范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多，越精细，数据的的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能是一些索引策略失效。</p>
<p>范式只是提出了设计的标准，实际设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际应用中，要灵活运用。</p>
<blockquote>
<p>范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要将&#x3D;&#x3D;范式和反范式&#x3D;&#x3D;混合使用</p>
</blockquote>
<h3 id="3-反范式化"><a href="#3-反范式化" class="headerlink" title="3.反范式化"></a>3.反范式化</h3><h4 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h4><p>有时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循业务优先的原则，首先满足业务需求，再尽量减少冗余。</p>
<p>有时候数据量特别大，如果安全按照MySQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式优化也是一种优化思路。此时可以通过在数据表中<strong>增加冗余字段</strong>来提高数据库的读性能。</p>
<p><strong>规范化 VS 性能</strong></p>
<blockquote>
<ul>
<li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p>
</li>
<li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p>
</li>
<li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p>
</li>
<li><p>通过在给定的表中插入计算列，以方便查询</p>
</li>
</ul>
</blockquote>
<h4 id="3-2-反范式的新问题"><a href="#3-2-反范式的新问题" class="headerlink" title="3.2 反范式的新问题"></a><strong>3.2 反范式的新问题</strong></h4><ul>
<li>存储 空间变大 了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致</li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源。</li>
<li>在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加 复杂</li>
</ul>
<h4 id="3-3-反范式的使用场景"><a href="#3-3-反范式的使用场景" class="headerlink" title="3.3 反范式的使用场景"></a><strong>3.3 反范式的使用场景</strong></h4><p>当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式的优化</p>
<p><strong>1.增加冗余字段的建议</strong></p>
<p>增加冗余字段一定要符合如下这两个条件。只有满足这两个条件，才可以考虑考虑增加冗余字段</p>
<p>1）这个冗余字段不需要经常进行修改</p>
<p>2）这个冗余字段查询的时候不可或缺</p>
<p><strong>2.历史快照，历史数据的需要</strong></p>
<p>反范式优化也常用在 数据仓库 的设计中，因为数据仓库通常 存储历史数据 ，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。  </p>
<h3 id="4-BCNF-巴斯范式"><a href="#4-BCNF-巴斯范式" class="headerlink" title="4.BCNF(巴斯范式)"></a><strong>4.BCNF(巴斯范式)</strong></h3><ul>
<li>在第三范式的基础上进行了改进，被称为修正的第三范式，并没有新的设计规范加进来，只是对第三范式中设计规范要求更强，使得数据冗余度更小。</li>
<li>定义：若一个关系达到了第三范式，并且**&#x3D;&#x3D;它只有一个候选键&#x3D;&#x3D;**，或者&#x3D;&#x3D;它的每个候选键都是单属性&#x3D;&#x3D;，则该关系自然达到BCNF.</li>
<li>一般说来，一个数据库设计符合3NF或BCNF就可以了</li>
</ul>
<h3 id="5-实战实例"><a href="#5-实战实例" class="headerlink" title="5.实战实例"></a>5.实战实例</h3><p>这个表中的字段很多，表里的数据量也很惊人。大量重复导致表变得庞大。</p>
<h3 id="6-ER模型"><a href="#6-ER模型" class="headerlink" title="6.ER模型"></a>6.ER模型</h3><ul>
<li><p>数据库设计是牵一发而动全身的，那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表，数据表中应该有哪些字段，数据表与数据表之间有什么关系，通过什么字段进行连接，  ，等等。这样我们才能进行整体的梳理和设计</p>
</li>
<li><p>其实ER模型就是一个这样的工具，ER模型也叫做实体关系模型，用来描述现实生活中客观存在的事物，事物的属性，以及事物之间关系的一种数据模型。在开发基于数据库的信息系统的设计阶段，通常使用ER模型来&#x3D;&#x3D;描述信息需求和信息特性，帮助我们清理业务逻辑，从而设计出优秀的数据库&#x3D;&#x3D;</p>
</li>
</ul>
<h4 id="6-1-ER模型包括哪些要素"><a href="#6-1-ER模型包括哪些要素" class="headerlink" title="6.1 ER模型包括哪些要素"></a>6.1 ER模型包括哪些要素</h4><p>ER 模型中有三个要素，分别是实体、属性和关系。  </p>
<ul>
<li>实体 ，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 矩形 来表示。实体分为两类，分别是 强实体 和 弱实体 。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</li>
<li>属性 ，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形 来表示。</li>
<li>关系 ，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用 菱形 来表示。</li>
<li>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，可以独立存在<br>的是实体，不可再分的是属性。也就是说，属性不能包含其他属性。</li>
</ul>
<h4 id="6-2-关系的类型"><a href="#6-2-关系的类型" class="headerlink" title="6.2 关系的类型"></a>6.2 关系的类型</h4><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p>
<ul>
<li>一对一 ：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</li>
<li>一对多 ：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学生则对应一个班级，班级对学生就是一对多的关系。</li>
<li>多对多 ：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这就是多对多的关系。</li>
</ul>
<h3 id="7-数据表的设计原则"><a href="#7-数据表的设计原则" class="headerlink" title="7.数据表的设计原则"></a>7.数据表的设计原则</h3><p>综合以上内容，总结出数据表设计的一般原则：”三少一多”</p>
<ul>
<li>数据表的个数越少越好<ul>
<li>RDBMS的核心在于对实体和联系的定义，也就是E-R图（Entity  Relationship  Diagram）,数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作</li>
</ul>
</li>
<li>数据表中的字段个数越少越好<ul>
<li>字段个数越多，数据冗余得可能性越大。设置字段个数少的前提是各个字段相互独立，这也是相对的，通常会在数据冗余和检索效率中进行平衡</li>
</ul>
</li>
<li>数据表中联合主键的字段个数越少越好<ul>
<li>设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是多个字段来定义一个主键）。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</li>
</ul>
</li>
<li>使用主键和外键越多越好  <ul>
<li>主外键越多说明关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。</li>
</ul>
</li>
<li>三少一多原则的核心就是简单可复用。简单指的是更少的表，更少的字段，更少的联合主键字段来完成数据表的设计。</li>
</ul>
<h3 id="8-数据库对象编写建议"><a href="#8-数据库对象编写建议" class="headerlink" title="8.数据库对象编写建议"></a>8.数据库对象编写建议</h3><h4 id="8-1-关于库"><a href="#8-1-关于库" class="headerlink" title="8.1 关于库"></a>8.1 关于库</h4><ul>
<li>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字<br>母开头。</li>
<li>【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。</li>
<li>【强制】库的名称格式：业务系统名称_子系统名。_</li>
<li>【强制】库名禁止使用关键字（如type,order等）。</li>
<li>【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。<ul>
<li>创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ;</li>
</ul>
</li>
<li>【建议】对于程序连接数据库账号，遵循 权限最小原则</li>
<li>使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限 。</li>
<li>【建议】临时库以 tmp_ 为前缀，并以日期为后缀；</li>
<li>备份库以 bak_ 为前缀，并以日期为后缀。</li>
</ul>
<h4 id="8-2-关于行、列"><a href="#8-2-关于行、列" class="headerlink" title="8.2 关于行、列"></a>8.2 关于行、列</h4><ul>
<li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议<br>以 英文字母开头 。</p>
</li>
<li><p>【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item</p>
</li>
<li><p>【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。</p>
</li>
<li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。</p>
</li>
<li><p>【强制】建表必须有comment。</p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用corporation_id, 而用corp_id 即可。  </p>
</li>
<li><p>布尔值以 is_描述</p>
</li>
<li><p>字段名称尽可能使用表达实际含义的英文单词或缩写</p>
</li>
<li><p>建表时关于主键，必须要有主键</p>
<ul>
<li>强调要求主键为id，类型为int或bigint，且为auto_increment建议使用unsigned无符号型</li>
<li>标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id,order_id等，并建立unique key索引。因为如果设为主键自主简直为随机插入，则会导致innodb内部页分裂和大量随机IO，性能下降</li>
</ul>
</li>
<li><p>表中所有字段尽量都是NOT NULL属性，业务可以根据需要定义DEFAULT值</p>
<ul>
<li>因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错，聚合函数计算结果偏差等问题</li>
</ul>
</li>
<li><p>建议所有存储相同数据的列名和列类型必须一致（一般作为查询列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</p>
</li>
<li><p>中间表（或临时表）用于保留中间结果集，名称以tmp_开头。备份表用于备份或抓紧原表快照，名称以bak_开头。中间表和备份表定期清理</p>
</li>
</ul>
<blockquote>
<p>一个规范的建表语句</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_info (</span><br><span class="line">`id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">`user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">`username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;,</span><br><span class="line">`email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;,</span><br><span class="line">`nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">`birthday` date NOT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;,</span><br><span class="line">`user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;,</span><br><span class="line">`user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;,</span><br><span class="line">`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE</span><br><span class="line">CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">`user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未</span><br><span class="line">通过，4为还未提交审核&#x27;,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `uniq_user_id` (`user_id`),</span><br><span class="line">KEY `idx_username`(`username`),</span><br><span class="line">KEY `idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。</li>
<li>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构<br>的导出和导入。</li>
</ul>
<h4 id="8-3-关于索引"><a href="#8-3-关于索引" class="headerlink" title="8.3 关于索引"></a>8.3 关于索引</h4><ul>
<li>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值 禁止被更新 。</li>
<li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。</li>
<li>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</li>
<li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如:sample 表 member_id 上的索引：idx_sample_mid。</li>
<li>【建议】单个表上的索引个数 不能超过6个 。</li>
<li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。</li>
<li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</li>
<li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除。</li>
</ul>
<h4 id="8-4-SQL编写"><a href="#8-4-SQL编写" class="headerlink" title="8.4 SQL编写"></a>8.4 SQL编写</h4><ul>
<li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</p>
</li>
<li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</p>
</li>
<li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p>
</li>
<li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p>
</li>
<li><p>【建议】SELECT<strong>语句不要使用UNION，推荐使用UNION ALL</strong>【这样就可以不用去重了】，并且UNION子句个数限制在5个以内。</p>
</li>
<li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p>
</li>
<li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p>
</li>
<li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p>
</li>
<li><p>【建议】对单表的多次alter操作必须合并为一次对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生 &#x3D;&#x3D;表锁&#x3D;&#x3D; ，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p>
</li>
<li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</p>
</li>
<li><p>【建议】事务里包含SQL不超过5个。 因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p>
</li>
<li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX;否则会产生&#x3D;&#x3D;间隙锁&#x3D;&#x3D;，内部扩大锁定范围，导致系统性能下降</p>
</li>
</ul>
<h3 id="9-PowerDesigner的使用"><a href="#9-PowerDesigner的使用" class="headerlink" title="9.PowerDesigner的使用"></a>9.PowerDesigner的使用</h3><p>PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作 &#x3D;&#x3D;数据流程图 、概念数据模型 、 物理数据模型&#x3D;&#x3D; ，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设计提供的一套完整的集成化企业级建模解决方案。  </p>
<p><a target="_blank" rel="noopener" href="https://pacslink.novalys.net/leadprocess/api/17/63dff71c-ebe7-ec11-80fb-005056080920">https://pacslink.novalys.net/leadprocess/api/17/63dff71c-ebe7-ec11-80fb-005056080920</a> 软件下载地址</p>
<h2 id="10-事务基础知识"><a href="#10-事务基础知识" class="headerlink" title="10.事务基础知识"></a>10.事务基础知识</h2><h3 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1.数据库事务概述"></a>1.数据库事务概述</h3><ul>
<li>事务是区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复来到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失</li>
</ul>
<h4 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h4><p>可以通过show engines;命令来查看哪些引擎支持事务。发现在MySQL中&#x3D;&#x3D;只有innodb支持事务&#x3D;&#x3D;</p>
<h4 id="1-2-基础概念"><a href="#1-2-基础概念" class="headerlink" title="1.2 基础概念"></a>1.2 基础概念</h4><ul>
<li><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</li>
<li><strong>事务处理的原则</strong>：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 案例:AA用户给用户转账100</span><br><span class="line">update account set money = money - 100 where name = &#x27;AA&#x27;;</span><br><span class="line"># 服务器宕机</span><br><span class="line">update account set money = money + 100 where name = &#x27;BB&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-事务的ACID特性"><a href="#1-3-事务的ACID特性" class="headerlink" title="1.3 事务的ACID特性"></a>1.3 事务的ACID特性</h4><ul>
<li><p><strong>原子性（atomicity）</strong></p>
<ul>
<li>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</li>
</ul>
</li>
<li><p><strong>一致性（consistency）</strong></p>
<ul>
<li>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述）根据定义，一致性是指事务执行前后，数据从一个 &#x3D;&#x3D;合法性状态&#x3D;&#x3D; 变换到另外一个 &#x3D;&#x3D;合法性状态&#x3D;&#x3D; 。这种状态是 语义上 的而不是语法上的，跟具体的业务有关。</li>
<li>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。  </li>
<li>举例（能量守恒）：<ul>
<li>A账户有200元，转账300元出去，此时就不是合法的，因为你定义了一个规则余额 &gt;&#x3D; 0</li>
<li>A账户200元，转账50元给B账户，A账户钱扣了，但是B账户因为各种意外钱没有增加，此时也不是合法状态，因为你定义了一个规则，要求A+B的总金额不变</li>
<li>在数据表中我们将姓名字段设置为唯一性约束，这时当食物进行提交或者事务发生回滚的时候，如果数据表中的姓名不唯一，就破坏了事务的一致性要求。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>隔离性（isolation）</strong></p>
<ul>
<li><p>事务的隔离性是指一个事务的执行 &#x3D;&#x3D;不能被其他事务干扰&#x3D;&#x3D; ，即一个事务内部的操作及使用的数据对 并发 的<br>其他事务是隔离的，并发执行的各个事务之间不能互相干扰。【一个事务其实可以看作是一个线程】</p>
</li>
<li><p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：  </p>
</li>
<li><p>举例</p>
</li>
<li><pre><code class="mysql">UPDATE accounts SET money = money - 50 WHERE NAME = &#39;AA&#39;;
UPDATE accounts SET money = money + 50 WHERE NAME = &#39;BB&#39;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 隔离性举例：并发执行的事务2与事务1相互干扰</span><br><span class="line"></span><br><span class="line">    ![image-20220609203306769](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220609203306769.png)</span><br><span class="line"></span><br><span class="line">- **持久性（Duration）**</span><br><span class="line"></span><br><span class="line">  - 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 ==永久性==的 ，==接下来的其他操作和数据库故障不应该对其有任何影响。==</span><br><span class="line">  - 持久性是通过 ==事务日志== 来保证的。日志包括了 ==重做日志（redo log） 和 回滚日志(undo log)== 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。  【先进行日志操作，再操作数据】</span><br><span class="line"></span><br><span class="line">&gt; 总结：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ACID是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 数据库事务，其实就是数据库设计者为了方便起见，把需要==保证原子性、隔离性、一致性和持久性的一个或多个数据库操作==称为一个事务。</span><br><span class="line"></span><br><span class="line">#### 1.4 事务的状态</span><br><span class="line"></span><br><span class="line">我们现在知道 ==事务== 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 事务 大致划分成几个状态：  </span><br><span class="line"></span><br><span class="line">- ==活动的（active）==</span><br><span class="line">  事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。</span><br><span class="line"></span><br><span class="line">- ==部分提交的==（partially committed）</span><br><span class="line"></span><br><span class="line">  当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响==并 没有刷新到磁盘==时，我们就说该事务处在 部分提交的 状态。</span><br><span class="line"></span><br><span class="line">- ==失败的==（failed）</span><br><span class="line"></span><br><span class="line">  当事务处在 ==活动的== 或者 ==部分提交的== 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失败的 状态  </span><br><span class="line"></span><br><span class="line">- ==中止的==（aborted）</span><br><span class="line"></span><br><span class="line">  如果==事务执行了一部分而变为 失败的 状态==，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要**撤销失败事务对当前数据库造成的影响**。我们把这个撤销的过程称之为 **回滚** 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态  </span><br><span class="line"></span><br><span class="line">- ==提交的==（committed）</span><br><span class="line"></span><br><span class="line">  当一个处在 部分提交的 状态的事务将修改过的数据都 ==同步到磁盘 上之后==，我们就可以说该事务处在了 提交的 状态。  </span><br><span class="line"></span><br><span class="line">- 事务的基本转换图如下</span><br><span class="line">  - ![image-20220609204844222](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220609204844222.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.如何使用事务</span><br><span class="line"></span><br><span class="line">使用事务有两种方式，分别为**显示事务和隐式事务**</span><br><span class="line"></span><br><span class="line">#### 2.1 显式事务</span><br><span class="line"></span><br><span class="line">步骤1：START TRANSACTION 或BEGIN，作用是显式开启一个事务</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql &gt; BEGIN;</span><br><span class="line"># 或者</span><br><span class="line">mysql &gt; START TRANSACTION;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个 修饰符 ：  </p>
<ul>
<li><p>&#x3D;&#x3D;READ ONLY&#x3D;&#x3D; ：标识当前事务是一个 只读事务 ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>
<blockquote>
<p>补充：只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用CREATE TEMPORARY TABLE创建的表），由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增删改操作的</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;READ WRITE&#x3D;&#x3D; ：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p>
</li>
<li><p>&#x3D;&#x3D;WITH CONSISTENT SNAPSHOT&#x3D;&#x3D; ：启动一致性读。</p>
</li>
</ul>
<p>步骤2：一系列事务中的操作（主要是DML，不含DDL）</p>
<p>步骤3：提交事务 或 中止事务（即回滚事务）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line"># 将事务回滚到某个保存点。</span><br><span class="line">mysql&gt; ROLLBACK TO [SAVEPOINT]</span><br></pre></td></tr></table></figure>

<p>其中关于SAVEPOINT相关操作有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在事务中创建保存点，方便后续针对保存点进行回滚，一个事务中可以存在多个保存点</span><br><span class="line">SAVEPOINT 保存点名称</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除某个保存点</span><br><span class="line">RELEASE SAVEPOINT 保存点名称</span><br></pre></td></tr></table></figure>

<h4 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h4><p>MySQL中有一个系统变量 autocommit【针对DML语句有效，对DDL操作是无效的】 ：  </p>
<ul>
<li>默认是开启的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit | ON |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 如果开启了事务的autocommit,则</span><br><span class="line">update account set balance = balance - 10 where id = 1;  -- 此时这条DML操作是一个独立的事务</span><br><span class="line">update account set balance = balance + 10 where id = 2;  -- 此时这条DML操作是一个独立的事务</span><br></pre></td></tr></table></figure>

<p>如何关闭自动提交？</p>
<ul>
<li>方式1：set  autocommit  &#x3D;  false;</li>
<li>方式2：我们在autocommit为true的情况下，使用start transaction 或 begin开启事务，那么DML操作就不会自动提交数据</li>
</ul>
<blockquote>
<p>Oracle默认不自动提交，需要手写commit命令，而MySQL是默认提交</p>
</blockquote>
<h4 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h4><ul>
<li><p>数据定义语言（Data Definition language，缩写为DDL）</p>
<ul>
<li>数据库对象，指的就是数据库、表、视图、存储过程等结构。当我们使用CREATE、ALTER、DROP等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事务。即：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT ...; -- 事务中的一条语句</span><br><span class="line">UPDATE ...; -- 事务中的一条语句</span><br><span class="line">... # 事务中的其他语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE ... -- 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式使用或修改MySQL数据库中的表</p>
<ul>
<li>当我们使用ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD等语句时也会隐式的提交前边语句所属于的事务</li>
</ul>
</li>
<li><p>事务控制或关于锁定的语句</p>
<ul>
<li>当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会 隐式的提交 上一个事务。即：</li>
<li>当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交 前边语句所属的事务。  </li>
<li>使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。</li>
</ul>
</li>
<li><p>加载数据的语句</p>
<ul>
<li>使用LOAD DATA语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务</li>
</ul>
</li>
<li><p>关于MySQL复制的一些语句</p>
<ul>
<li>使用START SLAVE，STOP SLAVE，RESET SLAVE、CHANGE MASTER TO等语句时会隐式的提交铅笔那语句所属的事务</li>
</ul>
</li>
<li><p>其它的一些语句  </p>
<ul>
<li>使用ANALYSE TABLE。CACHE INDEX，CHECK TABLE，FLUSH，LOAD INDEX INTO 　CACHE，OPTIMIZE　TABLE，REPAIR　TABLE，RESET等语句也会隐式的提交前边语句所属的事务。</li>
</ul>
</li>
</ul>
<h4 id="2-4-使用举例1：提交与回滚"><a href="#2-4-使用举例1：提交与回滚" class="headerlink" title="2.4 使用举例1：提交与回滚"></a>2.4 使用举例1：提交与回滚</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user3(</span><br><span class="line">NAME VARCHAR(15) PRIMARY KEY</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SELECT * FROM user3;</span><br><span class="line"></span><br><span class="line">BEGIN;  -- 因为使用了begin,所以就不会自动提交</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;张三&#x27;); # 此时不会自动提交数据</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;李四&#x27;);  # 此时执行完该条语句之后，不受autocommit影响</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;李四&#x27;);  # 受主键的影响，此时不能添加成功</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#情况2</span><br><span class="line">TRUNCATE TABLE user3; #DDL操作会自动提交数据，不受autocommit变量的影响</span><br><span class="line"></span><br><span class="line">BEGIN;  -- 因为使用了begin,所以就不会自动提交</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;张三&#x27;); # 此时不会自动提交数据</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO user3 VALUES(&#x27;李四&#x27;);  # 此时执行完该条语句之后，会自动提交</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;李四&#x27;);  # 事务的失败状态</span><br><span class="line">ROLLBACK;  # 结束的是最近一条事务，只回滚最近一条插入的语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @@completion_type;  # NO_CHAIN</span><br><span class="line">SET @@completion_type=1;  # CHAIN</span><br></pre></td></tr></table></figure>

<p>我们发现相同的代码，只是在事务开始设置之前设置了 SET @@completion_type&#x3D;1;，结果就和我们之前处理的一样，只有一个张三。这是为什么呢？</p>
<ul>
<li>completion_type参数的作用，实际上这个参数有3种可能：<ul>
<li>completion_type &#x3D; 0，这是默认情况。当我们执行commit的时候会提交事务，在执行下一个事务的时候，还需要使用START TRANSACTION或者BEGIN来开启</li>
<li>completion_type&#x3D;1,这种情况下，当我们提交事务后，相当于执行了COMMIT AND CHAIN，也就是开启一个链式事务，即当我们提交事务之后，会开启一个相同隔离级别的事务。</li>
<li>completion_type&#x3D;2.这种情况下 commit&#x3D;commit with release，也就是当我们提交后，会自动与服务器断开连接</li>
</ul>
</li>
</ul>
<blockquote>
<p>当我们设置 autocommit&#x3D;0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p>
<p>当我们设置 autocommit&#x3D;1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。  </p>
</blockquote>
<h4 id="2-5-使用举例2：测试InnoDB与myisam的支持情况"><a href="#2-5-使用举例2：测试InnoDB与myisam的支持情况" class="headerlink" title="2.5 使用举例2：测试InnoDB与myisam的支持情况"></a>2.5 使用举例2：测试InnoDB与myisam的支持情况</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#举例2</span><br><span class="line">CREATE TABLE test1(</span><br><span class="line">i INT PRIMARY KEY</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE test2(</span><br><span class="line">i INT PRIMARY KEY</span><br><span class="line">) ENGINE=MyISAM;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test1;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test2;</span><br><span class="line">#针对于innodb表</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test1 VALUES(1);</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test2 VALUES(1);</span><br><span class="line">ROLLBACK;  # 对于Myisam由于不支持事务，所以回滚操作无效，上面插入的数据仍然存在</span><br></pre></td></tr></table></figure>

<h4 id="2-6-使用举例3：测试savepoint"><a href="#2-6-使用举例3：测试savepoint" class="headerlink" title="2.6 使用举例3：测试savepoint"></a>2.6 使用举例3：测试savepoint</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#举例3</span><br><span class="line">CREATE TABLE user4(</span><br><span class="line">NAME VARCHAR(15),</span><br><span class="line">balance DECIMAL(10,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user4(NAME,balance) VALUES(&#x27;张三&#x27;,1000);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user4;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE user4 SET balance = balance - 100 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">UPDATE user4 SET balance = balance - 100 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SAVEPOINT s1;  # 设置保存点</span><br><span class="line">UPDATE user4 SET balance = balance + 1 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">ROLLBACK TO s1; # 回滚到保存点 注意此时并没有将事务提交</span><br><span class="line">ROLLBACK;  -- | COMMIT 这两条语句才是事务真正的  结束</span><br></pre></td></tr></table></figure>

<h3 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h3><p>MySQL是一个 <strong>客户端／服务器</strong> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每<br>个客户端与服务器连接上之后，就可以称为一个会话<strong>（ Session ）</strong>。每个客户端都可以在自己的会话中<br>向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理<br>多个事务。事务有 <strong>隔离性</strong> 的特性，理论上在<strong>某个事务</strong> 对<strong>某个数据</strong>进行访问 时，其他事务应该进行 <strong><strong>排</strong><br>队</strong> ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <strong>性能影响太大</strong> ，我们既想保持<br>事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 <strong>性能尽量高些</strong> ，那就看二者如何<strong>权衡取</strong><br><strong>舍</strong>了  。</p>
<h4 id="3-1数据准备"><a href="#3-1数据准备" class="headerlink" title="3.1数据准备"></a>3.1数据准备</h4><p>我们需要创建一个表：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">studentno INT,</span><br><span class="line">name VARCHAR(20),</span><br><span class="line">class varchar(20),</span><br><span class="line">PRIMARY KEY (studentno)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>然后向这个表里插入一条数据：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student VALUES(1, &#x27;小谷&#x27;, &#x27;1班&#x27;);</span><br></pre></td></tr></table></figure>

<p>现在表里的数据是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">| studentno | name | class |</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">| 1 | 小谷 | 1班 |</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h4><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 不保证串行执行 （也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：  </p>
<h5 id="1-脏写（dirty-write）"><a href="#1-脏写（dirty-write）" class="headerlink" title="1.脏写（dirty write）"></a><strong>1.脏写</strong>（dirty write）</h5><p>对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数<br>据，那就意味着发生了 脏写  </p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>SessionA</th>
<th>SessionB</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE STUDENT set name &#x3D; ‘李四’  where studentno &#x3D; 1;</td>
</tr>
<tr>
<td>4</td>
<td>UPDATE STUDENT set name &#x3D; ‘张三’  where studentno &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>rollback;</td>
</tr>
</tbody></table>
<h5 id="2-脏读（dirty-read）"><a href="#2-脏读（dirty-read）" class="headerlink" title="2.脏读（dirty read）"></a><strong>2.脏读</strong>（dirty read）</h5><p>对于两个事务 Session A、Session B，Session A 读取 了已经被 Session B 更新 但还 <strong>没有被提交</strong> 的字段。之后若 Session B 回滚 ，Session A 读取 的内容就是 <strong>临时且无效</strong> 的。  </p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>SessionA</th>
<th>SessionB</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE STUDENT set name &#x3D; ‘张三’  where studentno &#x3D; 1;</td>
</tr>
<tr>
<td>4</td>
<td>select * from student where studentno &#x3D; 1;（如果读到列name的值为‘张三’，则意味着发生了脏读）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>rollback;</td>
</tr>
</tbody></table>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新<br>为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而<br>Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象<br>就称之为 脏读 。  </p>
<h5 id="3-不可重复读（Non-Repeatable-Read）"><a href="#3-不可重复读（Non-Repeatable-Read）" class="headerlink" title="3.不可重复读（Non-Repeatable Read）"></a><strong>3.不可重复读（Non-Repeatable Read）</strong></h5><p>对于两个事务Session A、Session B，Session A <strong>读取</strong> 了一个字段，然后 Session B 更新 了该字段。 之后Session A <strong>再次读取</strong> 同一个字段， <strong>值就不同</strong> 了。那就意味着发生了不可重复读。</p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>SessionA</th>
<th>SessionB</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from student where studentno &#x3D; 1;（此时读到列name的值为‘王五’）</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE STUDENT set name &#x3D; ‘张三’  where studentno &#x3D; 1;</td>
</tr>
<tr>
<td>4</td>
<td>select * from student where studentno &#x3D; 1;（如果读到列name的值为‘张三’，则意味着发生了不可重复读）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>UPDATE STUDENT set name &#x3D; ‘李四’  where studentno &#x3D; 1;</td>
</tr>
<tr>
<td>6</td>
<td>select * from student where studentno &#x3D; 1;（如果读到列name的值为‘李四’，则意味着发生了不可重复读）</td>
<td></td>
</tr>
</tbody></table>
<p>我们在Session B中提交了几个 隐式事务 （注意是隐式事务，意味着语句结束事务就提交了），这些事务<br>都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看<br>到最新的值，这种现象也被称之为 不可重复读 。  </p>
<h5 id="4-幻读（phantom）"><a href="#4-幻读（phantom）" class="headerlink" title="4.幻读（phantom）"></a>4.幻读（phantom）</h5><p>对于两个事务Session A、Session B, Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。那就意味着发生了幻读。</p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>SessionA</th>
<th>SessionB</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from student where studentno &gt; 0;（此时读到列name的值为‘张三’）</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>insert into student values(2,’赵六’，‘2班’);</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>5</td>
<td>select * from student where studentno &gt;0;（如果读到列name的值为‘张三’和‘赵六’，则意味着发生了幻读）</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录；之后Session B中提交了一个 隐式事务 ，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为 幻读 。我们把<strong>新插入的那些记录</strong>称之为 <strong>幻影记录</strong> 。  </p>
<p><strong>注意1：</strong></p>
<p>那如果Session B中删除了一些符合studentno &gt; 0 的记录而不是插入新纪录，那Session A之后再根据studentno &gt; 0的条件读取的记录变少了，这种现象算不算幻读呢？这种现象不属于幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>
<p><strong>注意2：</strong></p>
<p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？这相当于是对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前没有获取到的记录。</p>
<h4 id="3-3-SQL中的四种隔离级别"><a href="#3-3-SQL中的四种隔离级别" class="headerlink" title="3.3 SQL中的四种隔离级别"></a>3.3 SQL中的四种隔离级别</h4><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</span><br></pre></td></tr></table></figure>

<p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 SQL标准 中设立了4个 隔离级别 ：  </p>
<ul>
<li>&#x3D;&#x3D;READ UNCOMMITTED&#x3D;&#x3D; ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li>
<li>&#x3D;&#x3D;READ COMMITTED ：&#x3D;&#x3D;读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li>
<li>&#x3D;&#x3D;REPEATABLE READ ：&#x3D;&#x3D;可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li>
<li>&#x3D;&#x3D;SERIALIZABLE ：&#x3D;&#x3D;可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li>
</ul>
<p>SQL标准 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：  </p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED</td>
<td>YES</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>NO</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>&#x3D;&#x3D;REPEATABLE READ&#x3D;&#x3D;</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody></table>
<p>脏写 怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。  </p>
<p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下：  </p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610115204937.png" alt="image-20220610115204937"></p>
<h4 id="3-4-MySQL支持的四种隔离级别"><a href="#3-4-MySQL支持的四种隔离级别" class="headerlink" title="3.4 MySQL支持的四种隔离级别"></a>3.4 MySQL支持的四种隔离级别</h4><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL 5.7.20的版本之前：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;tx_isolation&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"># MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation</span><br><span class="line"># 查看隔离级别，MySQL 5.7.20的版本及之后：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;transaction_isolation&#x27;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line">SELECT @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h4><p>通过下面的语句修改事务的隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ UNCOMMITTED</span><br><span class="line">&gt; READ COMMITTED</span><br><span class="line">&gt; REPEATABLE READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 推荐下面这种</span><br><span class="line">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ-UNCOMMITTED</span><br><span class="line">&gt; READ-COMMITTED</span><br><span class="line">&gt; REPEATABLE-READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>关于设置时使用GLOBAL或SESSION的影响：</p>
<ul>
<li>使用 GLOBAL 关键字（在全局范围影响）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET GLOBAL TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>则：</p>
<ul>
<li><p>当前已经存在的会话无效</p>
</li>
<li><p>只对执行完该语句之后产生的会话起作用</p>
</li>
</ul>
</li>
<li><p>使用SESSION关键字（在会话范围影响）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET SESSION TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>则：<ul>
<li>对当前会话的所有后续的事务有效</li>
<li>如果在事务之间执行，则对后续的事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 会话1中</span><br><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global transaction_isolation = &#x27;read-committed&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 当前已经存在的会话无效</span><br><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>重新开启一个新会话2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 会话2</span><br><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| READ-COMMITTED          |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>针对session</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">mysql&gt; set session transaction_isolation = &#x27;read-uncommitted&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 修改后在当前会话中就适用</span><br><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| READ-UNCOMMITTED        |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>不论是SESSION还是GLOBAL，如果重启mysql服务，则又会恢复到默认值</li>
</ul>
<h3 id="4-事务的常见分类"><a href="#4-事务的常见分类" class="headerlink" title="4.事务的常见分类"></a>4.事务的常见分类</h3><p>从事务理论的角度来看，可以把事务分为以下几种类型：</p>
<ul>
<li>扁平事务（Flat Transactions）</li>
<li>带有保存点的扁平事务（Flat Transactions with Savepoints）</li>
<li>链事务（Chained Transactions）</li>
<li>嵌套事务（Nested Transactions）</li>
<li>分布式事务（Distributed Transactions）</li>
</ul>
<h2 id="11-MySQL事务日志"><a href="#11-MySQL事务日志" class="headerlink" title="11.MySQL事务日志"></a>11.MySQL事务日志</h2><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li><p>事务的隔离性由 <strong>锁机制</strong> 实现。</p>
</li>
<li><p>而事务的原子性、一致性和持久性由事务的 <strong>redo 日志</strong>和<strong>undo 日志</strong>来保证。</p>
<ul>
<li>REDO LOG 称为 <strong>重做日志</strong> ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</li>
<li>UNDO LOG 称为 <strong>回滚日志</strong> ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性、一致性</strong>。</li>
</ul>
</li>
<li><p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。 REDO和UNDO都可以被视为是一种<strong>恢复操作</strong>，但是：</p>
<ul>
<li><p>redo log：是&#x3D;&#x3D;存储引擎层（innodb）&#x3D;&#x3D;生成的日志，记录的是“&#x3D;&#x3D;物理级别”&#x3D;&#x3D;上页的修改操作，比如页号xxx，偏移量yyy,写入了’zzz’数据。主要为了&#x3D;&#x3D;保证数据的可靠性&#x3D;&#x3D;。</p>
</li>
<li><p>undo log：是存储引擎层（innodb）生成的日志，记录的是&#x3D;&#x3D;逻辑操作&#x3D;&#x3D;日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于&#x3D;&#x3D;事务的回滚&#x3D;&#x3D;（undo log记录的是每个修改操作的逆操作）和&#x3D;&#x3D;一致性非锁定读&#x3D;&#x3D;（undo log 回滚行记录到某种特定的版本–MVCC，即多版本并发控制）</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-redo-日志"><a href="#1-redo-日志" class="headerlink" title="1.redo 日志"></a>1.redo 日志</h3><p>Innodb存储引擎是以&#x3D;&#x3D;页为单位&#x3D;&#x3D;来管理存储空间的。在真正访问页面之前，需要把在&#x3D;&#x3D;磁盘上&#x3D;&#x3D;的页缓存到&#x3D;&#x3D;内存中的Buffer  Pool&#x3D;&#x3D;之后才可以访问。所有的变量都必须&#x3D;&#x3D;先更新缓冲池中的数据&#x3D;&#x3D;，然后缓冲池中的&#x3D;&#x3D;脏页&#x3D;&#x3D;会以一定的频率被刷入磁盘（&#x3D;&#x3D;checkpoint机制&#x3D;&#x3D;），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h4 id="1-1为什么需要REDO日志"><a href="#1-1为什么需要REDO日志" class="headerlink" title="1.1为什么需要REDO日志"></a>1.1为什么需要REDO日志</h4><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，&#x3D;&#x3D;checkpoint机制可以保证数据的最终落盘&#x3D;&#x3D;，然而由于&#x3D;&#x3D;checkpoint 并不是每次变更的时候就触发 的&#x3D;&#x3D;，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>另一方面，事务包含 &#x3D;&#x3D;持久性&#x3D;&#x3D; 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p>
<p>那么如何保证这个持久性呢？ 一个简单的做法 ：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p>
<ul>
<li>修改量与刷新磁盘工作量严重不成比例<ul>
<li>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在innodb中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘中，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是大题小做了。</li>
</ul>
</li>
<li>随机IO刷新较慢<ul>
<li>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的buffer pool中的页面&#x3D;&#x3D;刷新到磁盘&#x3D;&#x3D;时，需要进行很多的&#x3D;&#x3D;随机IO&#x3D;&#x3D;，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;另一个解决的思路&#x3D;&#x3D; ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。  </p>
<p>innodb引擎的事务采用了WAL技术（&#x3D;&#x3D;Write-Ahead Logging&#x3D;&#x3D;），这种技术的思想就是&#x3D;&#x3D;先写日志，再写磁盘，只有日志写入成功，才算事务提交成功&#x3D;&#x3D;，这里的日志就是redo log，当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610163635853.png" alt="image-20220610163635853"></p>
<h4 id="1-2-redo日志的好处、特点"><a href="#1-2-redo日志的好处、特点" class="headerlink" title="1.2 redo日志的好处、特点"></a>1.2 redo日志的好处、特点</h4><p><strong>1.好处</strong></p>
<ul>
<li>redo日志降低了刷盘频率</li>
<li>redo日志占用的空间非常小</li>
</ul>
<p>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快</p>
<p><strong>2.特点</strong></p>
<ul>
<li>&#x3D;&#x3D;redo日志是顺序写入磁盘的&#x3D;&#x3D;<ul>
<li>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO，效率比随机IO快</li>
</ul>
</li>
<li>&#x3D;&#x3D;事务执行过程中，redo log不断记录&#x3D;&#x3D;<ul>
<li>redo log跟bin log的区别，redo log是&#x3D;&#x3D;存储引擎层&#x3D;&#x3D;产生的，而bin log是&#x3D;&#x3D;数据库层&#x3D;&#x3D;产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中</li>
</ul>
</li>
</ul>
<h4 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a>1.3 redo的组成</h4><p>Redo log可以简单分为以下两个部分：  </p>
<ul>
<li><p>&#x3D;&#x3D;重做日志的缓冲&#x3D;&#x3D; (redo log buffer) ，保存在内存中，是易失的  </p>
<ul>
<li><p>在服务器启动时，就向操作系统申请了一大片称之为redo log buffer的&#x3D;&#x3D;连续内存&#x3D;&#x3D;空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分成若干个连续的redo log block，一个redo log block占用512字节大小。</p>
</li>
<li><p>参数大小设置</p>
<ul>
<li>redo log buffer 大小，默认 16M ，最大值是4096M，最小值为1M。</li>
</ul>
</li>
<li><pre><code class="mysql">mysql&gt; show variables like &#39;%innodb_log_buffer_size%&#39;;
+------------------------+----------+
| Variable_name          | Value    |
+------------------------+----------+
| innodb_log_buffer_size | 16777216 |
+------------------------+----------+
1 row in set (0.08 sec)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ==重做日志文件== (redo log file) ，保存在硬盘中，是持久的。  </span><br><span class="line"></span><br><span class="line">  - redo日志文件如图所示，其中的ib_logfile0和ib_logfile1即为REDO日志。</span><br><span class="line"></span><br><span class="line">#### 1.4 redo的整体流程</span><br><span class="line"></span><br><span class="line">以一个更新事务为例，redo log流转过程如下，如下图所示</span><br><span class="line"></span><br><span class="line">![image-20220610165855451](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610165855451.png)</span><br><span class="line"></span><br><span class="line">&gt; 只要上面的第三步不出事，那么就能够确保事务的持久性</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝<br>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值<br>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加<br>写的方式<br>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 体会：</span><br><span class="line">&gt;</span><br><span class="line">&gt; write-ahead log（预先日志持久化）：在持久化一个数据页之前，先将内存中相应的日志页持久化。</span><br><span class="line"></span><br><span class="line">#### 1.5 redo log的刷盘策略</span><br><span class="line"></span><br><span class="line">redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 ==一定的频率== 刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。  </span><br><span class="line"></span><br><span class="line">![image-20220610181115732](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610181115732.png)</span><br><span class="line"></span><br><span class="line">注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 ==文件系统缓存（page cache）==中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。  </span><br><span class="line"></span><br><span class="line">针对这种情况，InnoDB给出 ==innodb_flush_log_at_trx_commit== 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：  </span><br><span class="line"></span><br><span class="line">- ==设置为0== ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）  </span><br><span class="line">- ==设置为1== ：表示每次事务提交时都将进行同步，刷盘操作（ ==默认值== ）</span><br><span class="line">- ==设置为2== ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。  </span><br><span class="line"></span><br><span class="line">&gt; 查看innodb_flush_log_at_trx_commit 或者设置该参数</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql&gt; show variables like &quot;innodb_flush_log_at_trx_commit&quot;;</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| Variable_name                  | Value |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| innodb_flush_log_at_trx_commit | 1     |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>另外，innodb存储引擎有一个&#x3D;&#x3D;后台线程&#x3D;&#x3D;，每隔一秒，就会把redo log buffer中的内容写到文件系统缓存（page cache）,然后调用刷盘操作。</p>
<p>一个没有提交事务的redo log记录，也可能会会刷盘。因为在事务执行过程中redo log是会写入redo log buffer中，这些redo log 记录会被&#x3D;&#x3D;后台线程&#x3D;&#x3D;刷盘。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610182724180.png" alt="image-20220610182724180"></p>
<h4 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h4><ul>
<li>innodb_flush_log_at_trx_commit &#x3D; 1时</li>
</ul>
<blockquote>
<p>小结：</p>
<p>为1时，只要事务提交成功，redo log记录就一定在硬盘里，不会又任何数据丢失。</p>
<p>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失，可以保证ACID的D，数据绝对不会丢失，但是&#x3D;&#x3D;效率最差&#x3D;&#x3D;的</p>
<p>建议使用默认值1，虽然操作系统宕机的概率小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全性相对来说更重要些。</p>
</blockquote>
<ul>
<li>innodb_flush_log_at_trx_commit&#x3D;2时</li>
</ul>
<blockquote>
<p>小结：</p>
<p>为2时，只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page  cache）.</p>
<p>如果仅仅只是&#x3D;&#x3D;MySQL挂了&#x3D;&#x3D;不会有任何数据丢失，但是操作系统宕机可能会有1秒数据的丢失，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p>
</blockquote>
<ul>
<li>innodb_flush_log_at_trx_commit&#x3D;0时</li>
</ul>
<blockquote>
<p>小结：</p>
<p>为0时，master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟的事务（master  thread是负责将缓冲池钟的数据异步刷新到磁盘，保证数据的一致性）</p>
<p>数值0的话，是一种折中的做法，它的IO效率理论是高于1和高于2的，但这种策略有丢失数据的风险，也无法保证ACID钟的D</p>
</blockquote>
<p>总结下来就是：0：延迟写，延迟刷  1：实时写，实时刷   2：实时写，延迟刷</p>
<blockquote>
<p>虽然用户可以通过设置参数innodb_flush_log_at_trx_commit为0或2来提高事务提交的性能，但需清楚，这种设置方法丧失了事务的ACID特性。</p>
</blockquote>
<h4 id="1-7-写入redo-log-buffer过程"><a href="#1-7-写入redo-log-buffer过程" class="headerlink" title="1.7 写入redo log  buffer过程"></a>1.7 写入redo log  buffer过程</h4><h5 id="1-补充概念：Mini-Transaction"><a href="#1-补充概念：Mini-Transaction" class="headerlink" title="1.补充概念：Mini-Transaction"></a>1.补充概念：Mini-Transaction</h5><ul>
<li>MySQL把底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr，比如，向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</li>
<li>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，</li>
<li><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610191845121.png" alt="image-20220610191845121"></li>
</ul>
<h5 id="2-redo日志写入log-buffer"><a href="#2-redo日志写入log-buffer" class="headerlink" title="2.redo日志写入log buffer"></a>2.redo日志写入log buffer</h5><p>&#x3D;&#x3D;向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写&#x3D;&#x3D;。当我们想往log  buffer中写入redo日志时，第一个遇到的问题就是已更改写哪个block的哪个偏移量处，所以innodb的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续写入的redo日志应该写入到log  buffer中的哪个位置，如图所示：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611084844985.png" alt="image-20220611084844985"></p>
<p>一个mtr执行过程中可能产生若干条redo日志，&#x3D;&#x3D;这些redo日志是一个不可分割的组&#x3D;&#x3D;，所以其实不是每生成一条redo日志，就将其插入到log  buffer中，而是每个mtr运行过程中产生的日志先暂存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log  buffer中。我们现在假设有两个名为T1，T2的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下：</p>
<ul>
<li>事务T1的两个mtr分别称为mtr_T1_1和mtr_T1_2</li>
<li>事务T2的两个mtr分别称为mtr_T2_1和mtr_T2_2</li>
</ul>
<p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611085543880.png" alt="image-20220611085543880"></p>
<p>不同的事务可能是 并发 执行的，所以 T1 、 T2 之间的 mtr 可能是 交替执行 的。  每当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log  buffer中，也就是说不同事务的mtr可能是交替写入log  buffer的，我们画个示意图（为了美观，我们把一个mtr中产生的所有redo日志当作一个整体来画）：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611085924719.png" alt="image-20220611085924719"></p>
<p>有的mtr产生的redo日志量特别大，比如 mtr_t1_2产生的redo日志占用空间比较大，占用了3个block来存储。</p>
<h5 id="3-redo-log-block的结构图"><a href="#3-redo-log-block的结构图" class="headerlink" title="3.redo  log  block的结构图"></a>3.redo  log  block的结构图</h5><p>一个redo log block的结构图是由&#x3D;&#x3D;日志头、日志体、日志尾&#x3D;&#x3D;组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据就是512-12-8&#x3D;492字节</p>
<blockquote>
<p>为什么一个block设计成512字节？</p>
<p>这个和磁盘的扇区有关，机器磁盘默认的扇区大小就是512字节，如果你要写入的数据大于512字节，那么要写入的扇区肯定不止一个，这是就要涉及到盘片的转动，找到下一个扇区，假设现在需要写入两个扇区A和B，如果扇区A写入成功，而扇区B写入失败，那么就会出现非原子性的写入，而如果每次只写入和扇区的大小一样的512字节，那么每次的写入都是原子性的。</p>
</blockquote>
<h4 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h4><h5 id="1-相关参数设置"><a href="#1-相关参数设置" class="headerlink" title="1.相关参数设置"></a>1.相关参数设置</h5><ul>
<li>innodb_log_group_home_dir ：指定 redo log 文件组所在的路径，默认值为 .&#x2F; ，表示在数据库的数据目录下。MySQL的默认数据目录（ var&#x2F;lib&#x2F;mysql ）下默认有两个名为 ib_logfile0 和ib_logfile1 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</li>
<li>innodb_log_files_in_group：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1…<br>iblogfilen。默认2个，最大100个。 </li>
<li>innodb_flush_log_at_trx_commit：控制 redo log 刷新到磁盘的策略，默认为1。</li>
<li>innodb_log_file_size：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大512G。</li>
</ul>
<h5 id="2-日志文件组"><a href="#2-日志文件组" class="headerlink" title="2.日志文件组"></a>2.日志文件组</h5><p>从上面的描述中可以看到，磁盘上的redo日志文件不止一个，而是以一个日志文件组的形式出现。这些文件以ib_logfile[数字]（数字可以是0，1，2….）的形式进行命名，每个的redo日志文件大小是一样的。</p>
<p>在将redo日志写入日志文件组时，是从ib_logfile0开始写，如果ib_logfile0写满了，就接着ib_logfile1写。同理，依此类推，如果写到最后一个文件该咋办？那就重新转到ib_logfile0继续写，所以整个过程如下图所示：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611095543560.png" alt="image-20220611095543560"></p>
<p>总共的redo日志文件大小其实就是：innodb_log_file_size *  innodb_log_files_in_group</p>
<p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然，所以innodb的设计者提出了&#x3D;&#x3D;checkpoint&#x3D;&#x3D;的概念。</p>
<h5 id="3-checkpoint"><a href="#3-checkpoint" class="headerlink" title="3.checkpoint"></a>3.checkpoint</h5><p>在整个日志文件组中还有两个重要的属性，分别是write pos、checkpoint</p>
<ul>
<li>write pos是当前记录的位置，一边写一边移</li>
<li>checkpoint是当前要擦除的位置，也是往后移</li>
</ul>
<p>每次刷盘redo log记录到日志文件组中，write pos位置就会后移更新。每次MySQL加载日志文件组恢复数据时，会清空加载过的redo log记录，并把checkpoint后移更新。write pos和checkpoint之间的还空着的部分可以用来写入新的redo log记录</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611101710456.png" alt="image-20220611101710456"></p>
<p>如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log记录，MySQL 得<br>停下来，清空一些记录，把 checkpoint 推进一下。  </p>
<h4 id="1-9-redo-log小结"><a href="#1-9-redo-log小结" class="headerlink" title="1.9 redo log小结"></a>1.9 redo log小结</h4><p>innodb的更新操作采用的是write ahead log (预先日志持久化)策略，即先写日志，再写入磁盘。</p>
<h3 id="2-undo-日志"><a href="#2-undo-日志" class="headerlink" title="2.undo 日志"></a>2.undo 日志</h3><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个undo log.</p>
<h4 id="2-1-如何理解undo日志"><a href="#2-1-如何理解undo日志" class="headerlink" title="2.1 如何理解undo日志"></a>2.1 如何理解undo日志</h4><p>事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做，但有时候事务执行到一半会出现一些情况，比如：</p>
<ul>
<li>情况一：事务执行过程中可能遇到各种错误，比如 服务器本身的错误 ， 操作系统错误 ，甚至是突然 断电 导致的错误。</li>
<li>情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前事务的执行</li>
</ul>
<p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为回滚，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。</p>
<p>每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要留一手——把回滚时所需要的东西记下来。</p>
<p>MySQL把这些为了回滚而记录的这些内容称之为撤销日志或混滚日志（即undo log）。注意，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</p>
<p>此外，undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p>
<h4 id="2-2-undo日志的作用"><a href="#2-2-undo日志的作用" class="headerlink" title="2.2 undo日志的作用"></a>2.2 undo日志的作用</h4><ul>
<li>作用1：回滚数据<ul>
<li>用户对undo日志可能有误解：undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此，undo是&#x3D;&#x3D;逻辑日志&#x3D;&#x3D;，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</li>
<li>这是因为在多用户并发系统中，可能会有数十数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到十五开始的样子，因为这样会影响其他事务正在进行的工作。</li>
</ul>
</li>
<li>作用2：MVCC<ul>
<li>undo的另一个作用是MVCC,，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，一次实现&#x3D;&#x3D;非锁定读取&#x3D;&#x3D;。</li>
</ul>
</li>
</ul>
<h4 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a>2.3 undo的存储结构</h4><h5 id="1-回滚段与事务"><a href="#1-回滚段与事务" class="headerlink" title="1.回滚段与事务"></a>1.回滚段与事务</h5><p>InnoDB对undo log的管理采用段的方式，也就是 &#x3D;&#x3D;回滚段（rollback segment）&#x3D;&#x3D; 。每个回滚段记录了1024 个 &#x3D;&#x3D;undo log segment&#x3D;&#x3D; ，而在每个undo log segment段中进行 &#x3D;&#x3D;undo页&#x3D;&#x3D; 的申请。</p>
<ul>
<li><p>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。</p>
</li>
<li><p>从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到了 128*1024 </p>
</li>
<li><p>innodb_undo_directory：设置rollback segment文件所在的路径。</p>
</li>
<li><p>innodb_undo_logs：设置rollback segment的个数，默认值为128</p>
</li>
<li><p>innodb_undo_cablespace：设置构成rollback  segment文件的数量，这样rollback segment可以较为平均地分布在多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件</p>
</li>
</ul>
<p><strong>undo页的重用</strong></p>
<ul>
<li>当我们开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页。在这个申请到的undo页中进行undo log的写入，我们知道mysql默认一页的大小是16K。</li>
<li>为每一个事务分配一个页，是非常浪费的，除非MySQL清理的非常勤快，斗则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的</li>
<li>于是undo页就设计的可以重用了，当事务提交时，并不会立即删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo  log在commit后，会被放到一个链表中，然后判断undo页的使用空间是否小于3&#x2F;4，如果小于3&#x2F;4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是离散的，所以清理对应的磁盘空间时，效率不高</li>
</ul>
<h5 id="2-回滚段与事务"><a href="#2-回滚段与事务" class="headerlink" title="2.回滚段与事务"></a>2.回滚段与事务</h5><ul>
<li>&#x3D;&#x3D;每个事务只会使用一个回滚段&#x3D;&#x3D;，一个回滚段在同一时刻可能会服务于多个事务。</li>
<li>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</li>
<li>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</li>
<li>&#x3D;&#x3D;回滚段存在于undo表空间&#x3D;&#x3D;中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</li>
<li>当事务提交时，InnoDB存储引擎会做以下两件事情：<ul>
<li>将undo log放入列表中，以供之后的purge操作</li>
<li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li>
</ul>
</li>
</ul>
<h5 id="3-回滚段中的数据分类"><a href="#3-回滚段中的数据分类" class="headerlink" title="3.回滚段中的数据分类"></a>3.回滚段中的数据分类</h5><ul>
<li>未提交的回滚数据(uncommitted undo information)：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖</li>
<li>已经提交但未过期的回滚数据(committed undo information)：该数据关联的事务已经提交，但是仍受到undo  retention参数的保持时间的影响</li>
<li>事务已经提交并过期的数据(expired undo information)  ：事务已经提交，而且超过保持时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖事务已经提交并过期的数据</li>
</ul>
<p>事务提交后并不能马上删除undo log及undo log所在的页，这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo  log放入一个链表中，是否可以最终删除undo log以及undo  log所在页purge线程来判断。</p>
<h4 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a>2.4 undo的类型</h4><p>在InnoDB存储引擎中，undo log分为：</p>
<ul>
<li>insert undo log：是在insert操作中产生的，因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除，不需要进行purge操作</li>
<li>update undo log  ：是在update和delete操作中产生的，该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo  log链表，等待purge线程进行最后的删除</li>
</ul>
<h4 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a>2.5 undo log的生命周期</h4><h5 id="1-简明生成过程"><a href="#1-简明生成过程" class="headerlink" title="1.简明生成过程"></a>1.简明生成过程</h5><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611121120360.png" alt="image-20220611121120360"></p>
<p>有了Redo Log和Undo Log之后：  </p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611121147251.png" alt="image-20220611121147251"></p>
<h5 id="2-详细生成过程"><a href="#2-详细生成过程" class="headerlink" title="2. 详细生成过程"></a>2. 详细生成过程</h5><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611121725487.png" alt="image-20220611121725487"></p>
<ul>
<li>DB_ROW_ID：如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键</li>
<li>DB_TRX_ID：每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中。</li>
<li>DB_ROLL_PTR：回滚指针，本质上就是指向undo log的指针</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611122131663.png" alt="image-20220611122131663"></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611122318517.png" alt="image-20220611122318517"></p>
<h5 id="3-undo-log是如何回滚的"><a href="#3-undo-log是如何回滚的" class="headerlink" title="3.undo log是如何回滚的"></a>3.undo log是如何回滚的</h5><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p>
<ul>
<li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</li>
<li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0</li>
<li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom</li>
<li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li>
</ul>
<h5 id="4-undo-log的删除"><a href="#4-undo-log的删除" class="headerlink" title="4.undo log的删除"></a>4.undo log的删除</h5><ul>
<li>针对于insert undo log</li>
</ul>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>
<ul>
<li>针对于update undo log</li>
</ul>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。  </p>
<blockquote>
<p>补充：</p>
<p>purge线程的两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delate Mark操作，在记录上标识Delete_Bit，而不删除记录，是一种假删除，只是做了个标记，真正的删除工作需要后台purge线程去完成。</p>
</blockquote>
<h4 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h4><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611123010714.png" alt="image-20220611123010714"></p>
<p>undo log是&#x3D;&#x3D;逻辑日志&#x3D;&#x3D;，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。<br>redo log是&#x3D;&#x3D;物理日志&#x3D;&#x3D;，记录的是数据页的物理变化，undo log不是redo log的逆过程。  </p>
<h2 id="12-锁"><a href="#12-锁" class="headerlink" title="12.锁"></a>12.锁</h2><p>事务的隔离性由这章讲述的锁来实现的</p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 &#x3D;&#x3D;锁机制&#x3D;&#x3D; 也为实现MySQL的各个隔离级别提供了保证。 &#x3D;&#x3D;锁冲突&#x3D;&#x3D; 也是影响数据库 &#x3D;&#x3D;并发访问性能&#x3D;&#x3D; 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。  </p>
<h3 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2.MySQL并发事务访问相同记录"></a>2.MySQL并发事务访问相同记录</h3><p>并发事务访问相同记录的情况大致可以划分为3种：  </p>
<h4 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h4><p>读-读 情况，即并发事务相继 读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生    </p>
<h4 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h4><p>写-写 情况，即&#x3D;&#x3D;并发事务相继对相同的记录做出改动&#x3D;&#x3D;。  </p>
<p>在这种情况下会发生 &#x3D;&#x3D;脏写&#x3D;&#x3D; 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 &#x3D;&#x3D;排队执行&#x3D;&#x3D; ，这个排队的过程其实是通过 <strong>锁</strong> 来实现的。这个所谓的锁其实是一个 <strong>内存中的结构</strong> ，在事务执行前本来是没有锁的，也就是说一开始是没有 <strong>锁结构</strong> 和记录进行关联的，如图所示： </p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611144829782.png" alt="image-20220611144829782"> </p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与<strong>这条记录关联的 锁结构</strong> ，当没有的时候就会在内存中生成一个 <strong>锁结构</strong> 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构与之关联：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611144952050.png" alt="image-20220611144952050">  </p>
<p>在锁结构里有很多的记录，为了简化理解，只把两个比较重要的属性拿了出来：</p>
<ul>
<li>trx信息：代表这个锁结构是哪个事务生成的</li>
<li>is_waiting：代表当前事务是否在等待</li>
</ul>
<p>当事务T1改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting属性就是false，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了，</p>
<p>当事务T1提交之前，另一个事务T2也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性值为true，表示当前事务需要提前等待，我们把这个场景就称之为获取锁失败，或者加锁失败，图示：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611145810881.png" alt="image-20220611145810881"></p>
<p><strong>在&#x3D;&#x3D;事务T1提交&#x3D;&#x3D;之后，就会把该事务生成的锁结构释放掉</strong>，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的is_waiting属性设置为false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611150115501.png" alt="image-20220611150115501"></p>
<p>小结几种说法：</p>
<ul>
<li>不加锁<ul>
<li>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。</li>
</ul>
</li>
<li>获取锁成功，或者加锁成功<ul>
<li>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务可以继续执行操作。</li>
</ul>
</li>
<li>获取锁失败，或者加锁失败，或者没有获取到锁  <ul>
<li>意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务需要等待，不可以继续执行操作。</li>
</ul>
</li>
</ul>
<h4 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h4><p><strong>读-写</strong> 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 &#x3D;&#x3D;脏读 、 不可重复读 、 幻读&#x3D;&#x3D; 的问题。</p>
<p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 &#x3D;&#x3D;REPEATABLE READ 隔离级别上就已经解决了 幻读&#x3D;&#x3D; 问题。  </p>
<h4 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h4><p>怎么解决 &#x3D;&#x3D;脏读 、 不可重复读 、 幻读&#x3D;&#x3D; 这些问题呢？其实有两种可选的解决方案：</p>
<ul>
<li><p>方案一：&#x3D;&#x3D;读操作&#x3D;&#x3D;利用多版本并发控制（ <strong>MVCC</strong> ，下章讲解），&#x3D;&#x3D;写操作&#x3D;&#x3D;进行 &#x3D;&#x3D;加锁&#x3D;&#x3D; 。</p>
<ul>
<li>所谓的<strong>MVCC</strong>，就是生成一个<strong>ReadView</strong>，通过ReadView找到符合条件的记录版本（历史版本由&#x3D;&#x3D;undo日志&#x3D;&#x3D;构建）。&#x3D;&#x3D;查询语句只能读&#x3D;&#x3D;到在生成ReadView之前已提交事务所作的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所作的更改是看不到的。而写操作肯定针对的是&#x3D;&#x3D;最新版本&#x3D;&#x3D;的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<strong>读-写</strong>操作并不冲突。</li>
</ul>
<blockquote>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在 READ COMMITTED 隔离级别下，一个事务在执行过程中&#x3D;&#x3D;每次&#x3D;&#x3D;执行SELECT操作时都会&#x3D;&#x3D;生成一个ReadView&#x3D;&#x3D;，<strong>ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改</strong> ，也就是避免了脏读现象；</li>
<li>在 REPEATABLE READ 隔离级别下，一个事务在执行过程中&#x3D;&#x3D;只有 第一次执行SELECT操作&#x3D;&#x3D; 才会生成一个ReadView，之后的SELECT操作都 &#x3D;&#x3D;复用 这个ReadView&#x3D;&#x3D;，这样也就避免了不可重复读和幻读的问题。</li>
</ul>
</blockquote>
</li>
<li><p>方案二：&#x3D;&#x3D;读、写操作都采用加锁&#x3D;&#x3D;的方式</p>
<ul>
<li>如果我们的一些&#x3D;&#x3D;业务场景不允许读取记录的旧版本&#x3D;&#x3D;，而是每次都必须去&#x3D;&#x3D;读取记录的最新版本&#x3D;&#x3D;。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存储事务执行完成，其他事务才可以访问账户的余额，这样在<strong>读取记录的时候</strong>就需要对其进行<strong>加锁</strong>操作，这样也就意味着<strong>读操作</strong>和<strong>写操作</strong>也像写-写操作那样排队执行。</li>
<li>脏读的产生是因为当前事务读取到了另一个未提交事务写的一条记录，如果另一事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</li>
<li>不可重复读的产生是因为当前事务读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时，会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会产生不可重复读了。</li>
<li>幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围插入了新纪录，当前事务再次读取该范围的记录时发现了新插入的记录。采用加锁的方式解决幻读的问题就有一些麻烦，&#x3D;&#x3D;因为当前事务在第一次读取记录时幻影记录并不存在&#x3D;&#x3D;，所以读取的时候加锁就有点尴尬（因为你不知道给谁加锁）。</li>
</ul>
</li>
<li><p>小结对比发现：</p>
<ul>
<li>采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 。</li>
<li>采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能。</li>
</ul>
</li>
</ul>
<p>一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 &#x3D;&#x3D;加锁&#x3D;&#x3D; 的方式执行。下面就讲解下MySQL中不同类别的锁  </p>
<h3 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h3><p>锁的分类图，如下：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206131649527.png" alt="image-20220611154335308"></p>
<h4 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h4><p>对于数据库中并发事务的读—读情况并不会引起什么问题。对于写—写、读—写或写—读这些情况可能会引起一些问题，需要使用&#x3D;&#x3D;MVCC或者加锁的方式来解决它们&#x3D;&#x3D;。在使用加锁的方式解决问题时，由于既要允许读—读情况不受影响，又要使写写，读写，写读情况中的操作相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为共享锁（Shared  Lock,S Lock）和排他锁（Exclusive Lock，X Lock）,也叫读锁和写锁。</p>
<ul>
<li>&#x3D;&#x3D;读锁 ：&#x3D;&#x3D;也称为 共享锁 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li>
<li>&#x3D;&#x3D;写锁 ：&#x3D;&#x3D;也称为 排他锁 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源</li>
</ul>
<p>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。  </p>
<p>举例（行级读写锁）：如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据；但是某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行</p>
<p>总结：这里的兼容是指对同一张表或记录的锁的兼容性情况</p>
<p>S-锁与S-锁兼容，其他的都不兼容。</p>
<h5 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1.锁定读"></a>1.锁定读</h5><p>在采用加锁方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取该记录的S锁，其实不严谨的，有时候需要在读取记录的时候就获取记录的X锁，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的SELECT语句格式：</p>
<p>&#x3D;&#x3D;对于InnoDB引擎中，下面两条语句的读和写指的都是行级锁&#x3D;&#x3D;</p>
<ul>
<li>&#x3D;&#x3D;对读取的记录加S锁：&#x3D;&#x3D;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line">#或</span><br><span class="line">SELECT ... FOR SHARE;  #(8.0新增语法)</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;对读取的记录加X锁&#x3D;&#x3D;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h5 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2.写操作"></a>2.写操作</h5><p>平常用到的写操作无非是delete、update、Insert这三种。</p>
<ul>
<li>INSERT:<ul>
<li>一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</li>
</ul>
</li>
</ul>
<p>在innodb中会默认给这这几种操作语句加上X行级锁</p>
<h4 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h4><p>为了尽可能提高数据库的并发度，每次锁定的数据越小越好，理论上每次之锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（设计检查、检查、释放锁等操作）。因此数据库系统需要在高并发相应和系统性能上方面进行平衡，这样就产生了锁粒度的概念。</p>
<p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；锁的粒度主要分为表级锁、页级锁和行锁。</p>
<h5 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1.表锁（Table Lock）"></a>1.表锁（Table Lock）</h5><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并不依赖于存储引擎（不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的），并且表锁是开销最小的策略（因为粒度比较大）。由于表级锁一次会将整个表锁定，所以很好的避免死锁问题。当然，锁的粒度大所带来的负面影响就是出现所资源争用的概率也会增高，导致并发率大打折扣。</p>
<p><strong>① 表级别的S锁、X锁</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 加上表级锁</span><br><span class="line">mysql&gt; lock tables account read;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line"># 加上表级锁后，自身事务可以进行读的操作</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | NAME   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 张三   |   40.00 |</span><br><span class="line">|  2 | 李四   |    0.00 |</span><br><span class="line">|  3 | 王五   |  100.00 |</span><br><span class="line">|  4 | 赵六   |  100.00 |</span><br><span class="line">|  5 | huhu   |   90.00 |</span><br><span class="line">|  6 | hehe   |  100.00 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 当该表被表级锁锁住时，自身事务也不可以进行写的操作</span><br><span class="line">mysql&gt; insert into account values(7,&#x27;刘起&#x27;,90);</span><br><span class="line">ERROR 1099 (HY000): Table &#x27;account&#x27; was locked with a READ lock and can&#x27;t be updated</span><br><span class="line"></span><br><span class="line">-- 查看锁的使用情况</span><br><span class="line">mysql&gt; show open tables where in_use &gt; 0;</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">| Database   | Table   | In_use | Name_locked |</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">| atguigudb3 | account |      1 |           0 |</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">1 row in set (0.26 sec)</span><br><span class="line"></span><br><span class="line">-- 释放读锁</span><br><span class="line">mysql&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 这是加表级锁的写锁</span><br><span class="line">mysql&gt; lock tables account write;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show open tables where in_use &gt;0;</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">| Database   | Table   | In_use | Name_locked |</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">| atguigudb3 | account |      1 |           0 |</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 可以对自身进行读</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | NAME   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 张三   |   40.00 |</span><br><span class="line">|  2 | 李四   |    0.00 |</span><br><span class="line">|  3 | 王五   |  100.00 |</span><br><span class="line">|  4 | 赵六   |  100.00 |</span><br><span class="line">|  5 | huhu   |   90.00 |</span><br><span class="line">|  6 | wajig  |  100.00 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 也可以对自身进行写</span><br><span class="line">mysql&gt; update account set name = &#x27;zhaoliu&#x27; where id =4;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>MyISAM在执行查询语句（select）前，会给设计的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁</li>
<li>&#x3D;&#x3D;InnoDB存储引擎是不会为这个表添加表级别的读锁或者写锁的&#x3D;&#x3D;</li>
</ul>
<p>MySQL的表级锁有两种模式</p>
<ul>
<li>表共享读锁（Table Read Lock）</li>
<li>表独享写锁（Table Write Lock）</li>
</ul>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>自己可读</th>
<th>自己可写</th>
<th>自己可操作其他表</th>
<th>他人可读</th>
<th>他人可写</th>
</tr>
</thead>
<tbody><tr>
<td>读锁（S）</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否，等</td>
</tr>
<tr>
<td>写锁 ( X )</td>
<td>是</td>
<td>&#x3D;&#x3D;是&#x3D;&#x3D;</td>
<td>否</td>
<td>&#x3D;&#x3D;否&#x3D;&#x3D;</td>
<td>否，等</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;② 意向锁 （intention lock&#x3D;&#x3D;  </p>
<p>InnoDB 支持 &#x3D;&#x3D;多粒度锁&#x3D;&#x3D;（multiple granularity locking） ，它允许 &#x3D;&#x3D;行级锁 与 表级锁 共存&#x3D;&#x3D;，而意向<br>锁就是其中的一种 &#x3D;&#x3D;表锁&#x3D;&#x3D; 。  </p>
<p>1.意向锁的存在是为了协调行级锁和表级锁的关系，支持多粒度（表锁与行锁）的锁并存。</p>
<p>2.意向锁是一种&#x3D;&#x3D;不与行级锁冲突的表级锁&#x3D;&#x3D;，这一点非常重要</p>
<p>3.表明“某个事务正在某些行持有了锁或该事务准备去持有”锁</p>
<p>意向锁分为两类：</p>
<ul>
<li>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加&#x3D;&#x3D;共享锁&#x3D;&#x3D;（S锁）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<ul>
<li>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加&#x3D;&#x3D;排他锁&#x3D;&#x3D;（X锁）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>即：意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁 。  </p>
<p>1.意向锁要解决的问题.</p>
<ul>
<li>在数据表的场景中，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了。这样当其他人想要获取数据表排他锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</li>
<li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁</li>
<li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排它锁。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>意向共享锁（IS）</th>
<th>意向排他锁(IS)</th>
</tr>
</thead>
<tbody><tr>
<td>意向共享锁(IS)</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>意向排它锁</td>
<td>兼容</td>
<td>&#x3D;&#x3D;兼容&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>意向共享锁</th>
<th>意向排他锁</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁( S  )</td>
<td>&#x3D;&#x3D;兼容&#x3D;&#x3D;</td>
<td>互斥</td>
</tr>
<tr>
<td>排他锁( X )</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody></table>
<p>从上面的案例可以得到如下结论：</p>
<ul>
<li>InnoDB 支持 &#x3D;&#x3D;多粒度锁&#x3D;&#x3D; ，特定场景下，&#x3D;&#x3D;行级锁可以与表级锁共存&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;意向锁之间互不排斥&#x3D;&#x3D;，但除了 IS 与 S 兼容外， 意向锁会与 &#x3D;&#x3D;共享锁 &#x2F; 排他锁【这两个锁是表级锁】&#x3D;&#x3D; 互斥 。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li>
<li>意向锁在保证并发性的前提下，实现了 行锁和表锁共存 且 满足事务隔离性 的要求。</li>
</ul>
<p><strong>③ 自增锁（AUTO-INC锁）</strong>  </p>
<p>在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性。举例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">`id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` varchar(255) NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure>

<p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改<br>如下所示。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `teacher` (name) VALUES (&#x27;zhangsan&#x27;), (&#x27;lisi&#x27;);</span><br></pre></td></tr></table></figure>

<p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1 | zhangsan |</span><br><span class="line">| 2 | lisi |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是“ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”。  </p>
<ol>
<li>“Simple inserts” （简单插入）<br>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</li>
<li>“Bulk inserts” （批量插入）<br>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE… SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</li>
<li>“Mixed-mode inserts” （混合模式插入）<br>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name)VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。</li>
</ol>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：  </p>
<p>（1）innodb_autoinc_lock_mode &#x3D; 0(“传统”锁定模式)</p>
<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会 限制并发 能力。<br>（2）innodb_autoinc_lock_mode &#x3D; 1(“连续”锁定模式)</p>
<p>在 MySQL 8.0 之前，连续锁定模式是 默认 的。在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT …SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。<br>（3）innodb_autoinc_lock_mode &#x3D; 2(“交错”锁定模式)</p>
<p>&#x3D;&#x3D;从 MySQL 8.0 开始，交错锁模式是 默认 设置。&#x3D;&#x3D;</p>
<p>在此锁定模式下，&#x3D;&#x3D;自动递增值&#x3D;&#x3D; 保证 在所有并发执行的所有类型的insert语句中是 &#x3D;&#x3D;唯一 且 单调递增 的&#x3D;&#x3D;。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能不是连续的。  </p>
<p><strong>④ 元数据锁（MDL锁）</strong>  </p>
<p>不需要显式使用，当在访问一个表的时候就会默认添加</p>
<h5 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2.InnoDB中的行锁"></a>2.InnoDB中的行锁</h5><h6 id="①-记录锁（Record-Locks）"><a href="#①-记录锁（Record-Locks）" class="headerlink" title="① 记录锁（Record Locks）"></a>① 记录锁（Record Locks）</h6><p>行锁（Row Lock）也称为记录锁，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行级锁，行级锁只&#x3D;&#x3D;在存储引擎层实现&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;优点&#x3D;&#x3D;：锁定粒度小，发生冲突概率低，可以实现的并发度高</p>
<p>&#x3D;&#x3D;缺点：&#x3D;&#x3D;对于锁的开销比较大，加锁会比较慢，容易出现死锁情况</p>
<p>&#x3D;&#x3D;InnoDB与MyISAM的最大不同有有两点：一是支持事务（Transaction）;二是采用了行级锁&#x3D;&#x3D;</p>
<p>记录锁是由S锁和X锁之分的，称之为S型记录锁和X型记录锁。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录所后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获得X型记录锁</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续X型记录锁。</li>
</ul>
<h6 id="②-间隙锁（Gap-Locks）"><a href="#②-间隙锁（Gap-Locks）" class="headerlink" title="② 间隙锁（Gap Locks）"></a>② 间隙锁（Gap Locks）</h6><p>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条记录加一个gap锁的示意图如下。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206131645606.png" alt="image-20220612212207773"></p>
<p>图中id值为8的记录加了gap锁，意味着 不允许别的事务在id值为8的记录前边的间隙插入新记录 ，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。  </p>
<p>&#x3D;&#x3D;gap锁的提出仅仅是为了防止插入幻影记录而提出的。&#x3D;&#x3D;，虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁  </p>
<p>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实影响了并发度的。</p>
<h6 id="③-临键锁（Next-Key-Locks）"><a href="#③-临键锁（Next-Key-Locks）" class="headerlink" title="③ 临键锁（Next-Key Locks）"></a><strong>③ 临键锁（Next-Key Locks）</strong></h6><p>有时候我们既想 锁住某条记录 ，又想 阻止 其他事务在该记录前边的 间隙插入新记录 ，所以InnoDB就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁，innodb默认的锁就是&#x3D;&#x3D;Next-Key locks&#x3D;&#x3D;。</p>
<p>next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能组织别的事务将新纪录插入被保护记录前边的间隙。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from student where id &lt;=8 and id &gt; 3 for update;</span><br></pre></td></tr></table></figure>

<h6 id="④-插入意向锁（Insert-Intention-Locks）"><a href="#④-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="④ 插入意向锁（Insert Intention Locks）"></a><strong>④ 插入意向锁（Insert Intention Locks）</strong></h6><p>我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁 （ next-key锁也包含 gap锁 ），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是&#x3D;&#x3D;InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个 间隙 中 插入 新记录，但是现在在等待&#x3D;&#x3D;。InnoDB就把这种类型的锁命名为 &#x3D;&#x3D;Insert Intention Locks&#x3D;&#x3D; ，官方的类型名称为：LOCK_INSERT_INTENTION ，我们称为 插入意向锁 。插入意向锁是一种 &#x3D;&#x3D;Gap锁&#x3D;&#x3D; ，不是&#x3D;&#x3D;意向锁&#x3D;&#x3D;，在insert操作时产生。</p>
<p>插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁 。&#x3D;&#x3D;事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。&#x3D;&#x3D;  </p>
<h5 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3.页锁"></a>3.页锁</h5><p>页锁就是在 &#x3D;&#x3D;页的粒度&#x3D;&#x3D; 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。&#x3D;&#x3D;页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。&#x3D;&#x3D;</p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间， &#x3D;&#x3D;锁空间的大小是有限的&#x3D;&#x3D; 。当某个层级的锁数量超过了这个层级的阈值时，就会进行 &#x3D;&#x3D;锁升级&#x3D;&#x3D; 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。  </p>
<h4 id="3-3-从对待锁的态度划分：乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分：乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分：乐观锁、悲观锁"></a>3.3 从对待锁的态度划分：乐观锁、悲观锁</h4><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<strong>数据并发的思维方式</strong> 。需要注意的是，&#x3D;&#x3D;乐观锁和悲观锁并不是锁，而是锁的 设计思想&#x3D;&#x3D; 。  </p>
<h5 id="1-悲观锁（Pessimistic-Locking）"><a href="#1-悲观锁（Pessimistic-Locking）" class="headerlink" title="1.悲观锁（Pessimistic Locking）"></a>1.悲观锁（Pessimistic Locking）</h5><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 &#x3D;&#x3D;阻塞&#x3D;&#x3D; 直到它拿到锁（&#x3D;&#x3D;共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程&#x3D;&#x3D;）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 &#x3D;&#x3D;synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现&#x3D;&#x3D;。 </p>
<p> 悲观锁不适用的场景较多，它存在一些不足，因为悲观锁大多数情况下依靠数据库的锁机制来实现，以保证程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是长事务而言，这样的开销往往无法承受，这时就需要乐观锁。</p>
<h5 id="2-乐观锁（Optimistic-Locking）"><a href="#2-乐观锁（Optimistic-Locking）" class="headerlink" title="2.乐观锁（Optimistic Locking）"></a>2.乐观锁（Optimistic Locking）</h5><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是&#x3D;&#x3D;不采用数据库自身的锁机制，而是通过程序来实现&#x3D;&#x3D;。在程序上，我们可以采用 &#x3D;&#x3D;版本号机制&#x3D;&#x3D; 或者 &#x3D;&#x3D;CAS机制&#x3D;&#x3D; 实现。&#x3D;&#x3D;乐观锁适用于多读的应用类型，这样可以提高吞吐量&#x3D;&#x3D;。在Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁  的一种实现方式：CAS实现的  </p>
<p><strong>1.乐观锁的版本号机制</strong>  </p>
<p>在表中&#x3D;&#x3D;设计一个 版本字段 version&#x3D;&#x3D; ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 UPDATE … SET version&#x3D;version+1 WHERE version&#x3D;version 。此时如果已经有事务对这条数据进行了更改，修改就不会成功。  </p>
<p><strong>2.乐观锁的时间戳机制</strong>  </p>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p>
<p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。  </p>
<p><strong>3.两种锁的适用场景</strong></p>
<p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>
<ul>
<li>乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 &#x3D;&#x3D;程序实现&#x3D;&#x3D; ， 不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li>悲观锁 适合 写操作多 的场景，因为写的操作具有 &#x3D;&#x3D;排它性&#x3D;&#x3D; 。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 &#x3D;&#x3D;读 - 写 和 写 - 写&#x3D;&#x3D; 的冲突。</li>
</ul>
<h4 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a>3.4 按加锁的方式划分：显式锁、隐式锁</h4><h5 id="1-隐式锁"><a href="#1-隐式锁" class="headerlink" title="1.隐式锁"></a>1.隐式锁</h5><p>一个事务在执行INSERT操作时，如果即将插入的间隙已经被其他事务加了gap锁，那么本次INSERT操作会阻塞，并且当前事务会在该间隙上加一个插入意向锁，否则一般情况下INSERT操作是不加锁的。</p>
<p>那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构），然后另一个事务：</p>
<ul>
<li>立即使用SELECT  …  LOCK IN  SHARE  MODE语句读取这条记录，也就是要获取这条记录的S锁，或者使用SELECT  …  FOR  UPDATE语句读取这条记录，也就是要获取这条记录的X锁，怎么办？<ul>
<li>如果允许这种情况发生，那么可能发生脏读问题。【即一个事务读取到了另一个事务尚未提交过的数据】</li>
</ul>
</li>
<li>立即修改这条记录，也就是要获取这条记录的X锁，怎么办？<ul>
<li>如果允许这种情况的发生，那么可能产生脏写问题。</li>
</ul>
</li>
</ul>
<p>这时候我们前边提过的事务ID又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下“</p>
<ul>
<li>情景一：对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是当前事务的 &#x3D;&#x3D;事务id&#x3D;&#x3D; ，如果&#x3D;&#x3D;其他事务此时想对该记录添加 S锁 或者 X锁 时&#x3D;&#x3D;，首先会看一下该记录的trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态（也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</li>
<li>情景二：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 &#x3D;&#x3D;Page&#x3D;&#x3D;<br>&#x3D;&#x3D;Header 部分有一个 PAGE_MAX_TRX_ID 属性&#x3D;&#x3D;，该属性代表对该页面做改动的最大的 事务id ，如<br>果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已<br>经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记<br>录，然后再重复 情景一 的做法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># session 1</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; insert INTO student VALUES(34,&quot;周八&quot;,&quot;二班&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># session 2</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from student lock in share mode; #执行完，当前事务被阻塞</span><br><span class="line"></span><br><span class="line"># 会话窗口session 3 查看当前的显式锁</span><br><span class="line">mysql&gt; SELECT * FROM performance_schema.data_lock_waits\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">REQUESTING_ENGINE_LOCK_ID: 140562531358232:7:4:9:140562535668584</span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: 422037508068888</span><br><span class="line">REQUESTING_THREAD_ID: 64</span><br><span class="line">REQUESTING_EVENT_ID: 6</span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: 140562535668584</span><br><span class="line">BLOCKING_ENGINE_LOCK_ID: 140562531351768:7:4:9:140562535619104</span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID: 15902</span><br><span class="line">BLOCKING_THREAD_ID: 64</span><br><span class="line">BLOCKING_EVENT_ID: 6</span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN: 140562535619104</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>隐式锁的逻辑过程如下：</p>
<p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。</p>
<p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 隐式锁 转换为 显式锁 (就是为该事务添加一个锁)。</p>
<p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。</p>
<p>D. 等待加锁成功，被唤醒，或者超时。</p>
<p>E. 写数据，并将自己的trx_id写入trx_id字段。   </p>
<h5 id="2-显式锁"><a href="#2-显式锁" class="headerlink" title="2.显式锁"></a>2.显式锁</h5><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：<br>显示加共享锁：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... lock in share mode</span><br></pre></td></tr></table></figure>

<p>显示加排它锁：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... for update;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-其他锁之：全局锁"><a href="#3-5-其他锁之：全局锁" class="headerlink" title="3.5 其他锁之：全局锁"></a>3.5 其他锁之：全局锁</h4><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份 。</p>
<p>全局锁的命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure>

<h4 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a>3.6 其它锁之：死锁</h4><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死<br>锁示例：  </p>
<table>
<thead>
<tr>
<th></th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction;  update account set money&#x3D;10 where id&#x3D;1;</td>
<td>start transaction;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>update account set money&#x3D;10 where id&#x3D;2;</td>
</tr>
<tr>
<td>3</td>
<td>update account set money&#x3D;20 where id&#x3D;2;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>update account set money&#x3D;20 where id&#x3D;1;</td>
</tr>
</tbody></table>
<p>这时候，事务1在等待事务2释放id&#x3D;2的行锁，而事务2在等待事务1释放id&#x3D;1的行锁。 事务1和事务2在互相等待对方的资源释放，就是进入了死锁状态。</p>
<ul>
<li>产生死锁的条件<ul>
<li>两个或者两个以上事务</li>
<li>每个事务都已经持有锁并且申请新的锁</li>
<li>锁资源同时只能被同一个事务持有或者不兼容</li>
<li>事务之间因为持有锁和申请锁彼此循环等待</li>
</ul>
</li>
</ul>
<blockquote>
<p>死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。</p>
</blockquote>
<ul>
<li>如何处理死锁：<ul>
<li>方式1：等待，直到超时（innodb_lock_wait_timeout&#x3D;50s）<ul>
<li>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其回滚，另外事务继续进行。这种方法简单有效，在innodb中，参数innodb_lock_wait_timeout用来设置超时时间</li>
<li>缺点：对于在线服务来说，这个等待时间往往是无法接受的</li>
<li>如果将时间简单的设置小一点，不可取，因为会误伤到普通的等待。</li>
</ul>
</li>
<li>方式2：使用死锁检测进行死锁处理<ul>
<li>方式1检测死锁太过被动，innodb还提供了wait-for graph算法来进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</li>
<li>这是一种较为主动的死锁检测机制，要求数据库保存锁的信息链表和事务等待链表两部分信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>死锁检测的原理是构建一个事务为顶点，锁为边的有向图，判断有向图是否存在环，存在既有死锁</p>
</blockquote>
<ul>
<li>一旦检测到回路，有死锁，这时候Innodb存储引擎会选择回滚undo量最小的事务，让其他事务继续执行（‘innodb_deaflock_detect&#x3D;on’表示开启这个逻辑）</li>
<li>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100&#x3D;1万次，一万个线程就会有1千万次检测</li>
</ul>
<p><strong>如何解决：</strong></p>
<ul>
<li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li>
<li>方式2：控制并发访问的数量，比如在中间件中实现对于想同行的更新，在进入引擎之前排队，这样在Innodb内部就不会有大量的死锁检测工作。</li>
</ul>
<p><strong>进一步的思路：</strong></p>
<p>可以通过将一行改成逻辑上的多行来减少锁冲突。比如，连锁超时总额的记录，可以考虑放到多条记录上，账户总额等于这多条记录的值的总和。</p>
<ul>
<li>如何避免死锁<ul>
<li>合理设计索引，使业务SQL尽可能通过索引定位更少的行，减少锁竞争</li>
<li>调整业务逻辑SQL执行顺序，避免update、delete长时间持有锁的SQL在事务前面</li>
<li>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。</li>
<li>在并发比较高的系统中，不要显式加锁，特别是在事务里显式加锁。如select … for  update语句，如果是在事务里执行了start transaction 或设置了autocommit等于0，那么就会锁定所有查找到的记录</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择。</li>
</ul>
</li>
</ul>
<h3 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4.锁的内存结构"></a>4.锁的内存结构</h3><p>我们前边说过对一条记录加锁的本质就是在内存中创建一个锁结构与之关联，那么是不是一个事务对多条记录加锁，就要创建多个锁结构呢？比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 事务T1</span><br><span class="line">select * from user lock in share mode;</span><br></pre></td></tr></table></figure>

<p>理论上创建多个锁结构没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了，所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个锁结构中。</p>
<ul>
<li>在同一个事务中进行加锁的操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型是一样的</li>
<li>等待状态是一样的</li>
</ul>
<p>InnoDB存储引擎中的键结构如下：</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132033904.png" alt="image-20220613203316672"></p>
<p>结构解析：</p>
<p>&#x3D;&#x3D;1.锁所在的事务信息：&#x3D;&#x3D;</p>
<p>不论是表锁还是行锁，都是在事务执行过程中生成的，哪个事务生成了这个锁结构，这里就记录这个事务的信息。</p>
<p>此锁所在的事务信息在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
<p>&#x3D;&#x3D;2.索引信息&#x3D;&#x3D;</p>
<p>对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针</p>
<p>&#x3D;&#x3D;3.表锁&#x2F;行锁信息&#x3D;&#x3D;<br>表锁结构 和 行锁结构 在这个位置的内容是不同的：</p>
<ul>
<li><p>表锁：</p>
<p>记载着是对哪个表加的锁，还有其他的一些信息</p>
</li>
<li><p>行锁：</p>
<p>记载了三个重要的信息：</p>
<ul>
<li><p>Space ID ：记录所在表空间。</p>
</li>
<li><p>Page Number ：记录所在页号。</p>
</li>
<li><p>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。  </p>
<blockquote>
<p>n_bits的值一般都比页面中记录条数多一些，主要是为了之后在页面中插入了新纪录后也不至于重新分配锁结构。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;4.type_mode&#x3D;&#x3D;</p>
<p>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：  </p>
<p>&#x3D;&#x3D;5.其他信息 ：&#x3D;&#x3D;<br>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。<br>&#x3D;&#x3D;6.一堆比特位 ：&#x3D;&#x3D;<br>如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 n_bits 属性<br>表示的。InnoDB数据页中的每条记录在 记录头信息 中都包含一个 heap_no 属性，伪记录 Infimum 的<br>heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录， heap_no 值就增1。 锁结<br>构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 heap_no ，即一个比特位映射<br>到页内的一条记录。  </p>
<h3 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5.锁监控"></a>5.锁监控</h3><p>关于MySQL锁的监控，我们一般可以通过检查InnoDB_row_lock等状态变量来分析系统上的行锁的争夺情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Innodb_row_lock_current_waits | 0 |</span><br><span class="line">| Innodb_row_lock_time | 0 |</span><br><span class="line">| Innodb_row_lock_time_avg | 0 |</span><br><span class="line">| Innodb_row_lock_time_max | 0 |</span><br><span class="line">| Innodb_row_lock_waits | 0 |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>对各个状态量的说明如下：</p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li>
<li>Innodb_row_lock_time ：从系统启动到现在锁定总时间长度；（等待总时长）</li>
<li>Innodb_row_lock_time_avg ：每次等待所花平均时间；（等待平均时长）</li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li>
<li>Innodb_row_lock_waits ：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<p>对于这5个状态变量，比较重要的3个见上面（橙色）。  </p>
<p>&#x3D;&#x3D;其他监控方法：&#x3D;&#x3D;</p>
<p>MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是INNODB_TRX 、 INNODB_LOCKS 和 INNODB_LOCK_WAITS 。</p>
<p>MySQL5.7及之前 ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p>
<p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了 performance_schema.data_locks ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，</p>
<p>performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。同时，information_schema.INNODB_LOCK_WAITS也被 &#x3D;&#x3D;performance_schema.data_lock_waits&#x3D;&#x3D; 所代替。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 会话1</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account for update;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 会话2</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account for update;  # 开始阻塞</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"># 会话3开始查看锁结构</span><br><span class="line">mysql&gt; select * from information_schema.INNODB_LOCK_WAITS\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">requesting_trx_id: 4190</span><br><span class="line">requested_lock_id: 4190:80:3:11</span><br><span class="line">  blocking_trx_id: 4189</span><br><span class="line"> blocking_lock_id: 4189:80:3:11</span><br><span class="line">1 row in set, 1 warning (0.06 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_TRX \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                    trx_id: 4190</span><br><span class="line">                 trx_state: LOCK WAIT</span><br><span class="line">               trx_started: 2022-06-13 21:00:46</span><br><span class="line">     trx_requested_lock_id: 4190:80:3:11</span><br><span class="line">          trx_wait_started: 2022-06-13 21:01:49</span><br><span class="line">                trx_weight: 2</span><br><span class="line">       trx_mysql_thread_id: 31</span><br><span class="line">                 trx_query: select * from account for update</span><br><span class="line">       trx_operation_state: starting index read</span><br><span class="line">         trx_tables_in_use: 1</span><br><span class="line">         trx_tables_locked: 1</span><br><span class="line">          trx_lock_structs: 2</span><br><span class="line">     trx_lock_memory_bytes: 1136</span><br><span class="line">           trx_rows_locked: 2</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line"> trx_adaptive_hash_latched: 0</span><br><span class="line"> trx_adaptive_hash_timeout: 0</span><br><span class="line">          trx_is_read_only: 0</span><br><span class="line">trx_autocommit_non_locking: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">                    trx_id: 4189</span><br><span class="line">                 trx_state: RUNNING</span><br><span class="line">               trx_started: 2022-06-13 21:00:21</span><br><span class="line">     trx_requested_lock_id: NULL</span><br><span class="line">          trx_wait_started: NULL</span><br><span class="line">                trx_weight: 2</span><br><span class="line">       trx_mysql_thread_id: 30</span><br><span class="line">                 trx_query: NULL</span><br><span class="line">       trx_operation_state: NULL</span><br><span class="line">         trx_tables_in_use: 0</span><br><span class="line">         trx_tables_locked: 1</span><br><span class="line">          trx_lock_structs: 2</span><br><span class="line">     trx_lock_memory_bytes: 1136</span><br><span class="line">           trx_rows_locked: 12</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line"> trx_adaptive_hash_latched: 0</span><br><span class="line"> trx_adaptive_hash_timeout: 0</span><br><span class="line">          trx_is_read_only: 0</span><br><span class="line">trx_autocommit_non_locking: 0</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_LOCKS\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    lock_id: 4190:80:3:11</span><br><span class="line">lock_trx_id: 4190</span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `atguigudb3`.`account`</span><br><span class="line"> lock_index: PRIMARY</span><br><span class="line"> lock_space: 80</span><br><span class="line">  lock_page: 3</span><br><span class="line">   lock_rec: 11</span><br><span class="line">  lock_data: 1</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    lock_id: 4189:80:3:11</span><br><span class="line">lock_trx_id: 4189</span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `atguigudb3`.`account`</span><br><span class="line"> lock_index: PRIMARY</span><br><span class="line"> lock_space: 80</span><br><span class="line">  lock_page: 3</span><br><span class="line">   lock_rec: 11</span><br><span class="line">  lock_data: 1</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h2 id="13-多版本并发控制"><a href="#13-多版本并发控制" class="headerlink" title="13 多版本并发控制"></a>13 多版本并发控制</h2><h3 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1.什么是MVCC"></a>1.什么是MVCC</h3><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 &#x3D;&#x3D;并发控制&#x3D;&#x3D; 。这项技术使得在InnoDB的事务隔离级别下执行 &#x3D;&#x3D;一致性读 操作&#x3D;&#x3D;有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。  </p>
<p>MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的（大家可以参考相关的DBMS文档）。这里讲解InnoDB中MVCC的实现机制（MySQL其他的存储引擎并不支持它）。</p>
<h3 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2.快照读与当前读"></a>2.快照读与当前读</h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到即使有读写冲突时，也能做到 不加锁 ， 非阻塞并发读 ，而这个读指的就是 快照读 , 而非 当前读 。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。  </p>
<h4 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h4><p>快照读又叫一致性读，读取的是快照数据。&#x3D;&#x3D;不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读&#x3D;&#x3D;；比如这样：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM player WHERE ...</span><br></pre></td></tr></table></figure>

<p>之所以出现快照读的情况，是基于提高并发性能的考虑，&#x3D;&#x3D;快照读的实现是基于MVCC&#x3D;&#x3D;，它在很多情况下，避免了加锁操作，降低了开销。</p>
<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>
<p>快照读的前提是 隔离级别&#x3D;&#x3D;不是串行级别&#x3D;&#x3D;，串行级别下的快照读会退化成当前读。  </p>
<h4 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h4><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。&#x3D;&#x3D;加锁的 SELECT&#x3D;&#x3D;，或者&#x3D;&#x3D;对数据进行增删改都会进行当前读&#x3D;&#x3D;。比如：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁</span><br><span class="line"></span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line"></span><br><span class="line">INSERT INTO student values ... # 排他锁</span><br><span class="line"></span><br><span class="line">DELETE FROM student WHERE ... # 排他锁</span><br><span class="line"></span><br><span class="line">DELETE FROM student WHERE ... # 排他锁</span><br></pre></td></tr></table></figure>

<h3 id="3-复习"><a href="#3-复习" class="headerlink" title="3.复习"></a>3.复习</h3><h4 id="3-1再谈隔离级别"><a href="#3-1再谈隔离级别" class="headerlink" title="3.1再谈隔离级别"></a>3.1再谈隔离级别</h4><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132140291.png" alt="image-20220613214022086">  </p>
<p>在MySQL中，默认的隔离级别是不可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的并发能力。</p>
<p>MVCC可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题！它可以在大多数情况下替代行级锁，降低系统的开销。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132149820.png" alt="image-20220613214959640"></p>
<h4 id="3-2隐藏字段、Undo-Log版本链"><a href="#3-2隐藏字段、Undo-Log版本链" class="headerlink" title="3.2隐藏字段、Undo Log版本链"></a>3.2隐藏字段、Undo Log版本链</h4><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的&#x3D;&#x3D;隐藏列 【隐藏字段】&#x3D;&#x3D;。  </p>
<ul>
<li>&#x3D;&#x3D;trx_id&#x3D;&#x3D; ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给trx_id 隐藏列。</li>
<li>&#x3D;&#x3D;roll_pointer&#x3D;&#x3D; ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然<br>后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p>举例：</p>
<ul>
<li>这是插入前数据的结构情况：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132155442.png" alt="image-20220613215525260"></p>
<blockquote>
<p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。  </p>
</blockquote>
<p>假设之后两个事务id分别为 10 、 20 的事务对这条记录进行 UPDATE 操作，操作流程如下：  </p>
<table>
<thead>
<tr>
<th>发生时间 顺序</th>
<th>事务10</th>
<th>事务20</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE student SET name&#x3D;”李四” WHERE id&#x3D;1;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>UPDATE student SET name&#x3D;”王五” WHERE id&#x3D;1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>UPDATE student SET name&#x3D;”钱七” WHERE id&#x3D;1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>UPDATE student SET name&#x3D;”宋八” WHERE id&#x3D;1;</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 roll_pointer 属性（ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 undo日志都连起来，串成一个链表：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132201223.png" alt="image-20220613220130037"></p>
<p>对该记录每次更新后，都会将旧值放到一条 &#x3D;&#x3D;undo日志&#x3D;&#x3D; 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 &#x3D;&#x3D;roll_pointer&#x3D;&#x3D; 属性连接成一个链表，我们把这个链表称之为 &#x3D;&#x3D;版本链&#x3D;&#x3D; ，版本链的头节点就是当前记录最新的值。</p>
<p>每个版本中还包含生成该版本时对应的 &#x3D;&#x3D;事务id&#x3D;&#x3D; 。  </p>
<h3 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4.MVCC实现原理之ReadView"></a>4.MVCC实现原理之ReadView</h3><p>MVCC的实现依赖于：&#x3D;&#x3D;隐藏字段、Undo  Log、Read View&#x3D;&#x3D;</p>
<h4 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h4><p>在MVCC机制中，多个事务对听一个行记录进行更新会产生多个历史版本，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p>
<p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护当前系统目前&#x3D;&#x3D;活跃事务&#x3D;&#x3D;的ID（活跃指的就是，启动了但还没提交）。</p>
<h4 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h4><p>使用&#x3D;&#x3D;READ UNCOMMITTED&#x3D;&#x3D;隔离级别的事务，用于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p>
<p>使用 &#x3D;&#x3D;SERIALIZABLE&#x3D;&#x3D; 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p>
<p>使用 &#x3D;&#x3D;READ COMMITTED 和 REPEATABLE READ&#x3D;&#x3D; 隔离级别的事务，都必须保证读到 &#x3D;&#x3D;已经提交了的 事务修改过的记录&#x3D;&#x3D;。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，&#x3D;&#x3D;核心问题&#x3D;&#x3D;就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p>这个ReadView中主要包含4个比较重要的内容，分别如下：  </p>
<ol>
<li><p>&#x3D;&#x3D;creator_trx_id&#x3D;&#x3D; ，创建这个 Read View 的事务 ID。</p>
<blockquote>
<p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;trx_ids&#x3D;&#x3D; ，表示在生成ReadView时当前系统中&#x3D;&#x3D;活跃的读写事务的 事务id&#x3D;&#x3D;列表 。</p>
</li>
<li><p>&#x3D;&#x3D;up_limit_id&#x3D;&#x3D; ，&#x3D;&#x3D;活跃的&#x3D;&#x3D;事务中最小的事务 ID。</p>
</li>
<li><p>&#x3D;&#x3D;low_limit_id&#x3D;&#x3D; ，表示生成ReadView时系统中应该分配给下一个事务的 &#x3D;&#x3D;id&#x3D;&#x3D; 值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p>
<blockquote>
<p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p>
</blockquote>
</li>
</ol>
<h4 id="4-3-ReadView的规则【重要】"><a href="#4-3-ReadView的规则【重要】" class="headerlink" title="4.3 ReadView的规则【重要】"></a>4.3 ReadView的规则【重要】</h4><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本 【这里的内容是存放在Undo Log中的】是否可见。</p>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
<h4 id="4-4-MVCC整体操作流程【重要】"><a href="#4-4-MVCC整体操作流程【重要】" class="headerlink" title="4.4 MVCC整体操作流程【重要】"></a>4.4 MVCC整体操作流程【重要】</h4><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID；</li>
<li>获取 ReadView；</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li>
<li>最后返回符合规则的数据。</li>
</ol>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性。依次类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
<blockquote>
<p>InnoDB中，MVCC是通过Undo Log+Read View进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见</p>
</blockquote>
<p>&#x3D;&#x3D;在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。&#x3D;&#x3D;  </p>
<p>如表所示  ：</p>
<table>
<thead>
<tr>
<th>事务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select * from student where id &gt;2;</td>
<td>获取一次Read View</td>
</tr>
<tr>
<td>………</td>
<td></td>
</tr>
<tr>
<td>select * from student where id &gt;2;</td>
<td>获取一次Read View</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。  </p>
</blockquote>
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141036007.png" alt="image-20220614103628819"></p>
<h3 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5.举例说明"></a>5.举例说明</h3><h4 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a>5.1 READ COMMITTED隔离级别下</h4><p>READ COMMITTED ：每次读取数据前都生成一个ReadView。  </p>
<p>现在有两个 事务id 分别为 10 、 20 的事务在执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141105775.png" alt="image-20220614110527599"></p>
<p>假设现在有一个使用 READ COMMITTED 隔离级别的事务开始执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下：</p>
<p>步骤1：在执行SELECT语句时会先生成一个Read VIew，ReadView的trx_ids列表的内容就是 [10，20]，up_limit_id为10，low_limit_id为21，creator_trx_id为0。</p>
<p>步骤2：从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是‘王五’，该版本的trx_id值为10，10在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p>
<p>步骤3：下一个版本的列name的内容是‘李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤4：下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView记录中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三‘的记录</p>
<p>之后，我们把 事务id 为 10 的事务提交一下 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>然后再到 事务id 为 20 的事务中更新一下表 student 中 id 为 1 的记录：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>此刻，表student中 id 为 1 的记录的版本链就长这样：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141149469.png" alt="image-20220614114942257"></p>
<p>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20均未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br><span class="line"></span><br><span class="line">#这一次的查询</span><br><span class="line"># SELECT2：Transaction 10提交，Transaction 20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;王五&#x27;</span><br></pre></td></tr></table></figure>

<p>这个SELECT2的执行过程如下：</p>
<p>步骤1：在执行SELECT语句时会先生成一个Read VIew，ReadView的trx_ids列表的内容就是 [20]，up_limit_id为20，low_limit_id为21，creator_trx_id为0。</p>
<p>步骤2：从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是‘宋八’，该版本的trx_id值为20，20在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p>
<p>步骤3：下一个版本的列name的内容是‘钱七’，该版本的trx_id值也为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤4：下一个版本的列name的内容是‘王五’，该版本的trx_id值为10，小于ReadView记录中的up_limit_id值20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘王五‘的记录</p>
<blockquote>
<p>强调：使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p>
</blockquote>
<h4 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a>5.2 REPEATABLE READ隔离级别下</h4><p>使用 REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。</p>
<p>比如，系统里有两个 事务id 分别为 10 、 20 的事务在执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"></span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141203759.png" alt="image-20220614120352573"></p>
<p>假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure>

<p>SELECT1的执行过程如下：</p>
<p>步骤1：在执行SELECT语句时会先生成一个Read VIew，ReadView的trx_ids列表的内容就是 [10，20]，up_limit_id为10，low_limit_id为21，creator_trx_id为0。</p>
<p>步骤2：从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是‘王五’，该版本的trx_id值为10，10在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p>
<p>步骤3：下一个版本的列name的内容是‘李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤4：下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView记录中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三‘的记录</p>
<p>之后，我们把 事务id 为 10 的事务提交一下，就像这样：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>然后再到 事务id 为 20 的事务中更新一下表 student 中 id 为 1 的记录：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中 id 为 1 的记录的版本链长这样：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141205028.png" alt="image-20220614120549822"></p>
<p>然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20均未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br><span class="line"></span><br><span class="line">#这一次的查询</span><br><span class="line"># SELECT2：Transaction 10提交，Transaction 20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值仍为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure>

<p>因为在REPEATABLE READ 隔离级别，所以这一次查询仍然是上面开始的第一个查询生成的ReadView。</p>
<p>这个SELECT2的执行过程如下：</p>
<p>步骤1：在执行SELECT语句时会用第一个查询生成的Read VIew，ReadView的trx_ids列表的内容就是 [10，20]，up_limit_id为10，low_limit_id为21，creator_trx_id为0。</p>
<p>步骤2：从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是‘宋八’，该版本的trx_id值为20，20在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p>
<p>步骤3：下一个版本的列name的内容是‘钱七’，该版本的trx_id值也为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤4：下一个版本的列name的内容是‘王五’，该版本的trx_id值为10，10在trx_ids列表内，所以不符合可见性要求，继续跳到下一个版本</p>
<p>步骤5：下一个版本的列name的内容是‘李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤6：下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView记录中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三‘的记录</p>
<h4 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a>5.3 如何解决幻读</h4><p>接下来说明InnoDB 是如何解决幻读的。</p>
<p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141305674.png" alt="image-20220614130541421"></p>
<p>假设现在有事务 A 和事务 B 并发执行， 事务 A 的事务 id 为 20 ， 事务 B 的事务 id 为 30 。 </p>
<p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id &gt;= 1;</span><br></pre></td></tr></table></figure>

<p> 在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： trx_ids&#x3D;[20,30] ， up_limit_id&#x3D;20 ， low_limit_id&#x3D;31 ， creator_trx_id&#x3D;20 。</p>
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p>
<p>步骤2：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id,name) values(2,&#x27;李四&#x27;);</span><br><span class="line">insert into student(id,name) values(3,&#x27;王五&#x27;);</span><br></pre></td></tr></table></figure>

<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141313717.png" alt="image-20220614131330510"></p>
<p> 步骤3：接着事务 A 开启第二次查询，根据&#x3D;&#x3D;可重复读隔离级别&#x3D;&#x3D;的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<p>1）首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</p>
<p>2）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p>
<p>3）同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。 </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141316983.png" alt="image-20220614131603776"> </p>
<p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。  </p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>这里介绍了 MVCC 在 &#x3D;&#x3D;READ COMMITTD 、 REPEATABLE READ&#x3D;&#x3D; 这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p>
<p>核心点在于 ReadView 的原理， READ COMMITTD 、 REPEATABLE READ 这两个隔离级别的一个&#x3D;&#x3D;很大不同就是生成ReadView的时机不同：&#x3D;&#x3D;</p>
<ul>
<li><p>READ COMMITTD 在每一次进行普通SELECT操作前都会生成一个ReadView</p>
</li>
<li><p>REPEATABLE READ 只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p>
</li>
</ul>
<blockquote>
<p>说明：我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。</p>
</blockquote>
<p>通过MVCC我们可以解决：</p>
<p>1.&#x3D;&#x3D;读写之间阻塞的问题。&#x3D;&#x3D;通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力</p>
<p>2.&#x3D;&#x3D;降低了死锁的概率。&#x3D;&#x3D;这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</p>
<p>3&#x3D;&#x3D;.解决快照读的问题&#x3D;&#x3D;。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</p>
<h2 id="14-其他数据库日志"><a href="#14-其他数据库日志" class="headerlink" title="14.其他数据库日志"></a>14.其他数据库日志</h2><p>我们在讲解数据库事务时，讲过两种日志：重做日志、回滚日志。</p>
<p>对于线上数据库应用系统来说，突然遭遇数据库宕机怎么办？在这种情况下，定位宕机的原因就非常关键，我们可以查看数据库的错误日志。除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。</p>
<p>千万不要小看日志。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数据库应用开发能力至关重要。  </p>
<h3 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1.MySQL支持的日志"></a>1.MySQL支持的日志</h3><h4 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a>1.1 日志类型</h4><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二进制日志 、 错误日志 、 通用查询日志和 慢查询日志 ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使用这些日志文件，可以查看MySQL内部发生的事情。  </p>
<p>这6类日志分别为：</p>
<ul>
<li><p>慢查询日志：记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p>
</li>
<li><p>通用查询日志：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p>
</li>
<li><p>错误日志：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</p>
</li>
<li><p><strong>二进制日志【bin log】</strong>：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p>
</li>
<li><p>中继日志【Relay log】：用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p>
</li>
<li><p>数据定义语句日志：记录数据定义语句执行的元数据操作。</p>
</li>
</ul>
<p>除二进制日志外，其他日志都是 &#x3D;&#x3D;文本文件&#x3D;&#x3D; 。默认情况下，所有日志创建于 MySQL数据目录 中。  </p>
<h4 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a>1.2 日志的弊端</h4><ul>
<li>日志功能会 降低MySQL数据库的性能 。<ul>
<li>例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志</li>
</ul>
</li>
<li>日志会 占用大量的磁盘空间 。<ul>
<li>日志会占用大量的磁盘空间。对于用户量非常大，操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还大。</li>
</ul>
</li>
</ul>
<h3 id="2-慢查询日志（slow-query-log）"><a href="#2-慢查询日志（slow-query-log）" class="headerlink" title="2.慢查询日志（slow query log）"></a>2.慢查询日志（slow query log）</h3><p>在第九章性能分析工具中讲过</p>
<h3 id="3-通用查询日志（general-query-log）"><a href="#3-通用查询日志（general-query-log）" class="headerlink" title="3.通用查询日志（general query log）"></a>3.通用查询日志（general query log）</h3><p>通用查询日志用来 记录用户的所有操作 ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，可以帮助我们准确定位问题。  </p>
<h4 id="3-2-查看当前状态"><a href="#3-2-查看当前状态" class="headerlink" title="3.2 查看当前状态"></a>3.2 查看当前状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%general%&#x27;;</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| general_log | OFF | #通用查询日志处于关闭状态</span><br><span class="line">| general_log_file | /var/lib/mysql/dmtsai.log | #通用查询日志文件的名称是dmtsai.log</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">2 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-启动日志"><a href="#3-3-启动日志" class="headerlink" title="3.3 启动日志"></a>3.3 启动日志</h4><p><strong>方式1：永久性方式</strong><br>修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log=ON</span><br><span class="line">general_log_file=[path[filename]] #日志文件所在目录路径，filename为日志文件名</span><br></pre></td></tr></table></figure>

<p>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名。  </p>
<p><strong>方式2：临时性方式</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=on; # 开启通用查询日志</span><br><span class="line"></span><br><span class="line">SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置</span><br></pre></td></tr></table></figure>

<p>对应的，关闭操作SQL命令如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=off; # 关闭通用查询日志</span><br></pre></td></tr></table></figure>

<p>查看设置后情况：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-查看日志"><a href="#3-4-查看日志" class="headerlink" title="3.4 查看日志"></a>3.4 查看日志</h4><p>通用查询日志是以 文本文件 的形式存储在文件系统中的，可以使用 文本编辑器 直接打开日志文件。每台MySQL服务器的通用查询日志内容是不同的。</p>
<ul>
<li>在Windows操作系统中，使用文本文件查看器；</li>
<li>在Linux系统中，可以使用vi工具或者gedit工具查看；</li>
<li>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。</li>
</ul>
<p>从 SHOW VARIABLES LIKE ‘general_log%’; 结果中可以看到通用查询日志的位置。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/mysqld, Version: 8.0.26 (MySQL Community Server - GPL). started with:</span><br><span class="line">Tcp port: 3306 Unix socket: /var/lib/mysql/mysql.sock</span><br><span class="line">Time Id Command Argument</span><br><span class="line">2022-01-04T07:44:58.052890Z 10 Query SHOW VARIABLES LIKE &#x27;%general%&#x27;</span><br><span class="line">2022-01-04T07:45:15.666672Z 10 Query SHOW VARIABLES LIKE &#x27;general_log%&#x27;</span><br><span class="line">2022-01-04T07:45:28.970765Z 10 Query select * from student</span><br><span class="line">2022-01-04T07:47:38.706804Z 11 Connect root@localhost on using Socket</span><br><span class="line">2022-01-04T07:47:38.707435Z 11 Query select @@version_comment limit 1</span><br><span class="line">2022-01-04T07:48:21.384886Z 12 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:21.385253Z 12 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:21.385640Z 12 Query USE `atguigu12`</span><br><span class="line">2022-01-04T07:48:21.386179Z 12 Query SHOW FULL TABLES WHERE Table_Type !=</span><br><span class="line">&#x27;VIEW&#x27;</span><br><span class="line">2022-01-04T07:48:23.901778Z 13 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:23.902128Z 13 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:23.905179Z 13 Query USE `atguigu`</span><br><span class="line">2022-01-04T07:48:23.905825Z 13 Query SHOW FULL TABLES WHERE Table_Type !=</span><br><span class="line">&#x27;VIEW&#x27;</span><br><span class="line">2022-01-04T07:48:32.163833Z 14 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:32.164451Z 14 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:32.164840Z 14 Query USE `atguigu`</span><br><span class="line">2022-01-04T07:48:40.006687Z 14 Query select * from account</span><br></pre></td></tr></table></figure>

<p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。  </p>
<h4 id="3-5-停止日志"><a href="#3-5-停止日志" class="headerlink" title="3.5 停止日志"></a>3.5 停止日志</h4><p><strong>方式1：永久性方式</strong><br>修改 my.cnf 或者 my.ini 文件，把[mysqld]组下的 general_log 值设置为 OFF 或者把general_log一项注释掉。修改保存后，再 重启MySQL服务 ，即可生效。 举例1：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log=OFF</span><br></pre></td></tr></table></figure>

<p>举例2：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">#general_log=ON</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong>  </p>
<h4 id="3-6-删除-刷新日志"><a href="#3-6-删除-刷新日志" class="headerlink" title="3.6 删除\刷新日志"></a>3.6 删除\刷新日志</h4><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。  </p>
<p>使用如下命令重新生成查询日志文件，具体命令如下。刷新MySQL数据目录，发现创建了新的日志文件。前提一定要开启通用日志。  【在刷新后，需要开启通用查询日志】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>

<h3 id="4-错误日志-error-log"><a href="#4-错误日志-error-log" class="headerlink" title="4.错误日志(error log)"></a>4.错误日志(error log)</h3><p>通过错误日志可以查看系统的运行状态，便于即时发现故障、修复故障。如果MySQL服务出现异常，错误日志是发现问题、解决问题的首选。</p>
<h4 id="4-1-启动日志"><a href="#4-1-启动日志" class="headerlink" title="4.1 启动日志"></a>4.1 启动日志</h4><p>在MySQL数据库中，错误日志功能是 &#x3D;&#x3D;默认开启&#x3D;&#x3D; 的。而且，错误&#x3D;&#x3D;日志 无法被禁止&#x3D;&#x3D; 。默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 mysqld.log （Linux系统）或hostname.err （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-error=[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名</span><br></pre></td></tr></table></figure>

<p>修改配置项后，需要重启MySQL服务以生效。  </p>
<h4 id="4-2-查看日志"><a href="#4-2-查看日志" class="headerlink" title="4.2 查看日志"></a>4.2 查看日志</h4><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。</p>
<p>查询错误日志的存储路径：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;log_err%&#x27;;</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| log_error | /var/log/mysqld.log |</span><br><span class="line">| log_error_services | log_filter_internal; log_sink_internal |</span><br><span class="line">| log_error_suppression_list | |</span><br><span class="line">| log_error_verbosity | 2 |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下。  </p>
<h4 id="4-3-删除-刷新日志"><a href="#4-3-删除-刷新日志" class="headerlink" title="4.3 删除\刷新日志"></a>4.3 删除\刷新日志</h4><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除，以保证MySQL服务器上的 硬盘空间 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以直接删除 。 </p>
<p>删除原有错误日志文件后 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@atguigu01 log]# mysqladmin -uroot -p flush-logs</span><br><span class="line">Enter password:</span><br><span class="line">mysqladmin: refresh failed; error: &#x27;Could not open file &#x27;/var/log/mysqld.log&#x27; for</span><br><span class="line">error logging.&#x27;</span><br></pre></td></tr></table></figure>

<p>补充操作【先做下面的操作，再做上面的刷新操作】：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p>flush-logs指令操作：</p>
<ul>
<li>MySQL5.5.7以前的版本，flush-logs将错误日志文件重命名为filename.err_old，并创建新的日志文件</li>
<li>从MySQL5.5.7开始，flush-logs只是重新打开日志文件，并不做日志备份和创建的操作</li>
<li>如果日志文件不存在，MySQL启动或者执行flush-logs时会自动创建新的日志文件。重新创建错误日志，大小为0字节。</li>
</ul>
<h3 id="5-二进制日志-bin-log"><a href="#5-二进制日志-bin-log" class="headerlink" title="5.二进制日志(bin log)"></a>5.二进制日志(bin log)</h3><p>binlog可以说是MySQL中比较 &#x3D;&#x3D;重要&#x3D;&#x3D; 的日志了，在日常开发及运维过程中，经常会遇到。</p>
<p>binlog即binary log，二进制日志文件，也叫作&#x3D;&#x3D;变更日志&#x3D;&#x3D;（update log）。它记录了数据库所有执行的&#x3D;&#x3D;DDL 和 DML&#x3D;&#x3D; 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</p>
<p>它以事件形式记录并保存在二进制文件中。通过这些信息，我们可以在线数据更新操作的全过程。</p>
<blockquote>
<p>如果想要记录所有语句（例如，为了识别有问题的查询），需要使用通用查询日志</p>
</blockquote>
<p>binlog主要应用场景：</p>
<ul>
<li>一是用于 &#x3D;&#x3D;数据恢复&#x3D;&#x3D;，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器</li>
<li>二是用于 &#x3D;&#x3D;数据复制&#x3D;&#x3D;  ，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</li>
</ul>
<p>可以说MySQL数据库的数据备份、主备、主主、主从都离不开bin log，需要依靠bin log来同步数据，保证数据一致性。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141643969.png" alt="image-20220614164349706"></p>
<h4 id="5-1-查看默认情况"><a href="#5-1-查看默认情况" class="headerlink" title="5.1 查看默认情况"></a>5.1 查看默认情况</h4><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| log_bin | ON |</span><br><span class="line">| log_bin_basename | /var/lib/mysql/binlog |</span><br><span class="line">| log_bin_index | /var/lib/mysql/binlog.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF |</span><br><span class="line">| log_bin_use_v1_row_events | OFF |</span><br><span class="line">| sql_log_bin | ON |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>如果是在MySQL5.7上面，打开log_bin的方法，就是修改 &#x2F;etc&#x2F;my.cnf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure>

<p>然后重启mysqld服务。</p>
<h4 id="5-2-日志参数设置"><a href="#5-2-日志参数设置" class="headerlink" title="5.2 日志参数设置"></a>5.2 日志参数设置</h4><p><strong>方式1：永久性方式</strong></p>
<p>修改MySQL的my.cnf或my.ini文件可以设置二进制日志的相关参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#启用二进制日志</span><br><span class="line">log-bin=atguigu-bin</span><br><span class="line">binlog_expire_logs_seconds=600</span><br><span class="line">max_binlog_size=100M</span><br></pre></td></tr></table></figure>

<p>重新启动MySQL服务，查询二进制日志的信息，执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| log_bin | ON |</span><br><span class="line">| log_bin_basename | /var/lib/mysql/atguigu-bin |</span><br><span class="line">| log_bin_index | /var/lib/mysql/atguigu-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF |</span><br><span class="line">| log_bin_use_v1_row_events | OFF |</span><br><span class="line">| sql_log_bin | ON |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>设置带文件夹的bin-log日志存放目录</strong>  </p>
<p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span><br></pre></td></tr></table></figure>

<p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R -v mysql:mysql binlog</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<p>数据库文件最好不要与日志文件放在同一个磁盘上，这样，当数据库文件所在的磁盘发生故障时，可以使用日志文件恢复数据</p>
</blockquote>
<p><strong>方式2：临时性方式</strong>  </p>
<p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是在mysql8中只有 会话级别 的设置，没有了global级别的设置。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># global 级别</span><br><span class="line">mysql&gt; set global sql_log_bin=0;</span><br><span class="line">ERROR 1228 (HY000): Variable &#x27;sql_log_bin&#x27; is a SESSION variable and can`t be used</span><br><span class="line">with SET GLOBAL</span><br><span class="line"># session级别</span><br><span class="line">mysql&gt; SET sql_log_bin=0;  #关闭sql_log_bin</span><br><span class="line">Query OK, 0 rows affected (0.01 秒)</span><br></pre></td></tr></table></figure>

<h4 id="5-3-查看日志"><a href="#5-3-查看日志" class="headerlink" title="5.3 查看日志"></a>5.3 查看日志</h4><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。   </p>
<p>MySQL服务 重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了 max_binlog_size 的上限（默认是1GB），就会创建一个新的日志文件。  </p>
<p>查看当前的二进制日志文件列表及大小。指令如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW BINARY LOGS;</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">| Log_name | File_size | Encrypted |</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">| atguigu-bin.000001 | 156 | No |</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">1 行于数据集 (0.02 秒)</span><br></pre></td></tr></table></figure>

<p>所有对数据库的修改都会记录在binlog中，但binlog是二进制文件，无法直接查看，想要直接查看，可以借助mysqlbinlog命令工具了。指令如下：下面命令将行事件以 伪SQL的形式 表现出来  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai ~]<span class="comment"># mysqlbinlog -v &quot;/var/lib/mysql/mysql-bin.000001&quot;;</span></span><br></pre></td></tr></table></figure>

<p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events [IN &#x27;log_name&#x27;] [FROM pos] [LIMIT [offset,] row_count];</span><br></pre></td></tr></table></figure>

<ul>
<li>IN ‘log_name’ ：指定要查询的binlog文件名（不指定就是第一个binlog文件）　</li>
<li>FROM pos ：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li>
<li>LIMIT [offset] ：偏移量(不指定就是0)</li>
<li>row_count :查询总条数（不指定就是所有行）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events in &#x27;mysql-bin.000001&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141817245.png" alt="image-20220614181703951"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events in &#x27;mysql-bin.000001&#x27; from 442;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141817947.png" alt="image-20220614181729711"></p>
<p>上面我们讲了这么多都是基于binlog的默认格式，binlog格式查看  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;binlog_format&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 行于数据集 (0.02 秒)</span><br></pre></td></tr></table></figure>

<p>除此之外，binlog还有两种格式，分别是Statement和Mixed</p>
<ul>
<li>Statement</li>
</ul>
<p>每一条会修改数据的sql都会记录在binlog中。</p>
<p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p>
<ul>
<li>Row</li>
</ul>
<p>5.1.5版本的MySQL才开始支持row level 的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>
<p>优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</p>
<ul>
<li>Mixed</li>
</ul>
<p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p>
<p>详细情况，下章讲解。  </p>
<h4 id="5-4-使用日志恢复数据"><a href="#5-4-使用日志恢复数据" class="headerlink" title="5.4 使用日志恢复数据"></a>5.4 使用日志恢复数据</h4><p>如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间的日志中恢复数据。</p>
<p>mysqlbinlog恢复数据的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename|mysql –uuser -ppass;</span><br></pre></td></tr></table></figure>

<p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复数据库中。  </p>
<ul>
<li>filename ：是日志文件名。</li>
<li>option ：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、<ul>
<li>–stop-position。</li>
<li>–start-date 和 –stop-date ：可以指定恢复数据库的起始时间点和结束时间点。</li>
<li>–start-position和–stop-position ：可以指定恢复数据的开始位置和结束位置。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141839419.png" alt="image-20220614183956153"></p>
<ul>
<li>通过binlog进行恢复数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141847056.png" alt="image-20220614184711787"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/mysqlbinlog --start-position=1696 --stop-position=1917 --database=atguigudb3 /var/lib/mysql/mysql-bin.000001 | /usr/bin/mysql -uroot -proot -v atguigudb3</span><br></pre></td></tr></table></figure>

<h4 id="5-5-删除二进制日志"><a href="#5-5-删除二进制日志" class="headerlink" title="5.5 删除二进制日志"></a>5.5 删除二进制日志</h4><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。&#x3D;&#x3D;PURGE MASTER LOGS&#x3D;&#x3D; 只删除指定部分的二进制日志文件， &#x3D;&#x3D;RESET MASTER&#x3D;&#x3D; 删除所有的二进制日志文件。具体如下：  </p>
<ol>
<li>PURGE MASTER LOGS：删除指定日志文件</li>
</ol>
<p>PURGE MASTER LOGS语法如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘指定日志文件名’</span><br><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE ‘指定日期’</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush logs;  # 重新生成一个二进制文件，后面的更新就将写到这个新生成的二进制文件中</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |      2844 |</span><br><span class="line">| mysql-bin.000002 |       487 |</span><br><span class="line">| mysql-bin.000003 |       201 |</span><br><span class="line">| mysql-bin.000004 |       201 |</span><br><span class="line">| mysql-bin.000005 |       201 |</span><br><span class="line">| mysql-bin.000006 |       201 |</span><br><span class="line">| mysql-bin.000007 |       154 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 删除 000003之前的二进制日志文件</span><br><span class="line">mysql&gt; purge master logs to &#x27;mysql-bin.000003&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000003 |       201 |</span><br><span class="line">| mysql-bin.000004 |       201 |</span><br><span class="line">| mysql-bin.000005 |       201 |</span><br><span class="line">| mysql-bin.000006 |       201 |</span><br><span class="line">| mysql-bin.000007 |       154 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这是删除该日期之前的所有二进制文件</span><br><span class="line">purge master logs before &#x27;20220614&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这是删除所有的二进制文件</span><br><span class="line">reset master</span><br><span class="line"></span><br><span class="line"># 执行完该语句后，原来的所有二进制文件都会被删除  谨慎使用</span><br></pre></td></tr></table></figure>

<h4 id="5-6-其它场景"><a href="#5-6-其它场景" class="headerlink" title="5.6 其它场景"></a>5.6 其它场景</h4><p>二进制日志可以通过数据库的 &#x3D;&#x3D;全量备份&#x3D;&#x3D; 和二进制日志中保存的 &#x3D;&#x3D;增量信息&#x3D;&#x3D; ，完成数据库的 &#x3D;&#x3D;无损失恢复&#x3D;&#x3D; 。但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p>
<p>在这种情况下，一个有效的解决办法是 &#x3D;&#x3D;配置主从数据库服务器&#x3D;&#x3D; ，甚至是 &#x3D;&#x3D;一主多从&#x3D;&#x3D; 的架构，把二进制日志文件的内容通过&#x3D;&#x3D;中继日志&#x3D;&#x3D;，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。  </p>
<h3 id="6-再谈二进制日志（binlog）"><a href="#6-再谈二进制日志（binlog）" class="headerlink" title="6.再谈二进制日志（binlog）"></a>6.再谈二进制日志（binlog）</h3><h4 id="6-1-写入机制"><a href="#6-1-写入机制" class="headerlink" title="6.1 写入机制"></a>6.1 写入机制</h4><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到 &#x3D;&#x3D;binlog cache&#x3D;&#x3D; ，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。 </p>
<p>我们可以通过binlog_cache_size参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）.binlog日志刷盘流程如下：</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141908276.png" alt="image-20220614190821974"> </p>
<blockquote>
<ul>
<li>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度快</li>
<li>上图的fsync，才是将数据持久化到磁盘的操作</li>
</ul>
</blockquote>
<p>write和fsync的时机，可以由参数 &#x3D;&#x3D;sync_binlog&#x3D;&#x3D; 控制，默认是 0 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141912788.png" alt="image-20220614191207437"></p>
<p>为了安全起见，可以设置为 1 ，表示每次提交事务都会执行fsync，就如同&#x3D;&#x3D;redo log 刷盘&#x3D;&#x3D;流程一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141913528.png" alt="image-20220614191347240"></p>
<p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。  </p>
<h4 id="6-2-binlog与redolog对比"><a href="#6-2-binlog与redolog对比" class="headerlink" title="6.2 binlog与redolog对比"></a>6.2 binlog与redolog对比</h4><ul>
<li><p>redo log 它是 &#x3D;&#x3D;物理日志&#x3D;&#x3D; ，记录内容是“在某个数据页上做了什么修改”，属于 &#x3D;&#x3D;InnoDB 存储引擎层&#x3D;&#x3D;产生的。</p>
</li>
<li><p>而 binlog 是 &#x3D;&#x3D;逻辑日志&#x3D;&#x3D; ，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，&#x3D;&#x3D;属于MySQL Server 层。&#x3D;&#x3D;  【注意：undo log也是逻辑日志】</p>
</li>
<li><p>虽然它们都属于持久化的保证，但是侧重点不同：</p>
<ul>
<li>redo log让InnoDB存储引擎拥有了崩溃恢复能力</li>
<li>bin log保证了MySQL集群架构的数据一致性</li>
</ul>
</li>
</ul>
<h4 id="6-3-两阶段提交"><a href="#6-3-两阶段提交" class="headerlink" title="6.3 两阶段提交"></a>6.3 两阶段提交</h4><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在&#x3D;&#x3D;事务执行过程中&#x3D;&#x3D;可以不断写入，而&#x3D;&#x3D;binlog只有在提交事务时&#x3D;&#x3D;才写入，所以redo log与binlog的 &#x3D;&#x3D;写入时机&#x3D;&#x3D; 不一样。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141923804.png" alt="image-20220614192304476"></p>
<p>&#x3D;&#x3D;redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？&#x3D;&#x3D;  </p>
<p>以update语句为例，假设id&#x3D;2的记录，字段c值是0，把字段c值更新成1，SQL语句为update T set c &#x3D; 1 where id &#x3D; 2;</p>
<p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141929571.png" alt="image-20220614192912269"></p>
<p>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。  因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为redo  log日志恢复，这一行c值是1，最终数据不一致。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141937104.png" alt="image-20220614193755746"></p>
<p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用&#x3D;&#x3D;两阶段提交方案&#x3D;&#x3D;。原理很简单，将redo log的写入拆分成了两个步骤prepare和commit，这就是两阶段提交。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141942787.png" alt="image-20220614194259456"></p>
<p>使用两阶段提交后，写入binlog时发生异常也不会有影响  ，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应的binlog日志，就会回滚该事务。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141945537.png" alt="image-20220614194520183"></p>
<p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢  ？</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141947396.png" alt="image-20220614194705755"></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。  </p>
<h3 id="7-中继日志"><a href="#7-中继日志" class="headerlink" title="7.中继日志"></a>7.中继日志</h3><h4 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h4><p>&#x3D;&#x3D;中继日志只在主从服务器架构的从服务器上存在。&#x3D;&#x3D;从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入 &#x3D;&#x3D;本地的日志文件&#x3D;&#x3D; 中，这个从服务器本地的日志文件就叫&#x3D;&#x3D;中继日志&#x3D;&#x3D; 。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的 &#x3D;&#x3D;数据同步&#x3D;&#x3D; 。</p>
<p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p>
<p>文件名的格式是： &#x3D;&#x3D;从服务器名 -relay-bin.序号&#x3D;&#x3D; 。中继日志还有一个索引文件： 从服务器名 -relaybin.index ，用来定位当前正在使用的中继日志。  </p>
<h4 id="7-2-查看中继日志"><a href="#7-2-查看中继日志" class="headerlink" title="7.2 查看中继日志"></a>7.2 查看中继日志</h4><p>中继日志与二进制日志的格式相同，可以用 mysqlbinlog 工具进行查看。下面是中继日志的一个片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SET TIMESTAMP=1618558728/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 950</span><br><span class="line">#210416 15:38:48 server id 1 end_log_pos 832 CRC32 0xcc16d651 Table_map:</span><br><span class="line">`atguigu`.`test` mapped to number 91</span><br><span class="line"># at 1000</span><br><span class="line">#210416 15:38:48 server id 1 end_log_pos 872 CRC32 0x07e4047c Delete_rows: table id</span><br><span class="line">91 flags: STMT_END_F -- server id 1 是主服务器，意思是主服务器删了一行数据</span><br><span class="line">BINLOG &#x27;</span><br><span class="line">CD95YBMBAAAAMgAAAEADAAAAAFsAAAAAAAEABGRlbW8ABHRlc3QAAQMAAQEBAFHWFsw=</span><br><span class="line">CD95YCABAAAAKAAAAGgDAAAAAFsAAAAAAAEAAgAB/wABAAAAfATkBw==</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 1040</span><br></pre></td></tr></table></figure>

<p>  这一段的意思是，主服务器（“server id 1”）对表 atguigu.test 进行了 2 步操作：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定位到表 atguigu.test 编号是 91 的记录，日志位置是 832；</span><br><span class="line">删除编号是 91 的记录，日志位置是 872。</span><br></pre></td></tr></table></figure>

<h4 id="7-3-恢复的典型错误"><a href="#7-3-恢复的典型错误" class="headerlink" title="7.3 恢复的典型错误"></a>7.3 恢复的典型错误</h4><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的 服务器名称 与之前 不同 。而中继日志里是 包含从服务器名 的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。解决的方法也很简单，把从服务器的名称改回之前的名称。  </p>
<h2 id="第15章-主从复制"><a href="#第15章-主从复制" class="headerlink" title="第15章_主从复制"></a>第15章_主从复制</h2><h3 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1.主从复制概述"></a>1.主从复制概述</h3><h4 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a>1.1 如何提升数据库并发能力</h4><p>在实际工作中，我们常常将Redis作为缓存与MySQL配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在在访问数据库，这样就提升了读取的效率，也减少了对后端数据库的访问压力。Redis的缓存架构是高并发架构中非常重要的一环。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220614195652323.png" alt="image-20220614195652323">  </p>
<p>此外，一般应用对数据库而言都是<strong>“ 读多写少 ”，</strong>也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做 <strong>主从架构</strong> 、<strong>进行 读写分离</strong> ，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p>
<p>如果我们的目的在于提升数据库高并发访问的效率，那么<strong>首先考虑</strong>的是如何 <strong>优化SQL和索引</strong> ，这种方式简单有效；<strong>其次才是采用 缓存的策略</strong> ，比如使用 <strong>Redis将热点数据保存在内存数据库</strong>中，提升读取的效率；最后才是对数据库采用 <strong>主从架构</strong> ，进行读写分离。  </p>
<p>按照上面的方式进行优化，使用和维护的成本是由低到高的。</p>
<h4 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a>1.2 主从复制的作用</h4><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。  </p>
<p><strong>第1个作用：读写分离。</strong>  我们可以通过主从复制的方式来同步数据，然后通过读写分离提高数据库并发处理能力。</p>
<ul>
<li>面对读多写少的需求，采用读写分离的方式，可以实现更高的并发访问。同时，我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到从服务器上，让读取更加顺畅。读取顺畅的另一个原因就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行select的读取。</li>
</ul>
<p><strong>第2个作用就是数据备份。</strong>我们通过主从复制将主库上的数据复制到了从库上，相当于是一种&#x3D;&#x3D;热备份机制&#x3D;&#x3D;，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p>
<p><strong>第3个作用是具有高可用性。</strong>  数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。</p>
<p>实际上，更高的高可用性，意味着需要付出更高的成本代价。在现实中我们需要结合业务需求和成本来进行选择。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206142002272.png" alt="image-20220614200238894"></p>
<h3 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2.主从复制的原理"></a>2.主从复制的原理</h3><p>&#x3D;&#x3D;Slave&#x3D;&#x3D; 会从 &#x3D;&#x3D;Master&#x3D;&#x3D; 读取 &#x3D;&#x3D;binlog&#x3D;&#x3D; 来进行数据同步。  </p>
<h4 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a>2.1 原理剖析</h4><p>三个线程</p>
<p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 &#x3D;&#x3D;3 个线程&#x3D;&#x3D; 来操作，一个主库线程，两个从库线程。 </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206142014457.png" alt="image-20220614201442112"> </p>
<ul>
<li><strong>二进制日志转储线程</strong> （Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 &#x3D;&#x3D;加锁&#x3D;&#x3D; ，读取完成之后，再将锁释放掉。</li>
<li><strong>从库 I&#x2F;O 线程</strong> 会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</li>
<li><strong>从库 SQL 线程</strong> 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志</p>
<p>除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p>
</blockquote>
<p>&#x3D;&#x3D;复制三步骤：&#x3D;&#x3D;</p>
<p>步骤1： Master 将写操作记录到二进制日志（ binlog ）。</p>
<p>步骤2： Slave 将 Master 的binary log events拷贝到它的中继日志（ relay log ）；</p>
<p>步骤3： Slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从 接入点 开始复制。  </p>
<p>&#x3D;&#x3D;复制的最大的问题：延时&#x3D;&#x3D;</p>
<h4 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a>2.2 复制的基本原则</h4><ul>
<li>每个 Slave 只有一个 Master</li>
<li>每个 Slave 只能有一个唯一的服务器ID</li>
<li>每个 Master 可以有多个 Slave</li>
</ul>
<h3 id="3-一主一从架构搭建"><a href="#3-一主一从架构搭建" class="headerlink" title="3.一主一从架构搭建"></a>3.一主一从架构搭建</h3><p>一台 主机 用于处理所有 写请求 ，一台 从机 负责所有 读请求 ，架构图如下：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206142023193.png" alt="image-20220614202339902"></p>
<h4 id="3-1准备工作"><a href="#3-1准备工作" class="headerlink" title="3.1准备工作"></a>3.1准备工作</h4><p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206151500784.png" alt="image-20220615150019515"></p>
<h3 id="4-同步数据库一致性问题"><a href="#4-同步数据库一致性问题" class="headerlink" title="4.同步数据库一致性问题"></a>4.同步数据库一致性问题</h3><p>主从同步的要求：</p>
<ul>
<li>读库和写库的数据一致(最终一致)；</li>
<li>写数据必须写到写库；</li>
<li>读数据必须到读库(不一定)；</li>
</ul>
<h4 id="4-1-理解主从延迟问题"><a href="#4-1-理解主从延迟问题" class="headerlink" title="4.1 理解主从延迟问题"></a>4.1 理解主从延迟问题</h4><p>进行主从同步的内容是二进制日志，它是一个文件，在进行 网络传输 的过程中就一定会 存在主从延迟（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的 数据不一致性 问题。  </p>
<h4 id="4-2-主从延迟问题原因"><a href="#4-2-主从延迟问题原因" class="headerlink" title="4.2 主从延迟问题原因"></a>4.2 主从延迟问题原因</h4><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。  </p>
<p>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。造成原因：</p>
<p>1、从库的机器性能比主库要差</p>
<p>2、从库的压力大</p>
<p>3、大事务的执行  </p>
<h4 id="4-3-如何减少主从延迟"><a href="#4-3-如何减少主从延迟" class="headerlink" title="4.3 如何减少主从延迟"></a>4.3 如何减少主从延迟</h4><p>若想要减少主从延迟的时间，可以采取下面的办法：</p>
<p>降低多线程大事务并发的概率，优化业务逻辑</p>
<p>优化SQL，避免慢SQL， 减少批量操作 ，建议写脚本以update-sleep这样的形式完成。</p>
<p>提高从库机器的配置 ，减少主库写binlog和从库读binlog的效率差。</p>
<p> 尽量采用 短的链路 ，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p>
<p>实时性要求的业务读强制走主库，从库只做灾备，备份。  </p>
<h4 id="4-4-如何解决一致性问题"><a href="#4-4-如何解决一致性问题" class="headerlink" title="4.4 如何解决一致性问题"></a>4.4 如何解决一致性问题</h4><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是 备份 ，并没有起到 读写分离 ，分担主库读压力 的作用。  </p>
<ul>
<li>方法1：异步复制</li>
<li>方法2：半同步复制</li>
<li>方法3：组复制</li>
</ul>
<h2 id="16-数据库备份与恢复"><a href="#16-数据库备份与恢复" class="headerlink" title="16.数据库备份与恢复"></a>16.数据库备份与恢复</h2><h3 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1.物理备份与逻辑备份"></a>1.物理备份与逻辑备份</h3><p>物理备份：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用 xtrabackup 工具来进行物理备份。</p>
<p>逻辑备份：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为 <strong>mysqldump</strong> 。逻辑备份就是 备份sql语句 ，在恢复的时候执行备份的sql语句实现数据库数据的重现。  </p>
<h2 id="X-MySQL索引："><a href="#X-MySQL索引：" class="headerlink" title="X: MySQL索引："></a>X: MySQL索引：</h2><blockquote>
<ul>
<li>说起提高数据库性能，索引是最物美价廉的东西了，不用加索引，不用加内存，不用改程序，不用调SQL，查询速度就可能提升百倍千倍了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- empno_index：索引名称</span><br><span class="line">-- emp (empno)：表示在 emp表的 empno列创建索引</span><br><span class="line">create index empno_index on emp (empno)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建的索引也会占用空间。</li>
<li>创建索引后只对创建了索引的列有作用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 如对ename字段就不会起作用</span><br><span class="line">select * from emp where ename = &quot;jidj&quot;   -- 没有在ename创建索引，所以速度依然不变</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>索引的原理：</p>
<ul>
<li>当没有索引的时候，select * from emp where id &#x3D; 1 ，会进行全表扫描，因此查询速度慢。</li>
<li>创建索引后，会创建一个索引的数据结构，比如二叉树，b+树</li>
<li>索引的代价：<ul>
<li>磁盘占用</li>
<li>对dml(update  delete  insert)语句有效率影响，因为需要重新维护索引结构。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>索引的类型：</p>
<ul>
<li><p>主键索引：逐渐自动的为主索引（类型为Primary key）</p>
<ul>
<li><pre><code class="mysql">create table t1 (
    id int primary key,   -- primary key 主键，同时也是索引，称为主键索引
    name varchar(32)
);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 唯一索引：unique</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    create table t1 (</span><br><span class="line">    	id int primary key unique,   -- unique，id是唯一的，同时也是索引，称unique索引。</span><br><span class="line">    	name varchar(32)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>普通索引：index</p>
</li>
<li><p>全文索引：FULLTEXT（适用于MylSAM存储引擎）。开发中考虑使用全文搜索（Solr）和ElasticSearch(ES)</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>索引的使用：</p>
<ul>
<li>添加索引</li>
<li>删除索引</li>
<li>查找索引</li>
<li>修改索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t25 (</span><br><span class="line">	id INT,</span><br><span class="line">	`name` VARCHAR(32)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 查询该表是否有索引</span><br><span class="line"></span><br><span class="line">show index from t25;</span><br><span class="line"></span><br><span class="line">-- 添加索引</span><br><span class="line">--  添加唯一索引</span><br><span class="line">CREATE unique index id_index on t25 (id);</span><br><span class="line"></span><br><span class="line">-- 添加普通索引方式1</span><br><span class="line">CREATE index ids_index on t25 (id);</span><br><span class="line"></span><br><span class="line">-- 如何选择：</span><br><span class="line">-- 1. 如果某列的值，是不会重复的，则优先考虑使用unique索引，否则使用普通索引</span><br><span class="line"></span><br><span class="line">-- 添加普通索引方式2</span><br><span class="line">ALTER TABLE t25 add index id_index (id) </span><br><span class="line"></span><br><span class="line">-- 添加主键索引</span><br><span class="line">ALTER TABLE t25 add primary KEY (id) </span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">DROP INDEX id_index on t25</span><br><span class="line"></span><br><span class="line">-- 删除主键索引</span><br><span class="line">ALTER TABLE t25 drop PRIMARY KEY</span><br><span class="line"></span><br><span class="line">-- 修改索引  ==  先删除，再添加新的索引</span><br><span class="line"></span><br><span class="line">-- 查询索引</span><br><span class="line">-- 1. </span><br><span class="line">show index from t25;</span><br><span class="line">-- 2.</span><br><span class="line">show indexes from t25;</span><br><span class="line">-- 3.</span><br><span class="line">show KEYS from t25;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>小结：哪些列上适合使用索引：</p>
<ul>
<li>较频繁的作为查询条件字段应该创建索引</li>
<li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li>
<li>更新非常频繁的字段不适合创建索引</li>
<li>不会出现在where子句中的字段不该创建索引</li>
</ul>
</blockquote>
<h2 id="XI-MySQL存储引擎"><a href="#XI-MySQL存储引擎" class="headerlink" title="XI:MySQL存储引擎"></a>XI:MySQL存储引擎</h2><blockquote>
<ul>
<li>MySQL的表类型由存储引擎（Storage Engine）决定，主要包括MylSAM、innoDB,Memory等。</li>
<li>MySQL数据表主要支持六种类型，分别是：CSV、Memory、ARCHIVE、MRG_MYISAM、MYISAM、InnoBDB.</li>
<li>这六种又分为两类：一类是“事务安全性”，比如InnoDB，其余都属于第二类，称为非事务安全性（myisam和memory）</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查看所有的存储引擎</span><br><span class="line">show ENGINES;</span><br></pre></td></tr></table></figure>

<img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513150552613.png" alt="image-20220513150552613"  />

<table>
<thead>
<tr>
<th>特点</th>
<th>myisam</th>
<th>Innodb</th>
<th>memory</th>
<th>archive</th>
</tr>
</thead>
<tbody><tr>
<td>批量插入的速度</td>
<td>高</td>
<td>低</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>事务安全</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>表锁</td>
<td>行锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>存储限制</td>
<td>没有</td>
<td>64TB</td>
<td>有</td>
<td>没有</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>集群索引</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据缓存</td>
<td></td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>数据可压缩</td>
<td>支持</td>
<td></td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>空间使用</td>
<td>低</td>
<td>高</td>
<td>N&#x2F;A</td>
<td>非常低</td>
</tr>
<tr>
<td>内存使用</td>
<td>低</td>
<td>高</td>
<td>中等</td>
<td>低</td>
</tr>
<tr>
<td>支持外键</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>小结：</p>
<ul>
<li>myisam不支持事务，也不支持外键，但其访问速度快，对事务完整性没有要求</li>
<li>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是比起MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</li>
<li>MEMORY存储引擎使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用hash索引。但是一旦服务关闭，表中的数据就会丢失掉，表的结构还在。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以管理员身份运行</span></span><br><span class="line"><span class="comment"># 关闭mysql服务</span></span><br><span class="line">C:\Windows\system32&gt;net stop mysql   </span><br><span class="line">MySQL 服务正在停止..</span><br><span class="line">MySQL 服务已成功停止。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启mysql服务</span></span><br><span class="line">C:\Windows\system32&gt;net start mysql</span><br><span class="line">MySQL 服务正在启动 .</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 查看所有的存储引擎</span><br><span class="line">show ENGINES;</span><br><span class="line"></span><br><span class="line">-- INNODB 存储引擎</span><br><span class="line">-- 1. 支持事务 2. 支持外键 3. 支持行级锁</span><br><span class="line"></span><br><span class="line">-- myisam 存储引擎</span><br><span class="line">-- 1. 添加速度快  2.不支持外键和事务  3. 支持表级锁</span><br><span class="line">CREATE TABLE t26 (</span><br><span class="line">	id int,</span><br><span class="line">	`name` VARCHAR(32)</span><br><span class="line">) ENGINE myisam;</span><br><span class="line"></span><br><span class="line">start TRANSACTION;	-- 开启事务</span><br><span class="line">SAVEPOINT t1;			-- 建立安全点</span><br><span class="line">INSERT INTO t26 VALUES(1,&quot;jack&quot;);</span><br><span class="line">select * from t26;		</span><br><span class="line">ROLLBACK to t1;   -- 回滚失效，因为myisam不支持事务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- memory 存储引擎</span><br><span class="line">-- 1. 数据存储在内存中 (一旦mysql服务关闭或重启，表结构还在，但是数据就消失了)</span><br><span class="line">-- 2. 执行速度很快（因为没有IO读写）  3. 默认支持索引（hash表）</span><br><span class="line">CREATE TABLE t27 (</span><br><span class="line">	id int,</span><br><span class="line">	`name` VARCHAR(32)</span><br><span class="line">) ENGINE memory;</span><br><span class="line"></span><br><span class="line">insert into t27 VALUES(1,&quot;tom&quot;),(2,&quot;jack&quot;),(3,&quot;hap&quot;);</span><br><span class="line">select * from t27;</span><br><span class="line"></span><br><span class="line">-- 修改存储引擎</span><br><span class="line">ALTER TABLE `t27`	ENGINE = INNODB;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何选择表的存储引擎：</p>
<ul>
<li>如果你的应用不需要事务，处理的只是基本的CRUD操作，那么MyISAM是不二选择，速度快</li>
<li>如果需要支持事务，选择InnoDB</li>
<li>Memory存储引擎就是将数据存储在内存中，由于没有磁盘I&#x2F;O的等待，速度极快，但由于是内存存储引擎，所作的任何修改在服务器重启后都将消失（经典用法：用户的在线状态）</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/27/MySQL%E5%AD%A6%E4%B9%A0/" data-id="clrv2tqxp000n4hku5edqhzmn" data-title="MySQL学习" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/06/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          并发编程学习
        
      </div>
    </a>
  
  
    <a href="/2022/06/15/Java%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 13.33px;">Go</a> <a href="/tags/JVM/" style="font-size: 13.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 13.33px;">个人</a> <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 13.33px;">云原生</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 13.33px;">并发</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 13.33px;">快捷键</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13.33px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 16.67px;">数据库</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/27/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Mac使用技巧</a>
          </li>
        
          <li>
            <a href="/2024/01/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/12/27/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Java语言学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/">Java虚拟机学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/">LeetCode刷题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Kevin he<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>