<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>并发编程学习 | 侬的杂货铺</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="并发编程学习java快捷键： CTRL+alt：给代码加上一些语句，如try-catch,if-else F4：查看类的层级关系 双击shift：进行全局搜索 Alt+Enter：抛出try-catch异常对码 Alt+Shift+M：将代码提取成一个方法 2.进程与线程2.1 进程与线程  进程： 进程可以视为程序的一个实例。大部分程序可以同时运行多个实例进程。但也有的程序只能启动一个实例进程。">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程学习">
<meta property="og:url" content="https://kdhello07.github.io/2022/06/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="侬的杂货铺">
<meta property="og:description" content="并发编程学习java快捷键： CTRL+alt：给代码加上一些语句，如try-catch,if-else F4：查看类的层级关系 双击shift：进行全局搜索 Alt+Enter：抛出try-catch异常对码 Alt+Shift+M：将代码提取成一个方法 2.进程与线程2.1 进程与线程  进程： 进程可以视为程序的一个实例。大部分程序可以同时运行多个实例进程。但也有的程序只能启动一个实例进程。">
<meta property="og:locale">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220518164204214.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190111092408622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWR1bl9jb29s,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220528111352661.png">
<meta property="article:published_time" content="2022-06-26T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-26T19:45:41.983Z">
<meta property="article:author" content="Kevin he">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220518164204214.png">
  
    <link rel="alternate" href="/atom.xml" title="侬的杂货铺" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">侬的杂货铺</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术、阅读、分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kdhello07.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-并发编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2022-06-26T16:00:00.000Z" itemprop="datePublished">2022-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      并发编程学习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发编程学习"><a href="#并发编程学习" class="headerlink" title="并发编程学习"></a>并发编程学习</h1><p><strong>java快捷键：</strong></p>
<p>CTRL+alt：给代码加上一些语句，如try-catch,if-else</p>
<p>F4：查看类的层级关系</p>
<p>双击shift：进行全局搜索</p>
<p>Alt+Enter：抛出try-catch异常对码</p>
<p>Alt+Shift+M：将代码提取成一个方法</p>
<h2 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2.进程与线程"></a>2.进程与线程</h2><h3 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h3><blockquote>
<ul>
<li>进程：<ul>
<li>进程可以视为程序的一个实例。大部分程序可以同时运行多个实例进程。但也有的程序只能启动一个实例进程。</li>
<li>进程就是用来加载指令、管理内存的。</li>
</ul>
</li>
<li>线程：（内核态线程，内核态，线程跑多个协程，栈MB级别）<ul>
<li>一个进程之内，可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行</li>
<li>Java中，线程作为最小的调度单位，进程作为资源分配的最小单位，在windows中进程是不活动的，只是作为线程的容器。</li>
</ul>
</li>
<li>两者对比：<ul>
<li>进程基本上是独立的，而线程存在于进程内，是进程的一个子集。</li>
<li>进程拥有共享的资源，如内存空间，供其内部的线程共享</li>
<li>线程更轻量，线程上下文切换成本一般要比进程上下文切换低。</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。</li>
<li>进程间通信更加复杂</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-2-并行与并发"><a href="#2-2-并行与并发" class="headerlink" title="2.2 并行与并发"></a>2.2 并行与并发</h3><blockquote>
<ul>
<li>一般会将这种线程轮流使用CPU的做法称为并发，concurrent</li>
<li>多核CPU下，每个核（core）都可以调度运行线程，这时候线程可以是并行的。</li>
<li>并发：是同一时间应对多件事情的能力 （同一时间段内做多件）</li>
<li>并行：是同一时间动手做多件事情的能力 （同一时间做多件）</li>
</ul>
</blockquote>
<h3 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3 应用"></a>2.3 应用</h3><blockquote>
<ul>
<li>同步与异步：<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
</li>
<li>注意：同步在多线程中还有另外一层意思，是让多个线程步调一致</li>
</ul>
</blockquote>
<h2 id="3-Java线程"><a href="#3-Java线程" class="headerlink" title="3. Java线程"></a>3. Java线程</h2><h3 id="3-1-创建和运行线程"><a href="#3-1-创建和运行线程" class="headerlink" title="3.1 创建和运行线程"></a>3.1 创建和运行线程</h3><blockquote>
<ul>
<li><p>方法一，直接使用Thread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法的参数是给线程指定名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体内实现了要执行的任务</span></span><br><span class="line">        XXXXXXXX</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Thread t = new Thread(&quot;t1&quot;)&#123;
        @Override
        public void run() &#123;
            log.debug(&quot;hello&quot;);
        &#125;
    &#125;;
    //t.setName(&quot;t1&quot;);
    t.start();
    log.debug(&quot;main&quot;);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 方法二，使用Runnable配合使用Thread</span><br><span class="line"></span><br><span class="line">  - 把线程和任务（要执行的代码分开）</span><br><span class="line">  - Thread代表线程</span><br><span class="line">  - Runnable可运行的任务（线程要执行的代码）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Runnable runnable = new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //要执行的任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">          </span><br><span class="line">    //创建线程对象</span><br><span class="line">    Thread t = new Thread(runnable);</span><br><span class="line">    //启动线程</span><br><span class="line">    t.start();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>例如</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Runnable runnable = new Runnable() &#123;
        @Override
        public void run() &#123;
            log.debug(&quot;hello&quot;);
        &#125;
    &#125;;
    Thread t = new Thread(runnable,&quot;t2&quot;);
    t.setName(&quot;t2&quot;);
    t.start();
    log.debug(&quot;main&quot;);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在Java 8之后也可以使用lambda 表达式进行简化</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      Runnable runnable = () -&gt; &#123;</span><br><span class="line">          log.debug(&quot;hello&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line">      Thread t = new Thread(runnable,&quot;t2&quot;);</span><br><span class="line">      t.setName(&quot;t2&quot;);</span><br><span class="line">      t.start();</span><br><span class="line">      log.debug(&quot;main&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>原理之Thread与Runnable的关系：</p>
<ul>
<li>分析Thread的源码，理清它与Runnable的关系：</li>
<li>小结：<ul>
<li>方法一是把线程和任务合并在了一起，方法二是把线程和任务分开了</li>
<li>用Runnable更容易与线程池等高级API配合</li>
<li>用Runnable让任务脱离了Thread继承体系，更灵活</li>
</ul>
</li>
</ul>
</li>
<li><p>方法三，FutureTask</p>
<ul>
<li><p>FutureTask能够接收Callable类型的参数，用来处理有返回结果的情况</p>
</li>
<li><pre><code class="java">//创建任务对象
FutureTask&lt;Integer&gt; task3 = new FutureTask&lt;Integer&gt;(() -&gt; &#123;
   log.debug(&quot;hello&quot;);
   return 100;
&#125;);
            
//参数1是任务对象，参数2是线程名字，推荐
new Thread(task3,&quot;t3&quot;).start();
            
//主线程阻塞，同步等待task执行完毕的结果
Integer result = task3.get();
log.debug(result);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 例如：</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">      Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public Integer call() throws Exception &#123;</span><br><span class="line">              log.debug(&quot;hello&quot;);</span><br><span class="line">              TimeUnit.MILLISECONDS.sleep(1000);</span><br><span class="line">              return 100;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">      Thread thread = new Thread(futureTask,&quot;t3&quot;);</span><br><span class="line">      thread.start();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      Integer integer = futureTask.get();</span><br><span class="line">      log.debug(&quot;结果是：&quot;+integer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-3-查看进程线程的方法"><a href="#3-3-查看进程线程的方法" class="headerlink" title="3.3 查看进程线程的方法"></a>3.3 查看进程线程的方法</h3><blockquote>
<ul>
<li>windows<ul>
<li>任务管理器查看进程</li>
<li>tasklist查看进程</li>
<li>taskkill杀死进程</li>
</ul>
</li>
<li>linux<ul>
<li>ps -fe 查看所有进程</li>
<li>ps  -fT -p <PID>  查看某个进程（PID）的所有线程</li>
<li>kill  [PID] 杀死进程[PID]</li>
<li>top 查看进程中相关信息</li>
</ul>
</li>
<li>java<ul>
<li>jps 命令查看所有Java线程</li>
<li>jstack <PID>查看某个Java进程的所有线程状态</li>
<li>jconsole 来查看某个Java进程中线程的运行情况（图形界面）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-4-原理之线程运行"><a href="#3-4-原理之线程运行" class="headerlink" title="3.4 原理之线程运行"></a>3.4 原理之线程运行</h3><blockquote>
<p>栈与栈帧</p>
<ul>
<li>我们都知道JVM中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</li>
<li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存。</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li>
</ul>
<p>线程上下文切换（Thread Context Switch）</p>
<ul>
<li>因为以下原因导致cpu不再执行当前的线程，转而执行另一个线程的代码<ul>
<li>线程的CPU时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要执行</li>
<li>线程自己调用了sleep,yield,wait,join,park,synchronized,lock等方法</li>
</ul>
</li>
<li>当Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的方法，Java中对应的概念就是程序计数器，它的作用是记住下一条JVM指令的执行地址，是线程私有的。<ul>
<li>Context Switch频繁发生会影响性能。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-5-常见方法"><a href="#3-5-常见方法" class="headerlink" title="3.5 常见方法"></a>3.5 常见方法</h3><blockquote>
<ul>
<li>start( ) ：启动新线程，start( )方法只能被调用一次，让线程进行就绪状态 （执行前，该线程的状态是NEW,执行后状态是RUNNABLE） </li>
<li>run( )：让线程进行运行。</li>
</ul>
</blockquote>
<h3 id="3-6-run-和start-区别"><a href="#3-6-run-和start-区别" class="headerlink" title="3.6  run()和start() 区别"></a>3.6  run()和start() 区别</h3><blockquote>
<ul>
<li>直接运行run( )方法，这并没有开启线程来进行执行，只是普通的方法执行由main线程来进行执行。</li>
<li>start( )方法会启动一个线程，并且由这个新开启的线程来运行run( )方法。start（）方法只能执行一次</li>
</ul>
</blockquote>
<h3 id="3-7-sleep-与yield-区别"><a href="#3-7-sleep-与yield-区别" class="headerlink" title="3.7 sleep() 与yield()区别"></a>3.7 sleep() 与yield()区别</h3><blockquote>
<ul>
<li><p>sleep:</p>
<ul>
<li>调用sleep会让当前线程从Running进入Timed Waiting状态(阻塞)</li>
<li>其他线程可以使用interrupt()方法来打断正在睡眠的线程，这是sleep方法会抛出InterruptedException </li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;enter sleep&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">//                    Thread.sleep(2000);</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;中断异常了&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.run();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">      </span><br><span class="line">    thread.start();</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;interrupt...&quot;</span>);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>yield:</p>
<ul>
<li>调用yield会让当前线程从Running进入Runnable就绪状态，然后调度执行其他同优先级的线程。如果这是没有同优先级的线程，那么不能保证让当前线程暂停的效果</li>
<li>具体的实现依赖于操作系统的任务调度</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>线程优先级：</p>
<ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果cpu比较忙，那么优先级高的线程会获得更多的时间片，但CPU空闲，优先级几乎没作用。</li>
</ul>
</blockquote>
<blockquote>
<p>案例：防止CPU占用100%</p>
<ul>
<li><p>&#x3D;&#x3D;sleep实现。&#x3D;&#x3D;【在没有利用cpu来进行计算时，不要让while(true)空转浪费CPU,这时可以用yield&#x2F;sleep来出让CPU的使用权给其他程序】</p>
</li>
<li><pre><code class="java">while (true) &#123;
    try &#123;
        Thread.sleep(50);
    &#125; catch(Exception e) &#123;
        sout(e);
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 可以用wait() 或条件变量来达到类似效果</span><br><span class="line">- 不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景</span><br><span class="line">- sleep适用于无需锁同步的场景</span><br><span class="line">- ==wait实现==</span><br><span class="line"></span><br><span class="line">### 3.8 join方法详解</span><br><span class="line"></span><br><span class="line">- ==join（）方法就是需要让调用该方法的线程 执行结束以后才可以继续往下运行。==（通过isAlive()来进行判断，如果为true，就在这里wait( )等待）</span><br><span class="line"></span><br><span class="line">- join(long mills)  方法是进行等待mills毫秒后，如果调用join方法的调用者依然存活，就不会继续进行等待，而是去执行后面的内容</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">   static int r = 0;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) throws Exception&#123;</span><br><span class="line">       test1();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void test1() throws Exception&#123;</span><br><span class="line">       log.debug(&quot;开始&quot;);</span><br><span class="line">       Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">           log.debug(&quot;开始&quot;);</span><br><span class="line">           try &#123;</span><br><span class="line">               sleep(1);</span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           r = 10;</span><br><span class="line">       &#125;);</span><br><span class="line">       thread.start();</span><br><span class="line">       thread.join(); //main线程会等待thread这个线程执行完后才开始往后继续执行，这里的join方法就是等待thread线程执行完</span><br><span class="line">       log.debug(&quot;jieguowei &quot;+r);</span><br><span class="line">       log.debug(&quot;结束&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<p>应用之同步（案例1）：</p>
<ul>
<li>以调用角度来讲，如果<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果，就能继续运行就是异步</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-9-interrupt方法详解"><a href="#3-9-interrupt方法详解" class="headerlink" title="3.9 interrupt方法详解"></a>3.9 interrupt方法详解</h3><blockquote>
<p>打断sleep、wait、join的线程 【打断处于阻塞状态】</p>
<ul>
<li><p>&#x3D;&#x3D;打断正在sleep的线程，会清空打断状态&#x3D;&#x3D;（初始情况下为false），即打断后，打断状态依然为false.以sleep为例</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Thread t1 = new Thread(() -&gt; &#123;
        log.debug(&quot;sleep...&quot;);
        try &#123;
            TimeUnit.SECONDS.sleep(5);
        &#125; catch (InterruptedException e) &#123;
                  
            e.printStackTrace();
        &#125;
    &#125;,&quot;t1&quot;);
      
    t1.start();
      
    log.debug(&quot;interrupt&quot;);
    try &#123;
        TimeUnit.SECONDS.sleep(1);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    log.debug(&quot;打断前，中断标记 &quot;+t1.isInterrupted());  //false
    t1.interrupt();
    log.debug(&quot;打断后，中断标记 &quot;+t1.isInterrupted());  //false
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ==打断正常执行的线程，不会清空中断状态，打断后，打断状态变为true.==</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">              if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                  //这里在主线程将该线程打断后，就会进入到其中来，然后break跳出。</span><br><span class="line">                  break;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  //没有被中断就做事</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,&quot;t1&quot;);</span><br><span class="line">        </span><br><span class="line">      t1.start();</span><br><span class="line">        </span><br><span class="line">      log.debug(&quot;interrupt&quot;);</span><br><span class="line">      try &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(1);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      log.debug(&quot;打断前，中断标记 &quot;+t1.isInterrupted());  //false</span><br><span class="line">      t1.interrupt();</span><br><span class="line">      log.debug(&quot;打断后，中断标记 &quot;+t1.isInterrupted());  //true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;两阶段终止模式：&#x3D;&#x3D;</p>
<ul>
<li>在一个线程T1中如何优雅地终止线程T2?这里的优雅指的是给T2一个料理后事的机会</li>
</ul>
<p>错误思路：</p>
<ul>
<li><p>使用线程对象的stop( )方法停止线程</p>
<ul>
<li>stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其他线程将永远无法获取锁</li>
</ul>
</li>
<li><p>使用system.exit(int)方法停止线程</p>
<ul>
<li>目的是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
</li>
<li><p>正确的解决办法：通过interrupt( ) + isInterrupted()方式来进行处理。【isInterrupted( )在返回中断状态后，不会清除中断状态，而interrupted( )方法功能是一样的，但是会清除掉中断状态，即会变成false】</p>
</li>
<li><pre><code class="java">@Slf4j(topic = &quot;c.Test3&quot;)
public class Test3 &#123;
    public static void main(String[] args) &#123;
        TwoPhaseTermination termination = new TwoPhaseTermination();
        termination.start();
        try &#123;
            TimeUnit.SECONDS.sleep(4);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        termination.stop();
    &#125;
&#125;
      
@Slf4j(topic = &quot;c.Test3&quot;)
class TwoPhaseTermination &#123;
    private Thread monitor;
    //启动监控线程
    public void start() &#123;
        monitor = new Thread(() -&gt; &#123;
            while (true) &#123;
                if (Thread.currentThread().isInterrupted()) &#123;
                    //如果被打断
                    log.debug(&quot;料理后事&quot;);
                    break;
                &#125;
                try &#123;
                    TimeUnit.SECONDS.sleep(1); //情况1
                    log.debug(&quot;执行监控记录&quot;);
                &#125; catch (InterruptedException e) &#123;
                    //这里是在线程处于sleep时，被主线程interrupt之后进入，但是此时isInterrupted()依然为false,
                    //因为打断sleep会清空中断状态，所以为了真正退出，所以需要再次进行interrupt,此时就是自己中断自己
                    //这是一次正常的interrupt，所以isInterrupted()就变为true了，因此就可以通过上面退出while了。
                    Thread.currentThread().interrupt();
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;);
        monitor.start();
    &#125;
      
    //停止监控线程
    public void stop() &#123;
        monitor.interrupt();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ==打断park线程==</span><br><span class="line"></span><br><span class="line">  - 打断park线程，不会清空打断状态</span><br><span class="line"></span><br><span class="line">  - park( )方法只有在中断状态为false （即isInterrupt( )方法返回false）的时候，才能够停下来。</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(&quot;park...&quot;);</span><br><span class="line">            LockSupport.park();  //执行到这里会一直等待</span><br><span class="line">            log.debug(&quot;unpark...&quot;);</span><br><span class="line">            log.debug(&quot;打断状态 &#123;&#125;&quot;,Thread.currentThread().isInterrupted());</span><br><span class="line">            //log.debug(&quot;打断状态 &#123;&#125;&quot;,Thread.currentThread().interrupted());</span><br><span class="line">            log.debug(&quot;park...&quot;);</span><br><span class="line">            LockSupport.park();  //执行到这里会一直等待</span><br><span class="line">            log.debug(&quot;unpark...&quot;);</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">                </span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                </span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<h3 id="3-10-不推荐使用的方法"><a href="#3-10-不推荐使用的方法" class="headerlink" title="3.10 不推荐使用的方法"></a>3.10 不推荐使用的方法</h3><blockquote>
<p>这些方法已经过时，容易破坏同步代码块，造成线程死锁</p>
<ul>
<li>stop( ) 停止线程运行</li>
<li>suspend( ) 挂起（暂停）线程运行</li>
<li>resume( ) 恢复线程运行</li>
</ul>
</blockquote>
<h3 id="3-11-主线程与守护线程（damon线程）"><a href="#3-11-主线程与守护线程（damon线程）" class="headerlink" title="3.11 主线程与守护线程（damon线程）"></a>3.11 主线程与守护线程（damon线程）</h3><blockquote>
<ul>
<li>默认情况下，Java进程需要等待所有线程都运行结束，才会结束。正常创建的线程都是非守护线程。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</li>
<li>通过 setDamon(true)  来进行设置是否是守护线程，默认为false。</li>
<li>注意：<ul>
<li>垃圾回收器线程（finalizer）就是一种守护线程</li>
<li>Tomcat中的Accept都是守护线程。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-12-线程状态（五种状态）"><a href="#3-12-线程状态（五种状态）" class="headerlink" title="3.12 线程状态（五种状态）"></a>3.12 线程状态（五种状态）</h3><blockquote>
<p>操作系统层面有五种状态：</p>
<ul>
<li>初始状态：仅是在语言层面创建了线程对象，还未与操作系统线程关联</li>
<li>可运行状态：就绪状态，指该状态已经被创建（与操作系统相关联），可以由CPU调度执行</li>
<li>运行状态：指获取了CPU时间片运行中的状态<ul>
<li>当CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>阻塞状态：<ul>
<li>如果调用了阻塞API，如BIO （阻塞IO）读写文件，这是该线程实际不会用到CPU，会导致线程上下文切换，进入阻塞状态</li>
<li>等BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说，只要它们一直不唤醒，调度器就一直不会考虑调度它们。</li>
</ul>
</li>
<li>终止状态：表示线程已经执行完毕，生命周期已经结束，不会再转换为其他状态</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220518164204214.png" alt="image-20220518164204214"></p>
</blockquote>
<h3 id="3-13-线程状态（六种状态）"><a href="#3-13-线程状态（六种状态）" class="headerlink" title="3.13 线程状态（六种状态）"></a>3.13 线程状态（六种状态）</h3><blockquote>
<p>Java层面有六种状态：（主要针对的是State枚举类字段有六个值，NEW，RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED）</p>
<ul>
<li>NEW：new线程刚被创建，但是还没有调用start( )方法</li>
<li>RUNNABLE：当调用了start( )方法之后，注意Java API层面的RUNNABLE状态涵盖了操作系统层面的【可运行状态】、【运行状态】、【阻塞状态】（由于BIO导致的线程阻塞，在Java里无法区分，仍然认为是可运行）</li>
<li>BLOCKED，WAITING,TIMED_WAITING都是Java API层面对阻塞状态的细分</li>
<li>TERMINATED当线程代码运行结束</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70" alt="线程状态图"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示线程的六种状态</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestState&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;t1状态&#123;&#125;&quot;</span>,t1.getState());</span><br><span class="line">        t1.start();</span><br><span class="line">        log.debug(<span class="string">&quot;t1状态&#123;&#125;&quot;</span>,t1.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;t1状态&#123;&#125;&quot;</span>,t1.getState());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;t2状态&#123;&#125;&quot;</span>,t2.getState());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;t3状态&#123;&#125;&quot;</span>,t3.getState());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            func();</span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line">        t4.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            func();</span><br><span class="line">        &#125;, <span class="string">&quot;t5&quot;</span>);</span><br><span class="line">        t5.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;t4状态&#123;&#125;&quot;</span>,t4.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t5状态&#123;&#125;&quot;</span>,t5.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">00</span> <span class="number">779</span> [main] c.TestState - t1状态NEW</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">00</span> <span class="number">787</span> [main] c.TestState - t1状态RUNNABLE</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">01</span> <span class="number">1795</span> [main] c.TestState - t1状态TERMINATED</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">02</span> <span class="number">2799</span> [main] c.TestState - t2状态TIMED_WAITING</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">03</span> <span class="number">3802</span> [main] c.TestState - t3状态WAITING</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">04</span> <span class="number">4809</span> [main] c.TestState - t4状态TIMED_WAITING</span><br><span class="line"><span class="number">17</span>:<span class="number">43</span>:<span class="number">04</span> <span class="number">4809</span> [main] c.TestState - t5状态BLOCKED</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(洗水壶 1分钟) --&gt; b(烧开水 15分钟)</span><br><span class="line">c(洗茶壶,洗茶杯,拿茶叶 4分钟)  </span><br><span class="line">b --&gt; f(泡茶)</span><br><span class="line">c --&gt; f(泡茶)</span><br></pre></td></tr></table></figure>

<h3 id="3-14-本章小结"><a href="#3-14-本章小结" class="headerlink" title="3.14 本章小结"></a>3.14 本章小结</h3><blockquote>
<p>本章的重点在于：</p>
<ul>
<li>线程创建</li>
<li>线程重要的方法：如 start( ),run( ),sleep( ),join( ),interrupt( ),isInterrupted( )</li>
<li>线程状态</li>
<li>同步等待 join( )</li>
<li>模式方面：两阶段终止（isInterrupted( )）</li>
</ul>
</blockquote>
<h2 id="4-共享模型之管程（Monitor）"><a href="#4-共享模型之管程（Monitor）" class="headerlink" title="4.共享模型之管程（Monitor）"></a>4.共享模型之管程（Monitor）</h2><h3 id="4-1-线程共享存在的问题"><a href="#4-1-线程共享存在的问题" class="headerlink" title="4.1 线程共享存在的问题"></a>4.1 线程共享存在的问题</h3><blockquote>
<ul>
<li><p>Java的体现：</p>
<ul>
<li><p>两个线程对初始值进行操作</p>
</li>
<li><pre><code class="java">public class Test4 &#123;
    private static int count = 0;
    public static void main(String[] args) throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                count++;
            &#125;
        &#125;, &quot;t1&quot;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                count--;
            &#125;
        &#125;);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug(&quot;&#123;&#125;&quot;,count);
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 问题分析：以上的结果值是随机的？因为Java中对静态变量的自增，自建操作并不是原子操作，要彻底理解，必须从字节码来进行分析？</span><br><span class="line"></span><br><span class="line">- 例如：对于i++而言（i为静态变量），实际会产生如下的JVM字节码指令。</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  0: getstatic     #2                  // Field count:I  获取静态变量i的值</span><br><span class="line">  3: iconst_1							//准备常量1</span><br><span class="line">  4: iadd								//自增</span><br><span class="line">  5: putstatic     #2                  // Field count:I   将修改后的值存入静态变量i</span><br><span class="line">              </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>而对应的i–也是类似</p>
</li>
<li><pre><code class="java">0: getstatic     #2                  // Field count:I
3: iconst_1
4: isub
5: putstatic     #2                  // Field count:I
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 而Java内存的模型如下，完成静态变量的自增和自减需要在主存和工作内存中进行数据交换。（静态变量存放在方法区/元空间中，由所有线程共享，而非静态变量i存放在虚拟机栈中，每个线程各自有一份）</span><br><span class="line">  - 如果上面代码是在单线程下是不会存在问题的。</span><br><span class="line">  - 在多线程环境下，会出现上下文切换，导致会出问题。</span><br><span class="line"></span><br><span class="line">==临界区==：一段代码块内如果存在对共享资源的多线程读写操作，称这段代码为临界区。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static int counter = 0;</span><br><span class="line">static void increment() &#123;</span><br><span class="line">	//临界区</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void increment() &#123;</span><br><span class="line">	//临界区</span><br><span class="line">    counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;竟态条件(RaceCondition)&#x3D;&#x3D;：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竟态条件。</p>
</blockquote>
<h3 id="4-2-synchronized解决方案"><a href="#4-2-synchronized解决方案" class="headerlink" title="4.2 synchronized解决方案"></a>4.2 synchronized解决方案</h3><blockquote>
<p>应用之互斥：</p>
<ul>
<li><p>为了避免临界区的竟态条件发生，有多种手段可以达到目的：</p>
<ul>
<li>阻塞式的解决方案：synchronized,Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
</li>
<li><p>本次课使用阻塞式的解决方案：synchronized，来解决问题，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其他线程再想获取这个对象锁时就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<ul>
<li>注意：</li>
<li>虽然Java中互斥和同步都可以采用synchronized关键字来完成，但它们是有区别的<ul>
<li>互斥是保证临界区的竟态条件发生，同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后、顺序不同，需要一个线程等待其他线程运行到某个点</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>synchronized：</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">	临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决上面的问题代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="comment">//临界区</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="comment">//临界区</span></span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：</p>
<ul>
<li>synchronized实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程所打断</li>
</ul>
</blockquote>
<h3 id="4-3-方法上的synchronized"><a href="#4-3-方法上的synchronized" class="headerlink" title="4.3 方法上的synchronized"></a>4.3 方法上的synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            方法体</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">######################################################</span><br><span class="line"><span class="comment">//锁住的是类对象，类对象只有一个。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">            方法体</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所谓的线程八锁：</p>
<p>其实就是考察synchronized锁住的是哪个对象：</p>
</blockquote>
<h3 id="4-4-变量的线程安全分析"><a href="#4-4-变量的线程安全分析" class="headerlink" title="4.4 变量的线程安全分析"></a>4.4 变量的线程安全分析</h3><blockquote>
<p>&#x3D;&#x3D;成员变量和静态变量是否线程安全？&#x3D;&#x3D;</p>
<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全。</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadUnsafe</span> <span class="variable">threadUnsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafe</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                threadUnsafe.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;Thread&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadUnsafe</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的代码存在问题：</span></span><br><span class="line">因为两个线程使用的是同一个ThreadUnsafe对象，而这个对象使用的是成员变量list,成员变量位于方法区或者叫元空间，所以两个线程操作的是堆中的同一个对象，因此会存在一个线程在add操作时读取了list，准备进行add但是还没有add成功的时候，而另一个线程就也读取了list对象，准备add,所以会出现虽然每个线程都add了一次，但是list对象本身可能只add了一个值，因此在后面进行两次remove的时候，就会出现ArrayIndexOutOfBoundsException。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;局部变量是否线程安全?&#x3D;&#x3D;</p>
<ul>
<li>局部变量是线程安全的</li>
<li>但局部变量引用的对象则未必：<ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的</li>
<li>如果该对象逃离方法的作用访问，它是线程不安全的</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadSafe</span> <span class="variable">threadsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafe</span>();  <span class="comment">//此时操作的是局部变量就是线程安全的了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                threadsafe.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;Thread&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象逃离对象的访问，就是线程不安全的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadSafeSubClass</span> <span class="variable">threadsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafeSubClass</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                threadsafe.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;Thread&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//这里就又会导致多个线程操作同一个对象，虽然该对象是一个对于前面来说是局部变量的对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;   </span><br><span class="line">           list.add(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常见的线程安全类：</p>
<ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>HashTable</li>
<li>java.util.concurrent包下的类</li>
</ul>
<p>这里说它们是线程安全的，多个线程调用它们同一个实例的某个方法时，是线程安全的，也可以理解为</p>
<ul>
<li>它们的每个方法是原子的 （例如HashTable中的put方法上加了synchronized）</li>
<li>但注意它们多个方法的组合不是原子的</li>
</ul>
</blockquote>
<blockquote>
<p>不可变类线程安全性：</p>
<ul>
<li>String，Integer等都是不可变类，因为其内部的对象是不可改变，因此它们的方法都是线程安全的</li>
</ul>
</blockquote>
<h3 id="4-5-习题"><a href="#4-5-习题" class="headerlink" title="4.5 习题"></a>4.5 习题</h3><blockquote>
<p>买票练习：</p>
<p>下面的代码是存在线程安全问题的。改进的方法就是在sell售票方法上面加上synchronized,对象加锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Sell&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sell</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//模拟多人买票</span></span><br><span class="line">        <span class="type">TicketWindow</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketWindow</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//卖出的票数统计</span></span><br><span class="line">        List&lt;Integer&gt; amount = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sell</span> <span class="operator">=</span> window.sell(randomAmount());</span><br><span class="line">                amount.add(sell);</span><br><span class="line">            &#125;,<span class="string">&quot;thread&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">            thread.start();</span><br><span class="line">            list.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread th : list) &#123;</span><br><span class="line">            th.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计卖出的票数与剩余的票数是否符合</span></span><br><span class="line">        log.debug(<span class="string">&quot;剩余票数&#123;&#125;&quot;</span>,window.getCount());</span><br><span class="line">        log.debug(<span class="string">&quot;卖出的票数&#123;&#125;&quot;</span>,amount.stream().mapToInt(i -&gt; i).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//售票窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketWindow</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TicketWindow</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取余票数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//售票</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sell</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.count &gt;= amount) &#123;</span><br><span class="line">            <span class="built_in">this</span>.count -= amount;</span><br><span class="line">            <span class="keyword">return</span> amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /L %n <span class="keyword">in</span> (1,1,10) <span class="keyword">do</span> java -<span class="built_in">cp</span> <span class="string">&quot;.;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repository\ch\qos\logback\logback-classic\1.2.11\logback-classic-1.2.11.jar;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repository\ch\qos\logback\logback-core\1.2.11\logback-core-1.2.11.jar;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repository\org\slf4j\slf4j-api\1.7.32\slf4j-api-1.7.32.jar&quot;</span> com.example.n4.Sell</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行命令如下：</span></span><br><span class="line">D:\workspace\idea\JVMDemo\concurrent\target\classes&gt;java -<span class="built_in">cp</span> <span class="string">&quot;.;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repositor</span></span><br><span class="line"><span class="string">y\ch\qos\logback\logback-classic\1.2.11\logback-classic-1.2.11.jar;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_reposi</span></span><br><span class="line"><span class="string">tory\ch\qos\logback\logback-core\1.2.11\logback-core-1.2.11.jar;D:\program\apache-maven-3.8.1-bin\apache-maven-3.8.1\mvn_repositor</span></span><br><span class="line"><span class="string">y\org\slf4j\slf4j-api\1.7.32\slf4j-api-1.7.32.jar&quot;</span> com.example.n4.Sell</span><br></pre></td></tr></table></figure>

<blockquote>
<p>转账练习：</p>
<ul>
<li>下面的代码存在线程安全问题，但是注意解决的办法不能简单的在transfer方法上面加synchronized,因为这样是等同于给某一个具体的Account对象进行加锁，并不能防止另一个Account对象对共享资源的访问，所以应该加Account.class对象，这样两个对象共用同一个锁对象，此时就能锁住了。但是这样做效率不是很高。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Transfer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                a.transfer(b,randomAmount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                b.transfer(a,randomAmount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="comment">//查看2000次转账后的总金额看是否发生变化</span></span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,(a.getMoney()+b.getMoney()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//账户</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target,<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="comment">//synchronized(Account.class) &#123;</span></span><br><span class="line">        <span class="comment">//synchronized(this) &#123;   </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= amount) &#123;</span><br><span class="line">                <span class="built_in">this</span>.setMoney(<span class="built_in">this</span>.getMoney() - amount);</span><br><span class="line">                target.setMoney(target.getMoney() + amount);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-Monitor概念"><a href="#4-6-Monitor概念" class="headerlink" title="4.6 Monitor概念"></a>4.6 Monitor概念</h3><p>Java对象头：（以32位虚拟机为例）</p>
<ul>
<li>普通对象</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                     Object Header (64 bits)                  </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|        <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)         |<span class="params">    Klass Word (32 bits) </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组对象</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">---------------------------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                                 Object Header (96 bits)                         </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br><span class="line">|<span class="params">        Mark Word(32bits)       </span>|    <span class="title class_">Klass</span> <span class="title class_">Word</span>(32bits) |<span class="params">  array length(32bits)  </span>|</span><br><span class="line">|<span class="params">----------------------------- --</span>|-----------------------|<span class="params">------------------------</span>|</span><br></pre></td></tr></table></figure>

<ul>
<li>其中Mark Word结构为</li>
</ul>
<blockquote>
<ul>
<li><p>mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位。JVM将字的最低两个位设置为标记位。</p>
</li>
<li><p>age:4：表示gc分代年龄，即转化为老年代的阈值</p>
</li>
</ul>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                  <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)                  |<span class="params">       State        </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| <span class="symbol">identity_hashcode:</span><span class="number">25</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span> |<span class="params"> 01     </span>|       <span class="title class_">Normal</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">  thread:23 </span>| <span class="symbol">epoch:</span><span class="number">2</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">1</span> |<span class="params"> 01     </span>|       <span class="title class_">Biased</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">               ptr_to_lock_record:30          </span>| <span class="number">00</span>     |<span class="params"> Lightweight Locked </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|               <span class="symbol">ptr_to_heavyweight_monitor:</span><span class="number">30</span>  |<span class="params"> 10     </span>| <span class="title class_">Heavyweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                                              </span>| <span class="number">11</span>     |<span class="params">    Marked <span class="keyword">for</span> GC   </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Monitor（锁）</strong></p>
<p>Monitor被翻译为<strong>监视器或管程</strong>。【注意】Monitor是在操作系统中的表示</p>
<ul>
<li><p>每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针</p>
</li>
<li><p>正常情况下，Java对象头中的Mark Word处于Normal状态（标志位为01），当执行synchronized代码之后，就转化到标识为10状态，其中ptr_to_heavyweight_monitor就会指向操作系统中的Monitor管程。后面的过程如下。</p>
</li>
<li><p>大致过程如下：</p>
<ul>
<li>刚开始Monitor中Owner为null</li>
<li>当Thread-2执行synchronized(obj){ }就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner</li>
<li>在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入Monitor中的entryList字段，进入 Blocked状态</li>
<li>Thread-2执行完同步代码块以后，然后会唤醒EntryList中等待的线程来竞争锁，竞争的是非公平的。</li>
<li>其中Monitor中还有WAITING字段，Thread-0，Thread-1是之前获得过锁，但条件不满足进行WAITING状态的线程，后面讲wait-notify时会分析。</li>
</ul>
</li>
<li><blockquote>
<p>注意：</p>
<ul>
<li>synchronized必须是进入同一个对象的monitor,才有上述的效果</li>
<li>不加synchronized的对象不会关联监视器，不遵从以上规则。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<p>原理之synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的代码编译成字节码文件为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: getstatic     #2    //&lt;- lock引用       // Field lock:Ljava/lang/Object;</span><br><span class="line">         3: dup						</span><br><span class="line">         4: astore_1			//lock引用 -&gt; slot 1  局部变量表</span><br><span class="line">         5: monitorenter		//将lock对象 Mark Word置为Monitor指针</span><br><span class="line">         6: getstatic     #3    // &lt;- i             // Field counter:I</span><br><span class="line">         9: iconst_1			//准备常数1</span><br><span class="line">        10: iadd				//+1操作</span><br><span class="line">        11: putstatic     #3    // -&gt; i              // Field counter:I</span><br><span class="line">        14: aload_1				//&lt;- lock引用</span><br><span class="line">        15: monitorexit			//将lock对象Mark Word重置，唤醒EntryList</span><br><span class="line">        16: goto          24</span><br><span class="line">        19: astore_2			//e -&gt; slot 2</span><br><span class="line">        20: aload_1				// &lt;- lock引用</span><br><span class="line">        21: monitorexit			//将lock对象Mark Word重置，唤醒entryList</span><br><span class="line">        22: aload_2				//&lt;- slot 2 (e)</span><br><span class="line">        23: athrow				//throw e</span><br><span class="line">        24: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             6    16    19   any</span><br><span class="line">            19    22    19   any</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>synchronized原理进阶</p>
</blockquote>
<ol>
<li><strong>轻量级锁</strong></li>
</ol>
<blockquote>
<ul>
<li><p>轻量级锁的适用场景：如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
</li>
<li><p>轻量级锁对使用者是透明的，即语法仍然是synchronized</p>
</li>
<li><p>假设有两个方法同步块，利用同一个对象加锁</p>
</li>
<li><pre><code class="java">static final Object obj = new Object();
public static void method1() &#123;
    synchronized (obj) &#123;
        //同步块A
        method2();
    &#125;
&#125;
    
public static void method2() &#123;
    synchronized (obj) &#123;
        //同步块B
    
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</span><br><span class="line"></span><br><span class="line">- 让锁记录中Object reference指向锁对象，并开始尝试用cas替换Object的Mark Word，将Mark Word的值存入锁记录。</span><br><span class="line"></span><br><span class="line">- 如果cas替换成功，对象头中存储了锁记录地址和状态 00，表示由该线程给对象加锁</span><br><span class="line"></span><br><span class="line">- 如果cas失败，有两种情况：</span><br><span class="line"></span><br><span class="line">  - 如果是其他线程已经持有了该Object的轻量级锁，这时表明有竞争，后进来的这个线程就进入锁膨胀过程</span><br><span class="line">  - 如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数。【每次重入，都会有一次CAS检查】</span><br><span class="line"></span><br><span class="line">- 当退出synchronized代码块（解锁时），如果有取值为null的记录，表示有重入，这时重置锁记录，表示重入计数减一。</span><br><span class="line"></span><br><span class="line">- 当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark Word的值恢复给对象头</span><br><span class="line"></span><br><span class="line">  - 成功，则解锁成功</span><br><span class="line">  - 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程。</span><br><span class="line"></span><br><span class="line">2. **锁膨胀**</span><br><span class="line"></span><br><span class="line">- 如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁，这时需要进行锁膨胀，将轻量级锁变为重量级锁。</span><br><span class="line"></span><br><span class="line">- Thread-0刚开始执行 synchronized(obj) 时是轻量级锁，然后在执行的过程中，Thread-1也来执行synchronized(obj)，发现已经有了轻量级锁了，所以加轻量级锁失败，进入锁膨胀流程。即为Object对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入Monitor的EntryList BlOCKED。当Thread-0执行完synchronized代码时，准备退出同步块解锁，使用cas将Mark Word的值恢复给对象头，失败，这时会进入重量级锁解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null,唤醒EntryList 中的BLOCKED线程。</span><br><span class="line"></span><br><span class="line">3. **自旋优化**</span><br><span class="line"></span><br><span class="line">- 重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞（上下文切换）</span><br><span class="line">- 自旋适用于多核CPU，因为自旋重试需要获取CPU的执行，因此单核没有意义，因为另外一个线程可能正在执行。</span><br><span class="line">- 在Java 6 之后，自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性就会高，就多自旋几次，反之，就少自旋，甚至不自旋。</span><br><span class="line">- 自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势</span><br><span class="line">- Java 7之后不能控制是否开启自旋功能</span><br><span class="line"></span><br><span class="line">4. **偏向锁**</span><br><span class="line"></span><br><span class="line">- 轻量级锁在没有竞争时（就自己这一个线程），每次重入仍然需要执行CAS操作</span><br><span class="line"></span><br><span class="line">- Java 6中引入了偏向锁来做进一步优化，只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS，以后只要不发生竞争，这个对象就归该线程所有。（线程ID就是看Mark Word中的偏向锁的thread字段）</span><br><span class="line"></span><br><span class="line">**偏向状态：**</span><br><span class="line"></span><br><span class="line">- Mark word头结构（64bit）</span><br><span class="line"></span><br><span class="line">![img](https://img-blog.csdnimg.cn/20190111092408622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWR1bl9jb29s,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">一个对象创建时：</span><br><span class="line"></span><br><span class="line">- 如果开启了偏向锁（默认开启），那么对象创建后，mark word值为0x05即最后三位为101，这时它的thread,epoch,age都为0，</span><br><span class="line">- 偏向锁是默认是延迟的，不会再程序启动立即生效，如果想避免延迟，可以加VM参数 -XX:BiasedLockingStartupDelay=0来禁用延迟</span><br><span class="line">- 如果没有开启偏向锁，那么对象创建后，mark word值为0x01,即最后3位为001，这时它的hashcode,age,都为0，第一次用到hashcode时才会赋值。</span><br><span class="line">- 可以通过-XX:-UseBiasedLocking 参数来设置是否开启 偏向锁，默认是开启的。</span><br><span class="line">- 当我们调用对象的hashcode（）方法以后，就会将对象hashcode（31位）存入到Mark Word中，此时Mark Word里面的空间就不足以来存储54位的thread(线程ID)，所以锁状态会强制从偏向锁换为正常锁</span><br><span class="line"></span><br><span class="line">**撤销——调用对象hashcode**</span><br><span class="line"></span><br><span class="line">- 调用了对象hashcode，但偏向锁的对象Mark Word中存储的是线程ID,如果调用hashcode会导致偏向锁被撤销</span><br><span class="line">- 轻量级锁会在锁记录中记录hashcode</span><br><span class="line">- 重量级锁会在Monitor中记录hashcode</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       //-XX:BiasedLockingStartupDelay=0  VM参数</span><br><span class="line">   	Dog dog = new Dog();</span><br><span class="line">       TimeUnit.SECONDS.sleep(4);</span><br><span class="line">       dog.hashCode();  //该操作会禁用对象的偏向锁</span><br><span class="line">       log.debug(ClassLayout.parseInstance(dog).toPrintable());  </span><br><span class="line">       synchronized (dog) &#123;</span><br><span class="line">           log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">       &#125;</span><br><span class="line">       log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<p><strong>撤销——其他线程使用对象</strong></p>
<blockquote>
<p>当有其他对象使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBiased</span> &#123;</span><br><span class="line">    <span class="comment">//-XX:BiasedLockingStartupDelay=0 -XX:-UseBiasedLocking  参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable()); <span class="comment">//偏向锁，可偏向</span></span><br><span class="line">            <span class="keyword">synchronized</span> (dog) &#123;</span><br><span class="line">                log.debug(ClassLayout.parseInstance(dog).toPrintable());<span class="comment">//偏向锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable());<span class="comment">//偏向锁</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">                TestBiased.class.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TestBiased.class.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable());  <span class="comment">//偏向锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (dog) &#123;</span><br><span class="line">                log.debug(ClassLayout.parseInstance(dog).toPrintable());  <span class="comment">//此时转为轻量级锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable()); <span class="comment">//正常锁状态</span></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插销——调用wait&#x2F;notify</strong></p>
<blockquote>
<p>也会让偏向锁变为重量级锁，因为wait和notify方法只有monitor对象才有。即就变为了重量级锁。</p>
</blockquote>
<p><strong>批量重定向</strong></p>
<blockquote>
<ul>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的ThreadID 【这里指的偏向指的Mark Word中的Thread字段，这个只与线程有关，而与synchronized（obj）中的这个obj无关系】</li>
<li>当&#x3D;&#x3D;撤销偏向锁【指的是由偏向锁状态转换为其他锁状态，如轻量级线程锁】&#x3D;&#x3D;阈值超过20次后，jvm会这样觉得，我是不是偏向错了呢，于是会在这些给这些对象加锁时重新偏向至加锁线程的线程ID，于是在20次之后于是就变成了偏向锁，而不是轻量级锁。</li>
</ul>
</blockquote>
<p><strong>批量撤销</strong></p>
<blockquote>
<p>当插销偏向锁阈值超过40次后，jvm会这样觉得，自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestBiased&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBiased</span> &#123;</span><br><span class="line">    <span class="comment">//-XX:BiasedLockingStartupDelay=0 -XX:-UseBiasedLocking  参数</span></span><br><span class="line">    <span class="comment">// 【10 0000 1000 1010 1110 1110 0100 0110 10】00 0000 0101  对应的偏向Mark word，</span></span><br><span class="line">    <span class="comment">// 【10 0000 1000 1010 1110 1110 0100 0110 10】  对应的偏向锁Mark word中的Thread</span></span><br><span class="line">    <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">static</span> Thread t3;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Vector&lt;Dog&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lopNumber</span> <span class="operator">=</span> <span class="number">39</span>;</span><br><span class="line">        <span class="comment">//刚开始偏向锁偏向 biased: 0x00000000822bb91a</span></span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lopNumber; i++) &#123;</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">                list.add(d);</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lopNumber; i++) &#123;</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">                log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t3);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lopNumber; i++) &#123;</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">                log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(i+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">		log.debug(<span class="string">&quot;###########&quot;</span>+<span class="string">&quot;\t&quot;</span>+ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Dog</span>()).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190111092408622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWR1bl9jb29s,size_16,color_FFFFFF,t_70" alt="img"></p>
<blockquote>
<p>分析上面的代码：</p>
<ul>
<li>刚一开始时，t1线程第一个Dog对象d为偏向锁状态中的biasable，此时还没有偏向具体的哪一个线程（线程ID）.</li>
<li>当t1线程中开始执行synchronized( d )之后，Dog对象d依然为偏向锁，此时，此时就会有具体偏向的线程ID，因此就不是bisable了，而变成了biased:(t1的线程ID).</li>
<li>所以当在t1线程中的剩余的38个Dog对象d来进行访问的时候，此时为偏向锁，并且偏向的线程ID还是线程t1的ID，因此就不用发生撤销（即转换为轻量级锁），所以剩余的对象在执行synchronized后依然是偏向锁</li>
<li>当线程t2开始执行的时候，在没执行synchronized之前，对象d的状态为偏向锁状态，并且指向线程t1的线程ID，因此在执行到第一个对象d的synchronized (d)时，由于偏向锁的偏向线程ID并不是指向的线程t2的ID，因此就会发生一次撤销偏向锁，d的状态变为轻量级锁。当执行完synchronized代码块之后，就解锁成为了一个正常锁。后面的【0-18】都是这种情况</li>
<li>当t2线程中的循环执行到执行到i&#x3D;19的时候，就相当于是已经达到&#x3D;&#x3D;撤销偏向锁&#x3D;&#x3D;阈值超过20次，因此就会改变偏向锁里面的偏向线程ID，就重新偏向至加锁线程的线程ID，因此偏向线程ID变为此时的线程ID即t2线程的线程ID。因此后面的循环里的i&#x3D;19-38，由于线程偏向的ID已经变为了t2，所以就不会发生撤销偏向锁。</li>
<li>当t3线程到来的时候，这39个变化的过程与在t2线程中是一样的，在执行完后，由于已经达到了插销偏向锁阈值超过40次的条件【这里的次数是三个线程中总的次数】，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的，所以后面新建的对象都是不可偏向的，即是正常的。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###线程t1中的执行情况</span></span><br><span class="line">13:44:26 6424 [t1] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6431 [t1] c.TestBiased -&gt; 1	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6514 [t1] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line"><span class="comment">###线程t2中的执行情况</span></span><br><span class="line">13:44:26 6516 [t2] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6518 [t2] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x00000096d2eff108 (thin lock: 0x00000096d2eff108)</span><br><span class="line">13:44:26 6519 [t2] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">13:44:26 6591 [t2] c.TestBiased -&gt; 18	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6592 [t2] c.TestBiased -&gt; 18	  0   8                    (object header: mark)     0x00000096d2eff108 (thin lock: 0x00000096d2eff108)</span><br><span class="line">13:44:26 6592 [t2] c.TestBiased -&gt; 18	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line"><span class="comment">###插销偏向锁阈值超过20次后发生的情况</span></span><br><span class="line">13:44:26 6594 [t2] c.TestBiased -&gt; 19	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6595 [t2] c.TestBiased -&gt; 19	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6596 [t2] c.TestBiased -&gt; 19	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6681 [t2] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d8b805 (biased: 0x000000009ebdb62e; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6687 [t2] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6689 [t2] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line"><span class="comment">###线程t3中的执行情况</span></span><br><span class="line">13:44:26 6692 [t3] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">13:44:26 6693 [t3] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x00000096d2fff0c8 (thin lock: 0x00000096d2fff0c8)</span><br><span class="line">13:44:26 6694 [t3] c.TestBiased -&gt; 0	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">13:44:26 6851 [t3] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000027af6d86105 (biased: 0x000000009ebdb618; epoch: 0; age: 0)</span><br><span class="line">13:44:26 6856 [t3] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x00000096d2fff0c8 (thin lock: 0x00000096d2fff0c8)</span><br><span class="line">13:44:26 6858 [t3] c.TestBiased -&gt; 38	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line"></span><br><span class="line"><span class="comment">###插销偏向锁阈值超过40次后的情况</span></span><br><span class="line">13:44:26 6863 [main] c.TestBiased -&gt; <span class="comment">###########	  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>锁消除</strong></li>
</ol>
<blockquote>
<ul>
<li>JIT即时编译器，进行热点代码探测，进行优化，如果发现synchronized代码块并不与其他线程进行竞争，所以JIT会进行一个锁消除的动作。</li>
</ul>
</blockquote>
<h3 id="4-7-wait与notify"><a href="#4-7-wait与notify" class="headerlink" title="4.7 wait与notify"></a>4.7 wait与notify</h3><p><strong>原理之wait&#x2F;notify</strong></p>
<blockquote>
<ul>
<li>Owner线程发现条件不满足，调用wait方法，即可进入waitset变为WAITING状态</li>
<li>BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片</li>
<li>BLOCKED线程会在Owner线程释放锁时唤醒</li>
<li>WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进入EntryList重新竞争</li>
</ul>
</blockquote>
<p><strong>API介绍</strong></p>
<blockquote>
<ul>
<li>obj.wait()：让进入obj监视器的线程到waitSet等待</li>
<li>obj.notify()：让obj上正在等待waitSet等待的线程中&#x3D;&#x3D;挑一个&#x3D;&#x3D;唤醒</li>
<li>obj.notifyAll()：让obj上正在waitSet等待的线程全部唤醒</li>
<li>obj.wait(long n)：有时限的等待，到n毫秒后结束等待，或是被notify.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>它们都是线程之间进行协作的手段，都属于Object对象的方法，&#x3D;&#x3D;必须获得此对象的锁，才能调用这几个方法。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="4-8-wait与notify的正确使用姿势"><a href="#4-8-wait与notify的正确使用姿势" class="headerlink" title="4.8 wait与notify的正确使用姿势"></a>4.8 wait与notify的正确使用姿势</h3><blockquote>
<p><strong>sleep(long n)和wait(long n)的区别</strong></p>
<ul>
<li>sleep是Thread方法，而wait是Object方法</li>
<li>sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起用</li>
<li>sleep在睡眠的同时，不会释放对象锁，但wait在等待的时候会释放对象锁</li>
<li>共同点：它们执行后，都进入TIMED_WAITING状态</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">	<span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">		obj.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//干活</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">	obj.notifyAll( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;同步&#x3D;&#x3D;&#x3D;&#x3D;模式之保护性暂停（Guarded Suspension）&#x3D;&#x3D;：用在一个线程等待另一个线程的执行结果</p>
<p>要点：</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个对象GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li>
<li>JDK中，join的实现，Future的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="comment">//线程1等待线程2的下载结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//等待结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.get();</span><br><span class="line">            log.debug((String)o);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行下载&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            obj.complete(result);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加了超时等待的情况实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果的方法</span></span><br><span class="line">    <span class="comment">//timeout 等待超时时间</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//开始时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;  <span class="comment">//while循环是解决虚假唤醒的问题</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> timeout - passTime;</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//注意这里要写的是waitTime，不能是timeOut，因为如果在虚假唤醒的情况下，就会导致超出timeOut的等待时间</span></span><br><span class="line">                    <span class="built_in">this</span>.wait(waitTime); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//求得经历时间</span></span><br><span class="line">                passTime = System.currentTimeMillis() - start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="comment">//线程1等待线程2的下载结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//等待结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.get(<span class="number">2000</span>);</span><br><span class="line">            log.debug((String)o);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行下载&quot;</span>);</span><br><span class="line"><span class="comment">//            Object result = new String(&quot;hello,world&quot;);</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            obj.complete(result);</span></span><br><span class="line">            obj.complete(<span class="literal">null</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>原理之join</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;保护者暂停模式（生产者与消费者一一对应）&#x3D;&#x3D;</p>
<blockquote>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MailBoxes</span> &#123;</span><br><span class="line">    <span class="comment">//Hashtable是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,GuardedObject&gt; boxes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//产生唯一ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">createGuardedObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>(generateId());</span><br><span class="line">        boxes.put(go.getId(),go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">getGuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//收信</span></span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> MailBoxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">&quot;收信 id：&#123;&#125;&quot;</span>,guardedObject.getId());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">mail</span> <span class="operator">=</span> guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;收信 id：&#123;&#125;，内容：&#123;&#125;&quot;</span>,guardedObject.getId(),mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Postman&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Postman</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Postman</span><span class="params">(<span class="type">int</span> id,String mail)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.mail = mail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> MailBoxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">&quot;送信 id:&#123;&#125;,内容&#123;&#125;&quot;</span>,guardedObject.getId(),mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果的方法</span></span><br><span class="line">    <span class="comment">//timeout 等待超时时间</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//开始时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;  <span class="comment">//while循环是解决虚假唤醒的问题</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> timeout - passTime;</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//求得经历时间</span></span><br><span class="line">                passTime = System.currentTimeMillis() - start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="comment">//线程1等待线程2的下载结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*GuardedObject obj = new GuardedObject();</span></span><br><span class="line"><span class="comment">        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            //等待结果</span></span><br><span class="line"><span class="comment">            log.debug(&quot;等待结果&quot;);</span></span><br><span class="line"><span class="comment">            Object o = obj.get(2000);</span></span><br><span class="line"><span class="comment">            log.debug((String)o);</span></span><br><span class="line"><span class="comment">        &#125;,&quot;t1&quot;).start();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            log.debug(&quot;执行下载&quot;);</span></span><br><span class="line"><span class="comment">//            Object result = new String(&quot;hello,world&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">//            obj.complete(result);</span></span><br><span class="line"><span class="comment">            obj.complete(null);</span></span><br><span class="line"><span class="comment">        &#125;,&quot;t2&quot;).start();*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">People</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id : MailBoxes.getIds())&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Postman</span>(id,<span class="string">&quot;内容:&quot;</span>+id).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&#x3D;&#x3D;异步模式之生产者&#x2F;消费者&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>与前面的保护性暂停中的GuardedObject不同，不需要产生结果和消费结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK中各种阻塞队列采用的就是这种模式。</li>
</ul>
</blockquote>
<blockquote>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test7&quot;)</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> id,Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test7&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="comment">//消息的队列集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列为空,消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从队列头部获取消息并返回</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            log.debug(<span class="string">&quot;已消费信息&#123;&#125;&quot;</span>,message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列已满，生产者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从尾部加，从头部取，先进后出</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            log.debug(<span class="string">&quot;以生产消息&#123;&#125;&quot;</span>,message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test7&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id,<span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">            &#125;,<span class="string">&quot;生产者&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-9-park-unpark"><a href="#4-9-park-unpark" class="headerlink" title="4.9 park &amp; unpark"></a>4.9 park &amp; unpark</h3><blockquote>
<p>基本使用</p>
<ul>
<li><p>它们是LockSupport类中的方法，静态方法（类方法）</p>
</li>
<li><pre><code class="java">//暂停当前线程
LockSupport.park()
        
//恢复某个线程
LockSupport.unpark(暂停的线程对象)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 先park再unpark</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      Thread th = new Thread(() -&gt; &#123;</span><br><span class="line">          log.debug(&quot;start...&quot;);</span><br><span class="line">          try &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(1);</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          log.debug(&quot;park...&quot;);</span><br><span class="line">          LockSupport.park();</span><br><span class="line">          log.debug(&quot;resume...&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      th.start();</span><br><span class="line">      try &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(2);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      LockSupport.unpark(th);</span><br><span class="line">      log.debug(&quot;unpark...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //输出结果为：</span><br><span class="line">  10:14:23 804 [Thread-0] c.Test8 -&gt; start...</span><br><span class="line">  10:14:24 1812 [Thread-0] c.Test8 -&gt; park...</span><br><span class="line">  10:14:25 2800 [Thread-0] c.Test8 -&gt; resume...</span><br><span class="line">  10:14:25 2800 [main] c.Test8 -&gt; unpark...</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>先unpark再park</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Thread th = new Thread(() -&gt; &#123;
        log.debug(&quot;start...&quot;);
        try &#123;
            TimeUnit.SECONDS.sleep(2);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        log.debug(&quot;park...&quot;);
        LockSupport.park();   //注意先unpark,再park并不会在这里停住
        log.debug(&quot;resume...&quot;);
    &#125;);
    th.start();
    try &#123;
        TimeUnit.SECONDS.sleep(1);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    LockSupport.unpark(th);
    log.debug(&quot;unpark...&quot;);
&#125;
//输出结果为：
10:11:02 732 [Thread-0] c.Test8 -&gt; start...
10:11:03 1731 [main] c.Test8 -&gt; unpark...
10:11:04 2742 [Thread-0] c.Test8 -&gt; park...
10:11:04 2742 [Thread-0] c.Test8 -&gt; resume...
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">- 与Object的wait &amp; notify相比</span><br><span class="line">  - wait，notify和notifyAll必须配合Object Monitor一起使用，而unpark不必</span><br><span class="line">  - park &amp; unpark是以线程为单位来阻塞和唤醒线程，而notify只能唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么精确</span><br><span class="line">  - park &amp; unpark可以先unpark，而wait &amp; notify不能先notify</span><br><span class="line"></span><br><span class="line">**原理之park &amp; unpark**</span><br><span class="line"></span><br><span class="line">每个线程都有自己的一个Parker对象，由三部分组成  _counter, _cond,和 _mutex。</span><br><span class="line"></span><br><span class="line">- 情况一：先调用park方法，再调用unpark方法</span><br><span class="line">  - 当前线程th0调用Unsafe.park()方法</span><br><span class="line">  - 检查 _counter，这种情况下为0，这时，获得 _mutex互斥锁</span><br><span class="line">  - 线程进入 _cond条件变量阻塞</span><br><span class="line">  - 设置 _counter = 0</span><br><span class="line">  - 另一个线程调用Unsafe.unpark()方法后</span><br><span class="line">  - 调用Unsafe.unpark(th0)方法，设置 _counter为1</span><br><span class="line">  - 唤醒 _cond条件变量中的th0</span><br><span class="line">  - th0线程恢复运行</span><br><span class="line">  - 设置 _counter为0</span><br><span class="line"></span><br><span class="line">- 情况二：先调用unpark( )方法，再调用park() 方法</span><br><span class="line">  - 调用Unsafe.unpark(th0)方法，设置 _counter为1</span><br><span class="line">  - 当前线程th0调用Unsafe.park()方法</span><br><span class="line">  - 检查_counter ,本情况为1，这时线程无需阻塞，继续运行</span><br><span class="line">  - 设置 _counter为0</span><br><span class="line"></span><br><span class="line">### 4.10 重新理解线程状态转换</span><br><span class="line"></span><br><span class="line">![image-20220523104544527](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220523104544527.png)</span><br><span class="line"></span><br><span class="line">- 情况一：NEW ——》RUNNABLE</span><br><span class="line">  - 当调用t.start() 方法时，由NEW ——》RUNNABLE</span><br><span class="line">- 情况二：RUNNABLE 《 ——》WAITING</span><br><span class="line">  - t线程用synchronized(obj) 获取了对象锁后</span><br><span class="line">    - 调用obj.wait()方法时，t线程从RUNNABLE ——》WAITING</span><br><span class="line">    - 调用obj.notify()，obj.notyAll(),t.interrupt()时（从waitSet ——》entryList）</span><br><span class="line">      - 竞争锁成功，t线程从 WAITING ——》BLOCKED ——》RUNNABLE</span><br><span class="line">      - 竞争锁失败，t线程从 WAITING ——》BLOCKED</span><br><span class="line">- 情况三：RUNNABLE 《 ——》WAITING</span><br><span class="line">  - 当前线程调用 t.join() 方法时，当前线程从RUNNABLE ——》WAITING</span><br><span class="line">    - 注意是当前线程在t线程对象的监视器上等待</span><br><span class="line">  - t线程运行结束，或调用了当前线程的interrupt()时，当前线程从WAITING ——》RUNNABLE</span><br><span class="line">- 情况四：RUNNABLE 《 ——》WAITING</span><br><span class="line">  - 当线程调用LockSupport.part()方法会让当前线程从RUNNABLE ——》WAITING</span><br><span class="line">  - 调用LockSupport.unpark(目标线程)或调用了线程的interrupt()，会让目标线程从WAITING ——》RUNNABLE</span><br><span class="line">- 情况五：RUNNABLE 《——》TIMED_WAITING</span><br><span class="line">  - t线程用 synchronized(obj)获取了对象锁后</span><br><span class="line">    - 调用obj.wait(long n)方法时，t线程从 RUNNABLE ——》TIMED_WAITING</span><br><span class="line">    - t线程等待时间超过了n毫秒，或调用obj.notify（）,obj.notifyAll(),t.interrupt()时</span><br><span class="line">      - 竞争锁成功，t线程从TIMED_WAITING——》BLOCKED——》RUNNABLE</span><br><span class="line">      - 竞争锁失败，t线程从TIMED_WAITING——》BLOCKED</span><br><span class="line">- 情况六：RUNNABLE 《——》TIMED_WAITING</span><br><span class="line">  - 当前线程调用t.join(long n)方法时，当前线程从RUNNABLE ——》TIMED_WAITING</span><br><span class="line">    - 注意是当前线程在t线程对象的监视器上等待</span><br><span class="line">  - 当前线程等待时间超过了n毫秒或t线程运行结束，或调用了当前线程的interrupt()时，当前线程从WAITING ——》RUNNABLE</span><br><span class="line">- 情况七：RUNNABLE 《——》TIMED_WAITING</span><br><span class="line">  - 当前线程调用Thread.sleep(long n),当前线程从RUNNABLE ——》TIMED_WAITING</span><br><span class="line">  - 当前线程等待时间超过了n毫秒，当前线程从TIMED_WAITING ——》RUNNABLE</span><br><span class="line">- 情况八：RUNNABLE 《——》TIMED_WAITING</span><br><span class="line">  - 当前线程调用LockSupport.parkNanos(long nanos) 或LockSupport.parkUntil(long millis)时，当前线程从RUNNABLE ——》TIMED_WAITING</span><br><span class="line">  - 调用LockSupport.unpark(目标线程)或调用了线程的interrupt()，或是等待超时，会让目标线程从TIMED_WAITING——》RUNNABLE</span><br><span class="line">- 情况九：RUNNABLE 《——》BLOAKED</span><br><span class="line">  - t线程用synchronized(obj)获取对象锁时 ，如果竞争失败，从RUNNABLE ——》BLOCKED</span><br><span class="line">  - 持obj线程的同步代码块执行完毕，会唤醒该对象上所有BLOCKED的线程重新竞争，如果其中t线程竞争成功，从BLOCKED ——》RUNNABLE，其他失败的线程仍然BLOCKED</span><br><span class="line">- 情况十：RUNNABLE ——》TERMINATED</span><br><span class="line">  - 当前线程执行完毕，进入TERMINATED</span><br><span class="line"></span><br><span class="line">### 4.11 多把锁</span><br><span class="line"></span><br><span class="line">- 多把不相关的锁，可以使用不同的锁对象，增加并发度</span><br><span class="line"></span><br><span class="line">- 将锁的粒度细分：</span><br><span class="line"></span><br><span class="line">  - 好处：增强并发度</span><br><span class="line"></span><br><span class="line">  - 缺点：容易死锁</span><br><span class="line"></span><br><span class="line">### 4.12 活跃性</span><br><span class="line"></span><br><span class="line">**死锁：**</span><br><span class="line"></span><br><span class="line">有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁</span><br><span class="line"></span><br><span class="line">- t1线程获得A对象锁，接下来想获取B对象的锁</span><br><span class="line">- t2线程获得B对象锁，接下来想获取A对象的锁</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//死锁的案例</span><br><span class="line">@Slf4j(topic = &quot;c.Test10&quot;)</span><br><span class="line">public class Test10 &#123;</span><br><span class="line">   public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       Object lock1 = new Object();</span><br><span class="line">       Object lock2 = new Object();</span><br><span class="line">       new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (lock1) &#123;</span><br><span class="line">               log.debug(&quot;lock1&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(2);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronized (lock2)&#123;</span><br><span class="line">                   log.debug(&quot;lock2&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;).start();</span><br><span class="line">       new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (lock2) &#123;</span><br><span class="line">               log.debug(&quot;lock 2&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(2);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronized (lock1) &#123;</span><br><span class="line">                   log.debug(&quot;lock 1&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">//        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">//        log.debug(&quot;neng&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<p><strong>定位死锁</strong></p>
<blockquote>
<ul>
<li>检测死锁可以使用 jstack 进程ID 这个控制台命令来进行查看是否死锁。以及还可以使用jconsole工具来进行检测死锁。</li>
</ul>
</blockquote>
<p><strong>哲学家就餐问题</strong></p>
<ul>
<li>下面是问题代码演示</li>
<li>解决办法：可以将一个哲学家获取筷子的顺序改为先右再左，其他哲学家都是先左后右。但是这样虽然能够解决死锁，但还有可能存在饥饿的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筷子类</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chopstick&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哲学家类</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name,Chopstick left,Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//尝试获得 左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">//尝试获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>,c1,c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>,c2,c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>,c3,c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>,c4,c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>,c5,c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为：</span></span><br><span class="line">08:<span class="number">48</span>:<span class="number">32</span> <span class="number">714</span> [苏格拉底] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">32</span> <span class="number">714</span> [亚里士多德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">33</span> <span class="number">1723</span> [亚里士多德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">33</span> <span class="number">1723</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">34</span> <span class="number">2729</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">34</span> <span class="number">2735</span> [柏拉图] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">35</span> <span class="number">3732</span> [赫拉克利特] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">35</span> <span class="number">3742</span> [苏格拉底] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">36</span> <span class="number">4733</span> [亚里士多德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">36</span> <span class="number">4742</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">37</span> <span class="number">5745</span> [赫拉克利特] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">38</span> <span class="number">6747</span> [亚里士多德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">39</span> <span class="number">7749</span> [柏拉图] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">40</span> <span class="number">8751</span> [苏格拉底] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">41</span> <span class="number">9753</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">08:<span class="number">48</span>:<span class="number">42</span> <span class="number">10755</span> [阿基米德] c.Test11 -&gt; eating...</span><br><span class="line">陷入了等待...  </span><br></pre></td></tr></table></figure>

<p><strong>活锁</strong></p>
<blockquote>
<p>活锁出现在两个线程互相改变对方的结果条件，最后谁也无法结束，例如：</p>
</blockquote>
<p>活锁案例演示：</p>
<blockquote>
<p>解决办法是让两者交错执行，就可以解决，例如将其中一个的睡眠时间设为800毫秒</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test12&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test12</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count：&#123;&#125;&quot;</span>,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count：&#123;&#125;&quot;</span>,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饥饿</strong></p>
<p>一个线程由于优先级太低，始终得不到CPU调度执行，也不能够结束。</p>
<h3 id="4-13-ReentrantLock"><a href="#4-13-ReentrantLock" class="headerlink" title="4.13 ReentrantLock"></a>4.13 ReentrantLock</h3><blockquote>
<p>ReentrantLock是Lock的子类</p>
</blockquote>
<blockquote>
<p>相对于synchronized它具备以下特点：</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁【防止线程饥饿】</li>
<li>支持多个条件变量【实际上是指有多个waitSet】</li>
<li>与synchronized一样，都支持可重入。</li>
</ul>
</blockquote>
<blockquote>
<p>基本语法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ReentrantLock对象</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可重入</strong></p>
<blockquote>
<p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁，如果是不可重入锁，那么第二次获得锁是，自己也会把锁挡住。</p>
</blockquote>
<p>可重入代码的演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;mian...&quot;</span>);</span><br><span class="line">            m1();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;m1...&quot;</span>);</span><br><span class="line">            m2();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;m2...&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可中断</strong></p>
<blockquote>
<ul>
<li>这里的可中断是指：当一个线程在获取某个锁对象时，如果没有获取到，就进入BOLCKED阻塞等待，通过ReentrantLock加锁的锁对象可以通过interrupt()方法打断，让正在等待这个锁对象的线程停止等待，避免死等下去。</li>
<li>而通过synchronized( )加锁的对象，不能够通过interrupt( )方法打断，即当一个线程如果在等待获取synchronized加锁的对象时，不能被interrupt( )打断，只有等待其他持有这个synchronized锁对象释放之后，才能获取到。</li>
<li>代码演示</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test14</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有竞争，那么此方法就会获取lock对象锁</span></span><br><span class="line">                <span class="comment">//如果有竞争就进入阻塞队列，可以被其他线程用interrupt()方法打断</span></span><br><span class="line">                log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line"><span class="comment">//                lock.lock();  该方法加锁不能被中断</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;没有获取锁，返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t1.isInterrupted());</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>锁超时</strong></p>
<p>立刻失败</p>
<ul>
<li>tryLock( ) ：返回boolean值，如果获取锁成功，返回true,获取锁失败，返回false.</li>
<li>tryLock(2, TimeUnit.SECONDS);</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test16</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//如果成功了</span></span><br><span class="line">            log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line"><span class="comment">//            boolean b = lock.tryLock();  </span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                b = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//临界区代码</span></span><br><span class="line">                log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;或得到锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.debug(<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用tryLock( )方法来解决哲学家就餐问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筷子类</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chopstick&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哲学家类</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name,Chopstick left,Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*//尝试获得 左手筷子</span></span><br><span class="line"><span class="comment">            synchronized (left) &#123;</span></span><br><span class="line"><span class="comment">                //尝试获得右手筷子</span></span><br><span class="line"><span class="comment">                synchronized (right) &#123;</span></span><br><span class="line"><span class="comment">                    eat();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="comment">//尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//尝试获得右手筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test11&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>,c1,c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>,c2,c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>,c3,c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>,c4,c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>,c5,c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>公平锁</strong></p>
<blockquote>
<p>ReentrantLock锁默认是不公平锁</p>
<p>公平锁一般没有必要，会降低并发度，后面分析原理时会讲解</p>
</blockquote>
<p><strong>条件变量</strong></p>
<blockquote>
<ul>
<li>synchronized中也有条件变量，就是我们讲原理时哪个waitSet休息室，当条件不满足时进入waitSet等待。</li>
<li>ReentrantLock的条件变量比synchronized强大之处在于，它是支持多个条件变量的，这就好比<ul>
<li>synchronized是那些不满足条件的线程都在一间休息室等消息</li>
<li>而ReentrantLock支持多间休息室，有专门等烟的休息室，专门等早餐的休息室，唤醒时也是按休息室来唤醒</li>
</ul>
</li>
<li>使用流程：<ul>
<li>await前需要获得锁</li>
<li>&#x3D;&#x3D;await执行后，会释放锁&#x3D;&#x3D;，进入conditionObject等待</li>
<li>await的线程被唤醒（或打断，或超时）去重新竞争lock锁</li>
<li>竞争lock锁成功后，从await后继续执行</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object room= <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasFood</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">ROOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//等烟的休息室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteSet</span> <span class="operator">=</span> ROOM.newCondition();</span><br><span class="line">    <span class="comment">//等外卖的休息室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitTakeoutSet</span> <span class="operator">=</span> ROOM.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           ROOM.lock();</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">              log.debug(<span class="string">&quot;有烟没？&#123;&#125;&quot;</span>,hasCigarette);</span><br><span class="line">              <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                  log.debug(<span class="string">&quot;没烟，先等会&quot;</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      waitCigaretteSet.await();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              log.debug(<span class="string">&quot;有烟没？&#123;&#125;&quot;</span>,hasCigarette);</span><br><span class="line">              log.debug(<span class="string">&quot;可以开始干活&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               ROOM.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？&#123;&#125;&quot;</span>,hasFood);</span><br><span class="line">                <span class="keyword">while</span> (!hasFood) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先等会&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitTakeoutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有外卖没？&#123;&#125;&quot;</span>,hasFood);</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                hasFood = <span class="literal">true</span>;</span><br><span class="line">                waitTakeoutSet.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                hasCigarette = <span class="literal">true</span>;</span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">34</span> <span class="number">785</span> [小南] c.Test5 -&gt; 有烟没？<span class="literal">false</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">34</span> <span class="number">797</span> [小南] c.Test5 -&gt; 没烟，先等会</span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">34</span> <span class="number">799</span> [小女] c.Test5 -&gt; 外卖送到没？<span class="literal">false</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">34</span> <span class="number">799</span> [小女] c.Test5 -&gt; 没外卖，先等会</span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">35</span> <span class="number">1800</span> [小女] c.Test5 -&gt; 有外卖没？<span class="literal">true</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">35</span> <span class="number">1800</span> [小女] c.Test5 -&gt; 可以开始干活</span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">36</span> <span class="number">2808</span> [小南] c.Test5 -&gt; 有烟没？<span class="literal">true</span></span><br><span class="line"><span class="number">11</span>:<span class="number">18</span>:<span class="number">36</span> <span class="number">2808</span> [小南] c.Test5 -&gt; 可以开始干活</span><br></pre></td></tr></table></figure>

<p><strong>同步模式之顺序控制</strong></p>
<ul>
<li><p><strong>固定运行顺序</strong></p>
<ul>
<li>比如，必须先2后1打印</li>
</ul>
</li>
<li><p>代码实例：(使用synchronized方法进行解决)</p>
</li>
<li><pre><code class="java">public class Test19 &#123;
    static final Object lock = new Object();
    //表示t2是否运行过
    static boolean t2Rununed = false;
    public static void main(String[] args) &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                while (!t2Rununed) &#123;
                    try &#123;
                        lock.wait();
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;

            log.debug(&quot;1&quot;);
        &#125;,&quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                log.debug(&quot;2&quot;);
                t2Rununed = true;
                lock.notifyAll();
            &#125;
        &#125;,&quot;t2&quot;);
        t1.start();
        t2.start();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 代码实例2：（使用ReentrantLock进行解决）</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class Test19 &#123;</span><br><span class="line">      static final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">      static Condition condition = lock.newCondition();</span><br><span class="line">      //表示t2是否运行过</span><br><span class="line">      static boolean t2Rununed = false;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try &#123;</span><br><span class="line">                  while (!t2Rununed) &#123;</span><br><span class="line">                      try &#123;</span><br><span class="line">                          condition.await();</span><br><span class="line">                      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  log.debug(&quot;1&quot;);</span><br><span class="line">              &#125;finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">  </span><br><span class="line">          &#125;,&quot;t1&quot;);</span><br><span class="line">  </span><br><span class="line">          Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try&#123;</span><br><span class="line">                  log.debug(&quot;2&quot;);</span><br><span class="line">                  t2Rununed = true;</span><br><span class="line">                  condition.signal();</span><br><span class="line">              &#125;finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,&quot;t2&quot;);</span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>代码示例三：（使用park 和unpark解决）</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Thread t1 = new Thread(() -&gt; &#123;
        LockSupport.park();
        log.debug(&quot;1&quot;);
    &#125;,&quot;t1&quot;);

    Thread t2 = new Thread(() -&gt; &#123;
        log.debug(&quot;2&quot;);
        LockSupport.unpark(t1);
    &#125;,&quot;t2&quot;);
    t1.start();
    t2.start();
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **交替输出**</span><br><span class="line"></span><br><span class="line">- 线程1输出 a 5次，线程2输出 b 5次，线程3输出c 5次。现在要求输出abcabcabcabcabcabc</span><br><span class="line"></span><br><span class="line">- 代码示例一：（wait &amp; notify版）</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class Test20 &#123;</span><br><span class="line">      //这里也可以取余来进行解决</span><br><span class="line">      static boolean aTrue = true;</span><br><span class="line">      static boolean bTrue = false;</span><br><span class="line">      static boolean cTrue = false;</span><br><span class="line">      static Object lock = new Object();</span><br><span class="line">  </span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          //打印a的线程1</span><br><span class="line">          Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">  </span><br><span class="line">              synchronized (lock) &#123;</span><br><span class="line">                  for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                      while (!aTrue) &#123;</span><br><span class="line">                          try &#123;</span><br><span class="line">                              lock.wait();</span><br><span class="line">                          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      log.debug(&quot;a&quot;);</span><br><span class="line">                      aTrue = false;</span><br><span class="line">                      bTrue = true;</span><br><span class="line">                      lock.notifyAll();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, &quot;t1&quot;);</span><br><span class="line">          //打印b的线程2</span><br><span class="line">          Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">              synchronized (lock) &#123;</span><br><span class="line">                  for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                      while (!bTrue) &#123;</span><br><span class="line">                          try &#123;</span><br><span class="line">                              lock.wait();</span><br><span class="line">                          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      log.debug(&quot;b&quot;);</span><br><span class="line">                      bTrue = false;</span><br><span class="line">                      cTrue = true;</span><br><span class="line">                      lock.notifyAll();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, &quot;t2&quot;);</span><br><span class="line">          //打印c的线程3</span><br><span class="line">          Thread t3 = new Thread(() -&gt; &#123;</span><br><span class="line">              synchronized (lock) &#123;</span><br><span class="line">                  for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                      while (!cTrue) &#123;</span><br><span class="line">                          try &#123;</span><br><span class="line">                              lock.wait();</span><br><span class="line">                          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      log.debug(&quot;c&quot;);</span><br><span class="line">                      cTrue = false;</span><br><span class="line">                      aTrue = true;</span><br><span class="line">                      lock.notifyAll();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, &quot;t3&quot;);</span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line">          t3.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>代码示例二：【await &amp; signal】</p>
</li>
<li><pre><code class="java">@Slf4j(topic = &quot;c.Test21&quot;)
public class Test21 &#123;
    public static void main(String[] args) &#123;
        AwaitSignal awaitSignal = new AwaitSignal(5);
        Condition a = awaitSignal.newCondition();
        Condition b = awaitSignal.newCondition();
        Condition c = awaitSignal.newCondition();
        Thread tha = new Thread(() -&gt; &#123;
            awaitSignal.print(&quot;a&quot;, a, b);
        &#125;);
        Thread thb = new Thread(() -&gt; &#123;
            awaitSignal.print(&quot;b&quot;, b, c);
        &#125;);
        Thread thc = new Thread(() -&gt; &#123;
            awaitSignal.print(&quot;c&quot;, c, a);
        &#125;);
        tha.start();
        thb.start();
        thc.start();
        try &#123;
            TimeUnit.SECONDS.sleep(1);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        awaitSignal.lock();
        try&#123;
            System.out.println(&quot;开始。。。&quot;);
            a.signal();
        &#125;finally &#123;
            awaitSignal.unlock();
        &#125;
    &#125;

&#125;

@Slf4j(topic = &quot;c.Test21&quot;)
class AwaitSignal extends ReentrantLock &#123;
    private int loopNumber;

    public AwaitSignal(int loopNumber) &#123;
        this.loopNumber = loopNumber;
    &#125;

    //参数1：要打印得内容
    //参数2：进入哪一间休息室
    //参数3：下一间休息室
    public void print(String str,Condition current,Condition next) &#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            this.lock();
            try &#123;
                //先等待唤醒后再进行打印
                try &#123;
                    current.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                log.debug(str);
                next.signal();

            &#125;finally &#123;
                this.unlock();
            &#125;
        &#125;

    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 代码示例三：【park &amp; unpark】</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Slf4j(topic = &quot;c.Test22&quot;)</span><br><span class="line">  public class Test22 &#123;</span><br><span class="line">      private static Thread tha,thb,thc;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          ParkUnpark parkUnpark = new ParkUnpark(5);</span><br><span class="line">          tha = new Thread(() -&gt; &#123;</span><br><span class="line">              parkUnpark.print(&quot;a&quot;,thb);</span><br><span class="line">          &#125;);</span><br><span class="line">          thb = new Thread(() -&gt; &#123;</span><br><span class="line">              parkUnpark.print(&quot;b&quot;,thc);</span><br><span class="line">          &#125;);</span><br><span class="line">          thc = new Thread(() -&gt; &#123;</span><br><span class="line">              parkUnpark.print(&quot;c&quot;,tha);</span><br><span class="line">          &#125;);</span><br><span class="line">          tha.start();</span><br><span class="line">          thb.start();</span><br><span class="line">          thc.start();</span><br><span class="line">          try &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(1);</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          LockSupport.unpark(tha);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Slf4j(topic = &quot;c.Test22&quot;)</span><br><span class="line">  class ParkUnpark &#123;</span><br><span class="line">      private int loopNumber;</span><br><span class="line">  </span><br><span class="line">      public ParkUnpark(int loopNumber) &#123;</span><br><span class="line">          this.loopNumber = loopNumber;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public void print(String str, Thread next) &#123;</span><br><span class="line">          for (int i = 0; i &lt; loopNumber; i++) &#123;</span><br><span class="line">              LockSupport.park();</span><br><span class="line">              log.debug(str);</span><br><span class="line">              LockSupport.unpark(next);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="5-共享模型之内存"><a href="#5-共享模型之内存" class="headerlink" title="5.共享模型之内存"></a>5.共享模型之内存</h2><blockquote>
<ul>
<li><p>上一章主要讲解的Monitor主要关注的是访问共享变量时，保证临界区代码的<strong>原子性</strong>。</p>
</li>
<li><p>这一章进一步深入学习共享变量在多线程间的<strong>可见性</strong>问题与多条指令执行时的<strong>有序性</strong>问题。</p>
</li>
</ul>
</blockquote>
<h3 id="5-1-Java内存模型"><a href="#5-1-Java内存模型" class="headerlink" title="5.1 Java内存模型"></a>5.1 Java内存模型</h3><blockquote>
<ul>
<li><p>JMM即Java Memory Model，它定义了主存【所有线程共享的，如静态成员变量】、工作内存【每个线程私有的】等抽象概念，底层对应着CPU寄存器，缓存，硬件内存，CPU指令优化等</p>
</li>
<li><p>JMM体现在以下几个方面：</p>
<ul>
<li>原子性：保证指令不会受到线程上下文切换的影响</li>
<li>可见性：保证指令不会受cpu缓存的影响</li>
<li>有序性：保证指令不会受CPU指令并行优化的影响</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-2-可见性"><a href="#5-2-可见性" class="headerlink" title="5.2 可见性"></a>5.2 可见性</h3><blockquote>
<p>停不下来的循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (run) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;停止t&quot;</span>);</span><br><span class="line">        run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序会一直执行而不会停下来</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>为什么呢？分析一下</p>
<ol>
<li>初始状态，t线程刚开始从主内存中读取了run的值到工作内存</li>
<li>因为t线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存值自己工作内存中的高速缓存，减少对主存中run的访问，提高效率。</li>
<li>1秒之后，main线程修改了run的值，并同步至主存，而t是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。</li>
</ol>
<blockquote>
<p>上面代码的解决办法：</p>
<ul>
<li>volatile（易变关键字）</li>
<li>它可以用来修饰&#x3D;&#x3D;成员变量和静态成员变量&#x3D;&#x3D;，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">//易变</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (run) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;停止t&quot;</span>);</span><br><span class="line">        run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>synchronized（关键字）</p>
</li>
<li><pre><code class="java">@Slf4j(topic = &quot;c.Test1&quot;)
public class Test1 &#123;
    static boolean run = true;
    
    //锁对象
    final static Object lock = new Object();
    
    public static void main(String[] args) &#123;
        new Thread(() -&gt; &#123;
           while (run) &#123;
               synchronized (lock) &#123;
                   if(!run) &#123;
                       break;
                   &#125;
               &#125;
           &#125;
        &#125;).start();
        try &#123;
            TimeUnit.SECONDS.sleep(1);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        log.debug(&quot;停止t&quot;);
        synchronized (lock) &#123;
            run = false;
        &#125;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**可见性 VS  原子性**</span><br><span class="line"></span><br><span class="line">- 前面例子体现的实际就是可见性，它保证的是在多个线程之间，==一个线程对volatile变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况==</span><br><span class="line">- volatile只能保证看到最新值，不能解决指令交错的问题。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">- synchronized语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性，但缺点是synchronized是属于重量级操作，性能相对更低</span><br><span class="line"></span><br><span class="line">- 如果在前面示例的死循环代码中加入System.out.println( )会发现即使不加volatile，线程t也能正确看到run变量的修改了，想一想为什么？</span><br><span class="line"></span><br><span class="line">  - 因为println( )方法是synchronized的</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public void println(String x) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<p><strong>同步模式之两阶段终止模式</strong></p>
<ul>
<li>使用volatile实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestTwoPhase</span> <span class="variable">twoPhase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTwoPhase</span>();</span><br><span class="line">        twoPhase.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        twoPhase.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTwoPhase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步模式之Balking</strong></p>
<ul>
<li>Balking(犹豫)模式用在一个线程发现另一个线程或者本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestTwoPhase</span> <span class="variable">twoPhase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTwoPhase</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            twoPhase.start();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            twoPhase.start();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            twoPhase.start();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        twoPhase.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        twoPhase.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test2&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTwoPhase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否执行过start方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">starting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>它还经常用来实现线程安全的单例模式【懒汉式】</p>
</li>
<li><pre><code class="java">public final class SingleInstance &#123;
    private static SingleInstance singleInstance;
    
    private SingleInstance() &#123;
    &#125;
    //线程安全的单例模式
    public static synchronized SingleInstance getInstance() &#123;
        if (singleInstance != null) &#123;
            return singleInstance;
        &#125;
        singleInstance = new SingleInstance();
        return singleInstance;
    &#125; 
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.3 有序性</span><br><span class="line"></span><br><span class="line">- JVM会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static int i;</span><br><span class="line">static int j;</span><br><span class="line"></span><br><span class="line">//在某个线程内执行如下赋值操作</span><br><span class="line">i = ...;</span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>可以看到，至于是先执行i还是先执行j，对最终的结果不会产生影响。所以，上面代码真正执行时，两种顺序都可以。</p>
</li>
<li><p>这种特性称之为指令重排，多线程下指令重排会影响正确性，为什么要有重排指令这项优化呢？从CPU执行指令的原理来理解一下吧。【指令流水】</p>
</li>
<li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，这一技术在一段时间内占据了计算机架构的重要地位</p>
</li>
<li><p>提示：&#x3D;&#x3D;分阶段，分工是提升效率的关键。&#x3D;&#x3D;</p>
</li>
<li><p>指令重排的前提是，重排指令不能影响结果</p>
</li>
<li><p>&#x3D;&#x3D;在成员变量或者静态成员变量上加上volatile变量后，可以禁用指令重排。&#x3D;&#x3D;</p>
</li>
</ul>
<p><strong>volatile原理</strong></p>
<blockquote>
<p>volatile的底层实现原理是内存屏障，Memory Barrier(Memory Fence)</p>
<ul>
<li>对volatile变量的写指令后会加入写屏障</li>
<li>对volatile变量的读指令前会加入读屏障</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;1.如何保证可见性&#x3D;&#x3D;</p>
<ul>
<li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中。</p>
</li>
<li><pre><code class="java">public void actor2(T_Result r) &#123;
    num = 2;
    ready = true; //ready是volatile赋值带写屏障
    // 写屏障
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public void actor1(I_Result r) &#123;</span><br><span class="line">      //读屏障</span><br><span class="line">      //ready是volatile读取值带读屏障</span><br><span class="line">      if (ready) &#123;</span><br><span class="line">          r.r1 = num + num;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          r.r1 = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;2.如何保证有序性&#x3D;&#x3D;</p>
<ul>
<li><p>写屏障会确保指令重排序时，不会将写屏幕之前的代码排在写屏障之后</p>
</li>
<li><pre><code class="java">public void actor2(T_Result r) &#123;
    num = 2;
    ready = true; //ready是volatile赋值带写屏障
    // 写屏障
&#125;
//即num = 2;不会出现在 ready=true;之后了
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public void actor1(I_Result r) &#123;</span><br><span class="line">      //读屏障</span><br><span class="line">      //ready是volatile读取值带读屏障</span><br><span class="line">      if (ready) &#123;</span><br><span class="line">          r.r1 = num + num;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          r.r1 = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>还是那句话，不能解决指令交错（不能保证原子性）</p>
<ul>
<li>写屏障仅仅是保证之后的读能读到最新的数据，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
</li>
</ul>
<p>3.double-checked locking问题</p>
<blockquote>
<p>如著名的double-checked locking单例模式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance singleInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程安全的单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SingleInstance.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleInstance != <span class="literal">null</span>) &#123;</span><br><span class="line">            	<span class="keyword">return</span> singleInstance;</span><br><span class="line">       		&#125;</span><br><span class="line">        	singleInstance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">        	<span class="keyword">return</span> singleInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优化后</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance singleInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程安全的单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//首次访问会同步，而之后的使用没有synchronized</span></span><br><span class="line">        <span class="keyword">if</span> (singleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleInstance.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                   	singleInstance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance( )才使用synchronized加锁，后续使用时无需加锁</li>
<li>有隐含的，但很关键的一点：第一个if使用了singleInstance变量，是在同步块之外</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的，因为synchronized虽然能够解决原子性、可见性、有序性，但是有序性这是在代码被synchronized全部包括的前提下才成立的。对于上面代码singleInstance &#x3D;&#x3D; null在synchronized代码块之外，所以会出现singleInstance &#x3D; new SingleInstance();的指令重排，该代码分为两条指令，一条是调用构造函数创建对象，一条是将创建了的对象进行赋值，如果发生了指令重排，就会导致先将还未构造完成的对象赋值给了变量（但是此时变量不是null，但指向的对象不可用，因为还没有构造完成）,因此在此时如果另外一个线程来进行判断singleInstance &#x3D;&#x3D; null时会为false,所以会将变量进行返回，但是该变量指向的对象还为空。所以会出现问题。</p>
<ul>
<li><p>上面问题的解决办法:</p>
</li>
<li><p>将变量加上 volatile,就可以防止指令重排。</p>
</li>
<li><pre><code class="java">public final class SingleInstance &#123;
    private static volatile SingleInstance singleInstance;
        
    private SingleInstance() &#123;
    &#125;
    //线程安全的单例模式
    public static SingleInstance getInstance() &#123;
        //实例没创建，才会进入内部的synchronized代码块
        if (singleInstance == null) &#123;
            synchronized (SingleInstance.class) &#123;
                //也许有其他线程已经创建了实例，所以再判断一次
                if (singleInstance == null) &#123;
                       singleInstance = new SingleInstance();
                &#125;
            &#125;
        &#125;
        return singleInstance;
    &#125; 
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">volatile是在jdk1.5之后才生效。</span><br><span class="line"></span><br><span class="line">**happens-before**</span><br><span class="line"></span><br><span class="line">happens-before规定了对共享变量的写操作对其他线程的读操作可见，它是可见性与有序性的一套规则总结，抛开一下happens-before规则，JMM并不能保证一个线程对共享变量的写，对于其他线程对该共享变量的读可见。</span><br><span class="line"></span><br><span class="line">- 线程解锁m之前对变量的写，对于接下来对m加锁的其他线程对该变量的读可见</span><br><span class="line"></span><br><span class="line"> - ```java</span><br><span class="line">   static int x;</span><br><span class="line">   static Object m = new Object();</span><br><span class="line">   new Thread(() -&gt; &#123;</span><br><span class="line">   	synchronized(m) &#123;   //synchronized能保证对象的可见性</span><br><span class="line">   		x = 10;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;,&quot;t1&quot;).start();</span><br><span class="line">   new Thread(() -&gt; &#123;</span><br><span class="line">   	synchronized(m) &#123;</span><br><span class="line">           sout(x);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).start();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<ul>
<li><p>线程对volatile变量的写，对接下来的其他线程对该变量的读可见</p>
<ul>
<li><pre><code class="java">volatile static int x;
new Thread(() -&gt; &#123;
    x = 10;
&#125;).start();

new Thread(() -&gt; &#123;
    sout(x);
&#125;).start();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 线程start前对变量的写，对该线程开始后对该变量的读可见</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    static int x;</span><br><span class="line">    x = 10;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">    	sout(x);</span><br><span class="line">    &#125;).start();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>线程结束前对变量的写，对其他线程得知它结束后的读可见（比如其他线程调用t1.isAlive( )或t1.join()等待它结束）</p>
<ul>
<li><pre><code>static int x;
Thread th = new Thread(() -&gt; &#123;
    x = 10;
&#125;);
th.start();
th.join();
sout(x);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 线程t1打断t2前（interrupt）对变量的写，对于其他线程得知c2被打断后对变量的读可见（通过t2.interrupted( )或t2.isInterrupted( )）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    static int x;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">    		while (true) &#123;</span><br><span class="line">    			if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">    				sout(x);</span><br><span class="line">    				break;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;,&quot;t2&quot;);</span><br><span class="line">    	t2.start();</span><br><span class="line">    	new Thread(() -&gt; &#123;</span><br><span class="line">    		sleep(1);</span><br><span class="line">    		x = 10;</span><br><span class="line">    		t2.interrupt();</span><br><span class="line">    	&#125;).start();</span><br><span class="line">    	while (!t2.isInterrupt()) &#123;</span><br><span class="line">    		Thread.yield();</span><br><span class="line">    	&#125;</span><br><span class="line">    	sout(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>对变量默认值（0，false，null）的写，对其他线程对该变量的读可见</p>
</li>
<li><p>具有传递性，如果x  hb-&gt; y 并且 y hb-&gt; z ，那么有x  hb-&gt; z，配合volatile的防指令重排，有下面的例子</p>
<ul>
<li><pre><code class="java">volatile static int x;
static int y;
new Thread(() -&gt; &#123;
   y = 10;
   x = 20;
&#125;).start();

new Thread(() -&gt; &#123;
    //x = 20 对t2可见，同时 y = 10也对t2可见
    sout(x);
&#125;)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ==注意：上面这些规则中说的变量都是指的成员变量或静态成员变量。==</span><br><span class="line"></span><br><span class="line">**线程安全单例习题**</span><br><span class="line"></span><br><span class="line">- 单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance() ）时的线程安全，并思考注释中的问题。</span><br><span class="line"></span><br><span class="line">  &gt; 饿汉式：类加载就会导致该单例对象被创建</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</span><br><span class="line"></span><br><span class="line">实现1：【饿汉式】</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//问题1：为什么加final? 防止子类继承它，重写方法，破坏它的单例</span><br><span class="line">//问题2：如果实现了序列化接口，还要做什么来防止反序列化破坏单例？因为反序列化生成的对象与单例对象相比就是不同的对象，解决办法就是实现一个方法readResolve.当有该方法后，就会返回方法中返回的对象，而不是反序列化后的对象。</span><br><span class="line">public final class Singleton implements Serializable &#123;</span><br><span class="line">    //问题3：为什么设置为私有？是否能防止反射创建新的实例？防止其他类通过构造方法无限创建对象。不能防止反射创建新的实例。因为反射可以获得类的构造器，并且通过构造器的setAccessable()为true来进行暴力反射，通过构造方法来进行创建对象</span><br><span class="line">	private Singleton()&#123;&#125;</span><br><span class="line">    //问题4：这样初始化是否能保证单例对象创建时的线程安全？ 可以，静态变量是在类加载的时候进行初始化的，由JVM来保证它的安全性。 cinit只执行一次，所以是线程安全的</span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">	//问题5：为什么提供静态方法而不是直接将INSTANCE设置为public,说出你知道的理由。用方法可以进行更好的封装，可以对其进行改进，可以创建对象时支持更多的控制，可以有范型的支持。</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object readResolve() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>实现2：【枚举】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题1：枚举单例是如何限制实例个数的</span></span><br><span class="line"><span class="comment">//问题2：枚举单例在创建的时候是否存在并发问题？ 不存在</span></span><br><span class="line"><span class="comment">//问题3：枚举单例能否被反射破坏单例？不能</span></span><br><span class="line"><span class="comment">//问题4：枚举单例能否被被反序列化破坏单例？不能</span></span><br><span class="line"><span class="comment">//问题5：枚举单例属于懒汉式还是饿汉式？ 饿汉式</span></span><br><span class="line"><span class="comment">//问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？可以添加构造方法</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分析这里的线程安全，并说明有什么缺点。锁粒度太大，效率太低</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现4：【DCL double check locking】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//问题1：解释为什么要加volatile?防止指令重排，导致获取到的对象是空对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="comment">//问题2：对比实现3为什么这样做？减小锁的粒度，提高效率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//问题3：为什么还要在这里添加非空判断，之前不是判断过了吗？防止在多线程环境下进行多次创建</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//也许有其他线程已经创建了实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                   	INSTANCE = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现5：【静态内部类】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//问题1：属于懒汉式还是饿汉式? 懒汉式，只有在调用getInstance时才创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//问题2：在创建时是否有并发问题？没有并发安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-共享模型之无锁"><a href="#6-共享模型之无锁" class="headerlink" title="6.共享模型之无锁"></a>6.共享模型之无锁</h2><blockquote>
<ul>
<li>CAS与volatile</li>
<li>原子整数</li>
<li>原子引用</li>
<li>原子累加器</li>
<li>Unsafe</li>
</ul>
</blockquote>
<h3 id="6-1-问题的引出"><a href="#6-1-问题的引出" class="headerlink" title="6.1 问题的引出"></a>6.1 问题的引出</h3><h3 id="6-2-CAS与volatile"><a href="#6-2-CAS与volatile" class="headerlink" title="6.2 CAS与volatile"></a>6.2 CAS与volatile</h3><blockquote>
<p>前面看到的AtomicInteger的解决办法，&#x3D;&#x3D;内部并没有用锁来保护共享变量的线程安全&#x3D;&#x3D;，那么它是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意balance是一个AtomicInteger类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">        <span class="keyword">if</span> (balance.compareAndSet(prev,next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键是compareAndSet（比较并设置），它的简称就是CAS，它必须是原子操作。</p>
<ul>
<li>注意：<ul>
<li>其实CAS的底层是lock cmpxchg指令（X86架构），在单核CPU和多核CPU下都能够保证（比较—交换）的原子性</li>
<li>在多核状态下，某个核执行到带lock的指令时，CPU会让总线锁住，当这个核把此指令执行完毕，再开启总线，这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>volatile</strong></p>
<blockquote>
<ul>
<li><p>获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。</p>
</li>
<li><p>它可以用来修饰成员变量或者静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存，即一个线程对volatile变量的修改，对另一个线程可见</p>
<ul>
<li><p>注意：</p>
</li>
<li><p>volatile仅仅保证了共享变量的可见性，让其他线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p>
</li>
</ul>
</li>
<li><p>CAS必须借助volatile才能读取到共享变量的最新值来实现【比较并交换】的效果</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>无锁效率为什么高？</p>
<ul>
<li>因为CAS虽然在while循环中一直高速运行，所以并不会发生线程上下文切换。而synchronized会由可运行状态转换为阻塞状态，发生上下文切换</li>
<li>但是CAS要在多核环境下才有效果，因为线程数过多，就无法给每个线程分配时间片，所以还是会发生上下文切换。</li>
</ul>
</blockquote>
<p><strong>CAS的特点</strong></p>
<ul>
<li>结合CAS和volatile可以实现无锁并发，适用于线程数少，多核CPU的场景下。</li>
<li>CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没有关系，可以进行重试</li>
<li>synchronized是基于悲观锁的思想：最悲观的估计，得防着其他线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会</li>
<li>CAS体现得是无所并发，无阻塞并发，请仔细体会这两句话得意思<ul>
<li>因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升得因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h3 id="6-3-原子整数"><a href="#6-3-原子整数" class="headerlink" title="6.3 原子整数"></a>6.3 原子整数</h3><p>J.U.C并发包提供了</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<p>以AtomicInteger为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">System.out.println(i.incrementAndGet());  <span class="comment">// ++i</span></span><br><span class="line">System.out.println(i.getAndIncrement());  <span class="comment">// i++</span></span><br><span class="line">System.out.println(i.get());</span><br><span class="line">System.out.println(i.addAndGet(<span class="number">5</span>)); <span class="comment">//</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>)); <span class="comment">//这是有步长，步长可正可负</span></span><br><span class="line">System.out.println(i.get());</span><br><span class="line">System.out.println(i.getAndAdd(-<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//updateAndGet接受的是一个接口类型的参数，</span></span><br><span class="line"><span class="comment">//其中operand是i.get()读取到的值，返回的是执行operand*10结果的值并将这个值设置到i中去</span></span><br><span class="line">i.updateAndGet((<span class="type">int</span> operand) -&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> operand * <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//i.updateAndGet(operand -&gt; operand * 10); //这与上面表达得意思相同</span></span><br><span class="line">System.out.println(i.get());</span><br></pre></td></tr></table></figure>

<h3 id="6-4-原子引用"><a href="#6-4-原子引用" class="headerlink" title="6.4 原子引用"></a>6.4 原子引用</h3><blockquote>
<p>为什么需要原子引用类型？</p>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
</blockquote>
<p>有如下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestAccount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAccount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DecimalAccount.demo(<span class="keyword">new</span> <span class="title class_">DecimalAccountCas</span>(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountCas</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line"><span class="comment">//    private BigDecimal balance;</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountCas</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">next</span> <span class="operator">=</span> prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span>(balance.compareAndSet(prev,next))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="comment">//获取余额</span></span><br><span class="line">    BigDecimal <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(DecimalAccount account)</span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>经典的ABA问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="comment">//获取值A</span></span><br><span class="line">        <span class="comment">//这个共享变量被其他线程修改过？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">        other();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试改为C.问题在于主线程无法感知共享变量是否被其他线程修改过，即便是最终又修改回来了</span></span><br><span class="line">        log.debug(<span class="string">&quot;change A -&gt; C &#123;&#125;&quot;</span>,ref.compareAndSet(prev,<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change A -&gt; B &#123;&#125;&quot;</span>,ref.compareAndSet(ref.get(),<span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;change B -&gt; A &#123;&#125;&quot;</span>,ref.compareAndSet(ref.get(),<span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主线程仅能判断出共享变量的值与最初值A是否相同，不能感知到这种从A改为B又改回A的情况，如果主线程希望：</p>
<p>只要有其他线程【动过了】共享变量，那么自己的CAS就算失败，这是，仅比较值是不够的，需要再加一个版本号</p>
</blockquote>
<p><strong>AtomicStampedReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="comment">//获取值A</span></span><br><span class="line">        <span class="comment">//这个共享变量被其他线程修改过？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">        <span class="comment">//获取版本号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        other();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试改为C.问题在于主线程无法感知共享变量是否被修改过</span></span><br><span class="line">        log.debug(<span class="string">&quot;change A -&gt; C &#123;&#125;&quot;</span>,ref.compareAndSet(prev,<span class="string">&quot;C&quot;</span>,stamp,stamp+<span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,ref.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            log.debug(<span class="string">&quot;change A -&gt; B &#123;&#125;&quot;</span>,ref.compareAndSet(ref.getReference(),<span class="string">&quot;B&quot;</span>,stamp,stamp+<span class="number">1</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">            log.debug(<span class="string">&quot;change B -&gt; A &#123;&#125;&quot;</span>,ref.compareAndSet(ref.getReference(),<span class="string">&quot;A&quot;</span>,stamp,stamp+<span class="number">1</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AtomicStampedReference可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; A -&gt; C，通过AtomicStampedReference，我们可以知道，引用变量中途被修改了几次，但是有时候，并不关心引用变量更改了几次，只是单纯的关心&#x3D;&#x3D;是否更改过&#x3D;&#x3D;，所以就有了AtomicMarkableReference</p>
</blockquote>
<p><strong>AtomicMarkableReference</strong></p>
<h3 id="6-5-原子数组"><a href="#6-5-原子数组" class="headerlink" title="6.5 原子数组"></a>6.5 原子数组</h3><ul>
<li>AtomicIntegerArray  </li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<p>有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这会存在多线程访问的问题</span></span><br><span class="line">        demo(() -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>],</span><br><span class="line">                (array) -&gt; array.length,</span><br><span class="line">                (array,index) -&gt; array[index]++,</span><br><span class="line">                array -&gt; System.out.println(Arrays.toString(array)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这是使用原子数组的方法</span></span><br><span class="line">        demo(() -&gt; <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">10</span>),</span><br><span class="line">                (array) -&gt; array.length(),</span><br><span class="line">                (array,index) -&gt;array.getAndIncrement(index),</span><br><span class="line">                array -&gt; System.out.println(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arraySupplier:提供数组，可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFun：获取数组长度的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> putConsumer：自增方法，回传array，index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> printConsumer：打印数组的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="line"><span class="params">                                 Function&lt;T,Integer&gt; lengthFun,</span></span><br><span class="line"><span class="params">                                 BiConsumer&lt;T,Integer&gt; putConsumer,</span></span><br><span class="line"><span class="params">                                 Consumer&lt;T&gt; printConsumer)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">T</span> <span class="variable">array</span> <span class="operator">=</span> arraySupplier.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> lengthFun.apply(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">//每个线程对数组作10000次操作</span></span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    putConsumer.accept(array,j%length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(thread -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-原子更新器"><a href="#6-6-原子更新器" class="headerlink" title="6.6 原子更新器"></a>6.6 原子更新器</h3><ul>
<li>AtomicReferenceFieldUpdate  &#x2F;&#x2F; 域&#x2F;字段</li>
<li>AtomicIntegerFieldUpdate</li>
<li>AtomicLongFiledUpdate</li>
</ul>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合volatile修饰的字段使用，否则会出现异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">AtomicReferenceFieldUpdater</span> <span class="variable">updater</span> <span class="operator">=</span> AtomicReferenceFieldUpdater.newUpdater(Student.class,String.class,<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        updater.compareAndSet(student,<span class="literal">null</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        log.debug(student.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-7-原子累加器"><a href="#6-7-原子累加器" class="headerlink" title="6.7 原子累加器"></a>6.7 原子累加器</h3><p>累加器性能比较</p>
<blockquote>
<ul>
<li><p>比较AtomicLong 与LongAdder</p>
</li>
<li><pre><code class="java">for (int i = 0; i &lt; 5; i++) &#123;
    demo( () -&gt; new LongAdder(), adder -&gt; adder.increment());
&#125;
    
for (int i = 0; i &lt; 5; i++) &#123;
    demo( () -&gt; new AtomicLong(), adder -&gt; adder.getAndIncrement());
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- LongAdder 输出的性能比ActomicLong快很多倍。</span><br><span class="line">- 性能提升的原因很简单，就是在有竞争的时候，设置多个累加单元，Thread-0累加Cell[0],而Thread-1累加Cell[1],最后将结果汇总，这样他们在累加时操作的不同的Cell变量，因此减少了CAS重试失败，从而提高性能</span><br><span class="line"></span><br><span class="line">**源码之LongAdder**</span><br><span class="line"></span><br><span class="line">LongAdder类有几个关键域</span><br><span class="line"></span><br><span class="line">### 6.8 Unsafe</span><br><span class="line"></span><br><span class="line">**概述**</span><br><span class="line"></span><br><span class="line">Unsafe对象提供了非常底层的，操作内存，线程的方法，Unsafe对象不能直接调用，只能通过反射获得</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test6 &#123;</span><br><span class="line">   public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">       //通过反射来获取对象</span><br><span class="line">       Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">       theUnsafe.setAccessible(true);</span><br><span class="line">       Unsafe unsafe = (Unsafe) theUnsafe.get(null);</span><br><span class="line">       System.out.println(unsafe);</span><br><span class="line"></span><br><span class="line">       Teacher t = new Teacher();</span><br><span class="line">       //1.获取域的偏移地址</span><br><span class="line">       long idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(&quot;id&quot;));</span><br><span class="line">       long nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(&quot;name&quot;));</span><br><span class="line">       //2.执行cas操作</span><br><span class="line">       unsafe.compareAndSwapInt(t,idOffset,0,1);</span><br><span class="line">       unsafe.compareAndSwapObject(t,nameOffset,null,&quot;张三&quot;);</span><br><span class="line">       //3.打印结果</span><br><span class="line">       log.debug(&quot;&#123;&#125;&quot;,t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher &#123;</span><br><span class="line">   volatile int id;</span><br><span class="line">   volatile String name;</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line">sun.misc.Unsafe@2eafffde</span><br><span class="line">10:32:13 632 [main] c.Test6 -&gt; Teacher(id=1, name=张三)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<h2 id="7-共享模型之不可变"><a href="#7-共享模型之不可变" class="headerlink" title="7.共享模型之不可变"></a>7.共享模型之不可变</h2><ul>
<li>不可变类的使用</li>
<li>不可变类的设计</li>
<li>无状态类设计</li>
</ul>
<h3 id="7-1-日期转换的问题"><a href="#7-1-日期转换的问题" class="headerlink" title="7.1 日期转换的问题"></a>7.1 日期转换的问题</h3><p><strong>问题提出</strong></p>
<p>下面的代码在运行时，由于SimpleDateFormat不是线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//不存在线程安全问题</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;1951-04-21&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,parse);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//存在线程安全问题</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (simpleDateFormat) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,simpleDateFormat.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-不可变设计"><a href="#7-2-不可变设计" class="headerlink" title="7.2 不可变设计"></a>7.2 不可变设计</h3><p>另一个更为熟悉的String类也是不可变的，以它为例，来说明不可变设计的要素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final的使用</strong></p>
<p>发现该类，类中所有属性都是final的</p>
<ul>
<li>属性用final修饰保证了该属性只是可读的，不能修改</li>
<li>类用final修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏可变性</li>
</ul>
<p><strong>保护性拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了确保不变性，都是使用保护性拷贝，而不是使用引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>享元模式</strong></p>
<ol>
<li>简介</li>
</ol>
<blockquote>
<p>定义：Flyweight pattern当需要重用数量有限的同一类对象时</p>
<ul>
<li>为了最小化内存使用，通过共享尽可能多的数据与其他类似的对象</li>
</ul>
<p>归类于 Structural patterns</p>
</blockquote>
<ol start="2">
<li>体现</li>
</ol>
<p><strong>2.1 包装类</strong></p>
<ul>
<li><p>在JDK中Boolean,Byte,Short,Integer,Long,Charactor等包装类提供了valueOf()方法，例如Long的valueOf( )会缓存-128~127之间的Long对象,在这个范围之间会重用对象，大于这个范围，才会新建Long对象</p>
</li>
<li><pre><code class="java">public static Long valueOf(long l) &#123;
    final int offset = 128;
    if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache
        return LongCache.cache[(int)l + offset];
    &#125;
    return new Long(l);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line">  - Byte,Short,Long缓存的范围都是-128~127</span><br><span class="line">  - Charactor缓存的范围是0-127</span><br><span class="line">  - Integer的默认范围是-128~127，最小值不能变，但最大值可以通过调整虚拟机参数来IntegerCache.high改变</span><br><span class="line">  - Boolean缓存了TRUE和FALSE</span><br><span class="line"></span><br><span class="line">**2.2 String串池**</span><br><span class="line"></span><br><span class="line">**2.3 BigDecimal BigInteger**</span><br><span class="line"></span><br><span class="line">**3.DIY**</span><br><span class="line"></span><br><span class="line">自定义模拟实现数据库连接池</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pool pool = new Pool(2);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                Connection connection = pool.borrow();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                pool.free(connection);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j(topic = &quot;c.Test&quot;)</span><br><span class="line">class Pool &#123;</span><br><span class="line">    //1.连接池大小</span><br><span class="line">    private final int poolSize;</span><br><span class="line">    //2.连接对象数组</span><br><span class="line">    private Connection[] connections;</span><br><span class="line">    //3.连接状态 0 表示空闲， 1表示繁忙 用原子数组</span><br><span class="line">    private AtomicIntegerArray status;</span><br><span class="line"></span><br><span class="line">    //4.构造方法初始化</span><br><span class="line">    public Pool(int poolSize) &#123;</span><br><span class="line">        this.poolSize = poolSize;</span><br><span class="line">        this.connections = new Connection[poolSize];</span><br><span class="line">        this.status = new AtomicIntegerArray(new int[poolSize]);</span><br><span class="line">        for (int i = 0; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = new MockConnection(&quot;connection &quot;+i+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.借连接</span><br><span class="line">    public Connection borrow() &#123;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            for (int i = 0; i &lt; poolSize; i++) &#123;</span><br><span class="line">                if (status.get(i) == 0) &#123;</span><br><span class="line">                    if(status.compareAndSet(i,0,1)) &#123;</span><br><span class="line">                        log.debug(&quot;borrow借连接 &#123;&#125;&quot;,connections[i]);</span><br><span class="line">                        return connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有空闲连接，让当前线程进入等待</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log.debug(&quot;wait&quot;);</span><br><span class="line">                    this.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //6.归还连接</span><br><span class="line">    public void free(Connection conn) &#123;</span><br><span class="line">        for (int i = 0; i &lt; poolSize; i++) &#123;</span><br><span class="line">            if (connections[i] == conn) &#123;</span><br><span class="line">                //只有一个线程能获取到该连接</span><br><span class="line">                status.set(i,0);</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    log.debug(&quot;free连接 &#123;&#125;&quot;,conn);</span><br><span class="line">                    this.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MockConnection implements Connection &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public MockConnection(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MockConnection&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Statement createStatement() throws SQLException &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><strong>final原理</strong></p>
<p>1.设置final变量的原理</p>
<p>理解了volatile原理，在对比final的实现就比较简单了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 aload_0</span><br><span class="line">1 invokespecial <span class="comment">#1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;</span></span><br><span class="line">4 aload_0</span><br><span class="line">5 bipush 20</span><br><span class="line">7 putfield <span class="comment">#2 &lt;com/example/n7/TestFinal.a : I&gt;</span></span><br><span class="line">	&lt;-- 写屏障【确保了可见性和有序性】</span><br><span class="line">10 <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>发现final变量的赋值也会通过putfield指令来完成，同样在这条指令之后也会加入写屏障，保证在其他线程读到它的值时不会出现为0的情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestFinal &#123;</span><br><span class="line">    final static int A = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T &#123;</span><br><span class="line">    public void <span class="function"><span class="title">test</span></span> () &#123;</span><br><span class="line">        System.out.println(TestFinal.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#test函数的字节码，在 A有final修饰的时候</span></span><br><span class="line">0 getstatic <span class="comment">#2 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span></span><br><span class="line">3 bipush 20     </span><br><span class="line">5 invokevirtual <span class="comment">#4 &lt;java/io/PrintStream.println : (I)V&gt;</span></span><br><span class="line">8 <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestFinal &#123;</span><br><span class="line">    static int A = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T &#123;</span><br><span class="line">    public void <span class="function"><span class="title">test</span></span> () &#123;</span><br><span class="line">        System.out.println(TestFinal.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#test函数的字节码，在 A没有final修饰的时候</span></span><br><span class="line">0 getstatic <span class="comment">#2 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span></span><br><span class="line">3 getstatic <span class="comment">#3 &lt;com/example/n7/TestFinal.A : I&gt;  </span></span><br><span class="line">6 invokevirtual <span class="comment">#4 &lt;java/io/PrintStream.println : (I)V&gt;</span></span><br><span class="line">9 <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在有final修饰的时候，会在其他类中也拷贝一份该数据，使用的是bipush指令，而在没有用final修饰的时候，字节码指令是getstatic，去类中获取静态变量，所以消耗的时间会长很多。</p>
</blockquote>
<h3 id="7-3-无状态"><a href="#7-3-无状态" class="headerlink" title="7.3 无状态"></a>7.3 无状态</h3><ul>
<li>在web阶段学习时，设计Servlet时为了保证其线程安全，都会有这样的建议，不要为Servlet设置成员变量，这种没有任何成员变量的类是线程安全的。<ul>
<li>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</li>
</ul>
</li>
</ul>
<h2 id="8-共享模型之工具"><a href="#8-共享模型之工具" class="headerlink" title="8.共享模型之工具"></a>8.共享模型之工具</h2><h3 id="8-1-线程池"><a href="#8-1-线程池" class="headerlink" title="8.1 线程池"></a>8.1 线程池</h3><h4 id="1-自定义线程池"><a href="#1-自定义线程池" class="headerlink" title="1.自定义线程池"></a><strong>1.自定义线程池</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestPool&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">RejectPolicy</span>&lt;Runnable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;Runnable&gt; queue, Runnable task)</span> &#123;</span><br><span class="line">                <span class="comment">//1.死等策略</span></span><br><span class="line"><span class="comment">//                queue.put(task);</span></span><br><span class="line">                <span class="comment">//2.带超时等待</span></span><br><span class="line"><span class="comment">//                queue.offer(task,1500,TimeUnit.MILLISECONDS);</span></span><br><span class="line">                <span class="comment">//3.让主线程放弃任务执行</span></span><br><span class="line"><span class="comment">//                log.debug(&quot;放弃&#123;&#125;&quot;,task);</span></span><br><span class="line">                <span class="comment">//4.抛出异常</span></span><br><span class="line"><span class="comment">//                throw new RuntimeException(&quot;任务执行失败&#123;&#125;&quot;+task);</span></span><br><span class="line">                <span class="comment">//5.让调用者自己执行任务</span></span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;在执行&#123;&#125;&quot;</span>,j);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue,T task)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置任务的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="comment">//当任务数没有超过coreSize时，直接交给worker对象执行</span></span><br><span class="line">        <span class="comment">//如果任务超过coreSize时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增worker&#123;&#125;,任务&#123;&#125;&quot;</span>,worker,task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">//1.死等</span></span><br><span class="line">                <span class="comment">//2.带超时等待</span></span><br><span class="line">                <span class="comment">//3.让主线程放弃任务执行</span></span><br><span class="line">                <span class="comment">//4.抛出异常</span></span><br><span class="line">                <span class="comment">//5.让调用者自己执行任务</span></span><br><span class="line"></span><br><span class="line">                taskQueue.tryPut(rejectPolicy,task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit,<span class="type">int</span> queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = taskQueue;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            <span class="comment">//1.当task不为空，就执行任务</span></span><br><span class="line">            <span class="comment">//2.当task执行完毕从任务队列中获取任务并执行</span></span><br><span class="line"><span class="comment">//            while (task != null || (task = taskQueue.take()) != null) &#123;</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = taskQueue.poll(timeout,timeUnit)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行。。。&#123;&#125;&quot;</span>,task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker被移除&#123;&#125;&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//1.任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时的阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//将timeout统一转换为纳秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//该方法返回的就是剩余时间</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞获取 获取可用的线程</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待任务队列&#123;&#125;&quot;</span>,element);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列&#123;&#125;&quot;</span>,element);</span><br><span class="line">            queue.addLast(element);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带超时时间阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task,<span class="type">long</span> timeout,TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待任务队列&#123;&#125;&quot;</span>,task);</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> )&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列&#123;&#125;&quot;</span>,task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断任务队列是否已满</span></span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capacity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>,task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//有空闲</span></span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列&#123;&#125;&quot;</span>,task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-ThreadPoolExecutor"><a href="#2-ThreadPoolExecutor" class="headerlink" title="2.ThreadPoolExecutor"></a><strong>2.ThreadPoolExecutor</strong></h4><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220528111352661.png" alt="image-20220528111352661"></p>
<h4 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1)线程池状态"></a><strong>1)线程池状态</strong></h4><p>ThreadPoolExecutor使用int的高3位来表示线程池状态，低20位表示线程数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runState 提供主要的生命周期控制，取值： RUNNING：接受新任务并处理排队任务 SHUTDOWN：不接受新任务，但处理排队任务 STOP：不接受新任务，不处理排队任务，并中断正在进行的任务 TIDYING：所有任务都已终止，workerCount 为零，转换到状态 TIDYING 的线程将运行 terminate() 钩子方法. </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rs为高三位代表线程状态，wc为低29位代表线程果树，ctl是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这些信息存储在一个原子变量ctl中，目的是将线程状态与线程果树合二为一，这样就可以用一次cas原子操作进行赋值。</p>
</li>
<li><pre><code class="java">//c为旧值，ctlOf返回结果为新值
ctl.compareAndSet(c,ctlOf(targetState,workerCountOd(c)));
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### **2)构造方法**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>corePoolSize核心线程数目（最多保留的线程数）</p>
</li>
<li><p>maximumPoolSize最大线程数目 （核心线程数corePoolSize+救急线程【是在核心线程和阻塞队列都满的时候才进行创建的】）</p>
</li>
<li><p>keepAliveTime 生存时间 ——针对救急线程</p>
</li>
<li><p>unit 时间单位——针对救急线程</p>
</li>
<li><p>workQueue阻塞队列</p>
</li>
<li><p>threadFactory线程工厂，可以为线程创建时起个好名字</p>
</li>
<li><p>handler拒绝策略</p>
</li>
</ul>
<hr>
<ul>
<li>线程池中刚开始没有线程，当有一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li>
<li>当线程数达到corePoolSize并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue阻塞队列排队，直到有空闲的线程。</li>
<li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建maximumPoolSize—corePoolSize数目的线程来救急。</li>
<li>如果线程到达maximumPoolSize仍然有新任务这时会执行拒绝策略。拒绝策略jdk提供了4种实现，其它著名框架也提供了实现。<ul>
<li>AbortPolicy让调用者抛出RejectedExecutionException异常，这是默认策略</li>
<li>CallerRunsPolicy让调用者运行任务</li>
<li>DiscardPolicy放弃本次任务</li>
<li>DiscardOldestPolicy防疫队列中最早的任务，本任务取而代之</li>
<li>Dubbo的实现，在抛出RejectedExecutionException异常之前会记录日志，并dump线程栈信息，方便定位问题。</li>
<li>Netty的实现，是创建一个新线程来执行任务</li>
<li>ActiveMQ的实现，带超时等待（60S）尝试放入队列，类似我们之前自定义的拒绝策略</li>
<li>PinPoint的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
</li>
<li>当高峰过去后，超过corePoolSize的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由KeepAliveTime和unit来控制</li>
<li>根绝这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</li>
</ul>
<h4 id="3）newFixedThreadPool"><a href="#3）newFixedThreadPool" class="headerlink" title="3）newFixedThreadPool"></a><strong>3）newFixedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Executors类中</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>核心线程数&#x3D;&#x3D;最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务<ul>
<li>评价：适用于任务量已知，相对耗时的任务</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//线程工厂就是为了起一个更好的名字</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;myPool_t&quot;</span>+t.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    pool2.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool2.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pool2.execute(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2781</span> [myPool_t1] c.Test -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2790</span> [myPool_t1] c.Test -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2792</span> [myPool_t2] c.Test -&gt; <span class="number">2</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2793</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] c.Test -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2794</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] c.Test -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">14</span>:<span class="number">41</span>:<span class="number">03</span> <span class="number">2796</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] c.Test -&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="4）newCachedThreadPool"><a href="#4）newCachedThreadPool" class="headerlink" title="4）newCachedThreadPool"></a><strong>4）newCachedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>核心线程数是0，最大线程数是Integer.Max_VALUE，救急线程的空闲生存时间是60S，意味着全部都是救急线程（60s后可以回收）</li>
<li>救急线程可以无限创建</li>
<li>队列采用了SynchronousQueue实现特点是：<ul>
<li>它没有容量，没有线程来取是放不进去的（一手交钱一手交货）</li>
</ul>
</li>
</ul>
<blockquote>
<p>评价：</p>
<ul>
<li>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲一分钟后释放线程</li>
<li>适合任务数比较密集，但每个任务执行时间较短的情况</li>
</ul>
</blockquote>
<ul>
<li><p>SynchronousQueue的使用示例【有点类似于golang中的无缓冲区的channel】</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    SynchronousQueue&lt;Integer&gt; integers = new SynchronousQueue&lt;&gt;();
    new Thread(() -&gt; &#123;
        try&#123;
            log.debug(&quot;putting &#123;&#125;&quot;,1);
            integers.put(1);
            log.debug(&quot;&#123;&#125; putted...&quot;,1);

            log.debug(&quot;putting &#123;&#125;&quot;,2);
            integers.put(2);
            log.debug(&quot;&#123;&#125; putted...&quot;,2);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;,&quot;t1&quot;).start();

    try &#123;
        TimeUnit.SECONDS.sleep(1);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;

    new Thread(() -&gt; &#123;
        try&#123;
            //取数据
            log.debug(&quot;take &#123;&#125;&quot;,1);
            integers.take();
            log.debug(&quot;&#123;&#125; taked...&quot;,1);

            log.debug(&quot;take &#123;&#125;&quot;,2);
            integers.take();
            log.debug(&quot;&#123;&#125; taked...&quot;,2);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;,&quot;t2&quot;).start();
&#125;
//output
14:58:00 1601 [t1] c.Test -&gt; putting 1
14:58:01 2585 [t2] c.Test -&gt; take 1
14:58:01 2586 [t1] c.Test -&gt; 1 putted...
14:58:01 2586 [t1] c.Test -&gt; putting 2
14:58:01 2586 [t2] c.Test -&gt; 1 taked...
14:58:01 2587 [t2] c.Test -&gt; take 2
14:58:01 2587 [t1] c.Test -&gt; 2 putted...
14:58:01 2588 [t2] c.Test -&gt; 2 taked...
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### **5）newSingleThreadExecutor**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>适用场景：</p>
<ul>
<li><p>希望多个任务排队执行。线程数固定为1，任务数多于1时，会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放</p>
</li>
<li><p>区别：</p>
<ul>
<li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</li>
<li>Executors.newSingleThreadExecutor()线程个数始终为1，不能修改<ul>
<li>FinalizableDelegatedExecutorService应用的是装饰器模式，只对外暴露了ExecutorService接口，因此不能调用ThreadPoolExecutor中特有的方法</li>
</ul>
</li>
<li>Executors.newFixedThreadPool(1)初始时为1，以后还可以修改<ul>
<li>对外暴露的是ThreadPoolExecutor对象，可以强转后调用setCorePoolSize等方法进行修改。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6）提交任务"><a href="#6）提交任务" class="headerlink" title="6）提交任务"></a><strong>6）提交任务</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交任务task,用返回值Future获得任务执行结果</span></span><br><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">Future&lt;String&gt; future = service.submit(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;main...&quot;</span>);</span><br><span class="line">log.debug(future.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交task中所有任务</span></span><br><span class="line">List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交task中所有任务，带超时时间</span></span><br><span class="line">List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交tasks中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其他任务取消</span></span><br><span class="line">&lt;T&gt; invokeAny(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Callable</span>&lt;T&gt; tasks&gt;) <span class="keyword">throws</span> InterruptedException,ExcutionExection</span><br><span class="line">    </span><br><span class="line"><span class="comment">//提交tasks中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其他任务取消,带超时时间</span></span><br><span class="line">&lt;T&gt; invokeAny(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Callable</span>&lt;T&gt;&gt; tasks，<span class="type">long</span> timeout,TimeUnit unit) <span class="keyword">throws</span> InterruptedException,ExcutionExection,TimeoutException</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;方法用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试invokeAny</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testInvokeAny</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">any</span> <span class="operator">=</span> service.invokeAny(Arrays.asList(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    log.debug(any);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试invokeAll方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testInvokeAll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    List&lt;Future&lt;String&gt;&gt; futures = service.invokeAll(Arrays.asList(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    futures.forEach(stringFuture -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(stringFuture.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7）关闭线程池"><a href="#7）关闭线程池" class="headerlink" title="7）关闭线程池"></a><strong>7）关闭线程池</strong></h4><p><strong>shutdown</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">	- 不会接收新任务</span></span><br><span class="line"><span class="comment">	- 但已提交任务会执行完</span></span><br><span class="line"><span class="comment">	- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//修改线程状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//仅会打断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">//扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终结没有运行的线程可以立刻终结，如果还有运行的线程也不会等</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shutdownNow</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程状态变为stop</span></span><br><span class="line"><span class="comment">	- 不会接收新任务</span></span><br><span class="line"><span class="comment">	- 会将队列中的任务返回</span></span><br><span class="line"><span class="comment">	- 并用interrupt的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//修改线程状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//打断所有线程，空闲的和正在执行的</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//获取队列中剩余任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终结</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不在RUNNING状态的线程池，此方法就返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池状态是否是TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用shutdown后，由于线程并不会等待所有任务运行结束，因此如果它想在线程池TERMINATED后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testShutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1 running...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;task1 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task2 running...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;task2 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task3 running...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;task3 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;shutdownNow...&quot;</span>);</span><br><span class="line">    List&lt;Runnable&gt; runnables = service.shutdownNow();</span><br><span class="line">    log.debug(<span class="string">&quot;other &#123;&#125;&quot;</span>,runnables.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1 running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;task1 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task2 running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;task2 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task3 running...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;task3 finish...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;shutdown...&quot;</span>);</span><br><span class="line">    service.shutdown();</span><br><span class="line">    <span class="comment">//等shutdown之前的线程执行完或者等够3秒后才往下执行</span></span><br><span class="line">    service.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    log.debug(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">    <span class="comment">//shutdown执行后再开启任务就会抛出错误</span></span><br><span class="line">    <span class="comment">/*service.submit(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            log.debug(&quot;task4 running...&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            log.debug(&quot;task4 finish...&quot;);</span></span><br><span class="line"><span class="comment">            return 1;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步模式之工作线程</strong></p>
<p><strong>1.定义</strong></p>
<ul>
<li>让有限的工作线程（worker thread）来轮流异步处理无限多的任务，也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</li>
<li>注意：不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</li>
<li>例如：如果一个餐馆的工人既要招呼客人（任务类型A）,又要到后厨做菜（任务类型B）显然效率不高，分成服务员（线程池A）与厨师（线程池B）更为合理。</li>
</ul>
<p><strong>2.饥饿</strong></p>
<p>固定大小线程池会有饥饿现象</p>
<ul>
<li>两个工人是同一个线程池中的两个线程</li>
<li>它们要做的事情是：为客人点菜和到后厨做菜，这是两个阶段的工作<ul>
<li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li>
<li>后厨做菜：没啥说的，做就是了</li>
</ul>
</li>
<li>比如工人A处理了点餐任务，接下来它要等着工人B把菜做好，然后上菜，这样配合的话没问题</li>
<li>但现在同时来了两个客人，这个时候工人A和工人B都去处理点餐了，这时没人做饭了，饥饿。（因为线程不足）</li>
</ul>
<p>解决办法：</p>
<ul>
<li>工人A专门处理点餐</li>
<li>工人B专门负责做菜</li>
</ul>
<p><strong>3.创建多少线程池合适</strong></p>
<ul>
<li>过小会导致程序不能充分地利用系统资源，容易导致饥饿</li>
<li>过大会导致更多的线程上下文切换，占用更多的内存</li>
</ul>
<p><strong>3.1 CPU密集型运算</strong>【数据分析】</p>
<p>通常采用CPU核数+1能够实现最优的CPU利用率，+1是保证当线程由于页缺失故障（操作系统）或其他原因导致暂停时，额外的这个线程就能顶上去，保证CPU时钟周期不被浪费。</p>
<p><strong>3.2 I&#x2F;O密集型运算</strong>【web应用程序】</p>
<p>CPU不总是处于繁忙状态，例如当你执行业务计算时，这时候会使用CPU资源，但当你执行I&#x2F;O操作时，远程RPC调用时，包括进行数据库操作时，这时候CPU就闲下来了，你可以利用多线程提高它的利用率</p>
<p>经验公式：</p>
<p>线程数  &#x3D; 核数 * 期望CPU利用率 * 总时间（CPU计算时间+等待时间）&#x2F;CPU计算时间</p>
<h4 id="8）任务调度线程池"><a href="#8）任务调度线程池" class="headerlink" title="8）任务调度线程池"></a>8）任务调度线程池</h4><p>在【任务调度线程池】功能加入之前，可以使用java.util.Timer来实现定时功能，Timer的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务再执行，前一个任务的延迟或异常都将会影响到之后的任务。</p>
<ul>
<li><p>Timer的使用案例</p>
</li>
<li><pre><code class="java">public static void main(String[] args) &#123;
    Timer timer = new Timer();
    TimerTask task1 = new TimerTask() &#123;
        @Override
        public void run() &#123;
            log.debug(&quot;task1...&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(2);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;;
    TimerTask task2 = new TimerTask() &#123;
        @Override
        public void run() &#123;
            log.debug(&quot;task2...&quot;);
        &#125;
    &#125;;

    log.debug(&quot;start...&quot;);
    timer.schedule(task1,1000);
    timer.schedule(task2,1000);
&#125;
//output
10:53:26 706 [main] c.TestTimer -&gt; start...
10:53:27 1713 [Timer-0] c.TestTimer -&gt; task1...
10:53:29 3717 [Timer-0] c.TestTimer -&gt; task2...   //taks2必须在task1执行完以后才能执行
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);</span><br><span class="line">    log.debug(&quot;begin...&quot;);</span><br><span class="line">    //这个方法里面指的是执行到该方法后等待的时间</span><br><span class="line">    /*executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.debug(&quot;running...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,2,1,TimeUnit.SECONDS);*/</span><br><span class="line"></span><br><span class="line">    //这里面delay指的是上一个任务结束之后才开始算的</span><br><span class="line">    executorService.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">        log.debug(&quot;running2...&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,1,1,TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

9）利用调度线程池来实现调度任务

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSchedule</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//获取当前时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">//获取这一周设置的时间点时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> now.withHour(<span class="number">11</span>).withMinute(<span class="number">41</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.SUNDAY);</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间大于上面设置的本周时间，必须找到下周设置的该时间点</span></span><br><span class="line">        <span class="keyword">if</span> (now.compareTo(time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">between</span> <span class="operator">=</span> Duration.between(now, time);</span><br><span class="line">        <span class="type">long</span> <span class="variable">millis</span> <span class="operator">=</span> between.toMillis();</span><br><span class="line">        System.out.println(millis);</span><br><span class="line">        <span class="comment">//initialDelay表示的当前时间内与周四时间的差值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialDelay</span> <span class="operator">=</span> millis;</span><br><span class="line">        <span class="comment">//period表示一周的时间毫秒数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">period</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">        pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        &#125;,initialDelay,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="3-Fork-Join"><a href="#3-Fork-Join" class="headerlink" title="3.Fork&#x2F;Join"></a>3.Fork&#x2F;Join</h4><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1)概念"></a>1)概念</h4><ul>
<li>Fork&#x2F;join是jdk1.7加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的CPU密集型运算。</li>
<li>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解，即递归相关的一些计算，如归并排序，斐波那契数列，都可以用分治思想进行求解</li>
<li>Fork&#x2F;Join在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</li>
<li>Fork&#x2F;Join默认会创建与CPU核心数小大相同的线程池。</li>
</ul>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2)使用"></a>2)使用</h4><ul>
<li><p>提交给Fork&#x2F;Join线程池的任务需要继承RecursiveTask(有返回值)或RecursiveAction()</p>
</li>
<li><pre><code class="java">public class TestForkJoin &#123;
    public static void main(String[] args) &#123;
        ForkJoinPool pool = new ForkJoinPool(4);
        System.out.println(pool.invoke(new MyTask(5)));


    &#125;
&#125;

class MyTask extends RecursiveTask&lt;Integer&gt; &#123;
    private int n;
    public MyTask(int n) &#123;
        this.n = n;
    &#125;

    @Override
    protected Integer compute() &#123;
        if (n == 1) &#123;
            return 1;
        &#125;
        MyTask task = new MyTask(n - 1);
        task.fork();  //让一个线程去执行任务
        Integer result =n + task.join();//接受任务结果
        return result;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 8.2 J.U.C</span><br><span class="line"></span><br><span class="line">#### 1.AQS原理*</span><br><span class="line"></span><br><span class="line">**1)概述**</span><br><span class="line"></span><br><span class="line">&gt; 全称是AbstractQueuedSynchronizer,是阻塞式和相关的同步器工具的框架</span><br><span class="line">&gt;</span><br><span class="line">&gt; 特点：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 用state属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</span><br><span class="line">&gt;   - getState——获取state状态</span><br><span class="line">&gt;   - setState——设置state状态</span><br><span class="line">&gt;   - compareAndSetState——乐观锁机制设置状态</span><br><span class="line">&gt;   - 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</span><br><span class="line">&gt; - 提供了基于FIFO的等待队列，类似于Monitor的EntryList</span><br><span class="line">&gt; - 条件变量来实现等待，唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</span><br><span class="line">&gt;</span><br><span class="line">&gt; 子类主要实现这样一些方法（默认抛出UnsupportedOperationException）</span><br><span class="line">&gt;</span><br><span class="line">&gt; - tryAcquire</span><br><span class="line">&gt; - tryRelease</span><br><span class="line">&gt; - tryAcquireShared</span><br><span class="line">&gt; - tryReleaseShared</span><br><span class="line">&gt; - isHeldExclusively</span><br><span class="line">&gt;</span><br><span class="line">&gt; 获取锁的姿势</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```java</span><br><span class="line">&gt; //如果获取锁失败</span><br><span class="line">&gt; if (!tryAcquire(arg)) &#123;</span><br><span class="line">&gt; 	//入队，可以选择阻塞当前线程  park /unpark</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p>释放锁的姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果释放锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">	<span class="comment">//让阻塞线程恢复执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义实现锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAqs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();  <span class="comment">//不可重入锁</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义锁  （不可重入锁）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//独占锁  同步器类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>,<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//加上了锁,并设置owner为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//                return super.tryAcquire(arg);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁，不成功会进入等待队列等待</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁，可打断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试加锁，一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试加锁，带超时时间</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加条件变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-ReentrantLock原理"><a href="#2-ReentrantLock原理" class="headerlink" title="2.ReentrantLock原理*"></a>2.ReentrantLock原理*</h4><p><strong>1.非公平锁实现原理</strong></p>
<blockquote>
<p>加锁解锁流程</p>
<ul>
<li><p>先从构造器开始看，默认为非公平锁</p>
</li>
<li><pre><code class="java">public ReentrantLock() &#123;
    sync = new NonfairSync();
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- NonFairSync继承自AQS</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  final void lock() &#123;</span><br><span class="line">      if (compareAndSetState(0, 1))</span><br><span class="line">          //没有竞争时，直接设置当前线程为owner</span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">      else</span><br><span class="line">          acquire(1);</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  public final void acquire(int arg) &#123;</span><br><span class="line">      if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>当第一个竞争出现时</p>
<ul>
<li>CAS尝试将state由0改为1，结果失败</li>
<li>进入tryAcquire逻辑，这时state已经是1，结果仍然失败</li>
<li>接下来进入addWaiter逻辑，构造Node队列（等待队列）<ul>
<li>Node的创建是懒惰的</li>
<li>其中第一个Node称为Dummy(哑元)或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
<li>当前线程进入acquireQueued逻辑<ul>
<li>acquiredQueued会在一个死循环中不断尝试获得锁，失败后进入park阻塞</li>
<li>如果自己是紧邻着head(排第二位)，那么再次tryAcquire尝试获得锁，当然这时state仍为1，失败</li>
<li>进入shouldParkAfterFailedAcquire逻辑，将前驱node,即head的waitStatus改为-1，这次返回false。</li>
<li>shouldParkAfterFailedAcquire执行完毕回到acquireQueued，再次tryAcquire尝试获取锁，当然这是state仍为1，失败</li>
<li>当再次进入shouldParkAfterFailedAcquire时，这时因为其前驱node的waitStatus已经是-1，这时返回true。</li>
<li>进入parkAndCheckInterrupt，Thread-1 park（灰色表示）</li>
</ul>
</li>
<li>再次有多个线程经历上述过程竞争失败，变成这个样子</li>
<li>Thread-0释放锁，进入tryRelease流程，如果成功<ul>
<li>设置exclusiveOwnerThread为null</li>
<li>state&#x3D;0</li>
</ul>
</li>
<li>当前队列不为null，并且head的waitStatus &#x3D; -1，进入unparkSuccessor流程</li>
<li>找到流程中离head最近的一个Node(没取消的)，unpark恢复其运行，本例中即为Thread-1</li>
<li>回到 Thread-1de acquireQueued流程</li>
<li>如果加锁成功（没有竞争），会设置<ul>
<li>exclusiveOwnerThread为Thread-1,state &#x3D; 1</li>
<li>head指向刚刚Thread-1所在的Node,该Node清空Thread</li>
<li>原本的head因为从链表断开，而可被垃圾回收</li>
</ul>
</li>
<li>如果这时候有其他线程来竞争（非公平的体现），例如这时候Thread-4来了</li>
<li>如果不巧又被Thread-4占了先<ul>
<li>Thread-4被设置为exclusiveOwnerThread，state &#x3D; 1</li>
<li>Thread-1再次进入acquireQueued流程，获取锁失败，重新进入park阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>2.可重入原理</strong></p>
<p><strong>3.可打断原理</strong></p>
<ul>
<li>不可打断模式：在此模式下，即使它被打断，仍会驻留在AQS队列中，等获得锁后方能继续运行（是继续运行，只是打断标记被设置为true）</li>
<li>可打断模式：会抛出打断异常</li>
</ul>
<p><strong>4.公平锁实现原理</strong></p>
<p><strong>5.条件变量实现原理</strong></p>
<p>每个条件变量其实就对应着一个等待队列，其实现类是ConditionObject</p>
<p><strong>await流程</strong></p>
<p>开始Thread-0持有锁，调用await，进入ConditionObject的addConditionWaiter流程创建新的Node状态为-2（Node Condition）,关联Thread-0，加入等待队列尾部</p>
<p><strong>signal流程</strong></p>
<p>假设Thread-1要来唤醒Thread-0。进入ConditionObject的doSignal流程，取得等待队列中第一个Node,即Thread-0所在Node。执行transferForSignal流程，将该Node加入AQS队列尾部，将Thread-0的waitStatus改为0，Thread-3的waitStatus改为-1。Thread-1释放锁，进入unpark流程。</p>
<h4 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3.读写锁"></a>3.读写锁</h4><p><strong>3.1 ReentrantReadWriteLock</strong></p>
<ul>
<li><p>当读操作远远高于写操作时，这时候使用读写锁。让读-读可以并发，提高性能。类似于数据库中的select … from … lock in share node</p>
</li>
<li><p>提供一个数据容器类内部分别使用读锁保护数据的read方法，写锁保护数据的write（）方法</p>
</li>
<li><pre><code class="java">public class TestReadWrite &#123;
    public static void main(String[] args) &#123;
        DataContainer dataContainer = new DataContainer();
        new Thread(() -&gt; &#123;
            dataContainer.write();
        &#125;,&quot;t1&quot;).start();
        try &#123;
            TimeUnit.MILLISECONDS.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        new Thread(() -&gt; &#123;
            dataContainer.write();
        &#125;,&quot;t2&quot;).start();
    &#125;
&#125;

@Slf4j(topic = &quot;c.DataContainer&quot;)
class DataContainer &#123;
    private Object data;
    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
    //获取读锁
    private ReentrantReadWriteLock.ReadLock r = rw.readLock();
    //获取写锁
    private ReentrantReadWriteLock.WriteLock w = rw.writeLock();


    public Object read() &#123;
        log.debug(&quot;获取读锁&quot;);
        r.lock();
        try &#123;
            log.debug(&quot;读取&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return data;
        &#125;finally &#123;
            log.debug(&quot;释放读锁&quot;);
            r.unlock();
        &#125;

    &#125;
    public void write() &#123;
        log.debug(&quot;获取写锁&quot;);
        w.lock();
        try &#123;
            log.debug(&quot;写入&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;finally &#123;
            log.debug(&quot;释放写锁&quot;);
            w.unlock();
        &#125;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **注意事项：**</span><br><span class="line"></span><br><span class="line">  - 读锁不支持条件变量</span><br><span class="line"></span><br><span class="line">  - 重入时升级不支持，即持有锁的情况下去获取写锁，会导致获取写锁永久等待</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    r.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        log.debug(&quot;读取&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

- 重入时降级支持：即持有写锁的情况下去获取读锁【这样可以防止在释放写锁的时候，数据被其他写线程更改，直接加上读线程】
</code></pre>
</li>
<li><p><strong>应用之缓存</strong></p>
<ul>
<li>&#x3D;&#x3D;缓存更新策略&#x3D;&#x3D;：<ul>
<li>更新时，是先清缓存还是先更新数据库<ul>
<li>先清缓存：导致的问题是清空后，在更新数据库之前，被其他线程读到了更新前数据库的内容并存入缓存，即使后面更新了数据库中的内容，也会继续使用已经存入缓存的旧数据【因为更新操作一般比查询操作慢】</li>
<li><strong>先更新数据库</strong>：可能会存在一段时间内，一个线程更新了数据库，但是在清空缓存前，另外一个线程可能正在使用缓存中与更新后数据库不一样的数据，但是这个时间会很短。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3.2 读写锁原理</strong></p>
<p>1.图解流程</p>
<p>读写锁用的是同一个Sync同步器，因此等待队列，state等也是同一个。</p>
<p>线程t1 w.lock，线程t2 r.lock</p>
<ul>
<li>t1成功上锁，流程与ReentrantLock加锁相比没有特殊之处，不同是写锁状态占了state的低16位，而读锁使用的是state的高16位</li>
<li>t2执行r.lock，这时进入读锁的sync.acquireShared(1) 流程，首先会进入tryAcquireShared流程，如果有下所占据，那么tryAcquireShared返回-1表示失败<ul>
<li>tryAcquireShared返回值表示<ul>
<li>-1表示失败</li>
<li>0表示成功，但后继节点不会继续唤醒</li>
<li>正数白哦是成功，而且数值是还有几个后继节点需要唤醒，读写锁返回1</li>
</ul>
</li>
</ul>
</li>
<li>这时会进入sync.doAcquireShared(1)流程，首先也是调用addWaiter添加节点，不同之处在于节点被设置为Node.SHARED模式而非Node.EXCLUSIVE模式，注意此时t2仍处于活跃状态</li>
<li>t2会看着自己的节点是不是老二，如果是，还会再次调用tryAcquireShared(1)来尝试获取锁</li>
<li>如果没有成功，在doAcquireShared内for(; ;)循环一次，把前驱节点的waitStatus改为-1，再for(; ;)循环一次尝试tryAcquireShared()如果还不成功，那么再parkAndChaeckInterrupt()处park</li>
</ul>
<p>线程t3 r.lock( )  线程 t4 w.lock( )</p>
<ul>
<li>在上面的那种状态下，假设又有t3加读锁和t4加写锁，这期间t1仍然持有锁，就变成了下面的样子</li>
</ul>
<p>线程t1 w.unlock( )</p>
<ul>
<li><p>这时会走到写锁的sync.release(1)流程，调用sync.tryRelease( 1 )成功，变成下面的样子</p>
</li>
<li><p>接下来执行唤醒流程sync.unparkSuccessor，既让老二恢复运行，这时t2在doAcquireShared内parkAndCheckInterrupt()处恢复运行</p>
</li>
<li><p>这回再来一次for(; ;)执行tryAcquireShared成功则让读锁计数加1 </p>
</li>
<li><p>这时t2已经恢复运行，接下来t2调用setHeadAndPropagate(node,1),它原本所在节点被设置为头节点</p>
</li>
<li><p>事情还没完，在setHeadAndPropagate方法内还会检查下一个节点是否是shared，如果是则调用doReleaseShared( )将head的状态从-1改为0并唤醒老二，这时t3在doAcquireShared内parkAndCheckInterrupt( )处恢复运行</p>
</li>
<li><p>这回再来一次for(; ;)执行tryAcquireShared成功则让读锁计数加一</p>
</li>
<li><p>这时t3已经恢复运行，接下来t3调用setHeadAndPropagate(node,1),它原本所在节点被设置为头节点</p>
</li>
</ul>
<p>线程t2.unlock( )  线程t3.unlock()</p>
<ul>
<li>t2进入sync.releaseShared( )中，调用tryReleaseShared( 1 )让计数减一，但由于计数还不为零</li>
<li>t3进入sync.releaseShared( 1)中，调用tryReleaseShared(1)让计数减一，这回计数为零了，进入doReleaseShared( )将头节点从-1改为0并唤醒老二，即</li>
<li>之后t4在acquireQueued中parkAndCheckInterrupt处恢复运行，再次for(; ;)这次自己是老二，并没有其他竞争，tryAcquire(1)成功，修改头节点，流程结束。</li>
</ul>
<p><strong>3.3 StampedLock</strong></p>
<p>该类自JDK8加入，是为了进一步优化读性能，它的特点是在使用读锁，写锁时都必须配合【戳】使用</p>
<p>加解读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock()</span><br><span class="line">lock.unlockRead(stamp)</span><br></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p>乐观读，StampedLock支持tryOptimisticRead( )方法（乐观读），读取完毕后需要做一次戳检验，如果检验通过，表示这期间确实没有写操作，数据可以安全使用，如果检验没通过，需要重新获取读锁，保证数据安全</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long stamp = lock.tryOptimisticRead();</span><br><span class="line">//验戳</span><br><span class="line">if (!lock.validate(stamp)) &#123;</span><br><span class="line">	//锁升级</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestStampedLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStampedLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DataContainerStamped</span> <span class="variable">dataContainerStamped</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            dataContainerStamped.read(<span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            dataContainerStamped.write(<span class="number">1000</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.DataContainerStamped&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataContainerStamped</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">&quot;optimistic read locking &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(readTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lock.validate(stamp)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;updating to read lock...&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(readTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>,stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>StampedLock不支持条件变量</li>
<li>StampedLock不支持可重入</li>
</ul>
</blockquote>
<h4 id="4-Semaphore"><a href="#4-Semaphore" class="headerlink" title="4.Semaphore"></a>4.Semaphore</h4><p>信号量，用来限制能同时访问共享资源的线程上限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSemaphore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建Semaphore对象</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);  <span class="comment">//限制上限为3，即在同时运行的线程数上限为3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(<span class="string">&quot;ending...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    s.release();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Semaphore应用</strong>：</p>
<ul>
<li>使用Semaphore限流，在访问高峰时，让请求线程阻塞，敢封其过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比Tomcat  LimitLatch的实现）</li>
<li>用Semaphore实现简单连接池，&#x3D;&#x3D;对比享元模式下的实现（用wait&#x2F;notify），性能和可读性显然更好&#x3D;&#x3D;，注意下面的实现中线程数和数据库连接数是相等的</li>
</ul>
<p><strong>Semaphore原理</strong>：</p>
<p><strong>1.加锁解锁流程</strong></p>
<ul>
<li>Semaphore有点像一个停车场，permits就好像停车位数量，当线程获得了permits就像是获得了停车位，然后停车场显示空余车位减一。</li>
<li>刚开始，permits(state)为3，这时5个线程来获取资源</li>
<li>假设其中Thread-1,Thread-2,Thread-4 cas竞争成功，而Thread-0和Thread-3竞争失败，进入AQS队列park阻塞</li>
<li>这时Thread-4释放了permits，状态如下</li>
<li>接下来Thread-0竞争成功，permits再次设置为0，设置自己为head节点，断开原来的head节点，unpark接下来的Thread-3节点，但由于permits是0，因此Thread-3在尝试不成功后再次进入park状态</li>
</ul>
<h4 id="5-CountDownLatch"><a href="#5-CountDownLatch" class="headerlink" title="5.CountDownLatch"></a>5.CountDownLatch</h4><ul>
<li>用来进行线程同步协作，等待所有线程完成倒计时，其中构造参数用来初始化等待计数值，await( )用来等待计数归零，countDown( )用来让计数减一</li>
<li>功能类似于golang里面的waitgroup</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCountDownLatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;ending...&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;awaiting...&quot;</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;await ending...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将CountDownLatch应用于线程池</p>
</li>
<li><pre><code class="java">     public static void main(String[] args) &#123;
        CountDownLatch countDownLatch = new CountDownLatch(3);
        ExecutorService service = Executors.newFixedThreadPool(4);
        service.submit(() -&gt; &#123;
            log.debug(&quot;begin...&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            countDownLatch.countDown();
            log.debug(&quot;ending...&#123;&#125;&quot;,countDownLatch.getCount());
        &#125;);
        service.submit(() -&gt; &#123;
            log.debug(&quot;begin...&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(2);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            countDownLatch.countDown();
            log.debug(&quot;ending...&#123;&#125;&quot;,countDownLatch.getCount());
        &#125;);
        service.submit(() -&gt; &#123;
            log.debug(&quot;begin...&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(3);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            countDownLatch.countDown();
            log.debug(&quot;ending...&#123;&#125;&quot;,countDownLatch.getCount());
        &#125;);
  
        service.submit(() -&gt; &#123;
            try &#123;
                log.debug(&quot;waiting...&quot;);
                countDownLatch.await();
                log.debug(&quot;wait end&quot;);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;);
        
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**应用之同步等待多个远程调用结束**</span><br><span class="line"></span><br><span class="line">#### 6.CyclicBarrier</span><br><span class="line"></span><br><span class="line">循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置【计数个数】，每个线程执行到某个需要同步的时刻调用await( )方法进行等待，当等待的线程数满足【计数个数】时，继续执行。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class TestCyclicBarrier &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //这里的线程池中的个数与barrier中的个数应该一致，这样才能出现我们想要的结果</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(2);</span><br><span class="line">//        CyclicBarrier cyclicBarrier = new CyclicBarrier(2);</span><br><span class="line">        </span><br><span class="line">        //注意这里的cyclicbarrier对象可以复用，这一点与countdownlatch是不一样的，因为cyclicbarrier在await方法调用后，设置的count变为了0，之后又会开启下一次 nextGeneration( ),count就又变为了最初设置的2</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(2,() -&gt; &#123;</span><br><span class="line">            log.debug(&quot;task1 task2 finished...&quot;);  //count = 2</span><br><span class="line">        &#125;);  </span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(&quot;task1 begin...&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();  //2-1</span><br><span class="line">//                    log.debug(&quot;task1 end...&quot;);</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(&quot;task2 begin...&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();  //1-1 = 0</span><br><span class="line">//                    log.debug(&quot;task1 end...&quot;);</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="7-线程安全集合类概述"><a href="#7-线程安全集合类概述" class="headerlink" title="7.线程安全集合类概述"></a>7.线程安全集合类概述</h4><p>线程安全集合类可以分为三类：</p>
<ul>
<li>遗留的线程安全集合如HashTable,Vector 【并发性能比较低，因为方法全部用synchronized加锁了，不推荐使用，有替代的类】</li>
<li>使用Collections装饰的线程安全集合，如：<ul>
<li>Collections.synchronizedCollection</li>
<li>Collections.synchronizedList</li>
<li>Collections.synchronizedMap</li>
<li>Collections.synchronizedSet</li>
<li>Collections.synchronizedNavigableMap</li>
</ul>
</li>
<li>java.util.concurrent.*</li>
</ul>
<p>重点介绍java.util.concurrent.*下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：Blocking、CopyOnWrite、Concurrent</p>
<ul>
<li><p>Blocking大部分实现基于锁，并提供用来阻塞的方法</p>
</li>
<li><p>CopyOnWrite之类容器修改开销相对较重 【适用于读多写少】</p>
</li>
<li><p>Concurrent类型的容器：</p>
<ul>
<li><p>内部很多操作使用cas优化，一般可以提供高吞吐量</p>
</li>
<li><p>弱一致性</p>
<ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li>
<li>求大小弱一致性，size操作未必是100%准确</li>
<li>读取弱一致性</li>
</ul>
</li>
<li><blockquote>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用fail-fast机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="8-ConcurrentHashMap"><a href="#8-ConcurrentHashMap" class="headerlink" title="8.ConcurrentHashMap"></a>8.ConcurrentHashMap</h4><p><strong>练习：单词计数</strong></p>
<p>生成测试数据</p>
<ul>
<li>下面的代码会存在线程安全问题，即便ConcurrentHashMap类中的每个方法都是线程安全的，但是多个方法组合到一起的时候就会出现线程安全问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String,Integer&gt; concurrentHashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//检查key有没有</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">counter</span> <span class="operator">=</span> concurrentHashMap.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> counter == <span class="literal">null</span> ? <span class="number">1</span> : counter + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//没有则put</span></span><br><span class="line">concurrentHashMap.put(<span class="string">&quot;hello&quot;</span>,newValue);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, LongAdder&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//computeIfAbsent 如果缺少一个key,则计算生成一个value，然后将key value放入map</span></span><br><span class="line"><span class="comment">/*LongAdder value = map.computeIfAbsent(&quot;hello&quot;, new Function&lt;String, LongAdder&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public LongAdder apply(String s) &#123;</span></span><br><span class="line"><span class="comment">                return new LongAdder();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"><span class="type">LongAdder</span> <span class="variable">value</span> <span class="operator">=</span> map.computeIfAbsent(<span class="string">&quot;hello&quot;</span>, (key) -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>());</span><br><span class="line"><span class="comment">//执行累加</span></span><br><span class="line">value.increment();</span><br></pre></td></tr></table></figure>

<p><strong>ConcurrentHashMap原理</strong></p>
<p><strong>1.JDK 7并发死链</strong></p>
<p>Map是采用的 数组+链表来进行实现。</p>
<p>JDK7在发生下标冲突的时候，在链表中进行插入是采用头插法。而在JDK8中采用的是尾插法</p>
<ul>
<li>在自动扩容的时候会出现并发死链。扩容因子就是里面的元素超过map中数组的比例是多少的时候就开始扩容，默认是3&#x2F;4.</li>
</ul>
<p><strong>测试代码</strong></p>
<p>注意：</p>
<ul>
<li>要在JDK 7下运行，否则扩容机制和hash的计算方法都变了</li>
<li>代码不要随便改动</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk 7中的HashMap源码</span></span><br><span class="line"><span class="comment">//newTable是rehash之后的数组链表。table是之前的数组链表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapcity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span>(rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span>:hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash,newCapcity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#####################################</span><br><span class="line">假设有两个线程来进行put元素，此时发生扩容进入到transfer函数</span><br><span class="line">table中的元素是这样的</span><br><span class="line"><span class="number">1</span>——》<span class="number">35</span>——》<span class="number">16</span>——》<span class="literal">null</span></span><br><span class="line"><span class="number">2</span>——》<span class="literal">null</span></span><br><span class="line"><span class="number">3</span>——》<span class="literal">null</span></span><br><span class="line">...</span><br><span class="line">	首先是Thread <span class="number">0</span>遍历到table中的第一个元素节点<span class="number">1</span>。e就相当于是 <span class="number">1</span>——》<span class="number">35</span>——》<span class="number">16</span>——》<span class="literal">null</span>.然后进入到<span class="keyword">while</span>循环Entry&lt;K,V&gt; next = e.next;此时next就相当于是<span class="number">35</span>——》<span class="number">16</span>——》<span class="literal">null</span>。</span><br><span class="line">    然后此时另外一个线程线程<span class="number">1</span>也执行到transfer函数，并且它将整个扩容流程都执行结束。执行完后newTable和table的结果变为</span><br><span class="line"><span class="number">35</span>——》<span class="number">1</span>——》<span class="literal">null</span></span><br><span class="line"><span class="number">16</span>——》<span class="literal">null</span></span><br><span class="line">...</span><br><span class="line">    此时切换到线程<span class="number">0</span>来进行执行，此时局部变量e,next被恢复，引用没变但内容变了，e的内容变为了<span class="number">1</span>——》<span class="literal">null</span>,next的内容<span class="number">35</span>——》<span class="number">1</span>——》<span class="literal">null</span>.此时开始执行<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash,newCapcity);的代码以及后面的代码，执行完第一次循环后</span><br><span class="line">newTable[<span class="number">1</span>] = <span class="number">1</span>——》<span class="literal">null</span></span><br><span class="line">	进行赋值操作，e=next,所以 e = <span class="number">35</span>——》<span class="number">1</span>——》<span class="literal">null</span>,然后进行<span class="keyword">while</span>循环的判断<span class="keyword">while</span>(<span class="literal">null</span> != e) 为真所以进行第二次循环，此时Entry&lt;K,V&gt; next = e.next; 因此next = <span class="number">1</span>——》<span class="literal">null</span>,然后执行e.next = newTable[i];</span><br><span class="line">newTable[i] = e;这两条语句，第二次循环后，</span><br><span class="line">newTable[<span class="number">1</span>] = <span class="number">35</span>——》<span class="number">1</span>——》<span class="literal">null</span></span><br><span class="line">	进行赋值操作，e=next,所以 e = <span class="number">1</span>——》<span class="literal">null</span>,然后有进行<span class="keyword">while</span>循环判断后进入给next进行赋值，此时next=<span class="literal">null</span>，然后执行 e.next = newTable[i];newTable[i] = e;这两条语句之后，</span><br><span class="line">newTable[<span class="number">1</span>] = <span class="number">1</span>——》<span class="number">35</span>——》<span class="number">1</span>——》<span class="number">35</span>。。。此时就形成了死链，</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>究其原因，是因为在多线程环境下使用了非线程安全的map集合</li>
<li>JDK8虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其他问题（如扩容丢数据）</li>
</ul>
<p><strong>JDK8中的ConcurrentHashMap里面的重要属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整个ConcurrentHashMap就是一个Node[ ]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment"> * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment"> * bins数组。在第一次插入时延迟初始化。大小总是二的幂。由迭代器直接访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment"> * 下一个要使用的表；仅在调整大小时为非空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment"> * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment"> * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment"> * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment"> * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment"> * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment"> * 表初始化和调整大小控制。如果为负数，则表正在初始化或调整大小：-1 表示初始化，否则 -(1 + 活动调整大小线程   * 的数量)。否则，当 table 为 null 时，保存要在创建时使用的初始表大小，或者默认为 0。初始化后，保存下一个   * 元素计数值，根据该值调整表的大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容时如果某个bin迁移完毕，用ForwardingNode作为旧table bin的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为treebin的头结点，存储root和first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为treebin的节点，存储parent,left,right   链表阈值为8,当链表长度过长时，性能由O(1)退化为O(n),并且能避免DPOS攻击（洪泛攻击），某一个链表长度超过8后，优先进行扩容，让让整个table数组的长度扩容到64的时候就会将链表转化为红黑树。如果转换为红黑树后，随着删除，红黑树结点的个数小于6后，就又会将红黑树转换为链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重要方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Node[] 中第i个Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab,<span class="type">int</span> i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cas修改Node[]中第i个Node的值，c为旧值，v为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab,<span class="type">int</span> i,Node&lt;K,V&gt; c,Node&lt;K,V&gt; v)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//直接修改Node[]中第i个Node的值，v为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab,<span class="type">int</span> i,Node&lt;K,V&gt; v)</span></span><br></pre></td></tr></table></figure>

<p><strong>构造器分析</strong></p>
<p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了table的大小，以后在第一次使用时才会真正创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// tableSizeFor方法时保证计算的大小是2^n，即16，32，64，要不然哈希表无法正常工作</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get流程</strong>【全程没有加锁，这也是为什么并发度高的原因】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//spread方法能确保返回结果是正数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">//(n - 1) &amp; h 找出桶下标，这个比取模运算快</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果头结点已经是要查找的key</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hash为负数表示该bin在扩容中或者是treebin,这时调用find方法来查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">//正常遍历链表，用equals比较</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>put流程</strong></p>
<p>以下数组简称（table）,链表简称bin</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//其中spread方法会综合高位低位，具有更好的hash性</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f是链表头结点</span></span><br><span class="line">        <span class="comment">//fh是链表头结点的hash</span></span><br><span class="line">        <span class="comment">//i是链表在table中的下标</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//要创建table</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//初始化table使用了cas，无需synchronized创建成功，进入下一轮循环</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//要创建链表头结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//添加链表头结点时使用了cas，无需synchronized</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//帮忙扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮忙之后进入下一轮循环</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//锁住链表头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//再次确认链表头结点没有被移动</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//找到相同的key</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">//更新</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//已经是最后的节点了，新增Node,追加至链表尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//putTreeVal会看key是否已经在数中，是，则返回对应的TreeNode</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//释放链表头结点的锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//如果链表长度 》= 树化阈值（8），进行链表转为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加size计数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//尝试将sizeCtl设置为-1（表示初始化table）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//获得锁，创建table,这时其他线程会在while()循环中yield直至table创建</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check是之前binCount的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">//已经有了counterCells,向cell累加</span></span><br><span class="line">        (as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        <span class="comment">//还没有，向baseCount累加</span></span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">//创建累加单元数组和cell,累加重试</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK7中的ConcurrentHashMap</strong></p>
<p>它维护了一个segment数组，每个segment对应一把锁</p>
<ul>
<li>优点：如果多个线程访问不同的segment,实际是没有冲突的，这与jdk8中是类似的</li>
<li>缺点：Segments数组默认大小为16，这个容量初始化指定后就不能改变，并且不是懒惰初始化</li>
</ul>
<p>每个segment数组都对应一个hashEntry数组【一个小的hash表】，就实现了分段锁，每个HashEntry数组又是数组+链表的结构</p>
<ul>
<li>其中this.segmentShift和this.segmentMask的作用是决定将key的hash结果匹配到哪个segment</li>
</ul>
<h4 id="9-LinkedBlockingQueue"><a href="#9-LinkedBlockingQueue" class="headerlink" title="9.LinkedBlockingQueue"></a><strong>9.LinkedBlockingQueue</strong></h4><ul>
<li>高明之处在于用了两把锁和dummy节点<ul>
<li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li>
<li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul>
<li>消费者与消费者线程仍让串行</li>
<li>生产者与生产者线程仍然串行</li>
</ul>
</li>
<li>一把锁用于队头，一把锁用于队尾</li>
</ul>
</li>
<li>与ArrayBlockingQueue的性能比较<ul>
<li>Linked支持有界，Array强制有界</li>
<li>Linked实现是链表，Array实现是数组</li>
<li>Linked是懒惰的，而Array需要提前初始化Node数组</li>
<li>Linked每次入队会生成新Node，而Array的Node是提前创建好的</li>
<li>Linked两把锁，Array一把锁</li>
</ul>
</li>
</ul>
<h4 id="10-ConcurrentLinkedQueue"><a href="#10-ConcurrentLinkedQueue" class="headerlink" title="10.ConcurrentLinkedQueue"></a>10.ConcurrentLinkedQueue</h4><p>ConcurrentLinkedQueue的设计与LinkedBlockingQueue非常像，也是</p>
<ul>
<li>两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li>
<li>dummy节点的引入让两把锁将来锁住的是不同对象，避免竞争</li>
<li>只是这锁使用了cas来实现</li>
</ul>
<p>事实上，ConcurrentLinkedQueue应用很广泛，例如Tomcat的Connector结构</p>
<h4 id="11-CopyOnWriteArrayList"><a href="#11-CopyOnWriteArrayList" class="headerlink" title="11.CopyOnWriteArrayList"></a><strong>11.CopyOnWriteArrayList</strong></h4><p>CopyOnWriteArraySet是它的马甲</p>
<ul>
<li><p>底层实现采用了写入时拷贝的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其他线程的&#x3D;&#x3D;并发读，读写分离&#x3D;&#x3D;</p>
</li>
<li><pre><code class="java">public boolean add(E e) &#123;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try &#123;
        //获取旧数组
        Object[] elements = getArray();
        int len = elements.length;
        //拷贝新的数组（这里是比较耗时的操作，但不影响其他读线程）
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        //添加新元素
        newElements[len] = e;
        //替换旧的数据
        setArray(newElements);
        return true;
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
</code></pre>
</li>
<li><p>在jdk11中使用的是synchronized，jdk8中使用的是可重入锁</p>
</li>
<li><p>其他读操作并未加锁。适合读多写少的应用场景</p>
</li>
</ul>
<p><strong>迭代器弱一致性</strong></p>
<ul>
<li><p>数据库的MVCC都是弱一致性的表现-</p>
</li>
<li><p>并发高和一致性是矛盾的需要权衡好</p>
</li>
</ul>
<h3 id="8-3第三方工具"><a href="#8-3第三方工具" class="headerlink" title="8.3第三方工具"></a>8.3第三方工具</h3><p>1.guava限流</p>
<p>应用之web服务器</p>
<h2 id="9-异步编程"><a href="#9-异步编程" class="headerlink" title="9.异步编程"></a>9.异步编程</h2><blockquote>
<p>wait&#x2F;sleep区别</p>
<ul>
<li>1.来自不同的类<ul>
<li>wait —&gt; Object</li>
<li>sleep —&gt; Thread</li>
</ul>
</li>
<li>2.关于锁的释放<ul>
<li>&#x3D;&#x3D;wait会释放锁&#x3D;&#x3D;，sleep不会释放锁</li>
</ul>
</li>
<li>3.使用的范围是不同的<ul>
<li>wait必须在同步代码块中</li>
<li>sleep是在任意地方</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-4-Lock-锁"><a href="#2-4-Lock-锁" class="headerlink" title="2..4 Lock(锁)"></a>2..4 Lock(锁)</h3><blockquote>
<p>lock三部曲：</p>
<ul>
<li>new ReentrantLock( );   &#x2F;&#x2F;创建锁对象</li>
<li>lock.lock();                    &#x2F;&#x2F;加锁</li>
<li>finally{ lock.unlock()}  &#x2F;&#x2F;解锁</li>
</ul>
</blockquote>
<blockquote>
<p>Synchronized与Lock的区别：</p>
<ul>
<li>Synchronized是内置的Java 关键字，Lock是一个关键字</li>
<li>Synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁</li>
<li>synchronized 会自动释放锁，lock必须要释放锁，如果不释放锁，会死锁</li>
<li>Synchronize 可重入锁，不可以中断的，非公平的。Lock,可重入锁，可以判断锁，非公平。（可以自己投票）</li>
<li>synchronized适合锁少量的代码同步问题，lock适合锁大量的同步代码</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="clrv2tqxo000j4hku3dvi9445" data-title="并发编程学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/27/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          docker常用命令
        
      </div>
    </a>
  
  
    <a href="/2022/06/27/MySQL%E5%AD%A6%E4%B9%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MySQL学习</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/">技术工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 13.33px;">Go</a> <a href="/tags/Hexo/" style="font-size: 13.33px;">Hexo</a> <a href="/tags/JVM/" style="font-size: 13.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 13.33px;">个人</a> <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 13.33px;">云原生</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 13.33px;">并发</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 13.33px;">快捷键</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13.33px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 16.67px;">数据库</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/27/hello-world/">Hexo使用技巧</a>
          </li>
        
          <li>
            <a href="/2024/01/27/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Mac使用技巧</a>
          </li>
        
          <li>
            <a href="/2022/12/27/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Java语言学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/">Java虚拟机学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/">LeetCode刷题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Kevin he<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>