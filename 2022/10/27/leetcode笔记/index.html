<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LeetCode刷题 | 侬的杂货铺</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="leetcode笔记1.字符串1.字符串哈希（leetcode 686）2.数组3.链表1.删除自身节点。（不能获取到头节点）1234567&#x2F;&#x2F;leetcode227题public void deleteNode(ListNode node) &#123;    &#x2F;&#x2F;论如何获得永生:先将自己变成后面的节点，然后再杀死自己    ListNode last&#x3D;node.next;    node.va">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题">
<meta property="og:url" content="https://kdhello07.github.io/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="侬的杂货铺">
<meta property="og:description" content="leetcode笔记1.字符串1.字符串哈希（leetcode 686）2.数组3.链表1.删除自身节点。（不能获取到头节点）1234567&#x2F;&#x2F;leetcode227题public void deleteNode(ListNode node) &#123;    &#x2F;&#x2F;论如何获得永生:先将自己变成后面的节点，然后再杀死自己    ListNode last&#x3D;node.next;    node.va">
<meta property="og:locale">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/215/1.png">
<meta property="article:published_time" content="2022-10-26T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-26T20:01:10.115Z">
<meta property="article:author" content="Kevin he">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/solution-static/215/1.png">
  
    <link rel="alternate" href="/atom.xml" title="侬的杂货铺" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">侬的杂货铺</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术、阅读、分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kdhello07.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-leetcode笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-10-26T16:00:00.000Z" itemprop="datePublished">2022-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      LeetCode刷题
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode笔记"><a href="#leetcode笔记" class="headerlink" title="leetcode笔记"></a>leetcode笔记</h1><h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h2><h4 id="1-字符串哈希（leetcode-686）"><a href="#1-字符串哈希（leetcode-686）" class="headerlink" title="1.字符串哈希（leetcode 686）"></a>1.字符串哈希（leetcode 686）</h4><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h2><h4 id="1-删除自身节点。（不能获取到头节点）"><a href="#1-删除自身节点。（不能获取到头节点）" class="headerlink" title="1.删除自身节点。（不能获取到头节点）"></a>1.删除自身节点。（不能获取到头节点）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode227题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="comment">//论如何获得永生:先将自己变成后面的节点，然后再杀死自己</span></span><br><span class="line">    ListNode last=node.next;</span><br><span class="line">    node.val= last.val;</span><br><span class="line">    node.next=last.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-树"><a href="#4-树" class="headerlink" title="4.树"></a>4.树</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代(即深度优先遍历二叉树)</span></span><br><span class="line"><span class="comment">     * 先序遍历二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) <span class="comment">//先压入右子树</span></span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) <span class="comment">//再压入左子树</span></span><br><span class="line">                stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代</span></span><br><span class="line"><span class="comment">     * 中序遍历二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">          List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span>  list;</span><br><span class="line">          Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">          <span class="keyword">while</span>(p != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">                  s.push(p);</span><br><span class="line">                  p = p.left;</span><br><span class="line">              &#125;</span><br><span class="line">              p = s.pop();</span><br><span class="line">              list.add(p.val);</span><br><span class="line">              p = p.right;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(list);</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序非递归遍历二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();    </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root, prev = root; <span class="comment">//pre记录上一个已经输出的结点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || stack.size() &gt; <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;    </span><br><span class="line">                stack.push(node);    </span><br><span class="line">                node = node.left;    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.peek().right; <span class="comment">//在出栈之前，先判断栈顶元素的右孩子结点</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span> || temp == prev) &#123; <span class="comment">//当前节点无右子树或右子树已经输出    </span></span><br><span class="line">                node = stack.pop();    </span><br><span class="line">                list.add(node.val);</span><br><span class="line">                prev = node; <span class="comment">//记录上一个已输出结点</span></span><br><span class="line">                node = <span class="literal">null</span>;    </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                node = temp; <span class="comment">//处理右子树</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-回溯"><a href="#5-回溯" class="headerlink" title="5.回溯"></a>5.回溯</h2><h2 id="6-贪心"><a href="#6-贪心" class="headerlink" title="6.贪心"></a>6.贪心</h2><h2 id="7-动态规划"><a href="#7-动态规划" class="headerlink" title="7.动态规划"></a>7.动态规划</h2><h4 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0-1背包问题</span></span><br><span class="line">	有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</span><br><span class="line">	---背包有是一维的情况</span><br><span class="line">	---背包也有多维的情况（如leetcode474）</span><br><span class="line">	//核心代码，注意滚动数组要从右往左，否则就成了完全背包了</span><br><span class="line">	for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">        for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">完全背包问题</span></span><br><span class="line">	有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</span><br><span class="line">	根据遍历物品与遍历背包的不同又会有求排列数和组合数的不同</span><br><span class="line">	---如果求组合数就是外层for循环遍历物品，内层for遍历背包。（1,5）和（5，1）是同一种情况（如leetcode518题）</span><br><span class="line">	//组合代码</span><br><span class="line">	public int change(int amount, int[] coins) &#123;</span><br><span class="line">        int[] dp=new int[amount+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for (int i = 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            for (int j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">	---如果求排列数就是外层for遍历背包，内层for循环遍历物品。（1,5）和（5，1）是两种情况（如leetcode377题）</span><br><span class="line">	//排列代码</span><br><span class="line">	public int combinationSum4(int[] nums, int target) &#123;</span><br><span class="line">        int[] dp=new int[target+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for (int i = 0; i &lt;= target; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class="line">                if(i&gt;=nums[j])&#123;</span><br><span class="line">                    dp[i]=dp[i]+dp[i-nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];        </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 先遍历物品，再遍历背包</span><br><span class="line">    for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">        for(int j = weight[i]; j &lt; bagWeight ; j++) &#123; // 遍历背包容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">爬楼梯问题</span></span><br><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    //简单动态规划的解法</span><br><span class="line">    // if(n&lt;=2)&#123;</span><br><span class="line">    //     return n;</span><br><span class="line">    // &#125;</span><br><span class="line">    // int a=1,b=2;</span><br><span class="line">    // for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">    //     int c=b;</span><br><span class="line">    //     b=a+b;</span><br><span class="line">    //     a=c;</span><br><span class="line">    // &#125;</span><br><span class="line">    // return b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将爬楼梯问题转化为完全背包的排列问题</span><br><span class="line">    //将代码中的2可以改为m,即一下子可以爬1到m阶楼梯，就相当于有1到m的面值的无限硬币个数，可以组成的总钱数为n的排列数有多少</span><br><span class="line">    int[] dp=new int[n+1];</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=2;j++)&#123;</span><br><span class="line">            if(i&gt;=j)&#123;</span><br><span class="line">            dp[i]=dp[i]+dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-打家劫舍问题"><a href="#2-打家劫舍问题" class="headerlink" title="2.打家劫舍问题"></a>2.打家劫舍问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>就是比较传统的一排街道，没有环，如果偷相邻的两个街道就会报警。</span><br><span class="line">	代码：</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态规划解法</span></span><br><span class="line"><span class="comment">         * dp[i]表示在前i个街区中不触碰警报能获取到的最大价值</span></span><br><span class="line"><span class="comment">         * 递推公式：如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</span></span><br><span class="line"><span class="comment">         *         如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）</span></span><br><span class="line"><span class="comment">         *      所以有：dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i])</span></span><br><span class="line"><span class="comment">         * 初始化：dp[0]=0,dp[1]=nums[0]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 因为我们每次只会用到i前面的dp[i-1]和dp[i-2]所以可以用滚动数组的解法</span></span><br><span class="line"><span class="comment">         * 用两个变量来进行记录</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c=Math.max(b,a+nums[i]);</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>还是一排街道，但是与第一种情况不同的是，这里面的首尾两个街道算是相邻的街道。所以需要做进一步思考。就是分情况讨论。</span><br><span class="line">    <span class="number">1</span>）.最终偷的结果首尾两个街道都不包括。即只考虑在除了首尾的中间的元素</span><br><span class="line">    <span class="number">2</span>）.最终偷的结果考虑首元素，但不考虑尾元素的情况</span><br><span class="line">    <span class="number">3</span>）.最终偷的结果考虑尾元素，但不考虑首元素的情况</span><br><span class="line">    综合得：<span class="number">2</span>、<span class="number">3</span>两种情况里面都包含了第一种情况，所以总得就只用分为<span class="number">2</span>，<span class="number">3</span>两种情况，在考虑<span class="number">2</span>、<span class="number">3</span>这两种情况得时候，这就是前面第一种打家劫舍类型去了，最后取这两者中得最大值。 </span><br><span class="line">    代码：</span><br><span class="line">    	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> r1=getAns(nums,l,r-<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> r2=getAns(nums,l+<span class="number">1</span>,r);</span><br><span class="line">            <span class="keyword">return</span> r1&gt;r2?r1:r2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAns</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">            <span class="type">int</span> n=r-l;</span><br><span class="line">            <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="type">int</span> c=Math.max(a+nums[i],b);</span><br><span class="line">                a=b;</span><br><span class="line">                b=c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-股票买卖问题"><a href="#3-股票买卖问题" class="headerlink" title="3.股票买卖问题"></a>3.股票买卖问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">leetcode 123题</span></span><br><span class="line">	- 分状态进行解决</span><br><span class="line">	每一天总共有5个状态</span><br><span class="line">		dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</span><br><span class="line">		0 不操作状态		相当手中现金为0  dp[i][0]=0</span><br><span class="line">	buy1	1 第一次买入		相当于是消耗了这一天的钱数  -prices[i]</span><br><span class="line">	sell1	2 第一次卖出		相当于是获得了这一天的钱数  +prices[i]</span><br><span class="line">	buy2	3 第二次买入		相当于是消耗了这一天的钱数  -prices[i]</span><br><span class="line">	sell2	4 第二次卖出		相当于是获得了这一天的钱数  +prices[i]</span><br><span class="line">	这一天可以不进行任何操作，或者在前一天的状态下进行其他四种状态的变化</span><br><span class="line">		在第i天，进行 	1 第一次买入  ：buy1=Math.max(buy1&#x27;,-prices[i])</span><br><span class="line">									:buy1&#x27;表示这一天不进行操作，-prices[i]表示这一天买入消耗这么多</span><br><span class="line">                        2 第一次卖出  :sell1=Math.max(sell1&#x27;,buy1+prices[i])</span><br><span class="line">                        3 第二次买入	 :buy2=Math.max(buy2&#x27;,sell1-prices[i])</span><br><span class="line">                        4 第二次卖出  :sell2=Math.max(sell2&#x27;,buy2+prices[i])</span><br><span class="line">                 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码演示</span></span><br><span class="line">	public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int buy1 = -prices[0], sell1 = 0;</span><br><span class="line">        int buy2 = -prices[0], sell2 = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">leetcode 188题</span></span><br><span class="line">这是在123题的基础上变为至多可以买卖k次,思想与123题类似</span><br><span class="line">    public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">        if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp=new int[k*2+1];</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        for (int i = 1; i &lt; k*2+1; i+=2) &#123;</span><br><span class="line">            dp[i]=-prices[0];</span><br><span class="line">            dp[i+1]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            for(int j=1;j&lt;k*2+1;j++)&#123;</span><br><span class="line">                if(j%2==1)&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-1]-prices[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-1]+prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[k*2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1eetcode309</span></span><br><span class="line">股票买卖问题，带手续费的</span><br><span class="line">	我们用 f[i]表示第 i 天结束之后的「累计最大收益」</span><br><span class="line">	该题分为以下几个状态（这里的状态是该天结束之后的状态）：</span><br><span class="line">		- 我们目前持有一支股票，对应的「累计最大收益」记为 f[i][0]；</span><br><span class="line">		- 我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]；</span><br><span class="line">		- 我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]。</span><br><span class="line">		这里的「处于冷冻期」指的是在第 i 天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	对于f[i][0]:我们可以是在这一天不进行任何操作，在之前就已经持有了一支股票，所以有f[i-1][0].或者是前一天不持有股票，然后今天买入，所以是必须在前一天处于非冷冻期中。因此为f[i][0]=f[i-1][2]-prices[i]</span><br><span class="line">	</span><br><span class="line">	对于f[i][1]:则是在前一天持有一支股票，然后在第i天卖出，所以处于冷冻期f[i][1]=f[i-1][0]+prices[i]</span><br><span class="line">	</span><br><span class="line">	对于f[i][2]:可以是当天不进行任何操作所以有f[i-1][2]，也可以是在前一天处于冷冻期，一天后就不是冷冻期了。所以有f[i][2]=f[i-1][1]</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">初始化</span></span><br><span class="line">		f[i][0]=-prices[0]</span><br><span class="line">		f[i][1]=0</span><br><span class="line">		f[i][2]=0</span><br><span class="line">		</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">代码：</span></span><br><span class="line">	public int maxProfit(int[] prices) &#123;</span><br><span class="line">        /*if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int[][] dp=new int[n][2];</span><br><span class="line">        dp[0][0]=-prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2]-prices[i]);</span><br><span class="line">            dp[i][1]=dp[i-1][0]+prices[i];</span><br><span class="line">            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[n-1][1],dp[n-1][2]);*/</span><br><span class="line"></span><br><span class="line">        //空间进行优化，因为第i天的状态只与第i-1天有关系</span><br><span class="line">        if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int a=-prices[0];</span><br><span class="line">        int b=0;</span><br><span class="line">        int c=0;</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            int d=Math.max(a,c-prices[i]);</span><br><span class="line">            int e=a+prices[i];</span><br><span class="line">            int f=Math.max(c,b);</span><br><span class="line">            a=d;</span><br><span class="line">            b=e;</span><br><span class="line">            c=f;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(b,c);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-最长子序列问题"><a href="#4-最长子序列问题" class="headerlink" title="4.最长子序列问题"></a>4.最长子序列问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如：leetcode1143。（leetcode1035）</span><br><span class="line">	值得注意的是这是一个二维的动态规划，既需要同时对两个数组进行动态分析。画出一个m*n的矩阵会便于进行分析</span><br></pre></td></tr></table></figure>



<h2 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h2><h2 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h2><h4 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有的位运算都是用补码进行运算</span></span><br><span class="line"></span><br><span class="line">	正数的原码，反码，补码都相同</span><br><span class="line">	负数的原码是除了第一个符号位为1外，其他位与正数原码相同，如-3的原码是 1000....0000011</span><br><span class="line">	负数的反码是在负数原码的基础上符号位不变，其他位取反    如-3的反码是  1111....1111100</span><br><span class="line">	负数的补码是在负数反码的基础上+1                    -3的反码是    1111....1111101</span><br></pre></td></tr></table></figure>

<h4 id="1-判断一个数是否是2的次幂"><a href="#1-判断一个数是否是2的次幂" class="headerlink" title="1.判断一个数是否是2的次幂"></a>1.判断一个数是否是2的次幂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> (sum&amp;(sum-<span class="number">1</span>))==<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="2-异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）"><a href="#2-异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）" class="headerlink" title="2.异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）"></a>2.异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如何才能做到线性时间复杂度和常数空间复杂度呢？</span><br><span class="line"></span><br><span class="line">答案是使用位运算。对于这道题，可使用异或运算 \oplus⊕。异或运算有以下三个性质。</span><br><span class="line"></span><br><span class="line">正数反码：与原码相同</span><br><span class="line"></span><br><span class="line">负数反码：符号位为“1”，数值位按位 取反。</span><br><span class="line">正数补码：与原码相同</span><br><span class="line">负数补码：求反加一</span><br><span class="line">记住：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有参与运算的都是以补码形式进行的 结果也是补码 因此也需要将补码转换成为原码的形式存在</span></span><br><span class="line"></span><br><span class="line">任何数和 0做异或运算，结果仍然是原来的数，即 a⊕0=a。</span><br><span class="line">任何数和其自身做异或运算，结果是 0，即 a⊕a=0。</span><br><span class="line">异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</span><br></pre></td></tr></table></figure>

<h4 id="3-与运算和或运算。（leetcode-318）"><a href="#3-与运算和或运算。（leetcode-318）" class="headerlink" title="3.与运算和或运算。（leetcode 318）"></a>3.与运算和或运算。（leetcode 318）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或运算  |   （1=1&amp;1 1=1|0 1=0|1 0=0|0） 注意这个没有短路的效果，有短路的是||和&amp;&amp;</span></span><br><span class="line">	常见的题目类型有：</span><br><span class="line">		1.看一个数的某一位是否为1或0.</span><br><span class="line">			如：   00000000</span><br><span class="line">				| 00000001</span><br><span class="line">                ————————————</span><br><span class="line">                  00000001</span><br><span class="line">     	2.看求某一个数的掩码</span><br><span class="line">     			a |= (1&lt;&lt;6)  (最终的效果就是a这个数的二进制数第六位数是1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">与运算  &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-移位运算"><a href="#4-移位运算" class="headerlink" title="4.移位运算"></a>4.移位运算</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> &lt;&lt;  左移运算</span>  </span><br><span class="line">	如 a= 1&lt;&lt;4  是将1变为二进制后往左移4位</span><br><span class="line">				00000001</span><br><span class="line">			 &lt;&lt; </span><br><span class="line">			 ____________</span><br><span class="line">			 a= 00010000=16</span><br><span class="line">	如 b= 3&lt;&lt;4  是将3转换为二进制后往左移4位，最终结果是48</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> &gt;&gt; 右移运算与左移运算则相反</span></span><br></pre></td></tr></table></figure>

<h4 id="5-非运算"><a href="#5-非运算" class="headerlink" title="5.非运算 ~"></a>5.非运算 ~</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意一点是所有位运算都是按照补码进行运算的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~运算是将要求的数的补码取反（包括符号位），得到补码，再由补码退出该数的原码，就是最终结果</span></span><br><span class="line">所以~10的求解过程是这样的</span><br><span class="line">	10的补码是 		                   0...00001010</span><br><span class="line">	所以~10的补码是上面10的补码所有位取反   1...11110101</span><br><span class="line">    就有了~10的原码就是					1...00001011  即~10等于 -11</span><br><span class="line">    </span><br><span class="line">    ~(-3)的求解过程是</span><br><span class="line">    -3的原码：1...00000011</span><br><span class="line">    -3的反码：1...11111100</span><br><span class="line">    -3的补码：1...11111101</span><br><span class="line">    </span><br><span class="line"> ~(-3)的补码：0...00000010</span><br><span class="line"> ~(-3)的反码：0...00000010</span><br><span class="line"> ~(-3)的原码：0...00000010   即 ~(-3)等于 2</span><br><span class="line"> </span><br><span class="line"> 结论：~(n) = -n-1  (无论n是正数还是负数)</span><br></pre></td></tr></table></figure>



<h4 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.剑指offer65题(利用位运算实现加法)</span><br></pre></td></tr></table></figure>



<h2 id="10-查找算法"><a href="#10-查找算法" class="headerlink" title="10.查找算法"></a>10.查找算法</h2><h4 id="1-二分查找算法"><a href="#1-二分查找算法" class="headerlink" title="1.二分查找算法"></a>1.二分查找算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.查找目标值的索引   如查找[5,7,8,10]的8位置，返回2，查找9，还是返回2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)&#123;</span><br><span class="line">                right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查找目标值索引的右边界  如查找[5,7,7,8,8,10]中8的右边界第一个值的索引即返回10对应的索引，查找7则返回第一个8的索引   (题目如剑指offer中53题，理解见图)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//与一般的二分查找区别在这里</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;=target)&#123;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-动态规划-二分查找"><a href="#2-动态规划-二分查找" class="headerlink" title="2.动态规划+二分查找"></a>2.动态规划+二分查找</h4><blockquote>
<p>见leetcode 300题</p>
</blockquote>
<h2 id="11-集合框架"><a href="#11-集合框架" class="headerlink" title="11.集合框架"></a>11.集合框架</h2><h4 id="1-List—ArrayList-LinkedList的使用"><a href="#1-List—ArrayList-LinkedList的使用" class="headerlink" title="1.List—ArrayList,LinkedList的使用"></a>1.List—ArrayList,LinkedList的使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是一个很重要的点</span></span><br><span class="line">1.当需要对集合中的数据进行频繁的随机访问的时候，建议使用ArrayList</span><br><span class="line">2.当需要对集合进行频繁的插入和删除数据时，建议使用LinkedList</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList的方法，add方法默认从末端添加元素</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList方法，add可以从开头或末尾添加元素</span><br></pre></td></tr></table></figure>

<h2 id="12-数学"><a href="#12-数学" class="headerlink" title="12.数学"></a>12.数学</h2><h4 id="1-求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）"><a href="#1-求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）" class="headerlink" title="1.求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）"></a>1.求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.方法1,暴力破解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.方法2.二分法</span></span><br><span class="line">如果num是完全平方数，就相当于是能从<span class="number">1</span>到num中间寻找一个数，这个数的平方等于num</span><br><span class="line">因此左边界是<span class="number">1</span>，右边界是num,然后进行二分查找。但是需要注意的是临时得到的中间数middle的平方可能会超出<span class="type">int</span>的范围，因此需要用<span class="type">long</span>类型来存储</span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="type">int</span> left=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> right=num;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">    <span class="type">int</span> middle=(right+left)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> square=(<span class="type">long</span>)middle*middle;</span><br><span class="line">    <span class="keyword">if</span>(square&gt;num)&#123;</span><br><span class="line">        right=middle-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(square&lt;num)&#123;</span><br><span class="line">        left=middle+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.方法3.数学。（利用一个完全平方数，能够由奇数相加得到）</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">4</span>=<span class="number">1</span>+<span class="number">3</span></span><br><span class="line"><span class="number">9</span>=<span class="number">1</span>+<span class="number">3</span>+<span class="number">5</span></span><br><span class="line"><span class="number">16</span>=<span class="number">1</span>+<span class="number">3</span>+<span class="number">5</span>+<span class="number">7</span></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">num -= x;</span><br><span class="line">x += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-矩阵快速幂（时间复杂度为O-logn-）解决斐波那契数列中使用（待看）"><a href="#2-矩阵快速幂（时间复杂度为O-logn-）解决斐波那契数列中使用（待看）" class="headerlink" title="2.矩阵快速幂（时间复杂度为O(logn)）解决斐波那契数列中使用（待看）"></a>2.矩阵快速幂（时间复杂度为O(logn)）解决斐波那契数列中使用（待看）</h4><h2 id="13-排序算法"><a href="#13-排序算法" class="headerlink" title="13.排序算法"></a>13.排序算法</h2><h4 id="1-内置的排序算法-比较器（Comparator）"><a href="#1-内置的排序算法-比较器（Comparator）" class="headerlink" title="1.内置的排序算法+比较器（Comparator）"></a>1.内置的排序算法+比较器（Comparator）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">java中的内置排序函数有Arrays和Collections类中的<span class="built_in">sort</span>函数，其中还可以自己定义排序的顺序，就是创建比较器对象，注意o1对象和o2对象比较顺序</span></span><br><span class="line">if(o1.get(i)&lt;o1.get(0))&#123;   //当这种情况发生时，如果想调整当前o1,o2的顺序，就返回正数，否则返回负数</span><br><span class="line">	return o1.get(0);  //将o1调整到o2之前</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	return -1;  //保持不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] nums=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Arrays.sort(nums, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1[<span class="number">0</span>]&gt;o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//因为要的是升序，但是o1大于o2所以应该调整顺序，所以返回正数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1[<span class="number">0</span>]&lt;o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//因为要的是升序，所以o1与o2已经是升序了，所以不变。o1，o2的顺序保持不变， </span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这是在第一维相等的情况下，比较第二维</span></span><br><span class="line">                <span class="keyword">if</span>(o1[<span class="number">1</span>]&gt;o2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1[<span class="number">1</span>]&lt;o2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(nums);</span><br><span class="line">    <span class="comment">//结果为：[1,2],[2,3],[2,6],[3,4],[5,2],[5,8],[6,1],[6,3]</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-快速排序-题目见剑指offer40"><a href="#2-快速排序-题目见剑指offer40" class="headerlink" title="2.快速排序(题目见剑指offer40)"></a>2.快速排序(题目见剑指offer40)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fastSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=i;</span><br><span class="line">    <span class="type">int</span> r=j;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[r]&gt;=arr[i])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[l]&lt;=arr[i])&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里其实判不判断l&lt;r都无所谓，只是进行了多一次交换，即便不满足，此时l==r，也不会有影响</span></span><br><span class="line">        <span class="type">int</span> temp=arr[r];</span><br><span class="line">        arr[r]=arr[l];</span><br><span class="line">        arr[l]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp=arr[i];</span><br><span class="line">    arr[i]=arr[l];</span><br><span class="line">    arr[l]=temp;</span><br><span class="line">    fastSort(arr,i,l-<span class="number">1</span>);</span><br><span class="line">    fastSort(arr,l+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优先队列（排序）"><a href="#3-优先队列（排序）" class="headerlink" title="3.优先队列（排序）"></a>3.优先队列（排序）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="comment">//                if(o1&gt;o2)&#123;</span></span><br><span class="line">        <span class="comment">//                    return o1-o2;</span></span><br><span class="line">        <span class="comment">//                &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//                    return o2-o1;</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//                if(o1&gt;o2)&#123;</span></span><br><span class="line">        <span class="comment">//                    //升序，因为o1是将要插入到优先队列中的元素，o2是队列中的头元素，</span></span><br><span class="line">        <span class="comment">//                    // 并且o1大于o2,所以返回1，直接放到后面</span></span><br><span class="line">        <span class="comment">//                    return 1;	   顺序变换    o1&gt;o2</span></span><br><span class="line">        <span class="comment">//                &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//                    return -1;  位置顺序不变  o1&lt;o2</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//                return o1-o2;  //升序</span></span><br><span class="line">        <span class="keyword">return</span> o2-o1;  <span class="comment">//降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] nums=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">			<span class="comment">//升序</span></span><br><span class="line">            <span class="keyword">if</span>(o1[<span class="number">0</span>]!=o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];  <span class="comment">//先根据第一维的数据进行排序，这是升序，如果换一下顺序就是降序</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pq.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size=pq.size();</span><br><span class="line">    <span class="comment">//注意在实际打印时的序列并不是有序的，而应该是依次取堆顶元素，这样取到的就是有序的</span></span><br><span class="line">    <span class="comment">//如果想让队列是有序的，可以先转化为数组再进行排序</span></span><br><span class="line">    <span class="comment">//Integer[] arr=new Integer[size];</span></span><br><span class="line">    <span class="comment">//Arrays.sort(pq.toArray(arr));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="type">int</span>[] arr=pq.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+arr[<span class="number">0</span>]+<span class="string">&quot; :&quot;</span>+arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(nums);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-归并排序-offer-51"><a href="#4-归并排序-offer-51" class="headerlink" title="4.归并排序(offer 51)"></a>4.归并排序(offer 51)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">利用对并排序求解逆序对（剑指offer 51题）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序的代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr=&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">67</span>,<span class="number">58</span>,<span class="number">12</span>,<span class="number">58</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Test</span>().mergeSort(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=arr.length-<span class="number">1</span>;</span><br><span class="line">    dfs(arr,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归划分</span></span><br><span class="line">    <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">    dfs(arr,l,m);</span><br><span class="line">    dfs(arr,m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//合并阶段</span></span><br><span class="line">    <span class="comment">//我们首先使用tmp数组存储要排序这一段数组</span></span><br><span class="line">    <span class="type">int</span>[] tmp=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= r; k++) &#123;</span><br><span class="line">        tmp[k]=arr[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再将左右有序的子树组合并为整个合起来有序的数组</span></span><br><span class="line">    <span class="comment">//用i,j来记录遍历左右子数组</span></span><br><span class="line">    <span class="type">int</span> i=l,j=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==m+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//代表左子数组已合并完，因此添加右子数组当前元素 tmp[j] ，并执行 j = j + 1；</span></span><br><span class="line">            arr[k]=tmp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==r+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//代表右子数组已合并完，因此添加左子数组当前元素tmp[i] ，并执行i=i+1；</span></span><br><span class="line">            arr[k]=tmp[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i]&gt;tmp[j])&#123;</span><br><span class="line">            <span class="comment">//当tmp[i&gt;tmp[j] 时： 添加右子数组当前元素tmp[j]，并执行j=j+1；</span></span><br><span class="line">            arr[k]=tmp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当tmp[i]≤tmp[j] 时： 添加左子数组当前元素tmp[i]，并执行i=i+1；</span></span><br><span class="line">            arr[k]=tmp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-堆排序（leetcode-215-解法见方法2）"><a href="#5-堆排序（leetcode-215-解法见方法2）" class="headerlink" title="5.堆排序（leetcode 215  解法见方法2）"></a>5.堆排序（leetcode 215  解法见方法2）</h4><blockquote>
<p>先按照顺序将数组元素组合成一个完全二叉树</p>
</blockquote>
<p><img src="https://assets.leetcode-cn.com/solution-static/215/1.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="comment">//建堆完毕后，nums【0】为最大元素。逐个删除堆顶元素，直到删除了k-1个。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//先将堆的最后一个元素与堆顶元素交换，由于此时堆的性质被破坏，需对此时的根节点进行向下调整操作。</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">//相当于删除堆顶元素，此时长度变为nums.length-2。即下次循环的i</span></span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="comment">//从最后一个父节点位置开始调整每一个节点的子树。数组长度为heasize，因此最后一个节点的位置为heapsize-1，所以父节点的位置为（heapsize-1-1)/2。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heapSize-<span class="number">2</span>)/ <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;      <span class="comment">//调整当前结点和子节点的顺序。</span></span><br><span class="line">        <span class="comment">//left和right表示当前父节点i的两个左右子节点。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, right = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="comment">//如果左子点在数组内，且比当前父节点大，则将最大值的指针指向左子点。</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; a[left] &gt; a[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果右子点在数组内，且比当前父节点大，则将最大值的指针指向右子点。</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最大值的指针不是父节点，则交换父节点和当前最大值指针指向的子节点。</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            <span class="comment">//由于交换了父节点和子节点，因此可能对子节点的子树造成影响，所以对子节点的子树进行调整。</span></span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-栈和队列"><a href="#14-栈和队列" class="headerlink" title="14.栈和队列"></a>14.栈和队列</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">剑指offer59_2</span></span><br></pre></td></tr></table></figure>

<h2 id="难题附录："><a href="#难题附录：" class="headerlink" title="难题附录："></a>难题附录：</h2><h3 id="1-lettcode-869-（关于回溯和预处理，重新排序看能否得到2次幂的数）"><a href="#1-lettcode-869-（关于回溯和预处理，重新排序看能否得到2次幂的数）" class="headerlink" title="1.lettcode 869.（关于回溯和预处理，重新排序看能否得到2次幂的数）"></a>1.lettcode 869.（关于回溯和预处理，重新排序看能否得到2次幂的数）</h3><h3 id="2-剑指Offer-35（复杂链表的复制）"><a href="#2-剑指Offer-35（复杂链表的复制）" class="headerlink" title="2.剑指Offer 35（复杂链表的复制）"></a>2.剑指Offer 35（复杂链表的复制）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意本题要求的是复制，因此原有的链表值和结构不能有改变</span></span><br><span class="line"><span class="comment">//本题的难点在于如果按照传统链表的方式进行遍历时，无法知道random指针指向的是哪里，</span></span><br><span class="line"><span class="comment">// 主要是不确定这个节点是否已经创建，因此需要先遍历一遍建立起已经创建的节点哈希表，再给构建的节点进行赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1 使用回溯+哈希表</span></span><br><span class="line">Map&lt;Node,Node&gt; hs=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node,Node&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!hs.containsKey(head))&#123;</span><br><span class="line">        Node cp=<span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        hs.put(head,cp);</span><br><span class="line">        cp.next=copyRandomList(head.next);</span><br><span class="line">        cp.random=copyRandomList(head.random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hs.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2 使用哈希表，但是是顺序遍历方式，这样比回溯方法好理解一点</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// 4. 构建新链表的 next 和 random 指向</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 返回新链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法3：使用拼接+拆分的方法</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">        tmp.next = cur.next;</span><br><span class="line">        cur.next = tmp;</span><br><span class="line">        cur = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.random != <span class="literal">null</span>)</span><br><span class="line">            cur.next.random = cur.random.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">    cur = head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="literal">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">    <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）"><a href="#3-leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）" class="headerlink" title="3.leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）"></a>3.leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">dp[i]表示的意思就是以arr[i]为结尾的子序列的长度。因此有j&lt;i&amp;&amp;arr[i]-arr[j]=d时，dp[i]=dp[j]+<span class="number">1</span></span><br><span class="line">为了方便，我们可以直接使用dp[i]就表示是以i为结尾的子序列的长度，此时就有dp[i]=dp[i-d]+<span class="number">1.</span></span><br><span class="line">#动态规划解决</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubsequence</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> difference)</span> &#123;</span><br><span class="line">    <span class="comment">//暴力破解超时</span></span><br><span class="line">    <span class="comment">/*int max=0;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length&amp;&amp;((arr.length-i-1)&gt;=max); i++) &#123;</span></span><br><span class="line"><span class="comment">            int count=1;</span></span><br><span class="line"><span class="comment">            int pre=arr[i];</span></span><br><span class="line"><span class="comment">            for (int j = i+1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">                if((arr[j]-pre)==difference)&#123;</span></span><br><span class="line"><span class="comment">                    count++;</span></span><br><span class="line"><span class="comment">                    pre=arr[j];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(count&gt;max)&#123;</span></span><br><span class="line"><span class="comment">                max=count;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return max;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划解决,该题如果不使用map来进行处理，而还是用数组的话，还是需要用两层循环，因此依旧会超时</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//使用变量记录最大值，可以减去后面遍历map，求解最大值</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> val:arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val-difference))&#123;</span><br><span class="line">            map.put(val,map.get(val-difference)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(val,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=Math.max(ans,map.get(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#数组解决办法</span><br><span class="line"><span class="comment">//该题也可以使用数组来取代hash表来进行解决，使得可以一次性就将结果查询出来</span></span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">40009</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubsequence2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        hash[i + M] = hash[i - d + M] + <span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans, hash[i + M]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）"><a href="#4-leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）" class="headerlink" title="4.leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）"></a>4.leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">1</span>背包问题的，其中背包的容量是二维的情况</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  动态规划</span></span><br><span class="line"><span class="comment"> 	*  这里dp[j][k]表示数组子集中累加的0和1的个数满足最大j个0和k个1时的子集中的字符串的最大个数</span></span><br><span class="line"><span class="comment">   	*  dp[5][3]=4就是表示子集中最多5个0和3个1的字符串个数为4</span></span><br><span class="line"><span class="comment">    *  这里我们使用滚动的二维数组来进行解决问题。</span></span><br><span class="line"><span class="comment">    *  当遍历到第i个字符串时，第i个字符串中有a=count[i][0]个0，有b=count[i][1]个1.就会出现两种情况：</span></span><br><span class="line"><span class="comment">  	*                      只有在j&gt;=a并且k&gt;=b时，才有可能出现第i个字符串是子集中的结果</span></span><br><span class="line"><span class="comment">  	*                   所以在前提条件j&gt;=a并且k&gt;=b被满足的情况下，才有下面两种情况的讨论，否则就不变</span></span><br><span class="line"><span class="comment">  	*                      第一种：子集中包括第i个字符串，dp[j][k]=dp[j-a][k-b]+1</span></span><br><span class="line"><span class="comment">  	*                      第二种：子集中不包括第i个字符串，dp[j][k]就保持不变</span></span><br><span class="line"><span class="comment">  	*  因此得到递推表达式是 dp[j][k]=Math.max(dp[j][k],dp[j-a][k-b]+1)</span></span><br><span class="line"><span class="comment">  	*  最终得到的结果就是dp[m][n]的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//注意在进行遍历的时候需要从右到左的顺序，否则会导致覆盖后的数据又被后面的数据覆盖了，导致结果数变大</span></span><br><span class="line"><span class="comment">//遍历物品，这里也是使用滚动数组的解法，只是和0-1背包问题不同的是，这里的价值是二维的，物品也是二维的</span></span><br><span class="line">    <span class="comment">//可以对空间进行优化，对于统计字符串的数组，可以在需要知道0和1的时候，用变量求解出来</span></span><br><span class="line">        <span class="comment">//可以对时间也进行优化，在j&lt;a或者k&lt;b时，dp[j][k]肯定就是保持不变的情况，可以提前结束for循环</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> strs.length;</span><br><span class="line"><span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//每个字符串都是一个物品，而m,n是一个背包，只不过是一个二维的背包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">//a、b表示strs中第i个字符串中 0和1 的个数</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:strs[i].toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;=a ; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n; k &gt;=b ; k--) &#123;</span><br><span class="line">            dp[j][k]=Math.max(dp[j-a][k-b]+<span class="number">1</span>,dp[j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-leetcode322题（该题的重点在于初始化）"><a href="#5-leetcode322题（该题的重点在于初始化）" class="headerlink" title="5.leetcode322题（该题的重点在于初始化）"></a>5.leetcode322题（该题的重点在于初始化）</h3><h3 id="6-leetcode138题（动态规划，注意这里递推公式是怎样写的）"><a href="#6-leetcode138题（动态规划，注意这里递推公式是怎样写的）" class="headerlink" title="6.leetcode138题（动态规划，注意这里递推公式是怎样写的）"></a>6.leetcode138题（动态规划，注意这里递推公式是怎样写的）</h3><h3 id="7-leetcode213题动态规划题（打家劫舍题）"><a href="#7-leetcode213题动态规划题（打家劫舍题）" class="headerlink" title="7.leetcode213题动态规划题（打家劫舍题）"></a>7.leetcode213题动态规划题（打家劫舍题）</h3><h3 id="8-leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）"><a href="#8-leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）" class="headerlink" title="8.***leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）"></a>8.***leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）</h3><h3 id="9-剑指offer36题（二叉搜索树）"><a href="#9-剑指offer36题（二叉搜索树）" class="headerlink" title="9.***剑指offer36题（二叉搜索树）"></a>9.***剑指offer36题（二叉搜索树）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二叉搜索树的性质：中序遍历是递增顺序的。</span><br></pre></td></tr></table></figure>

<h3 id="10-剑指offer的15天的题（三题都需要）需要重看一下（搜索-回溯的题）还有剑指offer68—II这道题"><a href="#10-剑指offer的15天的题（三题都需要）需要重看一下（搜索-回溯的题）还有剑指offer68—II这道题" class="headerlink" title="10.剑指offer的15天的题（三题都需要）需要重看一下（搜索+回溯的题）还有剑指offer68—II这道题"></a>10.剑指offer的15天的题（三题都需要）需要重看一下（搜索+回溯的题）还有剑指offer68—II这道题</h3><h3 id="11-剑指-Offer-64-求1-2-…-n-要求不能使用if-else-switch-A-B-C等结构"><a href="#11-剑指-Offer-64-求1-2-…-n-要求不能使用if-else-switch-A-B-C等结构" class="headerlink" title="11.剑指 Offer 64. 求1+2+…+n.要求不能使用if,else,switch,A?B:C等结构"></a>11.剑指 Offer 64. 求1+2+…+n.要求不能使用if,else,switch,A?B:C等结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重点掌握两种解决方法</span></span><br><span class="line">-位元算+快速乘法+高斯公式</span><br><span class="line">-位运算+递归解法</span><br></pre></td></tr></table></figure>

<h3 id="12-剑指offer16（求解数的整数次方）"><a href="#12-剑指offer16（求解数的整数次方）" class="headerlink" title="12.剑指offer16（求解数的整数次方）"></a>12.剑指offer16（求解数的整数次方）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重点掌握方法</span></span><br><span class="line">	-记忆化递归</span><br><span class="line">	-快速幂(重点掌握) 结合数的二进制来进行解决 </span><br></pre></td></tr></table></figure>

<h3 id="13-剑指Offer62-（求解圆圈中最后剩余的数字，约瑟夫环）"><a href="#13-剑指Offer62-（求解圆圈中最后剩余的数字，约瑟夫环）" class="headerlink" title="13.***剑指Offer62 （求解圆圈中最后剩余的数字，约瑟夫环）"></a>13.***剑指Offer62 （求解圆圈中最后剩余的数字，约瑟夫环）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该题的核心主要在于反推，主要题解见 https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</span> </span><br></pre></td></tr></table></figure>



<h3 id="14-leetcode677题"><a href="#14-leetcode677题" class="headerlink" title="14.leetcode677题"></a>14.leetcode677题</h3><h3 id="15-剑指offer20题待看，使用有限状态机进行解决"><a href="#15-剑指offer20题待看，使用有限状态机进行解决" class="headerlink" title="15.剑指offer20题待看，使用有限状态机进行解决"></a>15.剑指offer20题待看，使用有限状态机进行解决</h3><h3 id="16-leetcode423-学习这种解决问题的方法"><a href="#16-leetcode423-学习这种解决问题的方法" class="headerlink" title="16.leetcode423 学习这种解决问题的方法"></a>16.leetcode423 学习这种解决问题的方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">首先解决只存在一个未知数的方程求出这些方程中的未知数，再根据这些得到未知数的值代入到原来有多个未知数的方程中去，然后再依次进行求解。</span></span><br></pre></td></tr></table></figure>

<h3 id="17-剑指offer-38-回溯"><a href="#17-剑指offer-38-回溯" class="headerlink" title="17.剑指offer 38 回溯"></a>17.剑指offer 38 回溯</h3><h3 id="18-剑指offer-49-求解丑数"><a href="#18-剑指offer-49-求解丑数" class="headerlink" title="18.剑指offer 49 (求解丑数)"></a>18.剑指offer 49 (求解丑数)</h3><h3 id="19-剑指offer-60-（求解骰子的点数）"><a href="#19-剑指offer-60-（求解骰子的点数）" class="headerlink" title="19.剑指offer 60 （求解骰子的点数）"></a>19.剑指offer 60 （求解骰子的点数）</h3><h3 id="20-剑指offer-19-正则表达式匹配-动态规划"><a href="#20-剑指offer-19-正则表达式匹配-动态规划" class="headerlink" title="20.剑指offer 19 (正则表达式匹配 动态规划)"></a>20.剑指offer 19 (正则表达式匹配 动态规划)</h3><h3 id="21-剑指offer17-学会要掌握处理大数越界的问题"><a href="#21-剑指offer17-学会要掌握处理大数越界的问题" class="headerlink" title="21.剑指offer17 学会要掌握处理大数越界的问题"></a>21.剑指offer17 学会要掌握处理大数越界的问题</h3><h3 id="22-剑指offer-51-归并排序与逆序对"><a href="#22-剑指offer-51-归并排序与逆序对" class="headerlink" title="22.剑指offer 51 (归并排序与逆序对)"></a>22.剑指offer 51 (归并排序与逆序对)</h3><h3 id="23-剑指offer44题-（数字模拟）"><a href="#23-剑指offer44题-（数字模拟）" class="headerlink" title="23.剑指offer44题 （数字模拟）"></a>23.剑指offer44题 （数字模拟）</h3><h3 id="24-leetcode372（利用快速幂求解一个数的超级次方）"><a href="#24-leetcode372（利用快速幂求解一个数的超级次方）" class="headerlink" title="24.leetcode372（利用快速幂求解一个数的超级次方）"></a>24.leetcode372（利用快速幂求解一个数的超级次方）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以利用倒叙和正序的方法进行解题，正序的话就是使用秦九韶公式进行解决</span></span><br></pre></td></tr></table></figure>

<h3 id="25-leetcode1143-该题是典型的两维动态规划"><a href="#25-leetcode1143-该题是典型的两维动态规划" class="headerlink" title="25.leetcode1143	(该题是典型的两维动态规划)"></a>25.leetcode1143	(该题是典型的两维动态规划)</h3><h3 id="26-leetcode825-利用数学式子来进行解决问题-计数排序和排序"><a href="#26-leetcode825-利用数学式子来进行解决问题-计数排序和排序" class="headerlink" title="26.leetcode825(利用数学式子来进行解决问题)[计数排序和排序]"></a>26.leetcode825(利用数学式子来进行解决问题)[计数排序和排序]</h3><h3 id="27-leetcode394-（利用辅助栈来进行解决）"><a href="#27-leetcode394-（利用辅助栈来进行解决）" class="headerlink" title="27.leetcode394 （利用辅助栈来进行解决）"></a>27.leetcode394 （利用辅助栈来进行解决）</h3><h3 id="28-leetcode390-学习这种分析问题的做法，利用数学的方法进行解决"><a href="#28-leetcode390-学习这种分析问题的做法，利用数学的方法进行解决" class="headerlink" title="28.leetcode390(学习这种分析问题的做法，利用数学的方法进行解决)"></a>28.leetcode390(学习这种分析问题的做法，利用数学的方法进行解决)</h3><h3 id="29-leetcode-686题（上下界，字符串哈希的方法）"><a href="#29-leetcode-686题（上下界，字符串哈希的方法）" class="headerlink" title="29.leetcode 686题（上下界，字符串哈希的方法）"></a>29.leetcode 686题（上下界，字符串哈希的方法）</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/" data-id="clrv16wje000jz5ku41rm4ds7" data-title="LeetCode刷题" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Java虚拟机学习
        
      </div>
    </a>
  
  
    <a href="/2022/10/27/Linux%E5%AD%A6%E4%B9%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Linux学习</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 13.33px;">Go</a> <a href="/tags/JVM/" style="font-size: 13.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 13.33px;">个人</a> <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 13.33px;">云原生</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 13.33px;">并发</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 13.33px;">快捷键</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13.33px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 16.67px;">数据库</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/27/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Mac使用技巧</a>
          </li>
        
          <li>
            <a href="/2024/01/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/12/27/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Java语言学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/">Java虚拟机学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/">LeetCode刷题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Kevin he<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>