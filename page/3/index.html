<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>侬的杂货铺</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="侬的杂货铺">
<meta property="og:url" content="https://kdhello07.github.io/page/3/index.html">
<meta property="og:site_name" content="侬的杂货铺">
<meta property="og:locale">
<meta property="article:author" content="Kevin he">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="侬的杂货铺" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">侬的杂货铺</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术、阅读、分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kdhello07.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-typora/Java虚拟机学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java虚拟机学习"><a href="#Java虚拟机学习" class="headerlink" title="Java虚拟机学习"></a>Java虚拟机学习</h1><h2 id="1-JVM与Java体系结构"><a href="#1-JVM与Java体系结构" class="headerlink" title="1.JVM与Java体系结构"></a>1.JVM与Java体系结构</h2><p>1.虚拟机的执行：执行一个所谓的Java程序的时候，真正再执行的是一个叫做Java虚拟机的进程</p>
<p>2.HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li>通过计数器找到最具编译价值代码，除法即时编译或栈上替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。</li>
</ul>
<p>3.JRocket</p>
<p>4.IBM J9。 后面这三种虚拟机现在用的比较多。在jdk中用的还是hotspot这个。</p>
<h2 id="2-类加载子系统"><a href="#2-类加载子系统" class="headerlink" title="2.类加载子系统"></a>2.类加载子系统</h2><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_JVM架构-中.jpg" alt="第02章_JVM架构-中"  />

<h3 id="1-类加载器子系统概述"><a href="#1-类加载器子系统概述" class="headerlink" title="1. 类加载器子系统概述"></a>1. 类加载器子系统概述</h3><p>1.类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。</p>
<p>2.classloader只负责class文件的加载，至于它是否可以运行，则由Excution Engine决定。</p>
<p>3.加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>
<h3 id="2-类的加载过程"><a href="#2-类的加载过程" class="headerlink" title="2.类的加载过程"></a>2.类的加载过程</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_类的加载过程.jpg" alt="第02章_类的加载过程" style="zoom: 25%;" />

<p>总过程：加载 –》链接【验证  –》准备  –》 解析 】 –》 初始化 </p>
<blockquote>
<p>加载：</p>
<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>&#x3D;&#x3D;在内存中生成一个代表这个类的 java.lang.Class 对象&#x3D;&#x3D;，作为方法区这个类的各种数据的访问入口</li>
</ol>
</blockquote>
<blockquote>
<p>链接：</p>
<ol>
<li>验证（verify）<ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会损害虚拟机自身安全。</li>
</ul>
</li>
<li>准备(prepare)<ul>
<li>为类变量（static 变量）分配内存并且设置该类变量的默认初始值，即零值</li>
<li>&#x3D;&#x3D;这里不包含用final修饰的static，因为final在编译的时候就分配了，准备阶段会显式初始化&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;这里不会为实例变量分配初始化&#x3D;&#x3D;，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li>
</ul>
</li>
<li>解析(Resolve)<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。直接引用就是直接只想目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等，对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>初始化：</p>
<ol>
<li>初始化阶段就是执行类构造器方法<clinit>( )的过程</li>
<li>此方法不需要定义，是javac编译器自动收集类中的&#x3D;&#x3D;所有类变量的赋值操作和静态代码块中的语句合并而来&#x3D;&#x3D;。（如果类中没有类变量和静态代码块，编译后就不会有<clinit>( )方法）</li>
<li>构造器方法中指令按语句在源文件中出现的顺序hi行</li>
<li><clinit>( )不同于类的构造器。（关联：构造器是虚拟机视角下的<init>( )）</li>
<li>若该类具有父类，JVM会保证子类的<clinit>（ ）执行前，父类的<clinit>( )已经执行完毕</li>
<li>虚拟机必须保证一个类的<clinit>( )方法在多线程下被同步加锁</li>
</ol>
</blockquote>
<h3 id="3-类加载器的分类"><a href="#3-类加载器的分类" class="headerlink" title="3.类加载器的分类"></a>3.类加载器的分类</h3><p>1.JVM支持两种类型的类加载器，分别为引导类加载器（bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</p>
<p>2.所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</p>
<p>3.常见的有3个类加载器</p>
<p>4.虚拟机自带的加载器</p>
<ul>
<li>启动类加载器（引导类加载器）<ul>
<li>这个类加载使用c&#x2F;c++语言实现的，嵌套在类内部</li>
<li>用来加载Java的核心库，用于提供jvm自身需要的类</li>
<li>并不继承自Java.lang.ClassLoader,没有父加载器</li>
<li>&#x3D;&#x3D;加载扩展类和应用程序类加载器，并指定为他们的父类加载器&#x3D;&#x3D;</li>
<li>处于安全考虑，Bootstrap 启动类加载器只加载包名为&#x3D;&#x3D;java、javax、sun等开头的类&#x3D;&#x3D;</li>
</ul>
</li>
<li>扩展类加载器（Extension ClassLoader）<ul>
<li>java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从jdk的安装目录的jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
</li>
<li>应用程序类加载器（系统类加载器，AppClassLoader）<ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>&#x3D;&#x3D;该类加载是程序中默认的类加载器&#x3D;&#x3D;，一般说来，Java应用的类都是由它来加载完成</li>
<li>通过ClassLoader . getSystemClassLoader（）方法可以获取到该类加载器</li>
</ul>
</li>
</ul>
<p>5.用户自定义类加载器</p>
<ul>
<li>在Java的日常应用程序开发种，类的加载几乎都是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>为什么要自定义类加载器<ol>
<li>隔离加载类</li>
<li>修该类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ol>
</li>
</ul>
<h3 id="4-关于ClassLoader"><a href="#4-关于ClassLoader" class="headerlink" title="4.关于ClassLoader"></a>4.关于ClassLoader</h3><ul>
<li><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
</li>
<li><p>类中的方法有：</p>
<ul>
<li>getParent(): 返回该类加载器的超类加载器</li>
<li>loadClass(String name) : 加载名称为name的类，返回结果为java.lang.Class类的实例</li>
<li>findClass(String name):</li>
<li>findLoadedClass(String name)</li>
<li>defineClass(String name,byte[] b,int off,int len) : 把字节数组b中的内容转化为一个Java类，返回结果为java.lang.Class类的实例</li>
<li>resolveClass(Class&lt;?&gt; c): 连接指定的一个Java类</li>
</ul>
</li>
<li><p>获取ClassLoader的路径：</p>
<ul>
<li><p>获取当前类的ClassLoader</p>
<ul>
<li><p>clazz.getClassLoader() </p>
</li>
<li><pre><code class="java">ClassLoader stringLoader = String.class.getClassLoader();
//对于用户自定义类来说: 默认使用系统类加载器来进行加载
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取当前线程上下文的ClassLoader</span><br><span class="line"></span><br><span class="line">  - Thread.currentThread().getContextClassLoader()</span><br><span class="line"></span><br><span class="line">- 获取系统的ClassLoader</span><br><span class="line"></span><br><span class="line">  - ClassLoader.getClassLoader()</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    //获取系统类加载器   sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>获取调用者的ClassLoader</p>
<ul>
<li>DriverManager.getCallerClassLoader()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-双亲委派机制"><a href="#5-双亲委派机制" class="headerlink" title="5.双亲委派机制"></a>5.双亲委派机制</h3><blockquote>
<p>Java虚拟机对class文件采用的是&#x3D;&#x3D;按需加载的方式&#x3D;&#x3D;，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是&#x3D;&#x3D;双亲委派模式&#x3D;&#x3D;，即把请求交由父类加载器处理，它是一种任务委派模式。</p>
<p>工作原理：</p>
<ul>
<li><p>如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</p>
</li>
<li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</p>
</li>
<li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，自家在其才会尝试自己去加载，这就是双亲委派机制。</p>
<p>引导类（BootStrap ClassLoader）</p>
<p>​	^</p>
<p>扩展类（Extension ClassLoader）</p>
<p>​	^</p>
<p>系统类（Application ClassLoader）</p>
<p>​	^</p>
<p>自定义类加载器</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改。 因为核心API是由上层类加载器进行加载的。如java.lang.String是由启动类加载器进行加载的。</li>
</ul>
<p>沙箱安全机制：</p>
<ul>
<li>就是为了保护Java核心代码的机制。如防止自己定义使用java.lang.String这种形式的包名和类名</li>
</ul>
</blockquote>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h3><blockquote>
<p>在JVM中表示两个Class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同</li>
</ul>
</blockquote>
<blockquote>
<p>对类加载器的引用：</p>
<ul>
<li>JVM需知道一个类型是由启动类加载加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>类的主动使用和被动使用</strong></p>
<ul>
<li>主动使用（七种情况）：<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如Class.forName(“com.example.Test”)）</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>jdk7开始提供的动态语言支持：<ul>
<li>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化。</li>
</ul>
</li>
</ul>
</li>
<li>除了以上七种情况，其他使用Java类的方式都被看做是对&#x3D;&#x3D;类的被动使用，都不会导致对类的初始化。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h2 id="3-运行时数据区概述及线程"><a href="#3-运行时数据区概述及线程" class="headerlink" title="3.运行时数据区概述及线程"></a>3.运行时数据区概述及线程</h2><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_JVM架构-简图.jpg" alt="第02章_JVM架构-简图" style="zoom:50%;" />

<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><blockquote>
<p>JVM内存布局规定了Java在运行过程 中内存申请、分配、管理的策略，保证了jvm的高效稳定运行，&#x3D;&#x3D;不同的JVM对于内存的划分方式和管理机制存在了部分差异&#x3D;&#x3D;。</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220428110326650.png" alt="image-20220428110326650"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面红色部分：</span></span><br><span class="line">	方法区（metadata元空间，代码缓存（JIT即时编译的产物），堆外内存），堆这两个区域是多个线程共享的，随着虚拟机这个进程的创建而创建，销毁而销毁。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面灰色部分：</span></span><br><span class="line">	程序计数器，本地方法栈，虚拟机栈是单独线程私有的，与单个线程的生命周期是一样的。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>class Runtime</strong>:</p>
<ul>
<li><p>每个JVM只有一个Runtime实例，即为运行时环境，相当于内存结构中间的那个框架：运行时环境</p>
</li>
<li><p>static  Runtime getRuntime()  返回与当前Java应用程序关联的运行时对象。</p>
</li>
</ul>
</blockquote>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h3><blockquote>
<ul>
<li><p>线程是一个程序里的运行单元。JVM允许一个应用程序同时执行多个执行线程。</p>
</li>
<li><p>在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行中止以后，本地线程也会回收。</li>
</ul>
</li>
<li><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上，一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>JVM系统线程：</p>
<ul>
<li>这些后台线程不包括调用 public static void main(String[] agrs)的main线程以及所有这个main线程自己创建的线程。</li>
<li>这些主要的后台系统线程在HotSpot JVM里主要是这几个：<ul>
<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现 。这种线程的执行类型包括“stop-the-wrold”的垃圾收集，线程栈手机，线程挂起以及偏向锁撤销。</li>
<li>周期任务线程：这种线程是时间周期时间的体现（比如中断），他们一般用于周期性操作的调度执行</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li>
<li>编译线程：这种线程在运行时会将字节码编译成本地代码</li>
<li>信号调度线程：这种线程接收信号并发送给JVM,往它内部通过调用适当的方法进行处理</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="4-程序计数器（PC寄存器）"><a href="#4-程序计数器（PC寄存器）" class="headerlink" title="4.程序计数器（PC寄存器）"></a>4.程序计数器（PC寄存器）</h2><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220428114945803.png" alt="image-20220428114945803"></p>
<h3 id="1-PC-Register介绍"><a href="#1-PC-Register介绍" class="headerlink" title="1.PC Register介绍"></a>1.PC Register介绍</h3><blockquote>
<p>JVM中的程序计数寄存器，并非是广义上的物理寄存器，或许将其翻译为pc计数器（或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。&#x3D;&#x3D;JVM中的pc寄存器是对物理PC寄存器的一种抽象模拟&#x3D;&#x3D;</p>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_执行引擎的工作过程.jpg" alt="第12章_执行引擎的工作过程" style="zoom:33%;" />

<blockquote>
<p><strong>作用：</strong></p>
<ul>
<li>pc寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令</li>
</ul>
</blockquote>
<blockquote>
<p><strong>介绍：</strong></p>
<ul>
<li>很小的一块内存空间，也是运行速度最快的存储区域</li>
<li>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的&#x3D;&#x3D;当前方法&#x3D;&#x3D;，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，或者，如果是在执行native方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryEroor情况的区域。<ul>
<li>&#x3D;&#x3D;堆 和方法区有垃圾回收，PC寄存器也没有垃圾回收，栈区域有垃圾回收，&#x3D;&#x3D;</li>
<li>pc寄存器没有OutOfMemoryEroor（内存溢出），stack区域有，以及方法区和堆都有OutOfMemoryEroor。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-举例说明"><a href="#2-举例说明" class="headerlink" title="2.举例说明"></a>2.举例说明</h3><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220428130658431.png" alt="image-20220428130658431"></p>
<h3 id="3-两个常见问题"><a href="#3-两个常见问题" class="headerlink" title="3.两个常见问题"></a>3.两个常见问题</h3><blockquote>
<p><strong>Q1：使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢?</strong></p>
<p>A1：因为CPU需要不断的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</blockquote>
<blockquote>
<p><strong>Q2：PC寄存器为什么会被设定为线程私有？</strong></p>
<p>A2：都知道所谓的多线程在一个特定的时间段内只会执行其中一个线程的方法，&#x3D;&#x3D;CPU会不停地做任务切换，这样必然导致经常中断和恢复&#x3D;&#x3D;，如何保证分毫不差呢？为了能够准确的记录各个线程正在执行的当前字节码指令地址，&#x3D;&#x3D;最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。&#x3D;&#x3D; （每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响）</p>
</blockquote>
<blockquote>
<ul>
<li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li>
<li>在宏观上，我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li>
<li>但在微观上 ，由于只有一个CPU,一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</li>
</ul>
</blockquote>
<h2 id="5-虚拟机栈"><a href="#5-虚拟机栈" class="headerlink" title="&#x3D;&#x3D;5.虚拟机栈&#x3D;&#x3D;"></a>&#x3D;&#x3D;5.虚拟机栈&#x3D;&#x3D;</h2><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220429090223158.png" alt="image-20220429090223158"></p>
<h3 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1.虚拟机栈概述"></a>1.虚拟机栈概述</h3><blockquote>
<ul>
<li><p>由于跨平台性的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器的。</p>
</li>
<li><p>优点：</p>
<ul>
<li>跨平台，指令集小，编译器容易实现。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>性能下降，实现同样的功能需要更多的指令。</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;栈是运行时的单位，而堆是存储的单位。&#x3D;&#x3D;</p>
<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储问题，即数据怎么放，放在哪儿</li>
</ul>
</li>
<li><p>Java虚拟机栈，早期也叫Java栈，每个线程在创建时都会创建一个虚拟机栈，&#x3D;&#x3D;其内部保存一个个的栈帧，对应着一次次的Java方法调用&#x3D;&#x3D;。</p>
</li>
<li><p>Java虚拟机栈是线程私有的。</p>
</li>
<li><p>生命周期和线程一致</p>
</li>
<li><p><strong>作用：</strong></p>
<ul>
<li>主管Java程序的运行，它保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。</li>
<li>局部变量 VS 成员变量（属性）</li>
<li>基本数据变量 VS 引用类型变量（类、数组、接口）</li>
</ul>
</li>
<li><p><strong>栈的特点：</strong></p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li>
<li>JVM直接对Java栈的操作只有两个：<ul>
<li>每个方法执行，伴随着进栈（入栈，压栈）</li>
<li>执行结果后的出栈工作</li>
</ul>
</li>
<li>对于栈来说，不存在垃圾回收问题，但是有OOM (内存溢出)</li>
</ul>
</li>
<li><p>开发中遇到的异常有哪些？</p>
<ul>
<li>StackOverFlowError  (Java栈设置的大小固定，陷入死循环)</li>
<li>OutOfMemoryError （内存溢出，超出内存大小）</li>
</ul>
</li>
<li><p>可以设置栈内存大小，使用 -Xss1024k  或者-Xss256k来设置大小</p>
</li>
</ul>
</blockquote>
<h3 id="2-栈的存储单位"><a href="#2-栈的存储单位" class="headerlink" title="2.栈的存储单位"></a>2.栈的存储单位</h3><blockquote>
<ul>
<li>栈中的数据都是以栈帧的格式存在</li>
<li>&#x3D;&#x3D;在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）&#x3D;&#x3D;</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>栈运行原理：</strong></p>
<ul>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>&#x3D;&#x3D;Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令，另外一种是抛出异常，不管使用那种方式，都会导致栈帧被弹出。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第05章_栈桢内部结构.jpg" alt="第05章_栈桢内部结构" style="zoom: 33%;" />

<blockquote>
<p><strong>栈帧的内部结构：</strong></p>
<ul>
<li>&#x3D;&#x3D;局部变量表（Local variable）&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;操作数栈（Operand Stack）(或表达式栈)&#x3D;&#x3D;</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
</blockquote>
<h3 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3.局部变量表"></a>3.局部变量表</h3><blockquote>
<ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li>&#x3D;&#x3D;定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量&#x3D;&#x3D;，这些数据类型包括各类基本数据类型，对象引用（reference），以及returnAddress类型。</li>
<li>因为局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li>
<li>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li>&#x3D;&#x3D;方法嵌套调用的次数由栈的大小决定。&#x3D;&#x3D;一般说来，栈越大，方法嵌套调用次数越多，对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，进而函数调用就会占用更多的占空间，导致其嵌套调用次数就会减少。</li>
<li>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量完成参数值到参数列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></li>
</ul>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220429113920978.png" alt="image-20220429113920978"></p>
<blockquote>
<p><strong>关于Slot的理解：</strong></p>
<ul>
<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</li>
<li>局部变量表最基本的存储单元是Slot(变量槽)</li>
<li>在局部变量表里，32位以内的类型只占用一个Slot(包括returnAddress类型)，64位的类型（long 和double）占用两个Slot<ul>
<li>byte,short,char在存储前被转换位int，boolean也被转换位int,0表示false,1表示true</li>
<li>long和double则表示两个slot</li>
</ul>
</li>
<li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按&#x3D;&#x3D;照顺序被复制局部变量表中的每一个slot上&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可&#x3D;&#x3D;</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列</li>
</ul>
</blockquote>
<blockquote>
<p>slot的重复利用：</p>
<ul>
<li>栈帧之中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量的就很有可能会服用过期局部变量的槽位，从而达到节省资源的目的。</li>
</ul>
</blockquote>
<blockquote>
<p>静态变量与局部变量的对比：</p>
</blockquote>
<p>变量的分类： </p>
<ul>
<li>按照数据类型分为：<ol>
<li>基本数据类型 </li>
<li>引用数据类型</li>
</ol>
</li>
<li>按照在类中声明的位置分为: <ol>
<li>成员变量。在使用前都经历过默认初始化赋值</li>
<li>类变量：linking的prepare阶段：给类变量赋默认值 —》initial阶段：给类变量显式赋值（包括静态代码块）【所有类对象共享同一个区域】</li>
<li>实例变量（非static域）：随着对象的创建的，会在堆空间中分配实例变量空间，并进行默认赋值【每一个对象都有自己的一份】</li>
<li>局部变量。在使用前必须要显式赋值的，否则编译不通过。</li>
</ol>
</li>
</ul>
<blockquote>
<p>补充说明：</p>
<ul>
<li>在栈桢中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li>&#x3D;&#x3D;局部变量表中的变量也是重要的垃圾回收<strong>根节点</strong>，只要被局部变量表中直接或间接引用的对象都不会被回收。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4.操作数栈"></a>4.操作数栈</h3><blockquote>
<ul>
<li>每一个独立的栈帧中除了包含局部变量以外，还包含一个<strong>后进先出的操作数栈</strong>，也可以称之为表达式栈。</li>
<li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈或出栈，即入栈或出栈。</li>
<li>操作数栈，主要用于保存计算过程的中间结果 ，同时&#x3D;&#x3D;作为计算过程中变量临时的存储空间&#x3D;&#x3D;。</li>
<li>操作数栈就是jvm执行引擎的一个工作区，&#x3D;&#x3D;当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。&#x3D;&#x3D;</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度再编译器就定义好了，保存在方法的Code属性中，为max_stack的值。</li>
<li>栈中的任何一个元素都是可以任意的Java数据类型<ul>
<li>32bit的类型占用一个栈单位深度。</li>
<li>64bit的类型占用两个栈单位深度。</li>
</ul>
</li>
<li>&#x3D;&#x3D;操作数栈并非采用访问索引的方式来进行数据访问的&#x3D;&#x3D;，而是只能通过标准的入栈和出栈操作来完成一次数据访问。</li>
<li>&#x3D;&#x3D;如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中&#x3D;&#x3D;，并更新PC寄存器中下一条需要执行的字节码指令。</li>
<li>&#x3D;&#x3D;Java虚拟机的解释引擎是基于栈的执行引擎&#x3D;&#x3D;，其中的栈指的就是操作数栈。</li>
</ul>
</blockquote>
<h3 id="5-代码追踪"><a href="#5-代码追踪" class="headerlink" title="5.代码追踪"></a>5.代码追踪</h3><h3 id="6-栈顶缓存技术（Top-of-Stack-caching）"><a href="#6-栈顶缓存技术（Top-of-Stack-caching）" class="headerlink" title="6.栈顶缓存技术（Top-of-Stack-caching）"></a>6.栈顶缓存技术（Top-of-Stack-caching）</h3><blockquote>
<ul>
<li>基于栈式结构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派次数和内存读写次数。</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读写操作必然会影响速度，为了解决这个问题，HotSpot JVM的设计值们提出了&#x3D;&#x3D;栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="7-动态链接（或指向运行时常量池的方法引用）"><a href="#7-动态链接（或指向运行时常量池的方法引用）" class="headerlink" title="7.动态链接（或指向运行时常量池的方法引用）"></a>7.动态链接（或指向运行时常量池的方法引用）</h3><blockquote>
<ul>
<li>每一个栈帧内部都包含一个指向&#x3D;&#x3D;运行时常量池中该栈帧所属方法的引用&#x3D;&#x3D;，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在&#x3D;&#x3D;class文件的常量池里&#x3D;&#x3D;。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么&#x3D;&#x3D;动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Q: 为什么需要常量池呢？</li>
<li>A:常量池的作用就是为了提供一些符号和常量，便于指令的识别</li>
</ul>
</blockquote>
<h3 id="8-方法的调用：解析与分派（重点）"><a href="#8-方法的调用：解析与分派（重点）" class="headerlink" title="8.方法的调用：解析与分派（重点）"></a>8.方法的调用：解析与分派（重点）</h3><blockquote>
<ul>
<li>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。</li>
<li>&#x3D;&#x3D;静态链接：&#x3D;&#x3D;，当一个字节码文件被装载进 JVM内部时，如果&#x3D;&#x3D;被调用的目标方法在编译期可知，且运行期保持不变时&#x3D;&#x3D;，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li>
<li>&#x3D;&#x3D;动态链接：&#x3D;&#x3D;如果&#x3D;&#x3D;被调用的方法在编译器无法被确认下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用&#x3D;&#x3D;，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0 new #3 &lt;com/example/java/DynamicTest&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 invokespecial #4 &lt;com/example/java/DynamicTest.&lt;init&gt; : ()V&gt;    静态链接</span><br><span class="line"> 7 astore_1</span><br><span class="line"> 8 new #5 &lt;com/example/java/Animal&gt;</span><br><span class="line">11 dup</span><br><span class="line">12 invokespecial #6 &lt;com/example/java/Animal.&lt;init&gt; : ()V&gt;			静态链接</span><br><span class="line">15 astore_2</span><br><span class="line">16 aload_1</span><br><span class="line">17 aload_2</span><br><span class="line">18 invokevirtual #7 &lt;com/example/java/DynamicTest.print : (Lcom/example/java/Animal;)V&gt; 动态链接</span><br><span class="line">21 new #8 &lt;com/example/java/Cat&gt;</span><br><span class="line">24 dup</span><br><span class="line">25 invokespecial #9 &lt;com/example/java/Cat.&lt;init&gt; : ()V&gt;			静态链接</span><br><span class="line">28 astore_3</span><br><span class="line">29 aload_1</span><br><span class="line">30 aload_3</span><br><span class="line">31 invokevirtual #7 &lt;com/example/java/DynamicTest.print : (Lcom/example/java/Animal;)V&gt; 动态链接</span><br><span class="line">34 return</span><br></pre></td></tr></table></figure>



<blockquote>
<ul>
<li>对应的方法的绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</li>
<li>&#x3D;&#x3D;早期绑定：&#x3D;&#x3D;早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>&#x3D;&#x3D;晚期绑定：&#x3D;&#x3D;如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</li>
<li>Java中任何一个普通方法其实都具备虚函数的特征，如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>非虚方法：<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</li>
<li>其他方法都成为虚方法。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li>普通方法调用指令：<ul>
<li>&#x3D;&#x3D;invokestatic：调用静态方法，解析阶段确定唯一方法版本&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;invokespecial: 调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本&#x3D;&#x3D;</li>
<li>invokevirtual: 调用所有虚方法</li>
<li>invokeinterface:调用接口方法</li>
</ul>
</li>
<li>动态调用指令：<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
<li>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本，&#x3D;&#x3D;其中invokestatic 指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在Java7中增加了invokedynamic指令，这是Java为了实现动态类型语言支持而做的一种改进。</li>
<li>&#x3D;&#x3D;直到Java8的Lambda表达式的出现，invokedynamic指令的生成&#x3D;&#x3D;，在Java中才有了直接的生成方式。</li>
</ul>
<p>动态类型语言和静态类型语言：</p>
<ul>
<li>动态类型语言和静态类型于洋两者的区别就在于对类型的检查是在编译器还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。</li>
<li>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征，如JS,python这些的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此为了提高性能，JVM采用在类的方法区建立一个虚方法表（非虚方法不会出现在表中）来实现，使用索引表来代替查找。</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>Q: 那么虚方法表什么时候被创建呢？</li>
<li>A: 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕</li>
</ul>
</blockquote>
<h3 id="9-方法返回地址"><a href="#9-方法返回地址" class="headerlink" title="9.方法返回地址"></a>9.方法返回地址</h3><blockquote>
<ul>
<li>存放调用该方法的PC寄存器的值</li>
<li>一个方法的结束，有两种方式：<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置，&#x3D;&#x3D;方法正常退出时，调用者的PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址&#x3D;&#x3D;，而通过异常退出的，返回地址是要用过异常表来确定的，栈帧中一般不会保存这部分信息。</li>
<li>本质上，方法的退出就是房钱战阵出栈的过程，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入栈帧的操作数栈、设置PC寄存器等，让调用者方法继续执行下去</li>
<li>&#x3D;&#x3D;正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="10-一些附加信息"><a href="#10-一些附加信息" class="headerlink" title="10.一些附加信息"></a>10.一些附加信息</h3><blockquote>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息</p>
</blockquote>
<h3 id="11-栈的相关面试题"><a href="#11-栈的相关面试题" class="headerlink" title="11.栈的相关面试题"></a>11.栈的相关面试题</h3><blockquote>
<ul>
<li>举例栈溢出的情况？（StackOverFlow）<ul>
<li>通过-Xss设置栈的大小  OOM (内存溢出 OutOfMemory)</li>
</ul>
</li>
<li>调整栈大小，就能保证不出现溢出吗？<ul>
<li>不能保证，可能有内存溢出</li>
</ul>
</li>
<li>分配的虚拟机栈内存越大越好吗？<ul>
<li>因为计算机内存的大小是固定的，但是这样会导致总的线程数会变少。</li>
</ul>
</li>
<li>垃圾回收是否会涉及到虚拟机栈？<ul>
<li>不会，虚拟机栈不会涉及到垃圾回收，但是涉及到OOM.</li>
<li>本地方法栈与虚拟机栈一样</li>
<li>程序计数器垃圾回收，OOM都不存在</li>
<li>而方法区和堆两者都存在</li>
</ul>
</li>
<li>方法中定义的局部变量是否线程安全？<ul>
<li>具体问题具体分析</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="6-本地方法接口"><a href="#6-本地方法接口" class="headerlink" title="6.本地方法接口"></a>6.本地方法接口</h2><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220502161312269.png" alt="image-20220502161312269"  />

<blockquote>
<p>什么是本地方法？</p>
<ul>
<li>简单地讲，&#x3D;&#x3D;一个Native Method就是一个Java调用非Java代码的接口&#x3D;&#x3D;，一个Native Method是这样一个Java方法：该方法由非Java语言实现，比如C,这个特征并非Java所特有，很多其他的编程语言都有这一限制，比如在c++中，你可以用extern “C”告知C++编译器去调用一个C的函数。</li>
<li>在定义一个native method时，&#x3D;&#x3D;并不提供实现体&#x3D;&#x3D;（有些像定义一个Java interface）,因为其实现体是由非Java语言在外面实现的。</li>
<li>本地接口的作用是融合不同的编程语言为Java所用，他的初衷是融合c&#x2F;c++程序</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>native和abstract不能共用,</li>
</ul>
</blockquote>
<blockquote>
<p>为什么要使用Native Method?</p>
<ul>
<li>与Java环境外交互。<ul>
<li>有时Java应用需要与Java外面的环境进行交互，这是本地方法存在的主要原因。可以想象Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制，它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
</ul>
</li>
<li>与操作系统进行交互。<ul>
<li>jvm毕竟不是一个完整的系统，他经常依赖与一些底层系统的支持，这些底层系统通常是非常强大的操作系统，通过使用本地方法，我们得以用Java实现了jre与底层系统的交互，甚至jvm的一些部分就是用c写的。还有如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
</ul>
</li>
<li>sun’s Java<ul>
<li>sun的解释器是用c实现的，这使得它能像一些普通的c一样与外部交互，jre大部分使用Java实现的，他也通过一些本地方法与外界交互。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>现状：目前该方法使用的越来越少了，除非是与硬件有关的应用。</p>
</blockquote>
<h2 id="7-本地方法栈"><a href="#7-本地方法栈" class="headerlink" title="7.本地方法栈"></a>7.本地方法栈</h2><blockquote>
<ul>
<li><p>&#x3D;&#x3D;Java虚拟机用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。&#x3D;&#x3D;</p>
</li>
<li><p>本地方法栈也是线程私有的</p>
</li>
<li><p>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面与虚拟机栈是相同的）</p>
<ul>
<li>如果县城请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常</li>
</ul>
</li>
<li><p>本地方法是使用c语言实现的</p>
</li>
<li><p>&#x3D;&#x3D;它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库&#x3D;&#x3D;。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>&#x3D;&#x3D;当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限&#x3D;&#x3D;<ul>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li>
<li>它甚至可以直接使用本地处理其中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果jvm产品不打算支持本地native方法，也可以无需实现本地方法栈。</li>
<li>在HotSpot JVM中们直接将本地方法栈和虚拟机栈合二为一。</li>
</ul>
</blockquote>
<h2 id="8-堆"><a href="#8-堆" class="headerlink" title="&#x3D;&#x3D;8.堆&#x3D;&#x3D;"></a>&#x3D;&#x3D;8.堆&#x3D;&#x3D;</h2><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_JVM架构-简图.jpg" alt="第02章_JVM架构-简图" style="zoom: 50%;" />

<h3 id="1-堆的核心概述"><a href="#1-堆的核心概述" class="headerlink" title="1.堆的核心概述"></a>1.堆的核心概述</h3><blockquote>
<ul>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就被确定了。是JVM管理的最大一块内存空间。<ul>
<li>堆内存的大小的是可以调节的</li>
</ul>
</li>
<li>堆可以处于&#x3D;&#x3D;物理上不连续&#x3D;&#x3D;的内存空间中，但在&#x3D;&#x3D;逻辑上它应该被视为连续&#x3D;&#x3D;的。</li>
<li>所有线程共享Java堆，在这里还可以划分线程私有的缓冲区（TLAB）</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>所有的对象实例以及数组都应当在运行时分配到堆上。</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li>
<li>堆，是GC执行垃圾回收的重点区域  【频繁的进行GC操作，会影响用户线程的性能】</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_堆和方法区图.jpg" alt="第08章_堆和方法区图" style="zoom: 33%;" />

<blockquote>
<p>&#x3D;&#x3D;堆中内存细分：&#x3D;&#x3D;</p>
<ul>
<li>现代垃圾收集器大部分都是都基于分代收集理论设计，堆空间细分为：<ul>
<li>Java 7之前堆内存逻辑上分为三部分：新生区Young Generation space+养老区Tenure generation space+&#x3D;&#x3D;永久区(permanent space)&#x3D;&#x3D;<ul>
<li>新生区又分为Eden区和Survivor区,其中Survivor区又分为Survivor0区和Survivor1区（有时也叫做from区，to区，这两个区一般只能有一个区有用，另外一个区空闲）</li>
</ul>
</li>
<li>Java 8之前堆内存逻辑上分为三部分：新生区+养老区+&#x3D;&#x3D;元空间&#x3D;&#x3D;（meta space）<ul>
<li>新生区又分为Eden区和Survivor区</li>
</ul>
</li>
<li>约定：新生区 &#x3D;&#x3D; 新生代 &#x3D;&#x3D; 年轻代  ||  养老区 &#x3D;&#x3D; 老年区 &#x3D;&#x3D; 老年代  ||  永久区 &#x3D;&#x3D; 永久代</li>
<li>永久区或者元空间只是逻辑上在堆空间中，但是它不属于堆内存中的设置的HeapSize</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-设置堆内存大小与OOM"><a href="#2-设置堆内存大小与OOM" class="headerlink" title="2.设置堆内存大小与OOM"></a>2.设置堆内存大小与OOM</h3><blockquote>
<ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过-Xmx 和 -Xms来进行设置<ul>
<li>-Xms用于表示堆区的起始内存，等价于 -XX:InitialHeapSize  （这里面设置的空间只包含了新生区+养老区）</li>
<li>-Xmx则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
</ul>
</li>
<li>一旦堆区中的内存大小超过-Xmx所指定的最大内存的时候，将会抛出OutOfMemoryError异常</li>
</ul>
</blockquote>
<h3 id="3-年轻代（YoungGen）与老年代-OldGen"><a href="#3-年轻代（YoungGen）与老年代-OldGen" class="headerlink" title="3.年轻代（YoungGen）与老年代(OldGen)"></a>3.年轻代（YoungGen）与老年代(OldGen)</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_堆空间细节.jpg" alt="第08章_堆空间细节" style="zoom: 50%;" />

<blockquote>
<ul>
<li>存储在JVM中的Java对象可以被分为两类：<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
</li>
<li>配置新生代与老年代的比例：（开发过程中一般不会修改）<ul>
<li>&#x3D;&#x3D;默认&#x3D;&#x3D; -XX:NewRatio&#x3D;2,表示新生代占1，老年代占2</li>
<li>可以修改-XX:NewRatio&#x3D;4,表示新生代占1，老年代占4</li>
</ul>
</li>
<li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1</li>
<li>开发人员可以通过选项 -XX:SurvivorRatio调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8，&#x3D;&#x3D;默认值是8&#x3D;&#x3D;</li>
<li>-XX:-UseAdaptiveSizePolicy   关闭自适应的内存分配策略</li>
<li>&#x3D;&#x3D;几乎所有的&#x3D;&#x3D;Java对象都是在Eden区被new出来的。</li>
<li>绝大部分的Java对象的销毁都在新生代进行了</li>
<li>可以使用-Xmn设置新生代最大内存大小。<ul>
<li>这个参数一般使用默认值就可以</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4-图解对象分配过程"><a href="#4-图解对象分配过程" class="headerlink" title="4.图解对象分配过程"></a>4.图解对象分配过程</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_新生代对象分配与回收过程.jpg" alt="第08章_新生代对象分配与回收过程" style="zoom: 33%;" />

<blockquote>
<ol>
<li>new的对象先放Eden区（伊甸园区），此区有大小限制</li>
<li>当伊甸园的空间填满的时候，程序有需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收YGC（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象到放到Eden区</li>
<li>然后将Eden区中的剩余对象移动到幸存者0区（s0）</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，如果没有回收，接着再去幸存者1区。</li>
<li>啥时候能去养老区（Tenured&#x2F;Old）?可以设置次数。默认是15次。<ul>
<li>可以设置参数：-XX:MaxTenuringThreshold&#x3D;<N> 进行设置</li>
</ul>
</li>
<li>在养老区，相对悠闲，当养老区内存不足时，再次触发GC:Major GC,进行养老区的内存清理。</li>
<li>若养老区执行了FGC(Major GC)之后发现依然无法进行对象的保存，就会产生OOM异常<ul>
<li>java.lang.OutOfMemoryError：Java heap space</li>
</ul>
</li>
<li>总结：<ul>
<li>针对幸存者0区，幸存者1区的总结：复制之后有交换，谁空谁是to</li>
<li>s0或s1区满了并不会主动触发Minor GC。只有在Eden区满了的情况下才会去触发Eden区和s区的Minor GC</li>
<li>关于垃圾回收，频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>常用调优工具：</p>
<ul>
<li>JDK命令行</li>
<li>Jconsole</li>
<li>VisualVM</li>
<li>Jprofile</li>
<li>Java Flight Recoder</li>
<li>GCViewer</li>
<li>GC Easy</li>
</ul>
</blockquote>
<h3 id="5-Minor-GC、Major-GC、Full-GC"><a href="#5-Minor-GC、Major-GC、Full-GC" class="headerlink" title="5.Minor GC、Major GC、Full GC"></a>5.Minor GC、Major GC、Full GC</h3><blockquote>
<ul>
<li>JVM在进行GC时，并非每次都对上面三个内存区域（新生代、老年代；方法区（jdk 7里面是永久代，8里面是元空间））一起回收的，大部分时候回收的都是指新生代。</li>
<li>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC）,一种是整堆收集（Full GC）</li>
<li>部分收集：不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）:只是新生代的垃圾收集</li>
<li>老年代收集（Major GC&#x2F;Old GC）:只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li>&#x3D;&#x3D;注意,很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收&#x3D;&#x3D;</li>
</ul>
</li>
<li>混合收集（Mixed GC）:收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（Full GC）:收集整个java 堆和方法区的垃圾收集</li>
</ul>
</blockquote>
<blockquote>
<p>年轻代GC(Minor GC)触发机制：</p>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代指的是Eden代满，Survivor满不会触发GC.(每次Minor GC会清理年轻代的内存)</li>
<li>因为Java对象&#x3D;&#x3D;大多都具备朝生夕灭&#x3D;&#x3D;的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li>
<li>Minor GC会引发STW (Stop the world),暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
</blockquote>
<blockquote>
<p>老年代GC(Major GC&#x2F;Full GC)触发机制：</p>
<ul>
<li>指发生在老年代的GC,对象从老年代消失时，我们说“Major GC”或“Full GC”发生了</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM错误。</li>
</ul>
</blockquote>
<blockquote>
<p>Full GC触发机制：</p>
<ul>
<li>触发Full GC执行的情况有如下五种：<ul>
<li>调用System.gc()时，系统建议执行 Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区，survivor space0区（From区）向survivor space1区（To区）复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
</li>
<li>说明：full GC是开发或调优中尽量要避免的，这样暂停的时间会短一些。</li>
</ul>
</blockquote>
<blockquote>
<p>字符串常量池存在于堆空间中，以前存在于方法区。</p>
</blockquote>
<h3 id="6-堆空间分代思想"><a href="#6-堆空间分代思想" class="headerlink" title="6.堆空间分代思想"></a>6.堆空间分代思想</h3><blockquote>
<p>&#x3D;&#x3D;为什么需要把Java堆进行分代？不分代就不能正常工作了吗？&#x3D;&#x3D;</p>
<ul>
<li>经过研究得出，不同对象的生命周期不同，70%~99%的对象是临时对象。<ul>
<li>新生代：有Eden、两块大小相同的Survivor(又称为from&#x2F;to,s0&#x2F;s1)构成，to总为空</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象</li>
</ul>
</li>
<li>其实不分代完全可以，&#x3D;&#x3D;分代的唯一理由就是优化GC性能&#x3D;&#x3D;。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教师。GC的时候要找到哪些对象没用，这样&#x3D;&#x3D;就会对堆的所有区域进行扫描&#x3D;&#x3D;。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方法，当GC的时候先把这块存储朝生夕死对象的区域进行回收，这样就会腾出很大的空间出来。</li>
</ul>
</blockquote>
<h3 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7.内存分配策略"></a>7.内存分配策略</h3><blockquote>
<ul>
<li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1.对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM,每个GC都有所不同）时，就会被晋升到老年代中</li>
<li>对于晋升老年代的年龄阈值，可以通过选项-XX:MaxTenuringThreshold来设置</li>
</ul>
</blockquote>
<blockquote>
<p>内存分配策略(对象提升（promotion）策略)。针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄</li>
</ul>
</li>
<li>空间分配担保：<ul>
<li>-XX:HandlePromotionFailure</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="8-为对象分配内存：TLAB"><a href="#8-为对象分配内存：TLAB" class="headerlink" title="8.为对象分配内存：TLAB"></a>8.为对象分配内存：TLAB</h3><blockquote>
<p>&#x3D;&#x3D;为什么有TLAB(Thread Local Allocation Buffer)?&#x3D;&#x3D;</p>
<ul>
<li>堆区是线程共享区域，任何线程又可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;什么是TLAB?&#x3D;&#x3D;</p>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，&#x3D;&#x3D;JVM为每个线程分配了一个私有缓存区域&#x3D;&#x3D;，它包括在Eden空间内。</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为&#x3D;&#x3D;快速分配策略。&#x3D;&#x3D;</li>
<li>好像所有OpenJDK衍生出来的JVM都提供了TLAB的设计</li>
</ul>
</blockquote>
<blockquote>
<p>TLAB的再说明：</p>
<ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但&#x3D;&#x3D;JVM确实是将TLAB作为内存分配的首选&#x3D;&#x3D;。</li>
<li>开发人员可以通过选项“-XX:UserTLAB”设置是否开启TLAB空间。默认情况下是开启的</li>
<li>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</li>
</ul>
</blockquote>
<h3 id="9-小结堆空间的参数设置"><a href="#9-小结堆空间的参数设置" class="headerlink" title="9.小结堆空间的参数设置"></a>9.小结堆空间的参数设置</h3><blockquote>
<ul>
<li><p>-XX:+PrintFlagsInitial	查看所有的参数的默认初始值</p>
</li>
<li><p>-XX:+PrintFlagsFinal      查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>
<ul>
<li><p>具体查看某个参数的指令 cmd中操作： jps: 查看当前运行中的进程</p>
</li>
<li><p>​                                                                   jinfo -flag SurvivorRatio  进程id</p>
</li>
<li><p>-Xms:初始堆空间内存 （默认为物理内存的 1&#x2F;64）</p>
</li>
<li><p>-Xmx: 最大堆空间内存（默认为物理内存的1&#x2F;4）</p>
</li>
<li><p>-Xmn:设置新生代的大小。（初始值及最大值）</p>
</li>
<li><p>-XX:NewRatio:配置新生代与老年代在堆结构的占比</p>
</li>
<li><p>-XX:SurvivorRatio:设置新生代中Eden和s0&#x2F;s1空间的占比  8：1：1</p>
</li>
<li><p>-XX:MaxTenuringThreshold:设置新生代垃圾的最大年龄（阈值）</p>
</li>
<li><p>-XX:+PrintGCDetails:输出详细的GC处理日志</p>
</li>
<li><p>打印gc简要信息：① -XX:+PrintGC    ② -verbose:gc</p>
</li>
<li><p>-XX:HandlePromotionFailure:是否设置空间分配担保</p>
<ul>
<li>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC,否则将进行Full GC</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="10-堆是分配对象的唯一选择吗？"><a href="#10-堆是分配对象的唯一选择吗？" class="headerlink" title="10.堆是分配对象的唯一选择吗？"></a>10.堆是分配对象的唯一选择吗？</h3><blockquote>
<ul>
<li>随着JIT编译器的发展与&#x3D;&#x3D;逃逸分析技术&#x3D;&#x3D;逐渐成熟，&#x3D;&#x3D;栈上分配、标量替换优化技术&#x3D;&#x3D;将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了。</li>
<li>在Java虚拟机中，对象实在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，&#x3D;&#x3D;那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。&#x3D;&#x3D;这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术了。</li>
</ul>
</blockquote>
<blockquote>
<p>逃逸分析手段：</p>
<ul>
<li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li>
<li>通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>参数设置：</p>
<ul>
<li>在jdk6版本之后，HotSpot中默认就已经开启了逃逸分析。</li>
<li>如果使用的是较早的版本，开发人员则可以通过<ul>
<li>选项 -XX:+DoEscapeAnalysis显式开启逃逸分析</li>
<li>选项-XX:+PrintExcapeAnalysis查看逃逸分析的筛选结果</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;结论：开发中能使用局部变量的，就不要使用在方法外定义。&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>使用逃逸分析，编译器可以对代码做以下优化：</p>
<ul>
<li>栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。<ul>
<li>jdk8是默认开启的</li>
</ul>
</li>
<li>同步省略（锁消除）。如果一个对象被发现只能从一个线程北方问道，那么对于这个对象的操作可以不考虑同步。<ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来&#x3D;&#x3D;判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。&#x3D;&#x3D;这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，或者叫锁消除。</li>
<li>这个在看字节码文件时仍然存在锁，但是在运行的时候就把锁消除了。</li>
</ul>
</li>
<li>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。<ul>
<li>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li>
<li>相对的，哪些还可以分解的数据叫做聚合量，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li>
<li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程就是&#x3D;&#x3D;标量替换&#x3D;&#x3D;。</li>
<li>标量替换参数设置：<ul>
<li>参数 -XX:+EliminateAllocations  开启了标量替换（默认打开），允许将对象打散分配在栈上。</li>
</ul>
</li>
</ul>
</li>
<li>逃逸分析现在还不是很成熟，在Oracle HotSpot中并没有使用逃逸分析，但是使用了标量替换，所以优化后还是有性能提升的。所以总的来说，对象还是分配在堆上。</li>
</ul>
</blockquote>
<h2 id="9-方法区"><a href="#9-方法区" class="headerlink" title="&#x3D;&#x3D;9.方法区&#x3D;&#x3D;"></a>&#x3D;&#x3D;9.方法区&#x3D;&#x3D;</h2><h3 id="1-栈、堆、方法区-元空间-的交互关系"><a href="#1-栈、堆、方法区-元空间-的交互关系" class="headerlink" title="1.栈、堆、方法区(元空间)的交互关系"></a>1.栈、堆、方法区(元空间)的交互关系</h3><p>Person	person   &#x3D;  new  Person();</p>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_方式2：使用直接指针访问.jpg" alt="第10章_方式2：使用直接指针访问" style="zoom: 33%;" />

<h3 id="2-方法区的理解"><a href="#2-方法区的理解" class="headerlink" title="2.方法区的理解"></a>2.方法区的理解</h3><blockquote>
<ul>
<li>尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot VM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。所以，&#x3D;&#x3D;方法区看作是一块独立于Java堆的内存空间&#x3D;&#x3D;</li>
<li>方法区（method area）与Java堆一样，是各个线程共享的内存区域</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样，都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryEroor: PermGen space或者java.lang.OutOfMemoryError: Metaspace 【这是在JDK 8中】</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_堆和方法区图.jpg" alt="第08章_堆和方法区图" style="zoom: 33%;" />

<blockquote>
<ul>
<li>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。<ul>
<li>永久代和元空间都是方法区的逻辑实现</li>
</ul>
</li>
<li>本质上，方法区和永久代并不等价，仅是堆hotspot而言的。</li>
<li>元空间的本质和永久代类似，都是对JVM规范方法区的实现。不过元空间与永久代最大的区别在于：&#x3D;&#x3D;元空间不在虚拟机设置的内存中，而是使用本地内存&#x3D;&#x3D;</li>
<li>根据Java虚拟机规范的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</li>
</ul>
</blockquote>
<h3 id="3-设置方法区大小与OOM"><a href="#3-设置方法区大小与OOM" class="headerlink" title="3.设置方法区大小与OOM"></a>3.设置方法区大小与OOM</h3><blockquote>
<p>jdk8及以后：</p>
<ul>
<li>元数据区大小可以使用参数 -XX:MetaspaceSize和 -XX:MaxMetaspaceSize指定，替代上述原有的两个参数</li>
<li>默认值依赖于平台。windows下，-XX:MetaspaceSize 是21M,-XX:MaxMetaspaceSize的值是-1，即没有限制。</li>
<li>与永久代不同，如果不设置大小，默认情况下，虚拟机会耗尽所有的可用系统内存，如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_OOM.jpg" alt="第10章_OOM" style="zoom:50%;" />

<blockquote>
<p>OOM出现的两大原因：</p>
<ul>
<li>内存泄漏</li>
<li>内存溢出</li>
</ul>
</blockquote>
<h3 id="4-方法区的内部结构"><a href="#4-方法区的内部结构" class="headerlink" title="4.方法区的内部结构"></a>4.方法区的内部结构</h3><p><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第09章_方法区存储信息.jpg" alt="第09章_方法区存储信息"></p>
<blockquote>
<p>方法区存储内容如下：</p>
<ul>
<li>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存，域信息等。</li>
</ul>
</blockquote>
<blockquote>
<p>类型信息：</p>
<ul>
<li>对每个加载的类型（类class,接口interface,枚举enum,注解annotation），JVM必须在方法区中存储以下类型信息<ul>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object,都没有父类）</li>
<li>这个类型的修饰符（public，abstract,final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>域信息（成员变量）：</p>
<ul>
<li>JVM必须在方法区中保存类型的所有域相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称、域类型、域修饰符（public，private, protected, static, final, volatile, transient 的某个子集）</li>
</ul>
</blockquote>
<blockquote>
<p>方法信息：</p>
<ul>
<li>JVM必须保存所有方法的一下信息，同域信息一样包括声明顺序：<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符</li>
<li>方法的字节码、操作数栈、局部变量表及大小（abstract 和native方法除外）</li>
<li>异常表（abstract 和native方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>non-final的类变量：</p>
<ul>
<li><p>静态变量和类关联在一起，随着类的加载而加载，它们就成为类数据在逻辑上的一部分</p>
</li>
<li><p>类变量被类的所有实例共享，即使没有类实例也可以访问它</p>
</li>
<li><pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        Order order = null;
        order.hello();    //均不会报空指针异常
        sout(order.count);//均不会报空指针异常
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final常量：</span><br><span class="line"></span><br><span class="line">- 在编译时就已经被赋值，而无需等到后面的初始化阶段才赋值。</span><br><span class="line"></span><br><span class="line">运行时常量池 VS 常量池</span><br><span class="line"></span><br><span class="line">- 方法区，内部包含了运行时常量池</span><br><span class="line">- 字节码文件，内部包含了常量池</span><br><span class="line">- 要弄清楚方法区，需要理解清楚ClassFile,因为加载类的信息都在方法区</span><br><span class="line">- 要想弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池</span><br><span class="line"></span><br><span class="line">- 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是==常量池表（Constant Pool Table）,包含各种字面量和对类型、域和方法的符号引用==</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- Q:为什么需要常量池？</span><br><span class="line"></span><br><span class="line">- A;一个Java源文件的类、接口，编译后产生一个字节码文件，而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用，在==动态链接==的时候会用到运行时常量池。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 常量池中有什么？</span><br><span class="line"></span><br><span class="line">  - 数量值</span><br><span class="line">  - 字符串值</span><br><span class="line">  - 类引用</span><br><span class="line">  - 字段引用</span><br><span class="line">  - 方法引用</span><br><span class="line"></span><br><span class="line">- 小结：</span><br><span class="line"></span><br><span class="line">  - 常量池，可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</span><br><span class="line"></span><br><span class="line">运行时常量池：</span><br><span class="line"></span><br><span class="line">- ==运行时常量池（Runtime Constant Pool）是方法区的一部分==</span><br><span class="line">- 常量池表（Constant Pool Table）是Class文件的一部分，==用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。==</span><br><span class="line">- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池</span><br><span class="line">- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</span><br><span class="line">- 运行池常量池，相对于Class文件常量池的另一重要特征是：具备动态性</span><br><span class="line">- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OutOfMemoryError异常</span><br><span class="line"></span><br><span class="line">### 5.方法区使用举例</span><br><span class="line"></span><br><span class="line">### 6.方法区的演进细节</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第08章_方法区的演进细节-hotspot.jpg&quot; alt=&quot;第08章_方法区的演进细节-hotspot&quot; style=&quot;zoom: 50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- 首先明确只有HotSpot中才有永久代</span><br><span class="line">- Hotspot中方法区的变化：</span><br><span class="line">  - 1.6及之前：有永久代，静态变量存放在永久代上</span><br><span class="line">  - 1.7：有永久代，但已经逐步去永久代，字符串常量池、静态变量移除，保存在堆中</span><br><span class="line">  - ==1.8及之后：无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆。==</span><br><span class="line">  - ==注意：==静态引用对应的对象实体 （如new出来的内容，new Person()）始终都存在堆空间。</span><br><span class="line">  - 而上面jdk6说的静态变量存在永久代，指的是Static Person person这个引用名在永久代。</span><br><span class="line"></span><br><span class="line">为什么永久代会被元空间进行替代？</span><br><span class="line"></span><br><span class="line">- 为永久代设置空间大小是很困难的</span><br><span class="line">  - 在某些场景下，如果动态加载类过多，容易产生Perm区的OOM,比如某个实际Web工程，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</span><br><span class="line">  - 而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此默认情况下，元空间的大小仅受本地限制。</span><br><span class="line">- 对永久代进行调优时很困难的</span><br><span class="line"></span><br><span class="line">- Q:String Table为什么要调整？【从永久代中移到了堆空间中】</span><br><span class="line"></span><br><span class="line">- A:因为永久代的回收效率很低，在full GC的时候才会触发。而full gc是老年代的空间不足、永久代不足时才触发。这就导致String Table回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">   static ObjectHolder staticObject = new ObjectHolder();</span><br><span class="line">   ObjectHolder instanceObject = new ObjectHolder();</span><br><span class="line">   void func() &#123;</span><br><span class="line">       ObjectHolder localObject = new ObjectHolder();</span><br><span class="line">       sout(localObject);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;staticObject随着Test的类型信息存放在方法区&#x3D;&#x3D;，instanceObject随着Test的对象实例存放在堆中，localObject则是存放在foo()方法栈帧的局部变量表中</p>
</li>
<li><p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围中，所以结论：&#x3D;&#x3D;只要是对象实例必然会在Java堆中分配。&#x3D;&#x3D;</p>
</li>
<li><p>jdk7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，存储于Java堆之中。</p>
</li>
</ul>
</blockquote>
<h3 id="7-方法区的垃圾回收"><a href="#7-方法区的垃圾回收" class="headerlink" title="7.方法区的垃圾回收"></a>7.方法区的垃圾回收</h3><blockquote>
<ul>
<li>一般来说方法区的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。</li>
<li>方法区的垃圾收集主要回收两部分内容：&#x3D;&#x3D;常量池中废弃的常量和不再使用的类型&#x3D;&#x3D;</li>
<li>方法区内常量池之中主要存放的两发类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如本文字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念。包括下面三种:<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li>Hotspot虚拟机对常量池的回收策略是很明确的，&#x3D;&#x3D;只要常量池中的常量没有被任何地方引用，就可以被回收。&#x3D;&#x3D;</li>
<li>回收废弃常量与回收堆中的对象非常类似</li>
<li>jdk11的zgc收集器就不支持类卸载</li>
</ul>
</blockquote>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第09章_小结.jpg" alt="第09章_小结"></p>
<h2 id="10-对象的实例化、内存布局与访问定位"><a href="#10-对象的实例化、内存布局与访问定位" class="headerlink" title="10.对象的实例化、内存布局与访问定位"></a>10.对象的实例化、内存布局与访问定位</h2><h3 id="0-大厂面试题"><a href="#0-大厂面试题" class="headerlink" title="0.大厂面试题"></a>0.大厂面试题</h3><blockquote>
<ul>
<li>对象在JVM中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
<li>Java对象头里面有什么</li>
</ul>
</blockquote>
<h3 id="1-对象的实例化"><a href="#1-对象的实例化" class="headerlink" title="1.对象的实例化"></a>1.对象的实例化</h3><blockquote>
<p>&#x3D;&#x3D;创建对象的方式：&#x3D;&#x3D;</p>
<ul>
<li>new</li>
<li>Class的newInstance( )方法 【反射的方式，只能调用空参的构造器，权限必须是public】</li>
<li>Constructor的newInstance(Xxx)方法 【反射的方式，可以调用空参和有参的方式，权限没有要求】</li>
<li>使用clone( )  【不调用任何构造器，当前类需要实现Cloneable接口，实现clone( )方法】</li>
<li>使用反序列化  【从文件中、网络中获取一个对象的二进制流】</li>
<li>第三方库Objenesis</li>
</ul>
</blockquote>
<blockquote>
<p>创建对象的步骤：</p>
<ol>
<li>判断对象对应的类是否加载、链接、初始化<ul>
<li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派机制的模式下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应的class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</li>
</ul>
</li>
<li>为对象分配内存 【首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量（类的属性&#x2F;域）是引用变量，仅分配引用变量空间即可，即4个字节大小。】<ol>
<li>如果内存规整  ——》指针碰撞  【对应的垃圾回收算法是标记压缩算法】<ul>
<li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。</li>
<li>意思是所有用过的内存在一边，空间的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时，使用指针碰撞。</li>
</ul>
</li>
<li>如果内存不规整      【对应的垃圾回收算法是标记清除算法 CMS】<ol>
<li>虚拟机需要维护一个列表</li>
<li>空闲列表分配<ul>
<li>如果内存不是规整的，已使用的内存和未使用的内存交互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存</li>
<li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表”</li>
</ul>
</li>
</ol>
</li>
<li>说明<ul>
<li>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>
</ul>
</li>
</ol>
</li>
<li>处理并发安全问题<ol>
<li>采用CAS配上失败重试保证更新的原子性</li>
<li>每个线程预先分配一块TLAB ——》通过-XX:+&#x2F;-UseTLAB参数来设定</li>
</ol>
</li>
<li>初始化分配到的空间  ——》所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用 【属性的默认初始化】</li>
<li>设置对象的对象头<ul>
<li>将对行的所属类（即类的元数据信息），对象的hashcode和对象的GC信息、锁信息等数据存储在对象的对象头中，这个过程的具体设置方式取决于JVM实现。</li>
</ul>
</li>
<li>执行init方法进行初始化 【属性的显式初始化，代码块中初始化，构造器中初始化】<ul>
<li>在Java程序的视角看来，初始化才正式开始，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的兑现那个才算完全创建出来。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_内存布局.jpg" alt="第10章_内存布局" style="zoom: 200%;" />

<blockquote>
<p>内存布局</p>
<ul>
<li><p>对象头（Header）：</p>
<ul>
<li>运行时元数据（Mark word）<ul>
<li>哈希值</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
</li>
<li>类型指针 ——》指向类元数据InstanceKlass,确定该对象所属的类型</li>
<li>说明：如果是数组，还需记录数组的长度</li>
</ul>
</li>
<li><p>实例数据（Instance Data）</p>
<ul>
<li>说明 ——》它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来和本身拥有的字段）</li>
<li>规则<ul>
<li>相同宽度的字段总是被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果CompactFields参数为true(默认为true):子类的窄变量可能插入到父类变量的空隙</li>
</ul>
</li>
</ul>
</li>
<li><p>对齐填充（Padding） ——》不是必须的，也没有特别含义，仅仅起到占位符的作用</p>
</li>
<li><p>小结：图示</p>
</li>
<li><pre><code class="java">class Account &#123;
    double money;
    double balance;
&#125;

class Customer &#123;
    int ID = 1001;
    String name;
    Account acct;

    &#123;
        name = &quot;匿名客户&quot;;
    &#125;
    
    public Customer() &#123;
        Account acct = new Account();
        this.acct = acct;
    &#125;
&#125;


public class ClassTest &#123;
    public static void main(String[] args) &#123;
        Customer cust = new Customer();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ![第10章_图示对象的内存布局](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_图示对象的内存布局.jpg)</span><br><span class="line"></span><br><span class="line">### 3.对象的访问定位</span><br><span class="line"></span><br><span class="line">- Q:JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢?</span><br><span class="line"></span><br><span class="line">- A:定位，通过栈上reference访问</span><br><span class="line"></span><br><span class="line">对象访问方式主要有两种：</span><br><span class="line"></span><br><span class="line">- 句柄访问</span><br><span class="line">  - 优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</span><br><span class="line">  - ![第10章_方式1：句柄访问](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_方式1：句柄访问.jpg)</span><br><span class="line">- 直接指针（HotSpot使用）</span><br><span class="line">  - 优点：不要单独开启空间来存储指针</span><br><span class="line">  - ![第10章_方式2：使用直接指针访问](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第10章_方式2：使用直接指针访问.jpg)</span><br><span class="line"></span><br><span class="line">## 11.直接内存</span><br><span class="line"></span><br><span class="line">- 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</span><br><span class="line">- 直接内存是在Java堆外的，直接向系统申请的内存区间</span><br><span class="line">- 来源于NIO（non-blocking IO，非阻塞式IO）,通过存在堆中的DirectByteBuffer操作Native内存</span><br><span class="line">- 通常，访问直接内存的速度会优于Java堆。即读写性能高</span><br><span class="line">  - 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</span><br><span class="line">  - Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</span><br><span class="line"></span><br><span class="line">- 读写文件，需要与磁盘进行交互，需要由用户态切换到内核态，在内核态时，需要内存如右图所示。</span><br><span class="line"></span><br><span class="line">- 使用IO,这里需要两份内存存储重复数据，效率低。【JVM中的用户地址空间一份。OS中的内核地址空间一份】</span><br><span class="line">- 使用NIO时，操作系统直接划出的直接缓存区可以被Java代码直接访问，只有一份，NIO适合堆大文件的读写操作。</span><br><span class="line"></span><br><span class="line">- 也可能导致OutOfMemoryEroor异常</span><br><span class="line">- 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统给出的最大内存</span><br><span class="line">- 缺点：</span><br><span class="line">  - 分配回收成本较高</span><br><span class="line">  - 不受JVM内存回收管理</span><br><span class="line">- 直接内存大小可以通过MaxDirectMemorySize设置</span><br><span class="line">- 如果不指定，默认与堆的最大值-Xmx参数值一致</span><br><span class="line"></span><br><span class="line">- 方法区（元空间）放在堆外的本地内存中</span><br><span class="line">- 本地内存包括直接内存 和元数据区（元空间）</span><br><span class="line">- java process memory ~= java  heap  +  native  memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 12.执行引擎</span><br><span class="line"></span><br><span class="line">![第02章_JVM架构-中](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第02章_JVM架构-中.jpg)</span><br><span class="line"></span><br><span class="line">### 1.执行引擎概述</span><br><span class="line"></span><br><span class="line">- 执行引擎时Java虚拟机核心的组成部分之一</span><br><span class="line">- 虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而==虚拟机的执行引擎则是由软件自行实现的==，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，==能够执行那些不被硬件直接支持的指令集格式。==</span><br><span class="line">- ==JVM的主要任务是负责装载字节码到其内部==，但字节码并不能直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表、以及其他辅助信息。</span><br><span class="line">- 那么，如果想要让一个Java程序运行起来，==执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以==。简单来说，JVM中的执行引擎充当了高级语言翻译为机器语言的翻译官。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_执行引擎的工作过程.jpg&quot; alt=&quot;第12章_执行引擎的工作过程&quot; style=&quot;zoom: 33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">执行引擎的工作过程：</span><br><span class="line"></span><br><span class="line">- 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器</span><br><span class="line">- 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址</span><br><span class="line">- 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到存储在元空间中的目标对象的类型信息。</span><br><span class="line">- 从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的；输入的是二进制流，处理过程是字节码解析执行的等效过程，输出的执行结果。</span><br><span class="line"></span><br><span class="line">### 2.Java代码编译和执行过程</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_程序执行过程.jpg&quot; alt=&quot;第12章_程序执行过程&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤。</span><br><span class="line"></span><br><span class="line">- 绿色对应的是解释过程</span><br><span class="line">- 蓝色对应的是JIT编译过程</span><br><span class="line"></span><br><span class="line">Q：什么是解释器，什么是JIT编译器</span><br><span class="line"></span><br><span class="line">A：解释器：当Java虚拟机启动的时候会根据预定义的规范==对字节码采用逐行解释的方式执行==，将每条字节码文件中的内容解释为对应平台的本地机器指令执行。	JIT编译器（just in time Compile）：就是虚拟机将源代码直接编译成本地机器平台相关的机器语言。</span><br><span class="line"></span><br><span class="line">Q：为什么说Java是半编译半解释型语言？</span><br><span class="line"></span><br><span class="line">A：JDK1.0时代，将Java语言定位为解释执行，还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器（这是后端编译。将.java文件编译成.class文件是前端编译）。现在JVM在执行代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</span><br><span class="line"></span><br><span class="line">![第12章_理解执行引擎](D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_理解执行引擎.jpg)</span><br><span class="line"></span><br><span class="line">### 3.机器码、指令、汇编语言</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_机器语言、汇编、高级语言.jpg&quot; alt=&quot;第12章_机器语言、汇编、高级语言&quot; style=&quot;zoom: 50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">机器码：</span><br><span class="line"></span><br><span class="line">- 各种用二进制编码方式表示的指令，叫做机器指令码。开始人们就用它来编写程序，这就是机器语言</span><br><span class="line">- 用机器语言编写的程序，CPU可以直接读取运行，因此和其他语言编的程序相比，执行速度最快</span><br><span class="line">- 机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</span><br><span class="line"></span><br><span class="line">机器指令：</span><br><span class="line"></span><br><span class="line">- 由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</span><br><span class="line">- 指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文编写，如mov,inc等），可读性稍好</span><br><span class="line">- 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov）,对应的机器码也可能不同</span><br><span class="line"></span><br><span class="line">指令集：</span><br><span class="line"></span><br><span class="line">- 不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</span><br><span class="line">- 常见的：</span><br><span class="line">  - X86指令集，对应的是x86架构的平台</span><br><span class="line">  - ARM指令集，对应的是ARM架构的平台</span><br><span class="line"></span><br><span class="line">汇编语言：</span><br><span class="line"></span><br><span class="line">- 由于指令的可读性还是太差，于是人们发明了汇编语言</span><br><span class="line">- 汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址</span><br><span class="line">- 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</span><br><span class="line">  - 由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</span><br><span class="line"></span><br><span class="line">高级语言：</span><br><span class="line"></span><br><span class="line">- 为了更简单，后来就出现了各种高级语言，更接近人的语言</span><br><span class="line">- 当计算机执行高级语言执行的程序时，仍然需要把程序解释和编译成机器的指令码，完成这个过程的程序就叫做解释程序或编译程序。</span><br><span class="line"></span><br><span class="line">字节码：</span><br><span class="line"></span><br><span class="line">- 字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</span><br><span class="line">- 字节码主要为了实现特定软件运行和软件环境、==与硬件环境无关。==</span><br><span class="line">- 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</span><br><span class="line">  - 字节码的典型应用为Java bytecode</span><br><span class="line"></span><br><span class="line">### 4.解释器</span><br><span class="line"></span><br><span class="line">- JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法</span><br><span class="line">- 解释器工作机制：</span><br><span class="line">  - 真正意义上所承担的角色就是一个运行时解释者，将字节码文件中的内容翻译为对应平台的本地机器指令执行</span><br><span class="line">  - 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</span><br><span class="line">- 现状：</span><br><span class="line">  - 基于解释器执行已经沦落为低效的代名词，并且时常被一些c/c++程序员调侃。</span><br><span class="line">  - 为了解决这个问题，JVM平台支持一种叫做即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成机器码。每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</span><br><span class="line">  - 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</span><br><span class="line"></span><br><span class="line">### 5.JIT编译器</span><br><span class="line"></span><br><span class="line">- Hotspot VM是目前市面上高性能虚拟机的代表作之一。==它采用解释器与即时编译器并存的架构==。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</span><br><span class="line">- Q：既然Hotspot VM已经内置JIT编译器了，那么为什么还需要在使用解释器来拖累程序的执行性能呢？</span><br><span class="line">- A：当程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间，单边以为本地代码后，执行效率高。</span><br><span class="line"></span><br><span class="line">Hotspot VM的执行方式：</span><br><span class="line"></span><br><span class="line">- 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的代码编译为本地机器指令，以换取更高的程序执行效率。</span><br><span class="line"></span><br><span class="line">概念解释：</span><br><span class="line"></span><br><span class="line">- Java语言的编译器，其实是一段不确定的操作过程，因为它可能是指一个前端编译器（或叫编译器的前端）把.java文件转变成.class文件的过程。</span><br><span class="line">- 也可能是指虚拟机的后端运行期编译器（JIT编译器）把字节码转变成机器码的过程（这中间还经历了转换为汇编语言）</span><br><span class="line">- 还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compile）直接把.java文件编译成本地机器代码的过程</span><br><span class="line"></span><br><span class="line">热点代码及探测方式：</span><br><span class="line"></span><br><span class="line">- ==根据代码被调用执行的频率而定。那些需要被编译为本地代码的字节码也被称为热点代码==。JIT编译器在运行时会针对那些频繁被调用的热点代码作出深度优化，将其直接编译为对应平台的本地机器指令，以此来提升性能。</span><br><span class="line">- 热点代码都可以通过JIT编译器编译为本地机器指令，由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为==OSR(On Stack Replacement)编译==</span><br><span class="line">- 一个方法究竟需要被调用多少次，这里主要依靠热点探测功能。</span><br><span class="line">- ==目前Hotspot VM所采用的热点探测方式是基于计数器的热点探测。==</span><br><span class="line">- Hotspot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器和汇编计数器</span><br><span class="line">  - 方法调用计数器用于==统计方法的调用次数==</span><br><span class="line">  - 回边计数器则用于==统计循环体执行的循环次数==</span><br><span class="line"></span><br><span class="line">方法调用计数器：</span><br><span class="line"></span><br><span class="line">- 它的默认阈值在client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。（这个次数包括方法调用计数器与回边计数器值之和）</span><br><span class="line">- 这个阈值可以通过虚拟机参数 -XX:CompileThrehold来人为设定</span><br><span class="line">- 热度衰减：</span><br><span class="line">  - 如果不做任何设置，方法调用计数器统计的并不是方法被调用的次数，而是一个相对的执行效率，即一段时间内方法被调用的次数。即当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期</span><br><span class="line">  - 进行热度衰减的动作实在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCountDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译称本地代码。</span><br><span class="line">  - 另外，可以使用 -XX:CounterHalfLifeTime 参数设hi半衰周期的时间，单位是秒</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_方法调用计数器.jpg&quot; alt=&quot;第12章_方法调用计数器&quot; style=&quot;zoom: 33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">回边计数器：</span><br><span class="line"></span><br><span class="line">- 作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为回边。显然，建立回边计数器统计的目的就是为了触发OSR编译</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第12章_回边计数器.jpg&quot; alt=&quot;第12章_回边计数器&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">Hotspot VM可以设置程序执行方式：</span><br><span class="line"></span><br><span class="line">- 默认情况下是采用解释器与即时编译器并存的架构。当然开发人员可以根据需要进行修改来指定运行时到底是完全采用解释器执行还是完全采用即时编译器执行。</span><br><span class="line">- -Xint : 完全采用解释器模式执行程序</span><br><span class="line">- -Xcomp: 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</span><br><span class="line">- -Xmixed:采用解释器、即时编译器混合模式来共同执行程序。</span><br><span class="line"></span><br><span class="line">Hotspot VM中的JIT分类：</span><br><span class="line"></span><br><span class="line">- 在Hotspot VM中内嵌有两个JIT编译器，分别为Client Compile和Server Compile，但大多数情况下我们简称为c1编译器和c2编译器。开发人员可以通过如下命令显示指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</span><br><span class="line">  - -client : 指定Java虚拟机运行在Client模式下，并使用c1编译器</span><br><span class="line">    - c1编译器会对字节码进行==简单和可靠的优化，耗时短==，以达到更快的编译速度</span><br><span class="line">  - -server: 指定Java虚拟机运行在Server模式下，并使用c2编译器</span><br><span class="line">    - c2编译器进行==耗时较长的优化，以及激进优化==，但优化的代码执行效率更高</span><br><span class="line"></span><br><span class="line">c1和c2编译器不同的优化策略：</span><br><span class="line"></span><br><span class="line">- 在不同的编译器上有不同的优化策略，c1上主要有方法内联，去虚拟化、冗余消除</span><br><span class="line">  - 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</span><br><span class="line">  - 去虚拟化：对唯一的实现类进行内联</span><br><span class="line">  - 冗余消除：在运行期间把一些不会执行的代码折叠掉</span><br><span class="line">- c2的优化主要在全局层面，逃逸分析是优化的基础。基于逃逸分析在c2上有如下几种优化：</span><br><span class="line">  - 标量替换：用标量值代替聚合对象的属性值</span><br><span class="line">  - 栈上分配：对于未逃逸的对象分配对象在栈而不是堆</span><br><span class="line">  - 同步消除：消除同步操作，通常指synchronized</span><br><span class="line"></span><br><span class="line">- 分层编译策略：程序解释执行（不开启性能监控）可以触发c1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，c2编译会根据性能监控信息进行激进优化。</span><br><span class="line"></span><br><span class="line">- 在-server模式下，默认将开启分层编译策略，由c1和c2编译器相互协作来完成</span><br><span class="line"></span><br><span class="line">总结来讲：</span><br><span class="line"></span><br><span class="line">- JIT编译出来的机器码性能比解释器高。</span><br><span class="line">- c2编译器启动时长比c1编译器慢，系统稳定执行以后，c2编译器执行速度远远快于c1编译器</span><br><span class="line"></span><br><span class="line">在JDK10之后，引入了全新即时编译器，Graal编译器（与c1,c2是并列关系，属于JIT里面），性能已经快赶上c2编译器了</span><br><span class="line"></span><br><span class="line">- AOT编译器（与JIT是并列的关系），静态提前编译器，在jdk9引入的，是与即时编译相对立的一个概念。即时编译是在==程序的运行过程中==，而AOT编译指的是，==在程序运行之前==，便将字节码转换为机器码的过程。</span><br><span class="line">- 最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行，不必等待即时编译器的预热，减少Java应用给人带来第一次运行慢的不良体验</span><br><span class="line">- 缺点:</span><br><span class="line">  - 破坏了Java一次编译到处运行，必须为每个不同硬件，oS编译对应的发行包</span><br><span class="line">  - 降低了Java连接过程的动态性，加载的代码在编译器就必须全部已知。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 13.String Table</span><br><span class="line"></span><br><span class="line">### 1.String 的基本特性</span><br><span class="line"></span><br><span class="line">- String的两种定义方式：</span><br><span class="line">  - String  str  =  &quot;anc&quot;;  //==字面量定义方式  &quot;abc&quot;存储在字符串常量池中==</span><br><span class="line">  - String  str  =  new  String(&quot;abc&quot;);  </span><br><span class="line">- String类被声明为final的，不可被继承</span><br><span class="line">- String实现了Serializable接口，表示字符串是支持序列化的，实现了Comparable接口，表示String可以比较大小</span><br><span class="line">- String在jdk 8及以前内部定义了final char[] value用于存储字符串数据。jdk9时改为byte[]。为了节约内存空间，char占两个byte,而大多数存储的内容都用一个byte就足够了，对于像中文这样的，需要两个字节的则使用encoding-flag field来进行标识。</span><br><span class="line">- String:代表不可变的特性，简称不可变性。即已经存在的字符串就不会再变化。</span><br><span class="line">- ==通过字面量的方式（区别于new的方式）给一个字符串赋值，此时的字符串声明在字符串常量池中==</span><br><span class="line">- ==字符串常量池中是不会存储相同内容的字符串的==</span><br><span class="line">- String的String pool是一个固定大小的Hashtable，使用数组+链表来进行实现。当里面字符串过多时，就会有hash冲突，导致链表会很长，而链表长了，直接会造成的影响就是当调用String,intern()时性能会大幅下降。这里不能够扩容</span><br><span class="line">- 使用 -XX:StringTableSize 可设置StringTable的长度。jdk6中默认的是1009. jdk7中默认是60013，jdk8开始设置的最小值是1009.</span><br><span class="line"></span><br><span class="line">### 2.String 的内存分配</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   String s1 = &quot;abc&quot;;</span><br><span class="line">   String s2 = &quot;abc&quot;;</span><br><span class="line">   System.out.println(s1.hashCode());  //96354</span><br><span class="line">   System.out.println(s2.hashCode());	//96354</span><br><span class="line">   System.out.println(s1 == s2);   //true</span><br><span class="line"></span><br><span class="line">   String s3 = new String(&quot;efg&quot;);</span><br><span class="line">   String s4 = new String(&quot;efg&quot;);</span><br><span class="line">   System.out.println(s3.hashCode());	//100326</span><br><span class="line">   System.out.println(s4.hashCode());	//100326</span><br><span class="line">   System.out.println(s3 == s4);   //false     虽然hashcode值相同，它们的地址仍然不同</span><br><span class="line"></span><br><span class="line">   String s5 = &quot;poi&quot;;</span><br><span class="line">   String s6 = new String(&quot;poi&quot;);</span><br><span class="line">   System.out.println(s5.hashCode());	//111178</span><br><span class="line">   System.out.println(s6.hashCode());	//111178</span><br><span class="line">   System.out.println(s5 == s6);   //false     虽然hashcode值相同，它们的地址仍然不同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li>
<li>常量池就类似一个Java系统级别提供的缓存，8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊，它的主要使用方法有两种。<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中，比如：String info &#x3D; “abc”;</li>
<li>如果不是双引号声明的String对象，可以使用String提供的intern( )方法，后面重点谈。</li>
</ul>
</li>
<li>Java 6及以前，字符串常量池存放在永久代</li>
<li>Java 7 中Oracle 的工程师对字符串池的逻辑做了很大的改变，&#x3D;&#x3D;即将字符串常量池的位置调整到Java堆中&#x3D;&#x3D;<ul>
<li>所有的字符串都保存在堆（heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够得理由让我们重新考虑在Java 7中使用String.intern( )。</li>
</ul>
</li>
<li>Java 8 元空间，字符串常量在堆中。</li>
<li>String Table(字符串常量池为什么要调整到堆中去)？<ul>
<li>永久代（方法区、元空间）默认大小比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-String的基本操作"><a href="#3-String的基本操作" class="headerlink" title="3.String的基本操作"></a>3.String的基本操作</h3><blockquote>
<p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列，并且必须是指向同一个String 类实例。</p>
</blockquote>
<h3 id="4-字符串拼接操作"><a href="#4-字符串拼接操作" class="headerlink" title="4.字符串拼接操作"></a>4.字符串拼接操作</h3><blockquote>
<ul>
<li>&#x3D;&#x3D;常量与常量&#x3D;&#x3D;的&#x3D;&#x3D;拼接结果在常量池&#x3D;&#x3D;，原理是编译器优化</li>
<li>常量池中不会存在相同内容的常量</li>
<li>&#x3D;&#x3D;只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder&#x3D;&#x3D;</li>
<li>如果拼接的结果调用intern( )方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
<li>字符串拼接操作不一定使用的是StringBuilder</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#第一个特点演示</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">#第三个特点演示</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;	<span class="comment">//编译器优化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;		<span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中 new String() 	</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 +s2;</span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s7);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s7);   <span class="comment">//false</span></span><br><span class="line">System.out.println(s6 == s7);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//intern( )方法，会判断字符串常量池中是否有内容为s6的字符串，如果存在，则返回常量池中该常量值对应的地址，如果字符串常量池中不存在，则在常量池中加载一份该值对应的常量，并返回该值对应的地址。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">System.out.println(s3 == s8);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如下的 s1 + s2 的执行细节</span></span><br><span class="line"><span class="comment">        ①StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">        ②s.append(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">        ③s.append(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">        ④s.toString()  --》约等于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;	<span class="comment">//这里字节码文件反编译之后 String s4 = s1 + s2;</span></span><br><span class="line">    System.out.println(s3 == s4);  <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意与上面问题的差别：在变量前加 final</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;    <span class="comment">//区别</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;   <span class="comment">//这里字节码文件反编译之后 String s4 = &quot;ab&quot;</span></span><br><span class="line">    System.out.println(s3 == s4);  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译器优化，，即非StringBuilder的方式。</li>
<li>针对于final修饰类、方法、基本数据类型、引用数据类型的将量的结构时，能使用上final的时候建议使用上</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式<ul>
<li>StringBuilder  s  &#x3D;  new StringBuilder();   s.append(“a”); </li>
<li>String  str &#x3D; “”   str &#x3D;  str +  “a”;  &#x2F;&#x2F;这种方式每次执行都会去创建StringBuilder对象和一个String对象</li>
</ul>
</li>
<li>好处：<ul>
<li>使用StringBuilder的append()的方式，自始至终只创建过一个StringBuilder对象。使用String的字符串拼接方式，创建过多个StringBuilder和String的对象</li>
<li>使用StringBuilder的append()的方式，内存中由于创建了较多的StringBuilder和String的对象，内存占用更大，如果进行GC，需要花费额外的时间。</li>
</ul>
</li>
<li>改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器，StringBuilder s &#x3D; new  StringBuilder(highLevel) ;  &#x2F;&#x2F;底层使用 new char[highLevel];</li>
</ul>
</blockquote>
<h3 id="5-intern-的使用"><a href="#5-intern-的使用" class="headerlink" title="&#x3D;&#x3D;5.intern( )的使用&#x3D;&#x3D;"></a>&#x3D;&#x3D;5.intern( )的使用&#x3D;&#x3D;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>).intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;rty&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;rty&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果不是双引号声明的String对象，可以使用String提供的intern( )方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
<li>比如 String  myInfo  &#x3D;  new  String(“I love  atguigu”).intern();</li>
<li>也就是说，如果在任意字符串上调用String.intern( )方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true。<ul>
<li>（”a” + “b” + “c” &#x3D;&#x3D; “abc”） &#x2F;&#x2F;true</li>
</ul>
</li>
<li>通俗点讲，&#x3D;&#x3D;Interned  String就是确保字符串在内存里只有一份拷贝，这样就可以节约内存空间&#x3D;&#x3D;，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池。（String  Intern  pool）</li>
</ul>
</blockquote>
<blockquote>
<p>如何保证变量s指向的是字符串常量池中的数据呢？</p>
<ul>
<li>方式1：String  s &#x3D; “hello”;</li>
<li>方式2：String  s &#x3D; new  String(“hello”).intern();</li>
<li>String s &#x3D; new StringBuilder().toString().intern();</li>
</ul>
</blockquote>
<blockquote>
<p>intern( )的空间效率测试：空间使用上。</p>
<p>&#x3D;&#x3D;结论：&#x3D;&#x3D;对于程序中大量存在的字符串，尤其其中存在很多重复字符串时，使用intern( )可以节省内存空间。</p>
</blockquote>
<h3 id="6-String-Table的垃圾回收"><a href="#6-String-Table的垃圾回收" class="headerlink" title="6.String Table的垃圾回收"></a>6.String Table的垃圾回收</h3><blockquote>
<ul>
<li>与堆中回收方式相同，也是通过minor GC,major GC</li>
</ul>
</blockquote>
<h3 id="7-G1中的String-去重操作"><a href="#7-G1中的String-去重操作" class="headerlink" title="7.G1中的String 去重操作"></a>7.G1中的String 去重操作</h3><blockquote>
<p>这里说到的去重去的是堆上存在的重复的String对象。而不是堆中字符串常量池中的字符串对象去重</p>
</blockquote>
<h3 id="8-String中的面试题"><a href="#8-String中的面试题" class="headerlink" title="8.&#x3D;&#x3D;String中的面试题&#x3D;&#x3D;"></a>8.&#x3D;&#x3D;String中的面试题&#x3D;&#x3D;</h3><blockquote>
<ul>
<li><p>&#x3D;&#x3D;Q1&#x3D;&#x3D;：new String(“ab”)会创建几个对象？看字节码，就知道是两个</p>
</li>
<li><p>A1：两个，一个对象是，new 关键字在堆空间创建的，另一个对象是：字符串常量池中的对象，字节码指令 ldc</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;Q2&#x3D;&#x3D;：new String(“a”) + new String(“b”)会创建几个对象呢？</p>
</li>
<li><p>A2：</p>
<ul>
<li>对象1：new  StringBuilder()</li>
<li>对象2：new String(“a”)</li>
<li>对象3：常量池中的a</li>
<li>对象4：new String(“b”)</li>
<li>对象5：常量池中的b</li>
<li>深入剖析：StringBuilder的toString( );</li>
<li>对象6：new String(“ab”)。&#x3D;&#x3D;但值得注意的是，toString ( )的调用，在字符串常量池中没有生成”ab”&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;Q3的代码就是针对下面的代码：&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s.intern();  <span class="comment">//调用此方法之前</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s == s2);    <span class="comment">//jdk6中返回false, jdk7/8: false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">//此时s3变量记录的地址为：new String(&quot;11&quot;);</span></span><br><span class="line"><span class="comment">//执行完上一行代码以后，字符串常量池中不存在&quot;11&quot;</span></span><br><span class="line">s3.intern();   <span class="comment">//所以在字符串常量池中生成&quot;11&quot;。</span></span><br><span class="line"><span class="comment">// 如何理解s3.intern()：jdk6:创建了一个新的对象&quot;11&quot;，也就有了新的地址.jdk7：此时常量池中并没有创建&quot;11&quot;,而是创建了一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;   <span class="comment">//s4变量记录的地址，使用的是上一行代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">//jdk6: false，jdk7/8：true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q4是上面Q3的变体：代码如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">//此时s3变量记录的地址为：new String(&quot;11&quot;);</span></span><br><span class="line"><span class="comment">//执行完上一行代码以后，字符串常量池中不存在&quot;11&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;   <span class="comment">//在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">s3.intern();   </span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结String的intern()的使用：</p>
<ul>
<li>jdk1.6中，将这个字符串对象尝试放入串池。<ul>
<li>如果串池中有，则并不会放入，返回已有的串池中的对象的地址</li>
<li>如果没有，&#x3D;&#x3D;会把此对象复制一份&#x3D;&#x3D;，放入串池，并返回串池中的对象地址</li>
</ul>
</li>
<li>jdk1.7起，将这个字符串对象尝试放入串池。<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，&#x3D;&#x3D;则会把对象的引用地址复制一份&#x3D;&#x3D;，放入串池，并返回串池中的引用地址</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="14-垃圾回收概述"><a href="#14-垃圾回收概述" class="headerlink" title="14.垃圾回收概述"></a>14.垃圾回收概述</h2><h3 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1.什么是垃圾"></a>1.什么是垃圾</h3><blockquote>
<ul>
<li>关于垃圾回收有三个经典问题：<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率，也是面试的重点。</li>
<li>什么是垃圾呢？<ul>
<li>垃圾是指在&#x3D;&#x3D;运行程序过程中没有任何指针指向的对象&#x3D;&#x3D;，这个对象就是需要被回收的垃圾</li>
</ul>
</li>
<li>如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一致保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li>
</ul>
</blockquote>
<h3 id="2-为什么需要GC"><a href="#2-为什么需要GC" class="headerlink" title="2.为什么需要GC"></a>2.为什么需要GC</h3><blockquote>
<ul>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，&#x3D;&#x3D;内存迟早都会被消耗完&#x3D;&#x3D;，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾收集也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ul>
</blockquote>
<h3 id="3-早期垃圾回收"><a href="#3-早期垃圾回收" class="headerlink" title="3.早期垃圾回收"></a>3.早期垃圾回收</h3><blockquote>
<ul>
<li>在c&#x2F;c++中，垃圾回收基本上是手工进行地。开发人员可以使用new 关键字进行内存分配，并使用delete关键字进行内存释放。</li>
<li>这种方式灵活控制内存释放地时间，但是会给开发人员带来频繁申请和释放内存地管理负担。一般忘了，就会造成内存泄漏。垃圾对象永远无法清除，随着系统运行时间地增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</li>
</ul>
</blockquote>
<h3 id="4-Java垃圾回收机制"><a href="#4-Java垃圾回收机制" class="headerlink" title="4.Java垃圾回收机制"></a>4.Java垃圾回收机制</h3><blockquote>
<ul>
<li>自动内存管理，无需开发人员手动参与内存地分配与回收，这样&#x3D;&#x3D;降低内存泄漏和内存溢出的风险&#x3D;&#x3D;</li>
<li>如果过度依赖于自动管理，这对于程序员来说就是一个黑匣子，会严重的弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须&#x3D;&#x3D;对这些自动化技术实施必要的监控和调节。&#x3D;&#x3D;</li>
<li>GC的作用区域主要是在方法区（元空间）和堆</li>
<li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。其中，Java堆是垃圾收集器的工作重点。</li>
<li>从次数上将：<ul>
<li>频繁收集新生代</li>
<li>较少收集老年代</li>
<li>基本不动永久Perm代（方法区、元空间）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-大厂面试题"><a href="#5-大厂面试题" class="headerlink" title="5.大厂面试题"></a>5.大厂面试题</h3><blockquote>
<ul>
<li><p>有哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1</p>
</li>
<li><p>JVM GC算法有哪些，目前的JDK版本采用什么回收算法</p>
</li>
<li><p>G1回收器讲下回收过程</p>
</li>
<li><p>GC是什么？为什么要有GC</p>
</li>
<li><p>GC的两种判定方法？CMS收集器与G1收集器的特点</p>
</li>
<li><p>说一下GC算法，分代回收说下</p>
</li>
<li><p>垃圾收集策略和算法</p>
</li>
<li><p>垃圾回收算法的实现原理</p>
</li>
<li><p>什么情况下触发垃圾回收</p>
</li>
<li><p>如何选择合适的垃圾收集算法</p>
</li>
<li><p>JVM有哪三种垃圾回收器</p>
</li>
<li><p>system.gc()和runtime.gc()会做什么事情</p>
</li>
<li><p>CMS解决什么问题，说一下回收的过程</p>
</li>
<li><p>CMS回收停顿了几次，为什么要停顿两次</p>
</li>
</ul>
</blockquote>
<h2 id="15-垃圾回收相关算法"><a href="#15-垃圾回收相关算法" class="headerlink" title="15.垃圾回收相关算法"></a>15.垃圾回收相关算法</h2><h3 id="1-标记阶段：引用计数算法"><a href="#1-标记阶段：引用计数算法" class="headerlink" title="1.标记阶段：引用计数算法"></a>1.标记阶段：引用计数算法</h3><blockquote>
<p><strong>垃圾标记阶段：对象存活判断</strong></p>
<ul>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象引用时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：&#x3D;&#x3D;引用计数算法和可达性分析算法&#x3D;&#x3D;</li>
</ul>
</blockquote>
<blockquote>
<p><strong>方式一：引用计数算法</strong></p>
<ul>
<li>引用计数算法（Reference Counting）比较简单，对每个对象&#x3D;&#x3D;保存一个整型的引用计数器属性，用于记录对象被引用的情况。&#x3D;&#x3D;</li>
<li>对于一个对象A,只要有任何一个对象引用了A,则A的引用计数器就加一，当引用失效时，引用计数器就减一。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li>
<li>优点：<ul>
<li>实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性</li>
</ul>
</li>
<li>缺点：<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销</li>
<li>引用计数器有一个致命的问题，即&#x3D;&#x3D;无法处理循环引用&#x3D;&#x3D;的情况，。这是一条致命缺陷，导致在&#x3D;&#x3D;Java的垃圾回收器中没有使用这类算法&#x3D;&#x3D;。【如循环链表中就存在循环引用的情况，会导致内存泄漏，但是举例的时候不要用这个，因为Java中没有采用这种方式】</li>
</ul>
</li>
<li>小结：<ul>
<li>Java并没有选择引用计数，是因为其存在一个基本的半屉，也就是很难处理循环引用关系。</li>
<li>python如何解决循环引用：<ul>
<li>手动解除，很好理解，就是在合适的时机，解除引用关系</li>
<li>使用弱引用weakref,weakref是python提供的标准库，旨在解决循环引用</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//5MB</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceTest1</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceTest1</span>();</span><br><span class="line">        <span class="type">ReferenceTest1</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceTest1</span>();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为,如果是使用的引用计数，则即便进行显式调用gc算法，也不会进行回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-标记阶段：可达性分析算法"><a href="#2-标记阶段：可达性分析算法" class="headerlink" title="2.标记阶段：可达性分析算法"></a>2.标记阶段：可达性分析算法</h3><blockquote>
<p><strong>方式二：可达性分析</strong>（或跟搜索算法、追踪行垃圾收集）</p>
<ul>
<li>相对于引用计数而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以&#x3D;&#x3D;有效地解决在引用计数算法中地循环引用地问题，防止内存泄漏地发生。&#x3D;&#x3D;</li>
<li>相对于引用计数算法，这里地可达性分析就是Java、c#选择地。这种类型的垃圾收集通常也叫做追踪性垃圾收集（Tracing Garbage Collection）</li>
<li>所谓”GC  Roots”跟集合就是一组必须活跃的引用</li>
<li>基本思路：<ul>
<li>可达性分析算法是以跟对象集合（GC Roots）为起始点，按照从上至下的方式搜索&#x3D;&#x3D;被跟对象集合所连接的目标对象是否可达。&#x3D;&#x3D;</li>
<li>使用可达性分析算法后，内存中的存活对象都会被跟对象集合直接或间接连接着，搜索所走过的路径称为引用链（reference chain）</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</li>
<li>在可达性分析算法中，只有能够被跟对象集合直接或间接连接的对象才是存活对象。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>在Java语言中，&#x3D;&#x3D;GC  Roots（指向堆中对象）包括以下几类元素&#x3D;&#x3D;：【面试常考】</p>
<ul>
<li>虚拟机栈中引用的对象：<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈JNI （通常说的本地方法）引用的对象</li>
<li>方法区中常量引用的对象<ul>
<li>比如字符串常量池（String Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如NullPointerException、OutOfMemoryError），系统类加载器</li>
</ul>
</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI注册的回调、本地代码缓存</li>
<li>除了这些固定的GC  Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性的加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）<ul>
<li>如果只针对Java堆中的某一块区域进行垃圾回收(比如：典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
</li>
<li>小技巧：<ul>
<li>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</li>
</ul>
</li>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作就必须在一个能保障一致性的快照中进行，这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致GC进行时必须stop the world的一个重要原因。<ul>
<li>即便时号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-对象的finalization机制"><a href="#3-对象的finalization机制" class="headerlink" title="3.对象的finalization机制"></a>3.对象的finalization机制</h3><blockquote>
<ul>
<li><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供&#x3D;&#x3D;对象被销毁之前的自定义处理逻辑。&#x3D;&#x3D;</p>
</li>
<li><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize( )方法</p>
</li>
<li><p>&#x3D;&#x3D;finalize( )方法允许在子类中被重写，用于在对象被回收时进行资源回收&#x3D;&#x3D;。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
</li>
<li><p>永远不要主动调用某个对象的finalize( )方法，应该交给垃圾回收机制调用，理由包括下面三点：</p>
<ul>
<li>在finalize( )时可能会导致对象复活</li>
<li>finalize( )方法的执行时间是没有保障的，他完全由GC线程决定，极端情况下，若不发生GC,则finalize( )方法将没有执行机会</li>
<li>一个糟糕的finalize( )会严重影响GC的性能</li>
</ul>
</li>
<li><p>从功能上来说，finalize（）方法与c++中的析构函数相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize( )方法在本质上不同于c++中的析构函数</p>
</li>
<li><p>由于finalize( )方法的存在，&#x3D;&#x3D;虚拟机中的对象一般处于三种可能的状态：&#x3D;&#x3D;</p>
<ul>
<li>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了，一般说来，此对象需要被回收。但事实上，也并非是非死不可的，这时候它们暂时处于缓刑阶段。&#x3D;&#x3D;一个无法触及的对象有可能在某一个条件下复活自己&#x3D;&#x3D;，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态，如下：<ul>
<li>&#x3D;&#x3D;可触及的&#x3D;&#x3D;：从根节点开始，可以达到这个对象</li>
<li>&#x3D;&#x3D;可复活的&#x3D;&#x3D;：对象的所有引用都被释放，但是对象有可能在finalize( )中复活</li>
<li>&#x3D;&#x3D;不可触及的&#x3D;&#x3D;：对象的finalize( )被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能复活，因为&#x3D;&#x3D;finalize( )只会被调用一次。&#x3D;&#x3D;</li>
</ul>
</li>
<li>以上三种状态中，是由于finalize( )方法的存在，进行的区分，只有在对象不可触及时才可以被回收</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>具体过程:</p>
<ul>
<li>判断一个对象objA是否可回收，至少要经历两次标记过程：<ol>
<li>如果对象objA到GC Roots没有引用链，则进行第一次标记</li>
<li>进行筛选，判断此对象是否有必要执行finalize( )方法<ol>
<li>如果对象objA没有重写finalize( )方法，或者finalize( )方法已经被虚拟机调用过，则虚拟机视为“没有必要执行” ，objA被判定为不可触及的。</li>
<li>如果对象objA重写了finalize( )方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize( )方法执行</li>
<li>&#x3D;&#x3D;finalize( )方法是对象逃脱死亡的最后机会&#x3D;&#x3D;，稍后GC会对F-Queue队列中的对象进行第二次标记。&#x3D;&#x3D;如果objA在finalize( )方法中与引用链上的任何一个对象建立了联系&#x3D;&#x3D;，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况，&#x3D;&#x3D;在这个情况下，finalize方法不会被再次调用&#x3D;&#x3D;，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次【不管有没有在finalize( )中复活都是一样的】。</li>
</ol>
</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeTest obj;  <span class="comment">//类变量,属于GC Roots</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用房前类重写的finalize方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;  <span class="comment">//当前待回收的对象在finalize（）方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">FinalizeTest</span>();</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            System.out.println(<span class="string">&quot;第一次 GC&quot;</span>);</span><br><span class="line">            <span class="comment">//因为finalizer线程优先级很低，暂停两秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二次GC&quot;</span>);</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//下面这段代码与上面的完全相同，但是这次自救失败了</span></span><br><span class="line">            System.gc();</span><br><span class="line">             <span class="comment">//因为finalizer线程优先级很低，暂停两秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-MAT与JProfile的GC-Roots溯源"><a href="#4-MAT与JProfile的GC-Roots溯源" class="headerlink" title="4.MAT与JProfile的GC Roots溯源"></a>4.MAT与JProfile的GC Roots溯源</h3><blockquote>
<p>类变量也是GC Roots</p>
</blockquote>
<h3 id="5-清除阶段：标记-清除算法"><a href="#5-清除阶段：标记-清除算法" class="headerlink" title="5.清除阶段：标记-清除算法"></a>5.清除阶段：标记-清除算法</h3><blockquote>
<ul>
<li><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存</p>
</li>
<li><p>目前在JVM中比较常见的三种垃圾收集算法是标记-清除算法（Mark-Sweep）、复制算法（Coping）、标记-压缩算法（Mark-Compact）</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>标记清除算法是一种非常基础和常见的垃圾收集算法</p>
</li>
<li><p>执行过程：</p>
<ul>
<li>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</li>
<li>标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象</li>
<li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有被标记为可达对象，则将其回收。</li>
</ul>
</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第14章_标记-清除算法.jpg" alt="第14章_标记-清除算法" style="zoom: 33%;" />

<blockquote>
<p>缺点：</p>
<ul>
<li>效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表</li>
</ul>
<p>&#x3D;&#x3D;注意：何为清除&#x3D;&#x3D;</p>
<ul>
<li>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表。下次有新对象需要加载时，判断垃圾的位置空间是否足够，如果够，就存放。</li>
</ul>
</blockquote>
<h3 id="6-清除阶段：复制算法"><a href="#6-清除阶段：复制算法" class="headerlink" title="6.清除阶段：复制算法"></a>6.清除阶段：复制算法</h3><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第14章_复制算法.jpg" alt="第14章_复制算法" style="zoom:33%;" />

<blockquote>
<p>背景：</p>
<ul>
<li>为了解决标记-清除算法在垃圾收集效率方面的缺陷</li>
</ul>
<p>核心思想：</p>
<ul>
<li>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>没有标记和清除阶段，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片问题”</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>此算法的缺点是明显的，就是需要两倍的内存空间</li>
<li>对于G1这种分拆成大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ul>
<p><strong>特别的：</strong></p>
<ul>
<li>如果系统中的垃圾对象很多，复制算法不会很理想，复制算法需要复制的存活对象数量并不会太大或者说非常低才行。</li>
</ul>
<p>应用场景:</p>
<ul>
<li>在新生代，对常规应用的垃圾回收，一次通常可以回收70% -  90%的内存空间，回收性价比很高。所以现在的商业虚拟机都适用这种收集算法回收新生代。</li>
</ul>
</blockquote>
<h3 id="7-清除阶段：标记-压缩算法"><a href="#7-清除阶段：标记-压缩算法" class="headerlink" title="7.清除阶段：标记-压缩算法"></a>7.清除阶段：标记-压缩算法</h3><blockquote>
<p>背景：</p>
<ul>
<li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，&#x3D;&#x3D;基于老年代垃圾回收的特性，需要使用其他的算法&#x3D;&#x3D;</li>
<li>虽然标记–清除算法可以应用在老年代，但是会产生内存碎片，所以在标记–清除的基础之上进行改进，标记–压缩算法由此诞生。</li>
</ul>
<p>执行过程：</p>
<ul>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放</li>
<li>之后，清理边界外所有空间。</li>
</ul>
</blockquote>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第14章_标记-压缩算法.jpg" alt="第14章_标记-压缩算法" style="zoom:33%;" />

<blockquote>
<ul>
<li>标记压缩算法的最终效果等同于标记–清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记–清除–压缩算法</li>
<li>二者的本质差异在于标记清除算法是一种非移动式的回收算法，标记压缩算法是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策</li>
<li>可以看到标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了很多开销。</li>
</ul>
<p>优点：</p>
<ul>
<li>消除了标记–清除算法当中，内存区域分散的特点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法房中，内存减半的高额代价</li>
</ul>
<p>缺点：</p>
<ul>
<li>从效率上来说，标记–压缩算法要低于复制算法</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动的过程中，需要全程暂停用户应用程序，即STW</li>
</ul>
</blockquote>
<h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h3><table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的两倍</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存</li>
<li>而为了尽量兼顾上面提到的三个指标，标记–整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记–清除多了一个整理内存的阶段</li>
</ul>
</blockquote>
<h3 id="9-分代收集算法"><a href="#9-分代收集算法" class="headerlink" title="9.分代收集算法"></a>9.分代收集算法</h3><blockquote>
<ul>
<li>前面所有这些算法中，它们都具有自己独特的优势和特点。分代收集算法应运而生。</li>
<li>分代收集算法，是基于这样一个事实，不同的对象的生命周期是不一样的。因此，&#x3D;&#x3D;不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。&#x3D;&#x3D;一般是把Java堆分为新生代和老年代，这样就可以根据哥哥年代的特点使用不同的回收算法，以提高垃圾回收效率。</li>
<li>&#x3D;&#x3D;目前几乎所有的GC都是采用分代收集（Generational Collection）算法执行垃圾回收的&#x3D;&#x3D;</li>
<li>在HotSpot中，基于分代的概念，GC所使用的内存回收算法，必须结合年轻代和老年代各自的特点。<ul>
<li>年轻代：<ul>
<li>特点：区域相对老年代较小，对象生命周期、存活率低、回收频繁。</li>
<li>这种情况复制算法的回收整理，速度是最快的，复制算法的效率只和当前存活对象有关，因此很适用于年轻代的回收，而复制算法内存利用率不高的问题，通过Hotspot中的两个survivor的设计得到缓解。</li>
</ul>
</li>
<li>老年代：<ul>
<li>特点：区域较大、对象生命周期长、存活率高，回收不及年轻代频繁。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除与标记整理（压缩）的混合实现<ul>
<li>Mark阶段的开销与存活对象的数量成正比</li>
<li>Sweep阶段的开销与所管理区域的大小成正比</li>
<li>Caompact阶段的开销与存活对象的数据成正比</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在Hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施;当内存回收不佳（碎片导致的Concurrent MOde Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理</li>
</ul>
</blockquote>
<h3 id="10-增量收集算法、分区算法"><a href="#10-增量收集算法、分区算法" class="headerlink" title="10.增量收集算法、分区算法"></a>10.增量收集算法、分区算法</h3><blockquote>
<p>增量收集算法：</p>
<ul>
<li>上述现有的算法，在垃圾回收的过程中，应用软件会处理一种stoop the world的状态，在stop the world的状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。&#x3D;&#x3D;如果 垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性&#x3D;&#x3D;。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集算法。</li>
<li>基本思想：<ul>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，&#x3D;&#x3D;垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。&#x3D;&#x3D;</li>
<li>总的来说，增量收集算法的基础仍然是标记清除算法和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</li>
</ul>
</li>
<li>缺点：<ul>
<li>使用这种方式，由于在垃圾回收过程中，间断性地还执行应用程序代码，所以能减少系统的停顿时间。但是，&#x3D;&#x3D;因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>分区算法：</p>
<ul>
<li>一般说来，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长，为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li>
<li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小空间</li>
<li>每一个小区间都独立使用，独立回收，这种算法的好处是可以控制一次回收多少个小区间</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>上面这些只是基本的算法思路，实际GC实现过程中要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</li>
</ul>
</blockquote>
<h2 id="16-垃圾回收相关概念"><a href="#16-垃圾回收相关概念" class="headerlink" title="16.垃圾回收相关概念"></a>16.垃圾回收相关概念</h2><h3 id="1-System-gc（）的理解"><a href="#1-System-gc（）的理解" class="headerlink" title="1.System.gc（）的理解"></a>1.System.gc（）的理解</h3><blockquote>
<ul>
<li><p>在默认情况下，通过System.gc( )或者Runtime.getRuntime( ).gc()的调用，&#x3D;&#x3D;会显式触发Full GC，&#x3D;&#x3D;同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
</li>
<li><p>然而System.gc（）调用附带一个免责声明，无法保证对垃圾收集器的调用。</p>
</li>
<li><p>JVM实现者可以通过System.gc( )调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无需手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之前调用System.gc( )</p>
</li>
</ul>
</blockquote>
<h3 id="2-内存溢出与内存泄漏"><a href="#2-内存溢出与内存泄漏" class="headerlink" title="2.内存溢出与内存泄漏"></a>2.内存溢出与内存泄漏</h3><blockquote>
<p>内存溢出：</p>
<ul>
<li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用</li>
<li>javadoc中对OutOfMemoryError的解释是，&#x3D;&#x3D;没有空闲内存，并且垃圾收集器也无法提供更多内存。&#x3D;&#x3D;</li>
<li>没有空闲内存的情况，说明Java虚拟机的堆内存不够，原因有二：<ul>
<li>Java虚拟机的堆内存设置不够：<ul>
<li>比如，可能存在内存泄漏问题，也很有可能就是堆的大小设置不合理，可以通过参过参数 -Xms,-Xmx来调整。</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>
</ul>
</li>
</ul>
</li>
<li>在抛出OOM之前，通常垃圾收集器会被触发，尽其所能去清理出空间<ul>
<li>例如，在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</li>
<li>在java.nio.Bits.reserveMemory( )方法中，我们能清楚的看到，System.gc( )会被调用，以清理空间</li>
</ul>
</li>
<li>当然，也不是在任何情况下垃圾收集器都会被触发<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题。所以直接抛出OOM.</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>内存泄漏：</p>
<ul>
<li>&#x3D;&#x3D;严格来说&#x3D;&#x3D;，只有对象不会再被程序用到了，但是GC又不能回收它们的情况，才叫内存泄漏</li>
<li>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM,也可以叫做&#x3D;&#x3D;宽泛意义上的内存泄漏。&#x3D;&#x3D;</li>
<li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OOM异常，导致程序崩溃</li>
<li>注意：这里的存储空间并不是指物理内存，而是指虚拟机内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li>
<li>举例：<ul>
<li>单例模式：单例的生命周期和应用程序一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生</li>
<li>一些提供close的资源未关闭导致内存泄漏<ul>
<li>数据库连接（datasource.getConnection）,网络连接（socket）和io连接必须手动close,否则是不能被回收的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-Stop-The-World"><a href="#3-Stop-The-World" class="headerlink" title="3.Stop The  World"></a>3.Stop The  World</h3><blockquote>
<ul>
<li>简称STW,指的是GC事件发生过程中，会产生应用程序的停顿，停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW.<ul>
<li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行程序停顿<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li>&#x3D;&#x3D;如果出现分析过程中对象引用关系还在不断发生变化，则分析结果的准确性无法保证&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</li>
<li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不断造成电影卡带一样，所以我们需要减少STW的发生。</li>
<li>STW事件和采用哪款GC无关，所有的GC都有这个实践</li>
<li>哪怕是G1收集器也不能完全避免STW情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间</li>
<li>STW是JVM在后台自动发起和自动完成地。在用户不可见地情况下，把用户正常地工作线程全部停掉。</li>
<li>开发中不要用System.gc( ),会导致Stop-the-world地发生</li>
</ul>
</blockquote>
<h3 id="4-垃圾回收的并行与并发"><a href="#4-垃圾回收的并行与并发" class="headerlink" title="4.垃圾回收的并行与并发"></a>4.垃圾回收的并行与并发</h3><blockquote>
<p>并发：</p>
<ul>
<li>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li>
<li>并发不是真正意义上地同时进行，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理地速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时运行。</li>
</ul>
</blockquote>
<blockquote>
<p>并行：</p>
<ul>
<li>当系统有一个以上CPU时，当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）</li>
<li>其实决定并行地因素并不是CPU地数量，而是CPU地核心数量，比如一个CPU多个核也可以并行。</li>
<li>适合科学计算，后台处理等弱交互场景</li>
</ul>
</blockquote>
<blockquote>
<p>二者对比：</p>
<ul>
<li><p>并发：指的是多个事情，在同一时间段内同时发生了</p>
</li>
<li><p>并行：指的是多个事情，在同一时间点上同时发生了</p>
</li>
<li><p>并发地多个任务之间是互相抢占资源的</p>
</li>
<li><p>并行地多个人物之间是不互相抢占资源地</p>
</li>
<li><p>只有在多CPU或者一个CPU多核地情况中，才会发生并行，否则看似同时发生地事情，其实都是并发执行的。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>垃圾回收的并发与并行：</p>
<ul>
<li>在讨论垃圾收集器的上下文语境中，它们可以解释为：</li>
<li>并行（Parallel）&#x3D;&#x3D;:指多条垃圾收集线程并行工作&#x3D;&#x3D;，但此时用户线程仍处于等待状态，<ul>
<li>如ParNew,Parallel Scavenge,Parallel Old</li>
</ul>
</li>
<li>串行（Serial）:<ul>
<li>相较于并行的概念，单线程执行</li>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
</li>
<li>并发（Concurrent）：<ul>
<li>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行<ul>
<li>用户程序再继续运行，而垃圾收集程序线程运行于另一个CPU上</li>
<li>如：CMS,G1</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-安全点与安全区域"><a href="#5-安全点与安全区域" class="headerlink" title="5.安全点与安全区域"></a>5.安全点与安全区域</h3><blockquote>
<p>安全点：</p>
<ul>
<li>程序执行时，并非所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC,这些位置称为“安全点（safepoint）”</li>
<li>safepoint的选择很重要，如果太少可能会导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“&#x3D;&#x3D;是否具有让程序长时间执行的特征为标准&#x3D;&#x3D;。”比如：&#x3D;&#x3D;选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<blockquote>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<ul>
<li>抢先式中断：（目前没有虚拟机采用了）<ul>
<li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点</li>
</ul>
</li>
<li>主动式中断：<ul>
<li>设置一个中断标志，各个线程运行到Safe  Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>安全区域(Safe region)：</p>
<ul>
<li><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序不执行的时候呢？例如线程处于Sleep状态或blocked状态，这时候线程无法响应JVM的中断请求，走到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域来解决。</p>
</li>
<li><p>&#x3D;&#x3D;安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的，&#x3D;&#x3D;我们可以把safe  region看作是被扩展了的Safepoint</p>
</li>
<li><p>实际执行时，</p>
<ul>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC,JVM会忽略标识为Safe Region状态的线程</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC,如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="6-再谈引用：强引用"><a href="#6-再谈引用：强引用" class="headerlink" title="6.再谈引用：强引用"></a>6.再谈引用：强引用</h3><blockquote>
<ul>
<li>我们希望能描述这样一类对象，当内存空间还足够的时候，则能保留在内存中，如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</li>
<li>&#x3D;&#x3D;偏门但热门的面试题：&#x3D;&#x3D;<ul>
<li>&#x3D;&#x3D;强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？&#x3D;&#x3D;</li>
</ul>
</li>
<li>在jdk1.2版本之后，Java对引用的的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种，这四种引用强度逐渐减弱</li>
<li>除强引用外，其他三种引用均可以在java.lang.ref包中找到它们的身影，下图显式了这三种引用类型对应的类，开发人员可以直接使用它们。</li>
<li><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220510091527332.png" alt="image-20220510091527332"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Reference子类中只有终结器引用（FinalReference）是包内可见的，其他三种引用类型均为public，可以在应用程序中直接使用。<ul>
<li>强引用：最传统的引用的定义，是指在程序代码中普遍存在的引用赋值，即类似Object obj &#x3D; new Object();这种引用关系，&#x3D;&#x3D;无论在何种情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象。&#x3D;&#x3D;</li>
<li>软引用：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。【内存就回收，够就不回收】【缓存中使用】</li>
<li>弱引用：被软引用关联的对象只能生存到下一次垃圾收集前，&#x3D;&#x3D;当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象&#x3D;&#x3D;【缓存中使用】</li>
<li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来获得一个对象的实例。&#x3D;&#x3D;为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知&#x3D;&#x3D;【用于对象被回收的跟踪】</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><font color='red'>强引用：</font></p>
<ul>
<li>Java程序中，最常见的引用类型就是强引用，也就是最常见的普通对象引用，也是默认的引用类型。</li>
<li>&#x3D;&#x3D;强引用的对象是可触及的，垃圾回收器就永远不会回收这个引用指向的对象&#x3D;&#x3D;</li>
<li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强)引用赋值为null,就是可以被当作垃圾被收集了，当然具体回收实际要看垃圾回收策略。</li>
<li>相对地，软引用、弱引用和虚引用的对象都是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的，所以，&#x3D;&#x3D;强引用是造成Java内存泄漏的主要原因之一。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="7-再谈引用：软引用"><a href="#7-再谈引用：软引用" class="headerlink" title="7.再谈引用：软引用"></a>7.再谈引用：软引用</h3><blockquote>
<ul>
<li><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
</li>
<li><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列。</p>
</li>
<li><p>类似弱引用，只不过Java虚拟机会尽量让软引用地存活时间长一些，迫不得已才清理。</p>
</li>
<li><p>内存不够时，不会回收软引用指向地对象。当内存不够时，会回收软引用地可达对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj); <span class="comment">//此时结束Object对象有一个强引用obj,和一个软引用sf</span></span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">//销毁强引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的代码等价于下面代码</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">Objent</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过软引用获取对象</span></span><br><span class="line">sf.get();  <span class="comment">//可以获取到new Object()这个对象，如果在报OOM之前，就要回收软引用指向的对象  </span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-Xms30m -Xmx30m -XX:+PrintGCDetails  参数设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">int</span>[]&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>]); <span class="comment">//8M</span></span><br><span class="line">        sf.get()[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        System.out.println(sf.get());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//16M</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(sf.get());</span><br><span class="line">            System.out.println(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-再谈引用：弱引用"><a href="#8-再谈引用：弱引用" class="headerlink" title="8.再谈引用：弱引用"></a>8.再谈引用：弱引用</h3><blockquote>
<ul>
<li><p>弱引用也是用来描述那些非必需对象，&#x3D;&#x3D;只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。&#x3D;&#x3D;在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</p>
</li>
<li><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快的发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间</p>
</li>
<li><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
</li>
<li><p>&#x3D;&#x3D;弱引用、软引用都非常适合来保存那些可有可无的缓存数据。&#x3D;&#x3D;如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长时间，从而起到加速系统的作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj); <span class="comment">//此时结束Object对象有一个强引用obj,和一个弱引用wf</span></span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">//销毁强引用</span></span><br><span class="line"></span><br><span class="line">wf.get()  获取引用指向的对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用对象与软引用对象的最大不同就在于：当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收，弱引用对象更容易、更快被GC回收</p>
</li>
<li><p>面试题：你开发中使用过WeakHashMap</p>
</li>
</ul>
</blockquote>
<h3 id="9-再谈引用：虚引用"><a href="#9-再谈引用：虚引用" class="headerlink" title="9.再谈引用：虚引用"></a>9.再谈引用：虚引用</h3><blockquote>
<ul>
<li>虚引用（Phantom Reference）——对象回收跟踪</li>
<li>也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个</li>
<li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时可能被垃圾回收器回收</li>
<li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当时图通过虚引用的get()方法获取对象时，总是null。</li>
<li>&#x3D;&#x3D;为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;虚引用必须和引用队列一起使用&#x3D;&#x3D;。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，&#x3D;&#x3D;将这个虚引用加入引用队列，以通知应用程序对象的回收情况。&#x3D;&#x3D;</li>
<li>由于虚引用可以跟踪对象的回收时间，因此也可以将一些资源释放操作放置在虚引用中执行和记录。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomTest obj;</span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomTest&gt; phantomQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = ((PhantomReference) phantomQueue.remove());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程，PhantomTest实例被回收了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>); <span class="comment">//设置为守护线程，就是主线程不关闭，就也一直不关闭。当程序中没有非守护线程时，守护线程也就结束。垃圾回收线程也是守护线程</span></span><br><span class="line">        t.start(); <span class="comment">//开启守护线程</span></span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;PhantomTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomTest</span>();</span><br><span class="line">        <span class="comment">//构造了PhantomTest对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomTest&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj,phantomQueue);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可通过虚引用来获取引用指向的对象</span></span><br><span class="line">            System.out.println(phantomReference.get());</span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是可用的&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是可用的&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-再谈引用：终结器引用-了解即可"><a href="#10-再谈引用：终结器引用-了解即可" class="headerlink" title="10.再谈引用：终结器引用(了解即可)"></a>10.再谈引用：终结器引用(了解即可)</h3><blockquote>
<p>终结器引用：FinalReference</p>
<ul>
<li>它用以实现对象的finalize()方法，也可以称为终结器引用</li>
<li>无需手动编码，其内部配合引用队列使用</li>
<li>在GC时，终结器引用入队，由Finallizer线程通过终结器引用找到被引用对象并调用它的finalize( )方法，第二次GC时才能回收被引用对象。</li>
</ul>
</blockquote>
<h2 id="17-垃圾回收器"><a href="#17-垃圾回收器" class="headerlink" title="17.垃圾回收器"></a>17.垃圾回收器</h2><h3 id="1-GC分类与性能指标"><a href="#1-GC分类与性能指标" class="headerlink" title="1.GC分类与性能指标"></a>1.GC分类与性能指标</h3><blockquote>
<p><font color='red'>垃圾回收器概述：</font></p>
<ul>
<li>从不同角度分析垃圾收集器，可以将GC分为不同的类型<ul>
<li>按线程数（指的是执行垃圾回收的线程）<ul>
<li>串行回收</li>
<li>并行回收</li>
</ul>
</li>
<li>按照工作模式分<ul>
<li>并发式垃圾回收器<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li>
</ul>
</li>
<li>独占式垃圾回收器<ul>
<li>独占式垃圾回收器（stop the world）一旦运行,就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li>
</ul>
</li>
</ul>
</li>
<li>按碎片处理方式分：<ul>
<li>压缩式垃圾回收器<ul>
<li>在垃圾回收完成后，对存活对象进行压缩整理，清除回收后的碎片</li>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li>非压缩式垃圾回收器<ul>
<li>非压缩式的垃圾回收器不进行这步操作</li>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
</ul>
</li>
<li>按工作的内存区间分：<ul>
<li>年轻代垃圾回收器</li>
<li>老年代垃圾回收器</li>
</ul>
</li>
</ul>
</li>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>
<li>串行回收默认默认被应用在客户端的Client模式下的JVM中</li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li>
</ul>
</li>
<li>和串行回收相反。并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop the world”机制</li>
</ul>
<p><font color='red'>评估GC的性能指标：</font></p>
<ul>
<li>&#x3D;&#x3D;吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间&#x3D; 程序的运行时间 + 内存回收的时间）&#x3D;&#x3D;</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间占总运行时间的比例</li>
<li>&#x3D;&#x3D;暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间&#x3D;&#x3D;</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率</li>
<li>&#x3D;&#x3D;内存占用：Java堆区所占的内存大小&#x3D;&#x3D;</li>
<li>快速：一个对象从诞生到被回收所经历的时间</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>吞吐量、暂停时间、内存占用这三者共同构成一个不可能三角，三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项</p>
</li>
<li><p>在实际过程中，主要&#x3D;&#x3D;抓吞吐量、暂停时间这两点&#x3D;&#x3D;，因为内存占用随着硬件性能发展而能够有所改善</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>吞吐量：</p>
<ul>
<li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;(运行用户代码时间 + 垃圾收集时间)<ul>
<li>比如：虚拟机总共运行100分钟，其中垃圾收集花掉一分钟，那吞吐量就是99%</li>
</ul>
</li>
<li>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</li>
<li>吞吐量优先，意味着单位时间内，STW的时间最短</li>
</ul>
<p>暂停时间：</p>
<ul>
<li>暂停时间是指一个时间段内应用程序线程暂停，让GC线程执行的状态</li>
<li>暂停时间优先，意味着尽可能让单次STW的时间最短：</li>
</ul>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第17章_吞吐量与暂停时间.jpg" alt="第17章_吞吐量与暂停时间" style="zoom: 33%;" />

<ul>
<li>红色表示暂停时间或者垃圾回收时间，蓝色表示应用程序线程执行时间</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>&#x3D;&#x3D;高吞吐量&#x3D;&#x3D;较好因为这会让应用程序的最终用户感觉只有应用程序线程在做生产性工作，直觉上，吞吐量越高程序运行越快。</li>
<li>&#x3D;&#x3D;低暂停时间&#x3D;&#x3D;（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，&#x3D;&#x3D;有时候甚至短暂的200毫秒暂停都可能打断终端用户体验&#x3D;&#x3D;。因此，具有低的较大暂停时间是非常重要的，&#x3D;&#x3D;特别是对于一个交互式应用程序。&#x3D;&#x3D;</li>
<li>不幸的是高吞吐量和低暂停时间是一对相互竞争的目标（矛盾）<ul>
<li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
</li>
<li>一个GC算法只能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</li>
<li>现在的标准：&#x3D;&#x3D;在最大吞吐量优先的情况下，降低停顿时间。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="2-不同的垃圾回收器概述"><a href="#2-不同的垃圾回收器概述" class="headerlink" title="2.不同的垃圾回收器概述"></a>2.不同的垃圾回收器概述</h3><blockquote>
<p>&#x3D;&#x3D;面试题：Java常见的垃圾收集器有哪些？&#x3D;&#x3D;</p>
<ul>
<li>串行回收器：Serial&#x2F;Serial old  （这里地串行指地是单个垃圾收集线程）</li>
<li>并行回收器：ParNew，Parallel Scavenge，Parallel  Old  （并行指的是多个垃圾收集线程，如果有多个CPU或单个CPU多核话，就可以充分利用这些物理硬件地资源。如果是单核地话，则多个垃圾收集线程是并发执行，在执行过程中会发生任务切换，资源竞争）</li>
<li>并发回收器：CMS,G1（这里的并发是指在进行垃圾收集时，让垃圾收集线程与用户应用程序线程并发执行)</li>
</ul>
<p><img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第17章_经典的7种GC.jpg" alt="第17章_经典的7种GC"></p>
</blockquote>
<blockquote>
<ul>
<li>新生代收集器：Serial、ParNew、Parallel  Scavenge</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS</li>
<li>整堆收集器：G1</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端、服务器，所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾回收性能。</li>
<li>虽然我们会对哥哥收集器进行比较，但是并非为了挑选一个最好的垃圾收集器出来，没有这样一个完美方案，所以&#x3D;&#x3D;我们选择的只是对具体应用场景最合适的收集器。&#x3D;&#x3D;</li>
</ul>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第17章_垃圾收集器组合.jpg" alt="第17章_垃圾收集器组合" style="zoom:33%;" />

<ul>
<li><p>虚线是在jdk 8之后被弃用的组合。</p>
</li>
<li><p>实线表示在在jdk8中还在使用的</p>
</li>
<li><p>在jdk8中,使用的是 Parallel Scavenge GC(parallel GC)与Parallel old  GC搭配</p>
</li>
<li><p>在jdk9中则使用的是G1GC</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><font color='red'>如何查看默认的垃圾收集器：</font></p>
<ul>
<li>-XX:+PrintCommandLineFlags:擦好看命令行相关参数（包含使用的垃圾收集器）</li>
<li>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</li>
</ul>
</blockquote>
<h3 id="3-Serial回收器：串行回收"><a href="#3-Serial回收器：串行回收" class="headerlink" title="3.Serial回收器：串行回收"></a>3.Serial回收器：串行回收</h3><blockquote>
<ul>
<li><p>Serial收集器作为Hotspot中client模式下的默认新生代垃圾收集器</p>
</li>
<li><p>&#x3D;&#x3D;Serial收集器采用复制算法，串行回收和Stop the world机制的方式执行内存回收&#x3D;&#x3D;</p>
</li>
<li><p>除了年轻代以外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。&#x3D;&#x3D;Serial Old收集器同样也采用了串行回收和stop the world机制，只不过内存回收算法使用的是标记压缩算法&#x3D;&#x3D;</p>
<ul>
<li>serial old是运行在client模式下默认的老年代的垃圾回收器</li>
<li>serial old在server模式下主要有两个用途，①与新生代的parallel scavenge 配合使用。②作为老年代CMS收集器的后背垃圾收集方案</li>
</ul>
</li>
<li><p>这个收集器是一个单线程的收集器，但它的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop the world）。</p>
</li>
<li><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在Client模式下的虚拟机是个不错的选择</li>
</ul>
</li>
<li><p>在HotSpot虚拟机中，使用 -XX:+UseSerialGC参数可以指定年轻代和老年代都适用串行收集器</p>
<ul>
<li>等价于 新生代使用 Serial GC，老年代使用 Serial Old GC</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>这种垃圾收集器了解即可，现在用的比较少，而且在限定单核cpu才可以用，现在都不是单核的了</li>
<li>对于交互较强的应用而言，这种垃圾收集器是不能接受的，一般在Java Web应用程序中是不会采用串行垃圾收集器的</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4-ParNew回收器：并行回收"><a href="#4-ParNew回收器：并行回收" class="headerlink" title="4.ParNew回收器：并行回收"></a>4.ParNew回收器：并行回收</h3><blockquote>
<ul>
<li>如果说Serial GC是年轻代 中的单线程垃圾收集器，那么在ParNew收集器则是Serial收集器的多线程版本<ul>
<li>Par是Parallel的缩写，New：只能处理的是新生代</li>
</ul>
</li>
<li>ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、“Stop the world”机制</li>
<li>ParNew是很多JVM运行在Server模式下新生代的默认垃圾回收器。</li>
<li>对于新生代，回收次数频繁，使用并行方式高效</li>
<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li>
<li>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的收集效率在任何场景下都会比Serial收集器高效呢？<ul>
<li>不一定，因为在单CPU的环境下，ParNew收集器不比Serial收集器更高效，虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生地一些额外开销。</li>
</ul>
</li>
<li>在程序中，开发人员可以通过选项 -XX:+UseParNewGC手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代</li>
<li>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同地线程数。</li>
</ul>
</blockquote>
<h3 id="5-Parallel回收器：吞吐量优先"><a href="#5-Parallel回收器：吞吐量优先" class="headerlink" title="5.Parallel回收器：吞吐量优先"></a>5.Parallel回收器：吞吐量优先</h3><blockquote>
<ul>
<li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了&#x3D;&#x3D;复制算法，并行回收和Stop the world机制&#x3D;&#x3D;</p>
</li>
<li><p>那么Parallel收集器的出现是否多此一举呢？</p>
<ul>
<li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个&#x3D;&#x3D;可控制的吞吐量&#x3D;&#x3D;（Throughput），它也被称为吞吐量优先的垃圾收集器</li>
<li>自适应调节策略也是Parallel Scavenge与ParNew的一个重要区别</li>
</ul>
</li>
<li><p>高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，&#x3D;&#x3D;主要适合在后台运算而不需要太多交互的任务&#x3D;&#x3D;。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>Parallel 收集器在jdk1.6时提供了用于执行老年代收集的Parallel Old收集器，用来代替老年代的Serial Old收集器</p>
</li>
<li><p>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和stop the world机制</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在程序吞吐量优先的场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错</li>
<li>在Java 8中，默认也是此垃圾收集器</li>
</ul>
<p><font color='red'>参数配置：</font></p>
<ul>
<li>-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务</li>
<li>-XX:+UseParallelOldGC 手动指定老年代都是使用并行回收收集器<ul>
<li>分别适用于新生代和老年代。默认jdk8是开启的</li>
<li>上面两个参数，默认开启一个，另一个也会被开启（互相激活）</li>
</ul>
</li>
<li>-XX:ParallelGCThreads:设置年轻代并行收集器的线程数，一般地，最好与CPU数量相等，以避免过多的线程数量影响垃圾收集性能<ul>
<li>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</li>
<li>当CPU数量大于8个时，ParallelGCThreads的值等于 （3+【5*CPU_count】&#x2F;8）</li>
</ul>
</li>
<li>-XX：MaxGCPauseMillis设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。<ul>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMillis以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好，但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制</li>
<li>该参数使用需谨慎。</li>
</ul>
</li>
<li>-XX:GCTimeRatio 垃圾收集时间占总时间的比例用于衡量吞吐量的大小<ul>
<li>取值范围（0，100）.默认值是99，也就是垃圾回收时间不超过1%</li>
<li>与前一个-XX:MaxGCPauseMills参数有一定矛盾性。暂停时间越长，Ratio参数就越容易超过设定的比例。</li>
</ul>
</li>
<li>-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节能力<ul>
<li>在这种模式下，年轻代的大小、Eden和survivor的比例、晋升老年代的对象年龄（阈值）等参数会被自动调整，以此来达到堆大小、吞吐量和停顿时间之间的平衡点</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="6-CMS回收器：低延迟"><a href="#6-CMS回收器：低延迟" class="headerlink" title="6.CMS回收器：低延迟"></a>6.CMS回收器：低延迟</h3><blockquote>
<ul>
<li><p>在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可以认为有划时代意义的垃圾收集器，CMS(Concurrent Mark Sweep)收集器，&#x3D;&#x3D;这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作&#x3D;&#x3D;</p>
</li>
<li><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li>目前很大一部分的Java应用集中在互联网网站或者B&#x2F;S系统的服务器上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验，CMS收集器就非常适合这类应用的需求。</li>
</ul>
</li>
<li><p>CMS的垃圾收集算法采用&#x3D;&#x3D;标记-清除&#x3D;&#x3D;算法，并且也会stop the world（只是尽可能地减短stw的时间）</p>
</li>
<li><p>CMS作为老年代的收集器，却无法与jdk1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在jdk1.5使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个</p>
</li>
<li><p>在G1（jdk9中开始成为默认的垃圾回收器）出现之前，CMS的使用还是比较广泛的（在jdk14中就被永久去除了）</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p>
<ul>
<li>初始标记阶段（Initial Mark）:在这个阶段中，程序中所有的工作线程都将会因为stop the world机制而出现短暂的暂停，这个阶段的主要任务&#x3D;&#x3D;仅仅只是标记出GC Roots能直接关联到的对象&#x3D;&#x3D;。一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里的速度比较快。</li>
<li>并发标记阶段（Concurrent Mark）：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要暂停用户线程，可以与垃圾手机线程一起并发执行。</li>
<li>重新标记阶段（Remark）:由于在&#x3D;&#x3D;并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或交叉运行（）&#x3D;&#x3D;，因此为了修正并发标记期间，因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>并发清除阶段：此阶段清理删掉标记阶段判断的已经死亡的对象，释放内存空间，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>尽管CMS收集器采用的是并发回收（非独占式），&#x3D;&#x3D;但是在其初始化标记和再次标记这两个阶段中仍然需要执行Stop the world机制&#x3D;&#x3D;暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop the world”,只是尽可能地缩短暂停时间</li>
<li>&#x3D;&#x3D;由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。&#x3D;&#x3D;</li>
<li>另外，由于在垃圾收集阶段用户线程没有中断，&#x3D;&#x3D;所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用&#x3D;&#x3D;。因此CMS收集器不能像其他收集器那样，等到老年代几乎完全被填满了再进行收集，而是&#x3D;&#x3D;当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行&#x3D;&#x3D;。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次Concurrent  Mode  Failure失败，这时虚拟机将启动后备预案，临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
<li>由于CMS垃圾收集器采用的&#x3D;&#x3D;是标记-清除算法&#x3D;&#x3D;，所以不可避免的&#x3D;&#x3D;会产生一些内存碎片&#x3D;&#x3D;。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞技术，而只能够选择空闲列表（Free List）执行内存分配。</li>
<li>有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？<ul>
<li>因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提是它运行的资源不受影响。Mark Compact更适合Stop the world这种场景下使用。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>CMS的优点：</p>
<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<p>CMS的弊端：</p>
<ul>
<li>会产生内存碎片。导致并发清除后，用户线程可用的空间不足，在无法分配大对象的情况下，不得不提前触发Full GC</li>
<li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低</li>
<li>CMS收集器无法处理浮动垃圾。可能出现Concurrent Mode Failure失败而导致另一次Full GC产生，在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在进行下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ul>
</blockquote>
<blockquote>
<p>CMS收集器可以设置的参数：</p>
<ul>
<li>-XX:+UseConcMarkSweepGC 手动指定使用CMS收集器执行内存回收任务<ul>
<li>开启该参数后会自动将 -XX:+UseParNewGC打开，&#x3D;&#x3D;即：ParNew(young区使用)+CMS(old区使用)+Serial Old （old区备用）的组合&#x3D;&#x3D;</li>
</ul>
</li>
<li>-XX:CMSInitiatingOccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。<ul>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。&#x3D;&#x3D;JDK6及以上版本默认值为92%&#x3D;&#x3D;</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序中内存使用率增长很快，则应该降低这个阈值，以避免频繁地触发老年代串行收集器，因此通过该选项便可以有效降低Full GC的执行次数</li>
</ul>
</li>
<li>-XX:+UseCMSCompactAtFullCollection 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并行执行，所带来的问题就是停顿时间更长了。</li>
<li>-XX:CMSFullGCsBeforeCompaction 设置在执行多少次Full GC后对内存空间进行压缩整理。</li>
<li>-XX:ParallelCMSThreads:设置CMS的线程数量<ul>
<li>CMS默认启动的线程数量是（ParallelGCThreads + 3）&#x2F;4</li>
<li>ParallelGCThreads 是年轻代并行执行收集器的线程数。当CPU资源比较紧张的时候，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>小结：</p>
<p>怎样进行选择这些垃圾回收器呢？</p>
<ul>
<li>如果想要最小化地使用内存和并行开销，则选Serial GC</li>
<li>如果想要最大化应用程序地吞吐量，请选择Parallel GC</li>
<li>如果你想要最小化GC的中断或停顿时间，请选CMS GC</li>
</ul>
<p>新特性：</p>
<ul>
<li>jdk 9新特性：CMS被标记为Deprecate了<ul>
<li>可以继续用，但是会有警告</li>
</ul>
</li>
<li>jdk14新特性：删除了CMS垃圾收集器<ul>
<li>会报警告信息，不能用会自动按照该版本下的GC来进行使用。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="7-G1回收器：区域化分代式"><a href="#7-G1回收器：区域化分代式" class="headerlink" title="7.G1回收器：区域化分代式"></a>7.G1回收器：区域化分代式</h3><blockquote>
<ul>
<li><p>问题：既然已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）GC?</p>
<ul>
<li>回答：应用程序所对应的业务越来越庞大，复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化，，于是就有了G1 GC。</li>
<li>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量</li>
<li>官方给G1设定的目标是在延迟可控的情况i下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</li>
</ul>
</li>
<li><p>为什么名字叫Garbage First（G1）呢？</p>
<ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）(物理上不连续)。使用不同的region来表示Eden、幸存者0区，幸存者1区，老年代等</li>
<li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，&#x3D;&#x3D;每次根据允许的收集时间，优先回收价值最大的region&#x3D;&#x3D;</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region）,所以我们给G1一个名字：垃圾优先（Garbage First）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>G1是一款面向服务端应用的垃圾回收器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时。还兼顾高吞吐量的性能特征</li>
<li>在JDK1.7版本正式启用，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel + Parallel Old组合组合，被Oracle官方称为全功能的垃圾收集器。与此同时，CMS已经在JDK9中被标记为废弃。</li>
<li>G1 GC在JDK8中还不是默认的垃圾回收器，需要使用 -XX:+UseG1GC来启用</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>与其他垃圾回收器相比，&#x3D;&#x3D;G1使用了全新的分区算法，其特点&#x3D;&#x3D;如下所示：<ul>
<li>&#x3D;&#x3D;并行与并发：&#x3D;&#x3D;<ul>
<li>并行性：G1在回收期间，可以有多个线程同时工作，有效利用多核计算能力，此时用户线程STW.</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作也可以和应用程序同时执行，因此，一般说来，不会在整个回收阶段发生完全阻塞应用程序的情况。</li>
</ul>
</li>
<li>&#x3D;&#x3D;分代收集：&#x3D;&#x3D;<ul>
<li>从分代上看，&#x3D;&#x3D;G1依然属于分代型垃圾收集器&#x3D;&#x3D;，它会区分年轻代和老年代，年轻代依然有Eden区和survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量</li>
<li>&#x3D;&#x3D;将堆空间分为若干个区域，这些区域包含了逻辑上的年轻代和老年代&#x3D;&#x3D;</li>
<li>和之前的各类收集器不同，它同时兼顾年轻代和老年代，对比其他回收器，或者工作在年轻代，或者工作在老年代</li>
</ul>
</li>
<li>&#x3D;&#x3D;空间整合：&#x3D;&#x3D;<ul>
<li>CMS：标记清除算法，内存碎片，若干次GC后进行一次碎片整理。</li>
<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看做是标记压缩算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC.尤其当Java堆非常大的时候，G1的优势就更加明显。</li>
</ul>
</li>
<li>&#x3D;&#x3D;可预测的停顿时间模型：&#x3D;&#x3D;（即：软实时soft real-time）<ul>
<li>G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个 长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N 毫秒</li>
<li>由于分区的原因，G1可以只选择部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），&#x3D;&#x3D;在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region.保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。&#x3D;&#x3D;</li>
<li>相对于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
</li>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负担都要比CMS要高</li>
<li>从经验上来看，在小内存应用上CMS的表现大概率会优于G1,而G1在大内存应用上则发挥其优势，平衡点在6—8G。</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收器的参数设置：</p>
<ul>
<li>-XX:+UseG1GC	手动指定使用G1回收器执行内存回收任务</li>
<li>-XX:+G1HeapRegionSize    设置每个region的大小，值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000</li>
<li>-XX:MaxGCPauseMillis    设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是200ms.</li>
<li>-XX:ParallelGCThreads    设置STW工作线程数的值，最多设置为8</li>
<li>-XX:ConcGCThreads    设置并发标记的线程数，将n设置为并行垃圾回收线程数（ParallelGCThreads）的1&#x2F;4</li>
<li>-XX:InitiatingHeapOccupancyPercent    设置触发并发GC周期的Java堆占用率阈值，超过此值，就触发GC.默认值是45</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收器的常见操作步骤：</p>
<ul>
<li>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优<ul>
<li>开启G1垃圾回收器</li>
<li>设置堆的最大内存</li>
<li>设置最大的停顿时间</li>
</ul>
</li>
<li>G1中提供了三种垃圾回收模式：&#x3D;&#x3D;YoungGC, Mixed GC, Full Gc,&#x3D;&#x3D;在不同的条件下触发。</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收器的适用场景：</p>
<ul>
<li>面向服务端应用，针对具有大内存，多处理器的机器（在普通大小的堆里表现并不惊喜）</li>
<li>最主要的应用是需要低延迟，并具有大堆的应用程序提供解决方案</li>
<li>用来替换掉JDK1.5中的CMS收集器。在下面的情况时，使用G1可能比CMS好。<ul>
<li>超过50%的Java堆被活动数据占用</li>
<li>对象分配频率或年代提升频率变化很大</li>
<li>GC停顿时间过长</li>
</ul>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用程序线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>
<li>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续)的集合。通过Region的动态分配方式实现逻辑上的连续。</li>
<li>一个Region有可能属于Eden、Survivor或者Old&#x2F;Tenured内存区域，但是一个region只能属于一个角色</li>
<li>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H 块，主要用于存储大对象，如果超过1.5个region，就放到H</li>
<li>设置H区的原因：<ul>
<li>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不进行Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收器垃圾回收过程：</p>
<img src="D:\BaiduNetdiskDownload\JVM上篇配图\JVM上篇配图\第17章_G1-GC垃圾回收过程.jpg" alt="第17章_G1-GC垃圾回收过程" style="zoom: 33%;" />

<ul>
<li>年轻代GC（Young  GC）</li>
<li>老年代并发标记过程（Concurrent  Marking）</li>
<li>混合回收（Mixed GC）</li>
<li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制）</li>
</ul>
<p>具体过程如下：</p>
<ul>
<li>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程：G1的年轻代收集过程是一个并行的独占式收集器。在年轻代回收期，G1  GC暂停所有应用程序线程，启动多线程执行年轻代回收，然后从年轻代区间存活对象到Survivor区间或老年区间，也有可能时两个区域都会设计</li>
<li>当堆内存使用达到一定值时（默认45%）,开始老年代并发标记过程。</li>
<li>标记完成，马上开始混合回收过程。对于一个混合回收期，G1  GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了，同时，这个老年代Region是和年轻代Region一起被回收的。</li>
</ul>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;Remembered Set:&#x3D;&#x3D;</p>
<ul>
<li>一个对象被不同区域引用的问题</li>
<li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆，才能保证准确呢？</li>
<li>在其他的分代收集器，也存在这样的问题（G1更突出）</li>
<li>回收新生代也不得不同时扫描老年代</li>
<li>这样的话Minor  GC的效率就会降低</li>
</ul>
<p>解决办法：</p>
<ul>
<li>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</li>
<li>&#x3D;&#x3D;每个Region都有一个对应的Remembered Set&#x3D;&#x3D;</li>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set,就可以保证不进行全局扫描，也不会有遗漏。</li>
</ul>
</blockquote>
<blockquote>
<p>G1回收过程一：年轻代GC</p>
<ul>
<li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li>
<li>&#x3D;&#x3D;年轻代垃圾回收只会回收Eden区和Survivor区&#x3D;&#x3D;</li>
<li>YGC时，首先停止应用程序的执行（Stop-The-World）,G1创建回收集（Collection  Set）,回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存片段。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>G1的初衷就是要避免Full  GC的出现，但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop–The–World）,使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</li>
<li>要避免Full  Gc的发生，一旦发生需要进行调整，什么时候会发生Full  GC呢？比如堆内存大小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full  GC，这种情况可以通过增大内存解决。</li>
</ul>
</blockquote>
<h3 id="8-垃圾回收器总结"><a href="#8-垃圾回收器总结" class="headerlink" title="8.垃圾回收器总结"></a>8.垃圾回收器总结</h3><table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>适用于单CPU单核环境下的client模式</td>
</tr>
<tr>
<td>parNew</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境Server模式下与CMS配合使用</td>
</tr>
<tr>
<td>Parallel</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>响应速度优先</td>
<td>适用于单CPU单核环境下的client模式</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>CMS</td>
<td>并发运行</td>
<td>作用于老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>适用于互联网或B&#x2F;S业务</td>
</tr>
<tr>
<td>G1</td>
<td>并发、并行运行</td>
<td>作用于新生代、老年代</td>
<td>标记压缩算法、复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用</td>
</tr>
</tbody></table>
<blockquote>
<p>怎么选择垃圾回收器？</p>
<ul>
<li><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择何时的垃圾收集器可以让JVM的性能有一个很大的提升。</p>
</li>
<li><p>怎么选择垃圾回收器？</p>
<ul>
<li><p>优先调整堆的大小让JVM自适应完成</p>
</li>
<li><p>如果内存小于100M，使用串行收集器</p>
</li>
<li><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p>
</li>
<li><p>如果是多CPU，需要高吞吐量，允许停顿时间超过1秒，选择并行或者JVM自己选择</p>
</li>
<li><p>如果是多CPU，追求停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</p>
<p>官方推荐G1,并能高，现在互联网的项目，基本都是使用G1</p>
</li>
<li><p>最后需要明确一个观点:</p>
<ul>
<li>没有最好的收集器，更没有万能的收集器</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>面试：</p>
<ul>
<li>垃圾收集算法有哪些？如何判断一个对象是否可以回收？</li>
<li>垃圾收集器工作的基本流程。</li>
<li>另外大家需要多关注垃圾回收器这一章的各种常用的参数</li>
</ul>
</blockquote>
<h3 id="9-GC日志分析"><a href="#9-GC日志分析" class="headerlink" title="9.GC日志分析"></a>9.GC日志分析</h3><blockquote>
<ul>
<li>通过阅读GC日志，我们可以了解JVM虚拟机内存分配与回收策略</li>
<li>内存分配与垃圾回收的参数列表：<ul>
<li>-XX:+PrintGC    输出GC日志，类似：-verbose:gc</li>
<li>-XX:+PrintGCDetails    输出GC的详细日志</li>
<li>-XX:+PrintGCTimeStamps    输出GC的时间戳（以基准时间的形式）</li>
<li>-XX:+PrintGCDataStamps    输出GC的时间戳（以日期的形式，如2013-05-04T21:53:59.234+0800）</li>
<li>-XX:+PrintHeapAtGC    在进行GC的前后打印出堆的信息</li>
<li>-Xloggc:..&#x2F;logs&#x2F;gc.log    日志文件的输出路径</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="10-垃圾回收器的新发展"><a href="#10-垃圾回收器的新发展" class="headerlink" title="10.垃圾回收器的新发展"></a>10.垃圾回收器的新发展</h3><blockquote>
<ul>
<li>shenandoah  GC的弱项：高运行负担下的吞吐量下降</li>
<li>shenandoah  GC的强项：低延迟时间</li>
<li>shenandoah  GC的工作过程大致分为九个阶段。</li>
</ul>
</blockquote>
<blockquote>
<p>令人震惊的革命性的ZGC:</p>
<ul>
<li>在尽可能对吞吐量影响不大的前提下，是现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在&#x3D;&#x3D;十毫秒以内的低延迟。&#x3D;&#x3D;</li>
<li>ZGC的工作过程可以分为4个阶段：并发标记-并发预备重分配-并发重分配-并发重映射</li>
<li>ZGC几乎在所有地方是并发执行的，除了初始标记是STW的。所以停顿时间几乎就好肥仔初始标记上，这部分的实际时间是非常少的。</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/" data-id="clrv16wjd000fz5ku7yqefxxq" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-typora/SSM框架整合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SSM框架整合"><a href="#SSM框架整合" class="headerlink" title="SSM框架整合"></a>SSM框架整合</h1><h2 id="服务器开发分成三层"><a href="#服务器开发分成三层" class="headerlink" title="服务器开发分成三层"></a>服务器开发分成三层</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表现层controller SpringMVC框架</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">业务层service Spring框架</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">持久层dao mybatis框架</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由Spring去整合SpringMVC,Spring去整合Mybatis）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">整合的方法是选项配置文件+注解的方式</span></span><br></pre></td></tr></table></figure>

<p><strong>最终开发的目录结构</strong></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20210925114659814.png" alt="image-20210925114659814"  /><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20210925114813931.png" alt="image-20210925114813931"></p>
<h2 id="第一章：搭建整合环境"><a href="#第一章：搭建整合环境" class="headerlink" title="第一章：搭建整合环境"></a>第一章：搭建整合环境</h2><h3 id="1-搭建整合环境"><a href="#1-搭建整合环境" class="headerlink" title="1.搭建整合环境"></a>1.搭建整合环境</h3><p><strong>1.整合说明：SSM整合的方式有多种，这里使用选项配置文件+注解的方式</strong><br><strong>2.整合的思路：</strong><br>    1.先搭建整合的环境<br>    2.先把Spring的配置搭建完成<br>    3.再使用Spring整合SpringMVC框架<br>    4.最后使用Spring整合Mabatis框架<br><strong>3.创建数据库和表结构</strong><br>    1.语句	</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database ssm;</span><br><span class="line">use ssm;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">       name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">       money <span class="keyword">double</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>4.创建maven的工程（会使用到工程的聚合和拆分）</strong></p>
<p>​	1.创建ssm_parent父工程(打包方式选择pom,必须的)</p>
<p>​								<img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20210924150147633.png" alt="image-20210924150147633"></p>
<p>​	2.创建ssm_web子模块（打包方式是war包）</p>
<p>​	3.创建ssm_service子模块（打包方式是jar包）</p>
<p>​	4.创建ssm_dao子模块（打包方式是jar包）</p>
<p>​	5.创建ssm_domain子模块（打包方式是jar包）</p>
<p>​	6.web依赖于service，service依赖于dao，dao依赖于domain</p>
<p>​	7.在ssm_parent的pom.xml文件中导入坐标依赖</p>
<p>​	8.部署ssm_web的项目，只要把ssm_web项目加入到tomcat服务器中即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml文件 导入坐标依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修改properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修改properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--c3p0连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注解xml配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring中的事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring中的jdbc模板--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试单元--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring与junit结合起来的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatisjar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring整合mabatis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--springmvc web端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springmvc web端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springmvc中的servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springmvc中的jsp--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--支持json数据绑定的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--支持json数据绑定的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--支持json数据绑定的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--页面支持el表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>5.编写实体类，在ssm_domain项目中编写</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类中的字段对应数据库表中的属性名</span></span><br><span class="line"><span class="keyword">package</span> cn.itcast.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(Double money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.编写dao接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户dao接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="comment">//查询所有账户信息</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存账户信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">(Account account)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7.编写service接口和实现类</strong></p>
<p><em>service接口</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">//查询所有账户信息</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存账户信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">(Account account)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>service实现类</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Account;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.AccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层：查询所有的账户信息&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层：保存账户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二章：Spring框架代码的编写"><a href="#第二章：Spring框架代码的编写" class="headerlink" title="第二章：Spring框架代码的编写"></a>第二章：Spring框架代码的编写</h2><h3 id="1-搭建和测试Spring的开发环境"><a href="#1-搭建和测试Spring的开发环境" class="headerlink" title="1.搭建和测试Spring的开发环境"></a>1.搭建和测试Spring的开发环境</h3><p><strong>1.在ssm_web项目中创建applicationContext.xml的配置文件，编写具体的配置信息。</strong></p>
<p><em>配置applicationContext.xml</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解的扫描,希望处理service和dao,controller不需要Spring框架去处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置哪些注解不扫描--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--spring整合Mybatis框架--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC<span class="symbol">&amp;amp;</span>amp<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置SqlSessionFactory工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置AccountDao接口所在的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScannerConfigurer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置Spring框架声明式事务管理--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置aop增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* cn.itcast.service.impl.*ServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>在Test目录中创建测试类，看Spring环境搭建是否成功</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpring</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//加载spring配置文件</span></span><br><span class="line">        ApplicationContext ac=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对象  这里要给AccountServiceImpl类添加注解@Service(&quot;accountService&quot;)</span></span><br><span class="line">        AccountService accountService=ac.getBean(<span class="string">&quot;accountService&quot;</span>, AccountService.class);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        accountService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三章：Spring整合SpringMVC框架"><a href="#第三章：Spring整合SpringMVC框架" class="headerlink" title="第三章：Spring整合SpringMVC框架"></a>第三章：Spring整合SpringMVC框架</h2><h3 id="1-搭建和测试SpringMVC的开发环境"><a href="#1-搭建和测试SpringMVC的开发环境" class="headerlink" title="1.搭建和测试SpringMVC的开发环境"></a>1.搭建和测试SpringMVC的开发环境</h3><p><strong>1.在web.xml中配置DispatcherServlet前端控制器</strong></p>
<p><em>配置web.xml</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!--配置Spring的监听器  默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--设置配置文件的路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--解决中文乱码的过滤器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置前端控制器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载springmvc.xml配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启动服务器，创建该servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>创建springmvc.xml并配置</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描，只扫描Controller注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置的视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--过滤静态资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启SpringMVC注解的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>测试springmvc框架是否配置成功</strong></em></p>
<p>controller文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户web/controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller(&quot;accountController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表现层：查询所有账户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.jsp文件</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;account/findAll&quot;</span>&gt;测试&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>list.jsp文件</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;成功查询到账户信息&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-Spring整合SpringMVC的框架"><a href="#2-Spring整合SpringMVC的框架" class="headerlink" title="2.Spring整合SpringMVC的框架"></a>2.Spring整合SpringMVC的框架</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">整合原理：</span></span><br><span class="line">	spring整合springmvc:启动tomcat服务器的时候，需要加载spring配置文件</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ServletContext域对象</span></span><br><span class="line">	服务器启动的时候创建ServletContext对象，服务器关系对象销毁</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">监听器（在web.xml中配置）</span></span><br><span class="line">	监听ServletContext域对象的创建和销毁。执行一次，服务器启动执行</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">监听器去加载Spring的配置文件</span></span><br><span class="line">	创建web版本工厂，存储ServletConxtext对象</span><br></pre></td></tr></table></figure>

<p><em>web.xml文件</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Spring的监听器  默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--设置配置文件的路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>controller文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户web/controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller(&quot;accountController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用Service方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;表现层：查询所有账户&quot;</span>);</span><br><span class="line">        accountService.findAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四章：Spring整合Mybatis框架"><a href="#第四章：Spring整合Mybatis框架" class="headerlink" title="第四章：Spring整合Mybatis框架"></a>第四章：Spring整合Mybatis框架</h2><h3 id="1-搭建和测试Mybatis的开发环境"><a href="#1-搭建和测试Mybatis的开发环境" class="headerlink" title="1.搭建和测试Mybatis的开发环境"></a>1.搭建和测试Mybatis的开发环境</h3><p>1.在web项目中编写SqlMapConfig.xml的配置文件，编写核心配置文件</p>
<p><em>SqlMapConfig.xml</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC<span class="symbol">&amp;amp;</span>amp<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入映射配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.itcast.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>AccountDao文件编写</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户dao接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="comment">//查询所有账户信息</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from account&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存账户信息</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into account(name,money) values(#&#123;name&#125;,#&#123;money&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">(Account account)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>编写一个测试类</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.dao.AccountDao;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMybatis</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//加载mybatis的配置文件</span></span><br><span class="line">        InputStream in=Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">        SqlSessionFactory factory=<span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">        <span class="comment">//创建SqlSession对象</span></span><br><span class="line">        SqlSession session=factory.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//获取到代理对象</span></span><br><span class="line">        AccountDao dao=session.getMapper(AccountDao.class);</span><br><span class="line">        <span class="comment">//查询所有数据</span></span><br><span class="line">        List&lt;Account&gt; res=dao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Account a:res) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Account account=<span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        account.setName(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        account.setMoney(<span class="number">123d</span>);</span><br><span class="line">        <span class="comment">//加载mybatis的配置文件</span></span><br><span class="line">        InputStream in=Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">        SqlSessionFactory factory=<span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">        <span class="comment">//创建SqlSession对象</span></span><br><span class="line">        SqlSession session=factory.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//获取到代理对象</span></span><br><span class="line">        AccountDao dao=session.getMapper(AccountDao.class);</span><br><span class="line">        <span class="comment">//保存账户数据</span></span><br><span class="line">        dao.saveAccount(account);</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-Spring整合Mybatis的框架"><a href="#2-Spring整合Mybatis的框架" class="headerlink" title="2.Spring整合Mybatis的框架"></a>2.Spring整合Mybatis的框架</h3><p>1.在applicationContext.xml中配置spring整合mybatis</p>
<p><em>applicationContext.xml</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring整合Mybatis框架--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC<span class="symbol">&amp;amp;</span>amp<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置SqlSessionFactory工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置AccountDao接口所在的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScannerConfigurer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>AccountServiceImpl文件</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.dao.AccountDao;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Account;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层：查询所有的账户信息&quot;</span>);</span><br><span class="line">        <span class="comment">//调用dao方法</span></span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层：保存账户&quot;</span>);</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>controller文件</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Account;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户web/controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller(&quot;accountController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findAll</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        <span class="comment">//调用Service方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;表现层：查询所有账户&quot;</span>);</span><br><span class="line">        List&lt;Account&gt; list=accountService.findAll();</span><br><span class="line">        <span class="keyword">for</span>(Account a:list)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;list&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>list.jsp</em></p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;成功查询到账户信息&lt;/h1&gt;</span><br><span class="line">    $&#123;list&#125;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;list&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;account&quot;</span>&gt;</span><br><span class="line">        $&#123;account.name&#125;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.配置Spring的声明式事务管理</strong></p>
<p><em>applicationContext.xml配置</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置Spring框架声明式事务管理--&gt;</span><br><span class="line">    &lt;!--配置事务管理器--&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;!--配置事务通知--&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--配置aop增强--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.itcast.service.impl.*ServiceImpl.*(..))&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<p><em>controller文件</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Account;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户web/controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller(&quot;accountController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findAll</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        <span class="comment">//调用Service方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;表现层：查询所有账户&quot;</span>);</span><br><span class="line">        List&lt;Account&gt; list=accountService.findAll();</span><br><span class="line">        <span class="keyword">for</span>(Account a:list)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;list&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveAccount</span><span class="params">(Account account, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        accountService.saveAccount(account);</span><br><span class="line">        response.sendRedirect(request.getContextPath()+<span class="string">&quot;/account/findAll&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>index.jsp文件</em></p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;account/findAll&quot;</span>&gt;测试&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">    &lt;form action=<span class="string">&quot;account/save&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> /&gt;&lt;br&gt;</span><br><span class="line">        金额：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;money&quot;</span> /&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;保存&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/" data-id="clrv16wjd000gz5kucex42afb" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/leetcode%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode笔记"><a href="#leetcode笔记" class="headerlink" title="leetcode笔记"></a>leetcode笔记</h1><h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h2><h4 id="1-字符串哈希（leetcode-686）"><a href="#1-字符串哈希（leetcode-686）" class="headerlink" title="1.字符串哈希（leetcode 686）"></a>1.字符串哈希（leetcode 686）</h4><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h2><h4 id="1-删除自身节点。（不能获取到头节点）"><a href="#1-删除自身节点。（不能获取到头节点）" class="headerlink" title="1.删除自身节点。（不能获取到头节点）"></a>1.删除自身节点。（不能获取到头节点）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode227题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="comment">//论如何获得永生:先将自己变成后面的节点，然后再杀死自己</span></span><br><span class="line">    ListNode last=node.next;</span><br><span class="line">    node.val= last.val;</span><br><span class="line">    node.next=last.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-树"><a href="#4-树" class="headerlink" title="4.树"></a>4.树</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代(即深度优先遍历二叉树)</span></span><br><span class="line"><span class="comment">     * 先序遍历二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) <span class="comment">//先压入右子树</span></span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) <span class="comment">//再压入左子树</span></span><br><span class="line">                stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代</span></span><br><span class="line"><span class="comment">     * 中序遍历二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">          List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span>  list;</span><br><span class="line">          Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">          <span class="keyword">while</span>(p != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">                  s.push(p);</span><br><span class="line">                  p = p.left;</span><br><span class="line">              &#125;</span><br><span class="line">              p = s.pop();</span><br><span class="line">              list.add(p.val);</span><br><span class="line">              p = p.right;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(list);</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序非递归遍历二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();    </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root, prev = root; <span class="comment">//pre记录上一个已经输出的结点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || stack.size() &gt; <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;    </span><br><span class="line">                stack.push(node);    </span><br><span class="line">                node = node.left;    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.peek().right; <span class="comment">//在出栈之前，先判断栈顶元素的右孩子结点</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span> || temp == prev) &#123; <span class="comment">//当前节点无右子树或右子树已经输出    </span></span><br><span class="line">                node = stack.pop();    </span><br><span class="line">                list.add(node.val);</span><br><span class="line">                prev = node; <span class="comment">//记录上一个已输出结点</span></span><br><span class="line">                node = <span class="literal">null</span>;    </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                node = temp; <span class="comment">//处理右子树</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-回溯"><a href="#5-回溯" class="headerlink" title="5.回溯"></a>5.回溯</h2><h2 id="6-贪心"><a href="#6-贪心" class="headerlink" title="6.贪心"></a>6.贪心</h2><h2 id="7-动态规划"><a href="#7-动态规划" class="headerlink" title="7.动态规划"></a>7.动态规划</h2><h4 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0-1背包问题</span></span><br><span class="line">	有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</span><br><span class="line">	---背包有是一维的情况</span><br><span class="line">	---背包也有多维的情况（如leetcode474）</span><br><span class="line">	//核心代码，注意滚动数组要从右往左，否则就成了完全背包了</span><br><span class="line">	for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">        for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">完全背包问题</span></span><br><span class="line">	有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</span><br><span class="line">	根据遍历物品与遍历背包的不同又会有求排列数和组合数的不同</span><br><span class="line">	---如果求组合数就是外层for循环遍历物品，内层for遍历背包。（1,5）和（5，1）是同一种情况（如leetcode518题）</span><br><span class="line">	//组合代码</span><br><span class="line">	public int change(int amount, int[] coins) &#123;</span><br><span class="line">        int[] dp=new int[amount+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for (int i = 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            for (int j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">	---如果求排列数就是外层for遍历背包，内层for循环遍历物品。（1,5）和（5，1）是两种情况（如leetcode377题）</span><br><span class="line">	//排列代码</span><br><span class="line">	public int combinationSum4(int[] nums, int target) &#123;</span><br><span class="line">        int[] dp=new int[target+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for (int i = 0; i &lt;= target; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class="line">                if(i&gt;=nums[j])&#123;</span><br><span class="line">                    dp[i]=dp[i]+dp[i-nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];        </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 先遍历物品，再遍历背包</span><br><span class="line">    for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">        for(int j = weight[i]; j &lt; bagWeight ; j++) &#123; // 遍历背包容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">爬楼梯问题</span></span><br><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    //简单动态规划的解法</span><br><span class="line">    // if(n&lt;=2)&#123;</span><br><span class="line">    //     return n;</span><br><span class="line">    // &#125;</span><br><span class="line">    // int a=1,b=2;</span><br><span class="line">    // for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">    //     int c=b;</span><br><span class="line">    //     b=a+b;</span><br><span class="line">    //     a=c;</span><br><span class="line">    // &#125;</span><br><span class="line">    // return b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将爬楼梯问题转化为完全背包的排列问题</span><br><span class="line">    //将代码中的2可以改为m,即一下子可以爬1到m阶楼梯，就相当于有1到m的面值的无限硬币个数，可以组成的总钱数为n的排列数有多少</span><br><span class="line">    int[] dp=new int[n+1];</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=2;j++)&#123;</span><br><span class="line">            if(i&gt;=j)&#123;</span><br><span class="line">            dp[i]=dp[i]+dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211106192739458.png" alt="image-20211106192739458"></p>
<h4 id="2-打家劫舍问题"><a href="#2-打家劫舍问题" class="headerlink" title="2.打家劫舍问题"></a>2.打家劫舍问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>就是比较传统的一排街道，没有环，如果偷相邻的两个街道就会报警。</span><br><span class="line">	代码：</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态规划解法</span></span><br><span class="line"><span class="comment">         * dp[i]表示在前i个街区中不触碰警报能获取到的最大价值</span></span><br><span class="line"><span class="comment">         * 递推公式：如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</span></span><br><span class="line"><span class="comment">         *         如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）</span></span><br><span class="line"><span class="comment">         *      所以有：dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i])</span></span><br><span class="line"><span class="comment">         * 初始化：dp[0]=0,dp[1]=nums[0]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 因为我们每次只会用到i前面的dp[i-1]和dp[i-2]所以可以用滚动数组的解法</span></span><br><span class="line"><span class="comment">         * 用两个变量来进行记录</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c=Math.max(b,a+nums[i]);</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>还是一排街道，但是与第一种情况不同的是，这里面的首尾两个街道算是相邻的街道。所以需要做进一步思考。就是分情况讨论。</span><br><span class="line">    <span class="number">1</span>）.最终偷的结果首尾两个街道都不包括。即只考虑在除了首尾的中间的元素</span><br><span class="line">    <span class="number">2</span>）.最终偷的结果考虑首元素，但不考虑尾元素的情况</span><br><span class="line">    <span class="number">3</span>）.最终偷的结果考虑尾元素，但不考虑首元素的情况</span><br><span class="line">    综合得：<span class="number">2</span>、<span class="number">3</span>两种情况里面都包含了第一种情况，所以总得就只用分为<span class="number">2</span>，<span class="number">3</span>两种情况，在考虑<span class="number">2</span>、<span class="number">3</span>这两种情况得时候，这就是前面第一种打家劫舍类型去了，最后取这两者中得最大值。 </span><br><span class="line">    代码：</span><br><span class="line">    	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> r1=getAns(nums,l,r-<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> r2=getAns(nums,l+<span class="number">1</span>,r);</span><br><span class="line">            <span class="keyword">return</span> r1&gt;r2?r1:r2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAns</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">            <span class="type">int</span> n=r-l;</span><br><span class="line">            <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="type">int</span> c=Math.max(a+nums[i],b);</span><br><span class="line">                a=b;</span><br><span class="line">                b=c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-股票买卖问题"><a href="#3-股票买卖问题" class="headerlink" title="3.股票买卖问题"></a>3.股票买卖问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">leetcode 123题</span></span><br><span class="line">	- 分状态进行解决</span><br><span class="line">	每一天总共有5个状态</span><br><span class="line">		dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</span><br><span class="line">		0 不操作状态		相当手中现金为0  dp[i][0]=0</span><br><span class="line">	buy1	1 第一次买入		相当于是消耗了这一天的钱数  -prices[i]</span><br><span class="line">	sell1	2 第一次卖出		相当于是获得了这一天的钱数  +prices[i]</span><br><span class="line">	buy2	3 第二次买入		相当于是消耗了这一天的钱数  -prices[i]</span><br><span class="line">	sell2	4 第二次卖出		相当于是获得了这一天的钱数  +prices[i]</span><br><span class="line">	这一天可以不进行任何操作，或者在前一天的状态下进行其他四种状态的变化</span><br><span class="line">		在第i天，进行 	1 第一次买入  ：buy1=Math.max(buy1&#x27;,-prices[i])</span><br><span class="line">									:buy1&#x27;表示这一天不进行操作，-prices[i]表示这一天买入消耗这么多</span><br><span class="line">                        2 第一次卖出  :sell1=Math.max(sell1&#x27;,buy1+prices[i])</span><br><span class="line">                        3 第二次买入	 :buy2=Math.max(buy2&#x27;,sell1-prices[i])</span><br><span class="line">                        4 第二次卖出  :sell2=Math.max(sell2&#x27;,buy2+prices[i])</span><br><span class="line">                 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码演示</span></span><br><span class="line">	public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int buy1 = -prices[0], sell1 = 0;</span><br><span class="line">        int buy2 = -prices[0], sell2 = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">leetcode 188题</span></span><br><span class="line">这是在123题的基础上变为至多可以买卖k次,思想与123题类似</span><br><span class="line">    public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">        if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp=new int[k*2+1];</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        for (int i = 1; i &lt; k*2+1; i+=2) &#123;</span><br><span class="line">            dp[i]=-prices[0];</span><br><span class="line">            dp[i+1]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            for(int j=1;j&lt;k*2+1;j++)&#123;</span><br><span class="line">                if(j%2==1)&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-1]-prices[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-1]+prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[k*2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1eetcode309</span></span><br><span class="line">股票买卖问题，带手续费的</span><br><span class="line">	我们用 f[i]表示第 i 天结束之后的「累计最大收益」</span><br><span class="line">	该题分为以下几个状态（这里的状态是该天结束之后的状态）：</span><br><span class="line">		- 我们目前持有一支股票，对应的「累计最大收益」记为 f[i][0]；</span><br><span class="line">		- 我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]；</span><br><span class="line">		- 我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]。</span><br><span class="line">		这里的「处于冷冻期」指的是在第 i 天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	对于f[i][0]:我们可以是在这一天不进行任何操作，在之前就已经持有了一支股票，所以有f[i-1][0].或者是前一天不持有股票，然后今天买入，所以是必须在前一天处于非冷冻期中。因此为f[i][0]=f[i-1][2]-prices[i]</span><br><span class="line">	</span><br><span class="line">	对于f[i][1]:则是在前一天持有一支股票，然后在第i天卖出，所以处于冷冻期f[i][1]=f[i-1][0]+prices[i]</span><br><span class="line">	</span><br><span class="line">	对于f[i][2]:可以是当天不进行任何操作所以有f[i-1][2]，也可以是在前一天处于冷冻期，一天后就不是冷冻期了。所以有f[i][2]=f[i-1][1]</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">初始化</span></span><br><span class="line">		f[i][0]=-prices[0]</span><br><span class="line">		f[i][1]=0</span><br><span class="line">		f[i][2]=0</span><br><span class="line">		</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">代码：</span></span><br><span class="line">	public int maxProfit(int[] prices) &#123;</span><br><span class="line">        /*if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int[][] dp=new int[n][2];</span><br><span class="line">        dp[0][0]=-prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2]-prices[i]);</span><br><span class="line">            dp[i][1]=dp[i-1][0]+prices[i];</span><br><span class="line">            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[n-1][1],dp[n-1][2]);*/</span><br><span class="line"></span><br><span class="line">        //空间进行优化，因为第i天的状态只与第i-1天有关系</span><br><span class="line">        if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int a=-prices[0];</span><br><span class="line">        int b=0;</span><br><span class="line">        int c=0;</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            int d=Math.max(a,c-prices[i]);</span><br><span class="line">            int e=a+prices[i];</span><br><span class="line">            int f=Math.max(c,b);</span><br><span class="line">            a=d;</span><br><span class="line">            b=e;</span><br><span class="line">            c=f;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(b,c);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-最长子序列问题"><a href="#4-最长子序列问题" class="headerlink" title="4.最长子序列问题"></a>4.最长子序列问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如：leetcode1143。（leetcode1035）</span><br><span class="line">	值得注意的是这是一个二维的动态规划，既需要同时对两个数组进行动态分析。画出一个m*n的矩阵会便于进行分析</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211207131539996.png" alt="image-20211207131539996"></p>
<h2 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h2><h2 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h2><h4 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有的位运算都是用补码进行运算</span></span><br><span class="line"></span><br><span class="line">	正数的原码，反码，补码都相同</span><br><span class="line">	负数的原码是除了第一个符号位为1外，其他位与正数原码相同，如-3的原码是 1000....0000011</span><br><span class="line">	负数的反码是在负数原码的基础上符号位不变，其他位取反    如-3的反码是  1111....1111100</span><br><span class="line">	负数的补码是在负数反码的基础上+1                    -3的反码是    1111....1111101</span><br></pre></td></tr></table></figure>

<h4 id="1-判断一个数是否是2的次幂"><a href="#1-判断一个数是否是2的次幂" class="headerlink" title="1.判断一个数是否是2的次幂"></a>1.判断一个数是否是2的次幂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> (sum&amp;(sum-<span class="number">1</span>))==<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211028163231510.png" alt="image-20211028163231510"></p>
<h4 id="2-异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）"><a href="#2-异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）" class="headerlink" title="2.异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）"></a>2.异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如何才能做到线性时间复杂度和常数空间复杂度呢？</span><br><span class="line"></span><br><span class="line">答案是使用位运算。对于这道题，可使用异或运算 \oplus⊕。异或运算有以下三个性质。</span><br><span class="line"></span><br><span class="line">正数反码：与原码相同</span><br><span class="line"></span><br><span class="line">负数反码：符号位为“1”，数值位按位 取反。</span><br><span class="line">正数补码：与原码相同</span><br><span class="line">负数补码：求反加一</span><br><span class="line">记住：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有参与运算的都是以补码形式进行的 结果也是补码 因此也需要将补码转换成为原码的形式存在</span></span><br><span class="line"></span><br><span class="line">任何数和 0做异或运算，结果仍然是原来的数，即 a⊕0=a。</span><br><span class="line">任何数和其自身做异或运算，结果是 0，即 a⊕a=0。</span><br><span class="line">异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</span><br></pre></td></tr></table></figure>

<h4 id="3-与运算和或运算。（leetcode-318）"><a href="#3-与运算和或运算。（leetcode-318）" class="headerlink" title="3.与运算和或运算。（leetcode 318）"></a>3.与运算和或运算。（leetcode 318）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或运算  |   （1=1&amp;1 1=1|0 1=0|1 0=0|0） 注意这个没有短路的效果，有短路的是||和&amp;&amp;</span></span><br><span class="line">	常见的题目类型有：</span><br><span class="line">		1.看一个数的某一位是否为1或0.</span><br><span class="line">			如：   00000000</span><br><span class="line">				| 00000001</span><br><span class="line">                ————————————</span><br><span class="line">                  00000001</span><br><span class="line">     	2.看求某一个数的掩码</span><br><span class="line">     			a |= (1&lt;&lt;6)  (最终的效果就是a这个数的二进制数第六位数是1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">与运算  &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-移位运算"><a href="#4-移位运算" class="headerlink" title="4.移位运算"></a>4.移位运算</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> &lt;&lt;  左移运算</span>  </span><br><span class="line">	如 a= 1&lt;&lt;4  是将1变为二进制后往左移4位</span><br><span class="line">				00000001</span><br><span class="line">			 &lt;&lt; </span><br><span class="line">			 ____________</span><br><span class="line">			 a= 00010000=16</span><br><span class="line">	如 b= 3&lt;&lt;4  是将3转换为二进制后往左移4位，最终结果是48</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> &gt;&gt; 右移运算与左移运算则相反</span></span><br></pre></td></tr></table></figure>

<h4 id="5-非运算"><a href="#5-非运算" class="headerlink" title="5.非运算 ~"></a>5.非运算 ~</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意一点是所有位运算都是按照补码进行运算的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~运算是将要求的数的补码取反（包括符号位），得到补码，再由补码退出该数的原码，就是最终结果</span></span><br><span class="line">所以~10的求解过程是这样的</span><br><span class="line">	10的补码是 		                   0...00001010</span><br><span class="line">	所以~10的补码是上面10的补码所有位取反   1...11110101</span><br><span class="line">    就有了~10的原码就是					1...00001011  即~10等于 -11</span><br><span class="line">    </span><br><span class="line">    ~(-3)的求解过程是</span><br><span class="line">    -3的原码：1...00000011</span><br><span class="line">    -3的反码：1...11111100</span><br><span class="line">    -3的补码：1...11111101</span><br><span class="line">    </span><br><span class="line"> ~(-3)的补码：0...00000010</span><br><span class="line"> ~(-3)的反码：0...00000010</span><br><span class="line"> ~(-3)的原码：0...00000010   即 ~(-3)等于 2</span><br><span class="line"> </span><br><span class="line"> 结论：~(n) = -n-1  (无论n是正数还是负数)</span><br></pre></td></tr></table></figure>



<h4 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.剑指offer65题(利用位运算实现加法)</span><br></pre></td></tr></table></figure>



<h2 id="10-查找算法"><a href="#10-查找算法" class="headerlink" title="10.查找算法"></a>10.查找算法</h2><h4 id="1-二分查找算法"><a href="#1-二分查找算法" class="headerlink" title="1.二分查找算法"></a>1.二分查找算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.查找目标值的索引   如查找[5,7,8,10]的8位置，返回2，查找9，还是返回2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)&#123;</span><br><span class="line">                right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查找目标值索引的右边界  如查找[5,7,7,8,8,10]中8的右边界第一个值的索引即返回10对应的索引，查找7则返回第一个8的索引   (题目如剑指offer中53题，理解见图)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//与一般的二分查找区别在这里</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;=target)&#123;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211101211328241.png" alt="image-20211101211328241"></p>
<h4 id="2-动态规划-二分查找"><a href="#2-动态规划-二分查找" class="headerlink" title="2.动态规划+二分查找"></a>2.动态规划+二分查找</h4><blockquote>
<p>见leetcode 300题</p>
</blockquote>
<h2 id="11-集合框架"><a href="#11-集合框架" class="headerlink" title="11.集合框架"></a>11.集合框架</h2><h4 id="1-List—ArrayList-LinkedList的使用"><a href="#1-List—ArrayList-LinkedList的使用" class="headerlink" title="1.List—ArrayList,LinkedList的使用"></a>1.List—ArrayList,LinkedList的使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是一个很重要的点</span></span><br><span class="line">1.当需要对集合中的数据进行频繁的随机访问的时候，建议使用ArrayList</span><br><span class="line">2.当需要对集合进行频繁的插入和删除数据时，建议使用LinkedList</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList的方法，add方法默认从末端添加元素</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211102141245305.png" alt="image-20211102141245305"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList方法，add可以从开头或末尾添加元素</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211102141534247.png" alt="image-20211102141534247"></p>
<h2 id="12-数学"><a href="#12-数学" class="headerlink" title="12.数学"></a>12.数学</h2><h4 id="1-求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）"><a href="#1-求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）" class="headerlink" title="1.求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）"></a>1.求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.方法1,暴力破解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.方法2.二分法</span></span><br><span class="line">如果num是完全平方数，就相当于是能从<span class="number">1</span>到num中间寻找一个数，这个数的平方等于num</span><br><span class="line">因此左边界是<span class="number">1</span>，右边界是num,然后进行二分查找。但是需要注意的是临时得到的中间数middle的平方可能会超出<span class="type">int</span>的范围，因此需要用<span class="type">long</span>类型来存储</span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="type">int</span> left=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> right=num;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">    <span class="type">int</span> middle=(right+left)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> square=(<span class="type">long</span>)middle*middle;</span><br><span class="line">    <span class="keyword">if</span>(square&gt;num)&#123;</span><br><span class="line">        right=middle-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(square&lt;num)&#123;</span><br><span class="line">        left=middle+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.方法3.数学。（利用一个完全平方数，能够由奇数相加得到）</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">4</span>=<span class="number">1</span>+<span class="number">3</span></span><br><span class="line"><span class="number">9</span>=<span class="number">1</span>+<span class="number">3</span>+<span class="number">5</span></span><br><span class="line"><span class="number">16</span>=<span class="number">1</span>+<span class="number">3</span>+<span class="number">5</span>+<span class="number">7</span></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">num -= x;</span><br><span class="line">x += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-矩阵快速幂（时间复杂度为O-logn-）解决斐波那契数列中使用（待看）"><a href="#2-矩阵快速幂（时间复杂度为O-logn-）解决斐波那契数列中使用（待看）" class="headerlink" title="2.矩阵快速幂（时间复杂度为O(logn)）解决斐波那契数列中使用（待看）"></a>2.矩阵快速幂（时间复杂度为O(logn)）解决斐波那契数列中使用（待看）</h4><h2 id="13-排序算法"><a href="#13-排序算法" class="headerlink" title="13.排序算法"></a>13.排序算法</h2><h4 id="1-内置的排序算法-比较器（Comparator）"><a href="#1-内置的排序算法-比较器（Comparator）" class="headerlink" title="1.内置的排序算法+比较器（Comparator）"></a>1.内置的排序算法+比较器（Comparator）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">java中的内置排序函数有Arrays和Collections类中的<span class="built_in">sort</span>函数，其中还可以自己定义排序的顺序，就是创建比较器对象，注意o1对象和o2对象比较顺序</span></span><br><span class="line">if(o1.get(i)&lt;o1.get(0))&#123;   //当这种情况发生时，如果想调整当前o1,o2的顺序，就返回正数，否则返回负数</span><br><span class="line">	return o1.get(0);  //将o1调整到o2之前</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	return -1;  //保持不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] nums=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Arrays.sort(nums, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1[<span class="number">0</span>]&gt;o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//因为要的是升序，但是o1大于o2所以应该调整顺序，所以返回正数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1[<span class="number">0</span>]&lt;o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//因为要的是升序，所以o1与o2已经是升序了，所以不变。o1，o2的顺序保持不变， </span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这是在第一维相等的情况下，比较第二维</span></span><br><span class="line">                <span class="keyword">if</span>(o1[<span class="number">1</span>]&gt;o2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1[<span class="number">1</span>]&lt;o2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(nums);</span><br><span class="line">    <span class="comment">//结果为：[1,2],[2,3],[2,6],[3,4],[5,2],[5,8],[6,1],[6,3]</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-快速排序-题目见剑指offer40"><a href="#2-快速排序-题目见剑指offer40" class="headerlink" title="2.快速排序(题目见剑指offer40)"></a>2.快速排序(题目见剑指offer40)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fastSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=i;</span><br><span class="line">    <span class="type">int</span> r=j;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[r]&gt;=arr[i])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[l]&lt;=arr[i])&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里其实判不判断l&lt;r都无所谓，只是进行了多一次交换，即便不满足，此时l==r，也不会有影响</span></span><br><span class="line">        <span class="type">int</span> temp=arr[r];</span><br><span class="line">        arr[r]=arr[l];</span><br><span class="line">        arr[l]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp=arr[i];</span><br><span class="line">    arr[i]=arr[l];</span><br><span class="line">    arr[l]=temp;</span><br><span class="line">    fastSort(arr,i,l-<span class="number">1</span>);</span><br><span class="line">    fastSort(arr,l+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优先队列（排序）"><a href="#3-优先队列（排序）" class="headerlink" title="3.优先队列（排序）"></a>3.优先队列（排序）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="comment">//                if(o1&gt;o2)&#123;</span></span><br><span class="line">        <span class="comment">//                    return o1-o2;</span></span><br><span class="line">        <span class="comment">//                &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//                    return o2-o1;</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//                if(o1&gt;o2)&#123;</span></span><br><span class="line">        <span class="comment">//                    //升序，因为o1是将要插入到优先队列中的元素，o2是队列中的头元素，</span></span><br><span class="line">        <span class="comment">//                    // 并且o1大于o2,所以返回1，直接放到后面</span></span><br><span class="line">        <span class="comment">//                    return 1;	   顺序变换    o1&gt;o2</span></span><br><span class="line">        <span class="comment">//                &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//                    return -1;  位置顺序不变  o1&lt;o2</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//                return o1-o2;  //升序</span></span><br><span class="line">        <span class="keyword">return</span> o2-o1;  <span class="comment">//降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] nums=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">			<span class="comment">//升序</span></span><br><span class="line">            <span class="keyword">if</span>(o1[<span class="number">0</span>]!=o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];  <span class="comment">//先根据第一维的数据进行排序，这是升序，如果换一下顺序就是降序</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pq.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size=pq.size();</span><br><span class="line">    <span class="comment">//注意在实际打印时的序列并不是有序的，而应该是依次取堆顶元素，这样取到的就是有序的</span></span><br><span class="line">    <span class="comment">//如果想让队列是有序的，可以先转化为数组再进行排序</span></span><br><span class="line">    <span class="comment">//Integer[] arr=new Integer[size];</span></span><br><span class="line">    <span class="comment">//Arrays.sort(pq.toArray(arr));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="type">int</span>[] arr=pq.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+arr[<span class="number">0</span>]+<span class="string">&quot; :&quot;</span>+arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(nums);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-归并排序-offer-51"><a href="#4-归并排序-offer-51" class="headerlink" title="4.归并排序(offer 51)"></a>4.归并排序(offer 51)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">利用对并排序求解逆序对（剑指offer 51题）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序的代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr=&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">67</span>,<span class="number">58</span>,<span class="number">12</span>,<span class="number">58</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Test</span>().mergeSort(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=arr.length-<span class="number">1</span>;</span><br><span class="line">    dfs(arr,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归划分</span></span><br><span class="line">    <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">    dfs(arr,l,m);</span><br><span class="line">    dfs(arr,m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//合并阶段</span></span><br><span class="line">    <span class="comment">//我们首先使用tmp数组存储要排序这一段数组</span></span><br><span class="line">    <span class="type">int</span>[] tmp=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= r; k++) &#123;</span><br><span class="line">        tmp[k]=arr[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再将左右有序的子树组合并为整个合起来有序的数组</span></span><br><span class="line">    <span class="comment">//用i,j来记录遍历左右子数组</span></span><br><span class="line">    <span class="type">int</span> i=l,j=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==m+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//代表左子数组已合并完，因此添加右子数组当前元素 tmp[j] ，并执行 j = j + 1；</span></span><br><span class="line">            arr[k]=tmp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==r+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//代表右子数组已合并完，因此添加左子数组当前元素tmp[i] ，并执行i=i+1；</span></span><br><span class="line">            arr[k]=tmp[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i]&gt;tmp[j])&#123;</span><br><span class="line">            <span class="comment">//当tmp[i&gt;tmp[j] 时： 添加右子数组当前元素tmp[j]，并执行j=j+1；</span></span><br><span class="line">            arr[k]=tmp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当tmp[i]≤tmp[j] 时： 添加左子数组当前元素tmp[i]，并执行i=i+1；</span></span><br><span class="line">            arr[k]=tmp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-堆排序（leetcode-215-解法见方法2）"><a href="#5-堆排序（leetcode-215-解法见方法2）" class="headerlink" title="5.堆排序（leetcode 215  解法见方法2）"></a>5.堆排序（leetcode 215  解法见方法2）</h4><blockquote>
<p>先按照顺序将数组元素组合成一个完全二叉树</p>
</blockquote>
<p><img src="https://assets.leetcode-cn.com/solution-static/215/1.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="comment">//建堆完毕后，nums【0】为最大元素。逐个删除堆顶元素，直到删除了k-1个。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//先将堆的最后一个元素与堆顶元素交换，由于此时堆的性质被破坏，需对此时的根节点进行向下调整操作。</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">//相当于删除堆顶元素，此时长度变为nums.length-2。即下次循环的i</span></span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="comment">//从最后一个父节点位置开始调整每一个节点的子树。数组长度为heasize，因此最后一个节点的位置为heapsize-1，所以父节点的位置为（heapsize-1-1)/2。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heapSize-<span class="number">2</span>)/ <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;      <span class="comment">//调整当前结点和子节点的顺序。</span></span><br><span class="line">        <span class="comment">//left和right表示当前父节点i的两个左右子节点。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, right = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="comment">//如果左子点在数组内，且比当前父节点大，则将最大值的指针指向左子点。</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; a[left] &gt; a[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果右子点在数组内，且比当前父节点大，则将最大值的指针指向右子点。</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最大值的指针不是父节点，则交换父节点和当前最大值指针指向的子节点。</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            <span class="comment">//由于交换了父节点和子节点，因此可能对子节点的子树造成影响，所以对子节点的子树进行调整。</span></span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-栈和队列"><a href="#14-栈和队列" class="headerlink" title="14.栈和队列"></a>14.栈和队列</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">剑指offer59_2</span></span><br></pre></td></tr></table></figure>

<h2 id="难题附录："><a href="#难题附录：" class="headerlink" title="难题附录："></a>难题附录：</h2><h3 id="1-lettcode-869-（关于回溯和预处理，重新排序看能否得到2次幂的数）"><a href="#1-lettcode-869-（关于回溯和预处理，重新排序看能否得到2次幂的数）" class="headerlink" title="1.lettcode 869.（关于回溯和预处理，重新排序看能否得到2次幂的数）"></a>1.lettcode 869.（关于回溯和预处理，重新排序看能否得到2次幂的数）</h3><h3 id="2-剑指Offer-35（复杂链表的复制）"><a href="#2-剑指Offer-35（复杂链表的复制）" class="headerlink" title="2.剑指Offer 35（复杂链表的复制）"></a>2.剑指Offer 35（复杂链表的复制）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意本题要求的是复制，因此原有的链表值和结构不能有改变</span></span><br><span class="line"><span class="comment">//本题的难点在于如果按照传统链表的方式进行遍历时，无法知道random指针指向的是哪里，</span></span><br><span class="line"><span class="comment">// 主要是不确定这个节点是否已经创建，因此需要先遍历一遍建立起已经创建的节点哈希表，再给构建的节点进行赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1 使用回溯+哈希表</span></span><br><span class="line">Map&lt;Node,Node&gt; hs=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node,Node&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!hs.containsKey(head))&#123;</span><br><span class="line">        Node cp=<span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        hs.put(head,cp);</span><br><span class="line">        cp.next=copyRandomList(head.next);</span><br><span class="line">        cp.random=copyRandomList(head.random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hs.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2 使用哈希表，但是是顺序遍历方式，这样比回溯方法好理解一点</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// 4. 构建新链表的 next 和 random 指向</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 返回新链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法3：使用拼接+拆分的方法</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">        tmp.next = cur.next;</span><br><span class="line">        cur.next = tmp;</span><br><span class="line">        cur = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.random != <span class="literal">null</span>)</span><br><span class="line">            cur.next.random = cur.random.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">    cur = head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="literal">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">    <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）"><a href="#3-leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）" class="headerlink" title="3.leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）"></a>3.leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">dp[i]表示的意思就是以arr[i]为结尾的子序列的长度。因此有j&lt;i&amp;&amp;arr[i]-arr[j]=d时，dp[i]=dp[j]+<span class="number">1</span></span><br><span class="line">为了方便，我们可以直接使用dp[i]就表示是以i为结尾的子序列的长度，此时就有dp[i]=dp[i-d]+<span class="number">1.</span></span><br><span class="line">#动态规划解决</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubsequence</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> difference)</span> &#123;</span><br><span class="line">    <span class="comment">//暴力破解超时</span></span><br><span class="line">    <span class="comment">/*int max=0;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length&amp;&amp;((arr.length-i-1)&gt;=max); i++) &#123;</span></span><br><span class="line"><span class="comment">            int count=1;</span></span><br><span class="line"><span class="comment">            int pre=arr[i];</span></span><br><span class="line"><span class="comment">            for (int j = i+1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">                if((arr[j]-pre)==difference)&#123;</span></span><br><span class="line"><span class="comment">                    count++;</span></span><br><span class="line"><span class="comment">                    pre=arr[j];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(count&gt;max)&#123;</span></span><br><span class="line"><span class="comment">                max=count;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return max;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划解决,该题如果不使用map来进行处理，而还是用数组的话，还是需要用两层循环，因此依旧会超时</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//使用变量记录最大值，可以减去后面遍历map，求解最大值</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> val:arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val-difference))&#123;</span><br><span class="line">            map.put(val,map.get(val-difference)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(val,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=Math.max(ans,map.get(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#数组解决办法</span><br><span class="line"><span class="comment">//该题也可以使用数组来取代hash表来进行解决，使得可以一次性就将结果查询出来</span></span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">40009</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubsequence2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        hash[i + M] = hash[i - d + M] + <span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans, hash[i + M]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）"><a href="#4-leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）" class="headerlink" title="4.leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）"></a>4.leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">1</span>背包问题的，其中背包的容量是二维的情况</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  动态规划</span></span><br><span class="line"><span class="comment"> 	*  这里dp[j][k]表示数组子集中累加的0和1的个数满足最大j个0和k个1时的子集中的字符串的最大个数</span></span><br><span class="line"><span class="comment">   	*  dp[5][3]=4就是表示子集中最多5个0和3个1的字符串个数为4</span></span><br><span class="line"><span class="comment">    *  这里我们使用滚动的二维数组来进行解决问题。</span></span><br><span class="line"><span class="comment">    *  当遍历到第i个字符串时，第i个字符串中有a=count[i][0]个0，有b=count[i][1]个1.就会出现两种情况：</span></span><br><span class="line"><span class="comment">  	*                      只有在j&gt;=a并且k&gt;=b时，才有可能出现第i个字符串是子集中的结果</span></span><br><span class="line"><span class="comment">  	*                   所以在前提条件j&gt;=a并且k&gt;=b被满足的情况下，才有下面两种情况的讨论，否则就不变</span></span><br><span class="line"><span class="comment">  	*                      第一种：子集中包括第i个字符串，dp[j][k]=dp[j-a][k-b]+1</span></span><br><span class="line"><span class="comment">  	*                      第二种：子集中不包括第i个字符串，dp[j][k]就保持不变</span></span><br><span class="line"><span class="comment">  	*  因此得到递推表达式是 dp[j][k]=Math.max(dp[j][k],dp[j-a][k-b]+1)</span></span><br><span class="line"><span class="comment">  	*  最终得到的结果就是dp[m][n]的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//注意在进行遍历的时候需要从右到左的顺序，否则会导致覆盖后的数据又被后面的数据覆盖了，导致结果数变大</span></span><br><span class="line"><span class="comment">//遍历物品，这里也是使用滚动数组的解法，只是和0-1背包问题不同的是，这里的价值是二维的，物品也是二维的</span></span><br><span class="line">    <span class="comment">//可以对空间进行优化，对于统计字符串的数组，可以在需要知道0和1的时候，用变量求解出来</span></span><br><span class="line">        <span class="comment">//可以对时间也进行优化，在j&lt;a或者k&lt;b时，dp[j][k]肯定就是保持不变的情况，可以提前结束for循环</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> strs.length;</span><br><span class="line"><span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//每个字符串都是一个物品，而m,n是一个背包，只不过是一个二维的背包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">//a、b表示strs中第i个字符串中 0和1 的个数</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:strs[i].toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;=a ; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n; k &gt;=b ; k--) &#123;</span><br><span class="line">            dp[j][k]=Math.max(dp[j-a][k-b]+<span class="number">1</span>,dp[j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-leetcode322题（该题的重点在于初始化）"><a href="#5-leetcode322题（该题的重点在于初始化）" class="headerlink" title="5.leetcode322题（该题的重点在于初始化）"></a>5.leetcode322题（该题的重点在于初始化）</h3><h3 id="6-leetcode138题（动态规划，注意这里递推公式是怎样写的）"><a href="#6-leetcode138题（动态规划，注意这里递推公式是怎样写的）" class="headerlink" title="6.leetcode138题（动态规划，注意这里递推公式是怎样写的）"></a>6.leetcode138题（动态规划，注意这里递推公式是怎样写的）</h3><h3 id="7-leetcode213题动态规划题（打家劫舍题）"><a href="#7-leetcode213题动态规划题（打家劫舍题）" class="headerlink" title="7.leetcode213题动态规划题（打家劫舍题）"></a>7.leetcode213题动态规划题（打家劫舍题）</h3><h3 id="8-leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）"><a href="#8-leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）" class="headerlink" title="8.***leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）"></a>8.***leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）</h3><h3 id="9-剑指offer36题（二叉搜索树）"><a href="#9-剑指offer36题（二叉搜索树）" class="headerlink" title="9.***剑指offer36题（二叉搜索树）"></a>9.***剑指offer36题（二叉搜索树）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二叉搜索树的性质：中序遍历是递增顺序的。</span><br></pre></td></tr></table></figure>

<h3 id="10-剑指offer的15天的题（三题都需要）需要重看一下（搜索-回溯的题）还有剑指offer68—II这道题"><a href="#10-剑指offer的15天的题（三题都需要）需要重看一下（搜索-回溯的题）还有剑指offer68—II这道题" class="headerlink" title="10.剑指offer的15天的题（三题都需要）需要重看一下（搜索+回溯的题）还有剑指offer68—II这道题"></a>10.剑指offer的15天的题（三题都需要）需要重看一下（搜索+回溯的题）还有剑指offer68—II这道题</h3><h3 id="11-剑指-Offer-64-求1-2-…-n-要求不能使用if-else-switch-A-B-C等结构"><a href="#11-剑指-Offer-64-求1-2-…-n-要求不能使用if-else-switch-A-B-C等结构" class="headerlink" title="11.剑指 Offer 64. 求1+2+…+n.要求不能使用if,else,switch,A?B:C等结构"></a>11.剑指 Offer 64. 求1+2+…+n.要求不能使用if,else,switch,A?B:C等结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重点掌握两种解决方法</span></span><br><span class="line">-位元算+快速乘法+高斯公式</span><br><span class="line">-位运算+递归解法</span><br></pre></td></tr></table></figure>

<h3 id="12-剑指offer16（求解数的整数次方）"><a href="#12-剑指offer16（求解数的整数次方）" class="headerlink" title="12.剑指offer16（求解数的整数次方）"></a>12.剑指offer16（求解数的整数次方）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重点掌握方法</span></span><br><span class="line">	-记忆化递归</span><br><span class="line">	-快速幂(重点掌握) 结合数的二进制来进行解决 </span><br></pre></td></tr></table></figure>

<h3 id="13-剑指Offer62-（求解圆圈中最后剩余的数字，约瑟夫环）"><a href="#13-剑指Offer62-（求解圆圈中最后剩余的数字，约瑟夫环）" class="headerlink" title="13.***剑指Offer62 （求解圆圈中最后剩余的数字，约瑟夫环）"></a>13.***剑指Offer62 （求解圆圈中最后剩余的数字，约瑟夫环）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该题的核心主要在于反推，主要题解见 https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</span> </span><br></pre></td></tr></table></figure>



<h3 id="14-leetcode677题"><a href="#14-leetcode677题" class="headerlink" title="14.leetcode677题"></a>14.leetcode677题</h3><h3 id="15-剑指offer20题待看，使用有限状态机进行解决"><a href="#15-剑指offer20题待看，使用有限状态机进行解决" class="headerlink" title="15.剑指offer20题待看，使用有限状态机进行解决"></a>15.剑指offer20题待看，使用有限状态机进行解决</h3><h3 id="16-leetcode423-学习这种解决问题的方法"><a href="#16-leetcode423-学习这种解决问题的方法" class="headerlink" title="16.leetcode423 学习这种解决问题的方法"></a>16.leetcode423 学习这种解决问题的方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">首先解决只存在一个未知数的方程求出这些方程中的未知数，再根据这些得到未知数的值代入到原来有多个未知数的方程中去，然后再依次进行求解。</span></span><br></pre></td></tr></table></figure>

<h3 id="17-剑指offer-38-回溯"><a href="#17-剑指offer-38-回溯" class="headerlink" title="17.剑指offer 38 回溯"></a>17.剑指offer 38 回溯</h3><h3 id="18-剑指offer-49-求解丑数"><a href="#18-剑指offer-49-求解丑数" class="headerlink" title="18.剑指offer 49 (求解丑数)"></a>18.剑指offer 49 (求解丑数)</h3><h3 id="19-剑指offer-60-（求解骰子的点数）"><a href="#19-剑指offer-60-（求解骰子的点数）" class="headerlink" title="19.剑指offer 60 （求解骰子的点数）"></a>19.剑指offer 60 （求解骰子的点数）</h3><h3 id="20-剑指offer-19-正则表达式匹配-动态规划"><a href="#20-剑指offer-19-正则表达式匹配-动态规划" class="headerlink" title="20.剑指offer 19 (正则表达式匹配 动态规划)"></a>20.剑指offer 19 (正则表达式匹配 动态规划)</h3><h3 id="21-剑指offer17-学会要掌握处理大数越界的问题"><a href="#21-剑指offer17-学会要掌握处理大数越界的问题" class="headerlink" title="21.剑指offer17 学会要掌握处理大数越界的问题"></a>21.剑指offer17 学会要掌握处理大数越界的问题</h3><h3 id="22-剑指offer-51-归并排序与逆序对"><a href="#22-剑指offer-51-归并排序与逆序对" class="headerlink" title="22.剑指offer 51 (归并排序与逆序对)"></a>22.剑指offer 51 (归并排序与逆序对)</h3><h3 id="23-剑指offer44题-（数字模拟）"><a href="#23-剑指offer44题-（数字模拟）" class="headerlink" title="23.剑指offer44题 （数字模拟）"></a>23.剑指offer44题 （数字模拟）</h3><h3 id="24-leetcode372（利用快速幂求解一个数的超级次方）"><a href="#24-leetcode372（利用快速幂求解一个数的超级次方）" class="headerlink" title="24.leetcode372（利用快速幂求解一个数的超级次方）"></a>24.leetcode372（利用快速幂求解一个数的超级次方）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以利用倒叙和正序的方法进行解题，正序的话就是使用秦九韶公式进行解决</span></span><br></pre></td></tr></table></figure>

<h3 id="25-leetcode1143-该题是典型的两维动态规划"><a href="#25-leetcode1143-该题是典型的两维动态规划" class="headerlink" title="25.leetcode1143	(该题是典型的两维动态规划)"></a>25.leetcode1143	(该题是典型的两维动态规划)</h3><h3 id="26-leetcode825-利用数学式子来进行解决问题-计数排序和排序"><a href="#26-leetcode825-利用数学式子来进行解决问题-计数排序和排序" class="headerlink" title="26.leetcode825(利用数学式子来进行解决问题)[计数排序和排序]"></a>26.leetcode825(利用数学式子来进行解决问题)[计数排序和排序]</h3><h3 id="27-leetcode394-（利用辅助栈来进行解决）"><a href="#27-leetcode394-（利用辅助栈来进行解决）" class="headerlink" title="27.leetcode394 （利用辅助栈来进行解决）"></a>27.leetcode394 （利用辅助栈来进行解决）</h3><h3 id="28-leetcode390-学习这种分析问题的做法，利用数学的方法进行解决"><a href="#28-leetcode390-学习这种分析问题的做法，利用数学的方法进行解决" class="headerlink" title="28.leetcode390(学习这种分析问题的做法，利用数学的方法进行解决)"></a>28.leetcode390(学习这种分析问题的做法，利用数学的方法进行解决)</h3><h3 id="29-leetcode-686题（上下界，字符串哈希的方法）"><a href="#29-leetcode-686题（上下界，字符串哈希的方法）" class="headerlink" title="29.leetcode 686题（上下界，字符串哈希的方法）"></a>29.leetcode 686题（上下界，字符串哈希的方法）</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/leetcode%E7%AC%94%E8%AE%B0/" data-id="clrv16wje000jz5ku41rm4ds7" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-typora/hyperledger farbric使用笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/hyperledger%20farbric%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="hyperledger-farbric使用笔记"><a href="#hyperledger-farbric使用笔记" class="headerlink" title="hyperledger farbric使用笔记"></a>hyperledger farbric使用笔记</h1><h2 id="1-环境工具准备"><a href="#1-环境工具准备" class="headerlink" title="1.环境工具准备"></a>1.环境工具准备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.安装git</span></span><br><span class="line">[root@study ~]# apt-get install git</span><br><span class="line">如果显示apt-get不是命令，就执行下面的两步下载apt-get(这个工具有点类似于yum，也是一样下载工具)</span><br><span class="line">    1-1.下载apt-get</span><br><span class="line">    [root@study ~]# curl https://raw.githubusercontent.com/dvershinin/apt-get-centos/master/apt-get.sh -o /usr/local/bin/apt-get</span><br><span class="line">    1-2.修改apt-get权限</span><br><span class="line">    [root@study ~]# chmod 0755 /usr/local/bin/apt-get</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.下载cURL，这个工具一般系统上都有</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.下载docker (结合文章下载 https://www.jianshu.com/p/7d9ff93bc89e)</span></span><br><span class="line">	安装 Docker</span><br><span class="line"></span><br><span class="line">    3-1更新到最新 yum 包</span><br><span class="line">    [root@study ~]# yum update -y</span><br><span class="line"></span><br><span class="line">    3-2卸载旧版本（如果安装过旧版本的话）</span><br><span class="line">    [root@study ~]# yum remove docker docker-common docker-selinux docker-engine docer-io</span><br><span class="line"></span><br><span class="line">    3-3安装需要的软件包.yum-util 提供 yum-config-manager 功能， 另外两个是 devicemapper 驱动依赖</span><br><span class="line">    [root@study ~]# yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">    3-4设置 yum 源</span><br><span class="line">    [root@study ~]# yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">    3-5查看所有仓库中所有 docker 版本，并选择特定版本安装</span><br><span class="line">    [root@study ~]# yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line">    3-6由于 repo 中默认只开启 stable 的仓库，故这里安装的是最新稳定版（18.09.2）</span><br><span class="line">    （由于内核是 3.10 无法正常运行 18.06.x 及以上版本的 docker，所以不这么安装）</span><br><span class="line">    [root@study ~]# yum install -y docker-ce  </span><br><span class="line"></span><br><span class="line">    3-6（下面这个是系统达不到要求的话，执行安装低版本的，我这里使用上面的）</span><br><span class="line">    经过测试发现，3.10 内核可以运行 18.03.1.ce。yum install -y &lt;指定的版本&gt;</span><br><span class="line">    yum install -y docker-ce-18.03.1.ce</span><br><span class="line"></span><br><span class="line">    3-7启动并加入开机启动</span><br><span class="line">    [root@study ~]# systemctl start docker</span><br><span class="line">    [root@study ~]# systemctl enable docker</span><br><span class="line"></span><br><span class="line">    3-8验证安装是否成功（有 client 和 service 两部分表示 docker 安装启动都成功了）</span><br><span class="line">    [root@study ~]# docker --version</span><br><span class="line">    [root@study ~]# docker-compose --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.安装docker-compose</span></span><br><span class="line">	4-1下载最新版本的 docker-compose 到 /usr/bin 目录下</span><br><span class="line">	[root@study ~]# curl -L https://github.com/docker/compose/releases/download/1.23.2/docker-compose-`uname -s`-`uname -m` -o /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line">	4-2给 docker-compose 授权</span><br><span class="line">	[root@study ~]# chmod +x /usr/bin/docker-compose</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5.安装go环境</span></span><br><span class="line">	5-1安装go</span><br><span class="line">	[root@study ~]# yum install golang</span><br><span class="line">	5-0如果出现没有对应的源就先安装erel源,再执行上面的安装命令</span><br><span class="line">	[root@study ~]# yum install epel-release</span><br><span class="line">	5-2测试go是否安装成功</span><br><span class="line">	[root@study ~]# go version</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6.配置go的环境变量</span></span><br><span class="line">    6-1编辑配置文件（其中工作路径为 &#x27;/var/goproject&#x27; ，即我们编写的代码放到这个目录下面运行。）</span><br><span class="line">    [root@study ~]# vim /etc/profile</span><br><span class="line">        在文件的末尾添加如下代码：</span><br><span class="line">        export GOROOT=/usr/lib/go</span><br><span class="line">        export GOPATH=/var/goproject</span><br><span class="line">        export PATH=$PATH:$GOROOT/bin</span><br><span class="line">	6-2让环境变量生效</span><br><span class="line">	[root@study ~]# source /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="2-下载安装Fabric-and-Fabric-Samples并运行test-network"><a href="#2-下载安装Fabric-and-Fabric-Samples并运行test-network" class="headerlink" title="2.下载安装Fabric and Fabric Samples并运行test-network"></a>2.下载安装Fabric and Fabric Samples并运行test-network</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.新建目录(存放的目录)</span></span><br><span class="line">    [root@study ~]# mkdir -p $HOME/go/src/github.com/kdhello</span><br><span class="line">    [root@study ~]# cd $HOME/go/src/github.com/kdhello</span><br><span class="line">	为了后期管理的方便，创建了一个latest文件夹，是指下的这一个版本的文件（这时下载的是farbric2.3.3和farbric-ca1.5.2）</span><br><span class="line">	[root@study kdhello]# mkdir latest</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.下载二进制文件和样例(这里存在一定的问题，应该按照指定的版本进行执行)</span></span><br><span class="line">	[root@study latest]# curl -sSL https://bit.ly/2ysbOFE | bash -s</span><br><span class="line">    [root@study latest]# cd fabric-samples/test-network</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.在开启之前先关闭之前运行的容器或工件（containers or artifacts）</span></span><br><span class="line">	[root@study test-network]# ./network.sh down</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.开启容器</span></span><br><span class="line">	[root@study test-network]# ./network.sh up</span><br></pre></td></tr></table></figure>

<h2 id="3-关于docker容器操作的一些命令"><a href="#3-关于docker容器操作的一些命令" class="headerlink" title="3.关于docker容器操作的一些命令"></a>3.关于docker容器操作的一些命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.查看当前正在运行的容器</span></span><br><span class="line">	[root@study test-network]# docker ps -a</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211113164017981.png" alt="image-20211113164017981"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.创建channel。//如果容器未开启，会先开启容器，再创建隧道。</span></span><br><span class="line">	第一种方式：</span><br><span class="line">	[root@study test-network]# ./network.sh createChannel  </span><br><span class="line">	第二种方式：（指定隧道名channel1）</span><br><span class="line">	[root@study test-network]# ./network.sh createChannel -c channel1</span><br></pre></td></tr></table></figure>

<h2 id="4-network-sh的用法"><a href="#4-network-sh的用法" class="headerlink" title="4..&#x2F;network.sh的用法"></a>4..&#x2F;network.sh的用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  network.sh &lt;Mode&gt; [Flags]</span><br><span class="line">    Modes:</span><br><span class="line">      up - Bring up Fabric orderer and peer nodes. No channel is created</span><br><span class="line">      up createChannel - Bring up fabric network with one channel</span><br><span class="line">      createChannel - Create and join a channel after the network is created</span><br><span class="line">      deployCC - Deploy a chaincode to a channel (defaults to asset-transfer-basic)</span><br><span class="line">      down - Bring down the network</span><br><span class="line"></span><br><span class="line">    Flags:</span><br><span class="line">    Used with network.sh up, network.sh createChannel:</span><br><span class="line">    -ca &lt;use CAs&gt; -  Use Certificate Authorities to generate network crypto material</span><br><span class="line">    -c &lt;channel name&gt; - Name of channel to create (defaults to &quot;mychannel&quot;)</span><br><span class="line">    -s &lt;dbtype&gt; - Peer state database to deploy: goleveldb (default) or couchdb</span><br><span class="line">    -r &lt;max retry&gt; - CLI times out after certain number of attempts (defaults to 5)</span><br><span class="line">    -d &lt;delay&gt; - CLI delays for a certain number of seconds (defaults to 3)</span><br><span class="line">    -i &lt;imagetag&gt; - Docker image tag of Fabric to deploy (defaults to &quot;latest&quot;)</span><br><span class="line">    -cai &lt;ca_imagetag&gt; - Docker image tag of Fabric CA to deploy (defaults to &quot;latest&quot;)</span><br><span class="line">    -verbose - Verbose mode</span><br><span class="line"></span><br><span class="line">    Used with network.sh deployCC</span><br><span class="line">    -c &lt;channel name&gt; - Name of channel to deploy chaincode to</span><br><span class="line">    -ccn &lt;name&gt; - Chaincode name.</span><br><span class="line">    -ccl &lt;language&gt; - Programming language of the chaincode to deploy: go (default), java, javascript, typescript</span><br><span class="line">    -ccv &lt;version&gt;  - Chaincode version. 1.0 (default), v2, version3.x, etc</span><br><span class="line">    -ccs &lt;sequence&gt;  - Chaincode definition sequence. Must be an integer, 1 (default), 2, 3, etc</span><br><span class="line">    -ccp &lt;path&gt;  - File path to the chaincode.</span><br><span class="line">    -ccep &lt;policy&gt;  - (Optional) Chaincode endorsement policy using signature policy syntax. The default policy requires an endorsement from Org1 and Org2</span><br><span class="line">    -cccg &lt;collection-config&gt;  - (Optional) File path to private data collections configuration file</span><br><span class="line">    -cci &lt;fcn name&gt;  - (Optional) Name of chaincode initialization function. When a function is provided, the execution of init will be requested and the function will be invoked.</span><br><span class="line"></span><br><span class="line">    -h - Print this message</span><br><span class="line"></span><br><span class="line"> Possible Mode and flag combinations</span><br><span class="line">   up -ca -r -d -s -i -cai -verbose</span><br><span class="line">   up createChannel -ca -c -r -d -s -i -cai -verbose</span><br><span class="line">   createChannel -c -r -d -verbose</span><br><span class="line">   deployCC -ccn -ccl -ccv -ccs -ccp -cci -r -d -verbose</span><br><span class="line"></span><br><span class="line"> Examples:</span><br><span class="line">   network.sh up createChannel -ca -c mychannel -s couchdb -i 2.0.0</span><br><span class="line">   network.sh createChannel -c channelName</span><br><span class="line">   network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript/ -ccl javascript</span><br><span class="line">   network.sh deployCC -ccn mychaincode -ccp ./user/mychaincode -ccv 1 -ccl javascript</span><br></pre></td></tr></table></figure>

<h2 id="5-下载fabric和fabric-ca的包"><a href="#5-下载fabric和fabric-ca的包" class="headerlink" title="5.下载fabric和fabric-ca的包"></a>5.下载fabric和fabric-ca的包</h2><blockquote>
<p>分别手动下载 <code>fabric</code> 和 <code>fabric-ca</code> 编译后的压缩包，存放在 <code>fabric/scripts/</code> 目录下：</p>
<p> (这两个压缩包实际上对应的就是fabric和fabric-ca的源码压缩包)</p>
<ul>
<li>所以如果自己在要改写这些内容的时候就是改写源码里面的内容然后进行go build生成二进制文件放进去</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/hyperledger/fabric/releases/download/v2.4.1/hyperledger-fabric-linux-amd64-2.4.2.tar.gz  </span><br><span class="line"></span><br><span class="line">https://github.com/hyperledger/fabric-ca/releases/download/v1.5.2/hyperledger-fabric-ca-linux-amd64-1.5.2.tar.gz</span><br></pre></td></tr></table></figure>

<p>压缩压缩包，得到 <code>bin</code> 与 <code>config</code> 两个文件夹：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hyperledger-fabric-linux-amd64-2.4.1.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf hyperledger-fabric-ca-linux-amd64-1.5.2.tar.gz</span><br></pre></td></tr></table></figure>

<p>执行以下命令复制 <code>fabric-samples</code> 目录中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -r bin fabric-samples/</span><br><span class="line">cp -r config fabric-samples/</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="6-生成二进制文件"><a href="#6-生成二进制文件" class="headerlink" title="6.生成二进制文件"></a>6.生成二进制文件</h2><p>主要有两种方式：</p>
<blockquote>
<ol>
<li><p>使用 go build 命令</p>
<ul>
<li>1.进入&#x2F;fabric&#x2F;cmd&#x2F;orderer目录，然后执行 go build oderer</li>
<li>2.这种方式生成的oderer二进制命令文件直接就在 &#x2F;fabric&#x2F;cmd&#x2F;orderer&#x2F;orderer</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220408212720072.png" alt="image-20220408212720072"></p>
</li>
<li><p>使用make命令</p>
<ul>
<li>1.进入&#x2F;fabric目录，然后执行命令 make peer   (其他命令类似，例如make orderer)</li>
<li>2.生成的perr二进制命令会存储在 &#x2F;fabric&#x2F;build&#x2F;peer里面</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220408212812195.png" alt="image-20220408212812195"></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220408212833428.png" alt="image-20220408212833428"></p>
</li>
</ol>
</blockquote>
<h1 id="XX-错误排查："><a href="#XX-错误排查：" class="headerlink" title="XX:错误排查："></a>XX:错误排查：</h1><p>1.但出现如图所示的错误时，是docker-compose的版本过低导致的，将原先的docker-compose旧版本删除，再安装新的版本<img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220404202807887.png" alt="image-20220404202807887"></p>
<ul>
<li><p>解决办法：（<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a> 这是官网的解决办法）</p>
<ul>
<li><p>1.查看docker-compose安装的位置 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai ~]# which docker-compose </span><br><span class="line">/usr/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.删除该文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai ~]# rm /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.安装新版本 (注意版本号需要去官网查看)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai ~]# curl -L https://github.com/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` -o /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.给docker-compose执行权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai ~]# chmod +x /usr/bin/docker-compose</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/hyperledger%20farbric%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" data-id="clrv16wjf000kz5ku1bet9brl" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-typora/ssm-crud" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/ssm-crud/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ssm-crud"><a href="#ssm-crud" class="headerlink" title="ssm-crud"></a>ssm-crud</h1><h2 id="0-基础环境搭建"><a href="#0-基础环境搭建" class="headerlink" title="0.基础环境搭建"></a>0.基础环境搭建</h2><blockquote>
<ol>
<li>创建一个maven工程</li>
<li>引入项目依赖的jar包<ul>
<li>spring</li>
<li>springmvc</li>
<li>mybatis</li>
<li>数据库连接包，驱动包</li>
<li>其他包（jstl,servlet-api,junit）</li>
</ul>
</li>
<li>引入bootstrap前端框架</li>
<li>编写ssm整合的关键配置文件<ol>
<li>web.xml,spring,springmvc,mybatis</li>
</ol>
</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/ssm-crud/" data-id="clrv16wjf000lz5ku8n2b9ht0" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-typora/replicate" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/replicate/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/replicate/" data-id="clrv16wjf000mz5kugt790ryc" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-typora/共识算法笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="共识算法笔记"><a href="#共识算法笔记" class="headerlink" title="共识算法笔记"></a>共识算法笔记</h1><h2 id="1-分布式基础"><a href="#1-分布式基础" class="headerlink" title="1.分布式基础"></a>1.分布式基础</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1. 2阶段提交协议（2PC Two-phase Commit）</span></span><br><span class="line">	在分布式系统中，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。因此，二阶段提交的算法思路可以概括为： 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</span><br><span class="line">	</span><br><span class="line">	算法成立基于以下前提和假设：</span><br><span class="line">		1.该分布式系统中，存在一个节点作为协调者（Coordinator），其他节点作为参与者（Participants）。且节点之间可以进行网络通信。</span><br><span class="line">		2.所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</span><br><span class="line">		3.所有节点不会永久性损坏，即使损坏后仍然可以恢复。</span><br><span class="line">	</span><br><span class="line">	缺点：二阶段提交协议是阻塞的</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2. 3阶段提交协议（3PC）</span></span><br><span class="line">	与两阶段提交不同的是，三阶段提交是“非阻塞”协议。三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3. 远程过程调用（RPC）  /在面向对象编程中，RPC表示为远程方法调用(RMI)</span> </span><br><span class="line">	远程过程调用( RPC ) 是当计算机程序导致过程（子例程）在不同的地址空间（通常在共享网络上的另一台计算机上）执行时，它被编码为一个正常的（本地）过程调用，无需程序员为远程交互显式编码细节。通常通过请求-响应消息传递系统实现。</span><br><span class="line">	有go语言的rpc包，java的RMI远程方法调用，</span><br><span class="line">	Google Protocol Buffers (protobufs) 包包括用于其 RPC 协议[12]的接口定义语言，于 2015 年作为gRPC 开源。[13]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-Raft算法"><a href="#2-Raft算法" class="headerlink" title="2.Raft算法"></a>2.Raft算法</h2><h4 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为了便于可理解性，做了以下这两点。</span></span><br><span class="line">	1.第一将raft算法分为了三个部分，领导者选举，日志复制，安全性。</span><br><span class="line">	2.通过减少要考虑的状态数量来简化状态空间，使系统更加连贯并尽可能消除不确定性。使用了随机化来简化 Raft 领导者选举算法。</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">raft算法是2f+1型算法，即在2f+1个节点的情况下，可以容忍有f个故障节点</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Raft 将时间划分为任意长度的任期。</span></span><br><span class="line">	每个任期以选举开始。 选举成功后，由一个领导者管理集群直到任期结束。 一些选举失败，在这种情况下，任期结束而没有选择领导者。 可以在不同服务器上的不同时间观察任期之间的转换。任期在 Raft 中充当逻辑时钟。</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Raft算法中主要有两个常用RPC:</span></span><br><span class="line">	RequestVote RPC:由候选人在选举期间发起</span><br><span class="line">	AppendEntries RPC:由领导者发起以复制日志条目并提供一种心跳形式</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">状态机复制（replicate state machine）</span></span><br><span class="line">	在计算机科学领域，状态机复制是实现容错服务的一种常规方法，主要通过复制服务器，并协调客户端和这些服务器镜像间的交互来达到目标。这个方法也同时提供了理解和设计复制管理协议的一套基本框架。</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">split</span> vote(分裂选票)</span></span><br><span class="line">	分裂投票可能源于投票分裂，这种分裂发生在选举中，当两个或两个以上相似候选人的存在减少了他们每个人获得的选票，从而降低了其中任何一个人赢得另一个明显不同的候选人的机会。在要求获胜候选人获得多数选票的系统中，这可能会导致决选。</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-领导者选举"><a href="#2-领导者选举" class="headerlink" title="2.领导者选举"></a>2.领导者选举</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">网络分裂选票（网络分区）</span></span><br><span class="line">	候选人既不赢也不输选举：如果许多追随者同时成为候选人，可能会分裂选票，从而没有候选人获得多数票。 发生这种情况时，每个候选人将超时并通过增加其任期并启动另一轮 RequestVote RPC 来开始新的选举。 然而，如果没有额外的措施，分裂选票可能会无限期地重复。</span><br><span class="line">	Raft 使用随机选举超时来确保分裂选票很少发生并且它们被快速解决。每个候选人在选举开始时重新开始其随机选举超时，并在开始下一次选举之前等待该超时过去； 这降低了在新选举中再次出现分裂投票的可能性。</span><br></pre></td></tr></table></figure>

<h4 id="3-日志复制"><a href="#3-日志复制" class="headerlink" title="3.日志复制"></a>3.日志复制</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">日志、任期(term)、条目（entries）</span></span><br><span class="line">	日志由按顺序编号(index)的条目组成。 每个条目包含创建它的术语（每个框中的数字）和状态机的命令。 如果该条目可以安全地应用于状态机，则该条目被视为已提交。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">领导者和跟随者都有自己的日志和复制状态机</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211116215730184.png" alt="image-20211116215730184"></p>
<h2 id="3-Raft算法改进"><a href="#3-Raft算法改进" class="headerlink" title="3.Raft算法改进"></a>3.Raft算法改进</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用门限签名  (Sho)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用增量<span class="built_in">hash</span>  (对最后一个日志进行<span class="built_in">hash</span>运算，需要依靠前面<span class="built_in">hash</span>的结果，所以当最后一个<span class="built_in">hash</span>的结果一致，说明前面的日志就也一致)</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" data-id="clrv16wjf000nz5kuesd9e66f" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-typora/temp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/temp/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java秒杀系统:</p>
<ul>
<li><p>项目框架搭建：</p>
<ul>
<li>SpringBoot环境搭建</li>
<li>集成Thymeleaf，RespBean</li>
<li>mybatis</li>
</ul>
</li>
<li><p>分布式会话：</p>
<ul>
<li><p>用户登录</p>
<ul>
<li><p>设计数据库</p>
<ul>
<li>主要有以下这些表。用户表、商品表、订单表、秒杀商品表、秒杀订单表</li>
</ul>
</li>
<li><p>明文密码二次MD5加密</p>
<ul>
<li><p>为什么要进行二次MD5加密？</p>
</li>
<li><pre><code class="shell"># 第一次 （在前端加密，客户端）：密码加密是（明文密码+固定盐值）生成md5用于传输，目的，由于http是明文传输，当输入密码若直接发送服务端验证，此时被截取将直接获取到明文密码，获取用户信息。

# 第二次（服务端）：当获取到前端发送来的密码后。通过MD5（密码+随机盐值）再次生成密码后存入数据库。
防止数据库被盗的情况下，通过md5反查，查获用户密码。方法是盐值会在用户登陆的时候随机生成，并存在数据库中，这个时候就会获取到。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 参数校验+全局异常处理</span><br><span class="line"></span><br><span class="line">      - 利用枚举+公共返回对象来实现全局异常处理</span><br><span class="line"></span><br><span class="line">  - 共享Session</span><br><span class="line"></span><br><span class="line">    - Cookie存储在客户端，Session存储在服务端 【通过response的set-cookie来进行设置cookie并返回给客户端，客户端在发送请求时，就会携带存储在cookie中的session信息，服务端就可以根据客户端传来的session信息与自己存储的session信息进行比对】</span><br><span class="line">    - 解决分布式共享问题。</span><br><span class="line">      - 分布式共享问题：session是通过Servlet创建的，tomcat服务器都是将其存储在内存中，所以在分布式环境下，进行负载均衡时，就会出现同一用户的请求就会被分发到两个web站点上。</span><br><span class="line">    - SpringSession</span><br><span class="line">    - Redis</span><br><span class="line">      - 使用Redis来进行存储，将用户cookie信息与用户进行映射。</span><br><span class="line"></span><br><span class="line">- 功能开发</span><br><span class="line"></span><br><span class="line">  - 商品列表</span><br><span class="line">  - 商品详情</span><br><span class="line">  - 秒杀</span><br><span class="line">  - 订单详情</span><br><span class="line"></span><br><span class="line">- 系统压测</span><br><span class="line"></span><br><span class="line">  - JMeter</span><br><span class="line"></span><br><span class="line">  - 自定义变量模拟多用户</span><br><span class="line"></span><br><span class="line">  - 正式压测</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。 </span><br><span class="line">      TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。 它是软件测试结果的测量单位。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>商品列表</p>
</li>
<li><pre><code>* windows优化前QPS: 256  
* linux优化前QPS: 164
*
* windows优化页面缓存和对象缓存后QPS: 871
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 秒杀</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">   * 秒杀</span><br><span class="line">   * windows优化前QPS： 270</span><br><span class="line">   * linux优化前：122</span><br><span class="line">   *</span><br><span class="line">   * windows优化缓存和页面静态化后QPS: 348</span><br><span class="line">   *</span><br><span class="line">   * rabbitmq优化缓存后qps: 539</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>页面优化 （见文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Wangdiankun/article/details/106663103">https://blog.csdn.net/Wangdiankun/article/details/106663103</a> ）</p>
<ul>
<li>页面缓存+URL缓存+对象缓存<ul>
<li>页面缓存：对于通用页面，一般使用页面缓存，直接将需要返回给用户的页面存储到redis中，然后当有人再次访问时直接出redis中取出直接返回给用户，不在进行其他操作，节省系统资源。（设置过期时间）</li>
<li>url缓存：url缓存是一种特殊的页面缓存，原因在于他有特殊的参数信息，对应不同的页面，比如一个商品的详情页，就需要url缓存，因为不同的商品有不同的信息，使用页面缓存并不能实现这一功能。 （设置过期时间）</li>
<li>对象缓存在所有缓存中是一个比较小的缓存单位，最常用的是对用户常用信息的缓存，加快系统对常用用户信息的读取速度从而加快系统的反应速度。</li>
</ul>
</li>
<li>页面静态化，前后端分离<ul>
<li>页面静态化也是前后端分离的一大优势所在，就是利用浏览器缓存数据从而减少与服务器的交互。</li>
</ul>
</li>
<li>静态资源优化<ul>
<li>（1）JS&#x2F;CSS压缩，减少流量<br>（2）多个JS&#x2F;CSS组合，减少连接数<br>（3）CDN就近访问</li>
</ul>
</li>
</ul>
</li>
<li><p>接口优化</p>
<ul>
<li><p>Redis预减库存减少数据库的访问</p>
<ul>
<li><pre><code>// 例如在进行下单的时候。还有在判断是否重复抢购的时候
这里是将向mysql数据库中查询的过程转化为向redis内存数据库中进行查询
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 内存标记减少Redis的访问</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    //通过内存标记减少redis的访问，可以通过设置一个全局变量map来存储每个商品剩余的数量，从而可以减少对redis数据库的查询</span><br><span class="line">    if (emptyStockMap.get(goodsId)) &#123;</span><br><span class="line">    	return RespBean.error(RespBeanEnum.EMPTY_STOCK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>Rabbitmq异步下单</p>
<ul>
<li><pre><code>下单   通过RabbitMQ可以快速返回，从而达到一个流量削峰的功能，将向MYSQL查询的过程放在queue中进行完成

//在前端页面js中，使用rabbitmq后，需要进行判断是否已经下单成功，还是在排队中
</code></pre>
</li>
<li><p>Springboot整合rabbitmq</p>
</li>
<li><p>交换机</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>安全优化</p>
<ul>
<li>秒杀接口地址隐藏</li>
<li>算术验证码</li>
<li>接口防刷</li>
</ul>
</li>
<li><p>主流的秒杀方案</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/temp/" data-id="clrv16wjg000oz5ku4frf28m5" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-typora/leetcode笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/leetcode%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="leetcode笔记"><a href="#leetcode笔记" class="headerlink" title="leetcode笔记"></a>leetcode笔记</h1><h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h2><h4 id="1-字符串哈希（leetcode-686）"><a href="#1-字符串哈希（leetcode-686）" class="headerlink" title="1.字符串哈希（leetcode 686）"></a>1.字符串哈希（leetcode 686）</h4><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h2><h4 id="1-删除自身节点。（不能获取到头节点）"><a href="#1-删除自身节点。（不能获取到头节点）" class="headerlink" title="1.删除自身节点。（不能获取到头节点）"></a>1.删除自身节点。（不能获取到头节点）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode227题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="comment">//论如何获得永生:先将自己变成后面的节点，然后再杀死自己</span></span><br><span class="line">    ListNode last=node.next;</span><br><span class="line">    node.val= last.val;</span><br><span class="line">    node.next=last.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-树"><a href="#4-树" class="headerlink" title="4.树"></a>4.树</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代(即深度优先遍历二叉树)</span></span><br><span class="line"><span class="comment">     * 先序遍历二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) <span class="comment">//先压入右子树</span></span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) <span class="comment">//再压入左子树</span></span><br><span class="line">                stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代</span></span><br><span class="line"><span class="comment">     * 中序遍历二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">          List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span>  list;</span><br><span class="line">          Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">          <span class="keyword">while</span>(p != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">                  s.push(p);</span><br><span class="line">                  p = p.left;</span><br><span class="line">              &#125;</span><br><span class="line">              p = s.pop();</span><br><span class="line">              list.add(p.val);</span><br><span class="line">              p = p.right;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(list);</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序非递归遍历二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();    </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root, prev = root; <span class="comment">//pre记录上一个已经输出的结点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || stack.size() &gt; <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;    </span><br><span class="line">                stack.push(node);    </span><br><span class="line">                node = node.left;    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.peek().right; <span class="comment">//在出栈之前，先判断栈顶元素的右孩子结点</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span> || temp == prev) &#123; <span class="comment">//当前节点无右子树或右子树已经输出    </span></span><br><span class="line">                node = stack.pop();    </span><br><span class="line">                list.add(node.val);</span><br><span class="line">                prev = node; <span class="comment">//记录上一个已输出结点</span></span><br><span class="line">                node = <span class="literal">null</span>;    </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                node = temp; <span class="comment">//处理右子树</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-回溯"><a href="#5-回溯" class="headerlink" title="5.回溯"></a>5.回溯</h2><h2 id="6-贪心"><a href="#6-贪心" class="headerlink" title="6.贪心"></a>6.贪心</h2><h2 id="7-动态规划"><a href="#7-动态规划" class="headerlink" title="7.动态规划"></a>7.动态规划</h2><h4 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0-1背包问题</span></span><br><span class="line">	有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</span><br><span class="line">	---背包有是一维的情况</span><br><span class="line">	---背包也有多维的情况（如leetcode474）</span><br><span class="line">	//核心代码，注意滚动数组要从右往左，否则就成了完全背包了</span><br><span class="line">	for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">        for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">完全背包问题</span></span><br><span class="line">	有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</span><br><span class="line">	根据遍历物品与遍历背包的不同又会有求排列数和组合数的不同</span><br><span class="line">	---如果求组合数就是外层for循环遍历物品，内层for遍历背包。（1,5）和（5，1）是同一种情况（如leetcode518题）</span><br><span class="line">	//组合代码</span><br><span class="line">	public int change(int amount, int[] coins) &#123;</span><br><span class="line">        int[] dp=new int[amount+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for (int i = 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            for (int j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">	---如果求排列数就是外层for遍历背包，内层for循环遍历物品。（1,5）和（5，1）是两种情况（如leetcode377题）</span><br><span class="line">	//排列代码</span><br><span class="line">	public int combinationSum4(int[] nums, int target) &#123;</span><br><span class="line">        int[] dp=new int[target+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for (int i = 0; i &lt;= target; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class="line">                if(i&gt;=nums[j])&#123;</span><br><span class="line">                    dp[i]=dp[i]+dp[i-nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];        </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 先遍历物品，再遍历背包</span><br><span class="line">    for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">        for(int j = weight[i]; j &lt; bagWeight ; j++) &#123; // 遍历背包容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">爬楼梯问题</span></span><br><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    //简单动态规划的解法</span><br><span class="line">    // if(n&lt;=2)&#123;</span><br><span class="line">    //     return n;</span><br><span class="line">    // &#125;</span><br><span class="line">    // int a=1,b=2;</span><br><span class="line">    // for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">    //     int c=b;</span><br><span class="line">    //     b=a+b;</span><br><span class="line">    //     a=c;</span><br><span class="line">    // &#125;</span><br><span class="line">    // return b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将爬楼梯问题转化为完全背包的排列问题</span><br><span class="line">    //将代码中的2可以改为m,即一下子可以爬1到m阶楼梯，就相当于有1到m的面值的无限硬币个数，可以组成的总钱数为n的排列数有多少</span><br><span class="line">    int[] dp=new int[n+1];</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=2;j++)&#123;</span><br><span class="line">            if(i&gt;=j)&#123;</span><br><span class="line">            dp[i]=dp[i]+dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211106192739458.png" alt="image-20211106192739458"></p>
<h4 id="2-打家劫舍问题"><a href="#2-打家劫舍问题" class="headerlink" title="2.打家劫舍问题"></a>2.打家劫舍问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>就是比较传统的一排街道，没有环，如果偷相邻的两个街道就会报警。</span><br><span class="line">	代码：</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态规划解法</span></span><br><span class="line"><span class="comment">         * dp[i]表示在前i个街区中不触碰警报能获取到的最大价值</span></span><br><span class="line"><span class="comment">         * 递推公式：如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</span></span><br><span class="line"><span class="comment">         *         如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）</span></span><br><span class="line"><span class="comment">         *      所以有：dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i])</span></span><br><span class="line"><span class="comment">         * 初始化：dp[0]=0,dp[1]=nums[0]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 因为我们每次只会用到i前面的dp[i-1]和dp[i-2]所以可以用滚动数组的解法</span></span><br><span class="line"><span class="comment">         * 用两个变量来进行记录</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c=Math.max(b,a+nums[i]);</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>还是一排街道，但是与第一种情况不同的是，这里面的首尾两个街道算是相邻的街道。所以需要做进一步思考。就是分情况讨论。</span><br><span class="line">    <span class="number">1</span>）.最终偷的结果首尾两个街道都不包括。即只考虑在除了首尾的中间的元素</span><br><span class="line">    <span class="number">2</span>）.最终偷的结果考虑首元素，但不考虑尾元素的情况</span><br><span class="line">    <span class="number">3</span>）.最终偷的结果考虑尾元素，但不考虑首元素的情况</span><br><span class="line">    综合得：<span class="number">2</span>、<span class="number">3</span>两种情况里面都包含了第一种情况，所以总得就只用分为<span class="number">2</span>，<span class="number">3</span>两种情况，在考虑<span class="number">2</span>、<span class="number">3</span>这两种情况得时候，这就是前面第一种打家劫舍类型去了，最后取这两者中得最大值。 </span><br><span class="line">    代码：</span><br><span class="line">    	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> r1=getAns(nums,l,r-<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> r2=getAns(nums,l+<span class="number">1</span>,r);</span><br><span class="line">            <span class="keyword">return</span> r1&gt;r2?r1:r2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAns</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">            <span class="type">int</span> n=r-l;</span><br><span class="line">            <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="type">int</span> c=Math.max(a+nums[i],b);</span><br><span class="line">                a=b;</span><br><span class="line">                b=c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-股票买卖问题"><a href="#3-股票买卖问题" class="headerlink" title="3.股票买卖问题"></a>3.股票买卖问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">leetcode 123题</span></span><br><span class="line">	- 分状态进行解决</span><br><span class="line">	每一天总共有5个状态</span><br><span class="line">		dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</span><br><span class="line">		0 不操作状态		相当手中现金为0  dp[i][0]=0</span><br><span class="line">	buy1	1 第一次买入		相当于是消耗了这一天的钱数  -prices[i]</span><br><span class="line">	sell1	2 第一次卖出		相当于是获得了这一天的钱数  +prices[i]</span><br><span class="line">	buy2	3 第二次买入		相当于是消耗了这一天的钱数  -prices[i]</span><br><span class="line">	sell2	4 第二次卖出		相当于是获得了这一天的钱数  +prices[i]</span><br><span class="line">	这一天可以不进行任何操作，或者在前一天的状态下进行其他四种状态的变化</span><br><span class="line">		在第i天，进行 	1 第一次买入  ：buy1=Math.max(buy1&#x27;,-prices[i])</span><br><span class="line">									:buy1&#x27;表示这一天不进行操作，-prices[i]表示这一天买入消耗这么多</span><br><span class="line">                        2 第一次卖出  :sell1=Math.max(sell1&#x27;,buy1+prices[i])</span><br><span class="line">                        3 第二次买入	 :buy2=Math.max(buy2&#x27;,sell1-prices[i])</span><br><span class="line">                        4 第二次卖出  :sell2=Math.max(sell2&#x27;,buy2+prices[i])</span><br><span class="line">                 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码演示</span></span><br><span class="line">	public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int buy1 = -prices[0], sell1 = 0;</span><br><span class="line">        int buy2 = -prices[0], sell2 = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">leetcode 188题</span></span><br><span class="line">这是在123题的基础上变为至多可以买卖k次,思想与123题类似</span><br><span class="line">    public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">        if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp=new int[k*2+1];</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        for (int i = 1; i &lt; k*2+1; i+=2) &#123;</span><br><span class="line">            dp[i]=-prices[0];</span><br><span class="line">            dp[i+1]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            for(int j=1;j&lt;k*2+1;j++)&#123;</span><br><span class="line">                if(j%2==1)&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-1]-prices[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-1]+prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[k*2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1eetcode309</span></span><br><span class="line">股票买卖问题，带手续费的</span><br><span class="line">	我们用 f[i]表示第 i 天结束之后的「累计最大收益」</span><br><span class="line">	该题分为以下几个状态（这里的状态是该天结束之后的状态）：</span><br><span class="line">		- 我们目前持有一支股票，对应的「累计最大收益」记为 f[i][0]；</span><br><span class="line">		- 我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]；</span><br><span class="line">		- 我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]。</span><br><span class="line">		这里的「处于冷冻期」指的是在第 i 天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	对于f[i][0]:我们可以是在这一天不进行任何操作，在之前就已经持有了一支股票，所以有f[i-1][0].或者是前一天不持有股票，然后今天买入，所以是必须在前一天处于非冷冻期中。因此为f[i][0]=f[i-1][2]-prices[i]</span><br><span class="line">	</span><br><span class="line">	对于f[i][1]:则是在前一天持有一支股票，然后在第i天卖出，所以处于冷冻期f[i][1]=f[i-1][0]+prices[i]</span><br><span class="line">	</span><br><span class="line">	对于f[i][2]:可以是当天不进行任何操作所以有f[i-1][2]，也可以是在前一天处于冷冻期，一天后就不是冷冻期了。所以有f[i][2]=f[i-1][1]</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">初始化</span></span><br><span class="line">		f[i][0]=-prices[0]</span><br><span class="line">		f[i][1]=0</span><br><span class="line">		f[i][2]=0</span><br><span class="line">		</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">代码：</span></span><br><span class="line">	public int maxProfit(int[] prices) &#123;</span><br><span class="line">        /*if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int[][] dp=new int[n][2];</span><br><span class="line">        dp[0][0]=-prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2]-prices[i]);</span><br><span class="line">            dp[i][1]=dp[i-1][0]+prices[i];</span><br><span class="line">            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[n-1][1],dp[n-1][2]);*/</span><br><span class="line"></span><br><span class="line">        //空间进行优化，因为第i天的状态只与第i-1天有关系</span><br><span class="line">        if(prices.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int a=-prices[0];</span><br><span class="line">        int b=0;</span><br><span class="line">        int c=0;</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            int d=Math.max(a,c-prices[i]);</span><br><span class="line">            int e=a+prices[i];</span><br><span class="line">            int f=Math.max(c,b);</span><br><span class="line">            a=d;</span><br><span class="line">            b=e;</span><br><span class="line">            c=f;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(b,c);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-最长子序列问题"><a href="#4-最长子序列问题" class="headerlink" title="4.最长子序列问题"></a>4.最长子序列问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如：leetcode1143。（leetcode1035）</span><br><span class="line">	值得注意的是这是一个二维的动态规划，既需要同时对两个数组进行动态分析。画出一个m*n的矩阵会便于进行分析</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211207131539996.png" alt="image-20211207131539996"></p>
<h2 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h2><h2 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h2><h4 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有的位运算都是用补码进行运算</span></span><br><span class="line"></span><br><span class="line">	正数的原码，反码，补码都相同</span><br><span class="line">	负数的原码是除了第一个符号位为1外，其他位与正数原码相同，如-3的原码是 1000....0000011</span><br><span class="line">	负数的反码是在负数原码的基础上符号位不变，其他位取反    如-3的反码是  1111....1111100</span><br><span class="line">	负数的补码是在负数反码的基础上+1                    -3的反码是    1111....1111101</span><br></pre></td></tr></table></figure>

<h4 id="1-判断一个数是否是2的次幂"><a href="#1-判断一个数是否是2的次幂" class="headerlink" title="1.判断一个数是否是2的次幂"></a>1.判断一个数是否是2的次幂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> (sum&amp;(sum-<span class="number">1</span>))==<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211028163231510.png" alt="image-20211028163231510"></p>
<h4 id="2-异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）"><a href="#2-异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）" class="headerlink" title="2.异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）"></a>2.异或运算。解决只出现一次的数字问题（leetcode136和leetcode260）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如何才能做到线性时间复杂度和常数空间复杂度呢？</span><br><span class="line"></span><br><span class="line">答案是使用位运算。对于这道题，可使用异或运算 \oplus⊕。异或运算有以下三个性质。</span><br><span class="line"></span><br><span class="line">正数反码：与原码相同</span><br><span class="line"></span><br><span class="line">负数反码：符号位为“1”，数值位按位 取反。</span><br><span class="line">正数补码：与原码相同</span><br><span class="line">负数补码：求反加一</span><br><span class="line">记住：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有参与运算的都是以补码形式进行的 结果也是补码 因此也需要将补码转换成为原码的形式存在</span></span><br><span class="line"></span><br><span class="line">任何数和 0做异或运算，结果仍然是原来的数，即 a⊕0=a。</span><br><span class="line">任何数和其自身做异或运算，结果是 0，即 a⊕a=0。</span><br><span class="line">异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</span><br></pre></td></tr></table></figure>

<h4 id="3-与运算和或运算。（leetcode-318）"><a href="#3-与运算和或运算。（leetcode-318）" class="headerlink" title="3.与运算和或运算。（leetcode 318）"></a>3.与运算和或运算。（leetcode 318）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或运算  |   （1=1&amp;1 1=1|0 1=0|1 0=0|0） 注意这个没有短路的效果，有短路的是||和&amp;&amp;</span></span><br><span class="line">	常见的题目类型有：</span><br><span class="line">		1.看一个数的某一位是否为1或0.</span><br><span class="line">			如：   00000000</span><br><span class="line">				| 00000001</span><br><span class="line">                ————————————</span><br><span class="line">                  00000001</span><br><span class="line">     	2.看求某一个数的掩码</span><br><span class="line">     			a |= (1&lt;&lt;6)  (最终的效果就是a这个数的二进制数第六位数是1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">与运算  &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-移位运算"><a href="#4-移位运算" class="headerlink" title="4.移位运算"></a>4.移位运算</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> &lt;&lt;  左移运算</span>  </span><br><span class="line">	如 a= 1&lt;&lt;4  是将1变为二进制后往左移4位</span><br><span class="line">				00000001</span><br><span class="line">			 &lt;&lt; </span><br><span class="line">			 ____________</span><br><span class="line">			 a= 00010000=16</span><br><span class="line">	如 b= 3&lt;&lt;4  是将3转换为二进制后往左移4位，最终结果是48</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> &gt;&gt; 右移运算与左移运算则相反</span></span><br></pre></td></tr></table></figure>

<h4 id="5-非运算"><a href="#5-非运算" class="headerlink" title="5.非运算 ~"></a>5.非运算 ~</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意一点是所有位运算都是按照补码进行运算的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~运算是将要求的数的补码取反（包括符号位），得到补码，再由补码退出该数的原码，就是最终结果</span></span><br><span class="line">所以~10的求解过程是这样的</span><br><span class="line">	10的补码是 		                   0...00001010</span><br><span class="line">	所以~10的补码是上面10的补码所有位取反   1...11110101</span><br><span class="line">    就有了~10的原码就是					1...00001011  即~10等于 -11</span><br><span class="line">    </span><br><span class="line">    ~(-3)的求解过程是</span><br><span class="line">    -3的原码：1...00000011</span><br><span class="line">    -3的反码：1...11111100</span><br><span class="line">    -3的补码：1...11111101</span><br><span class="line">    </span><br><span class="line"> ~(-3)的补码：0...00000010</span><br><span class="line"> ~(-3)的反码：0...00000010</span><br><span class="line"> ~(-3)的原码：0...00000010   即 ~(-3)等于 2</span><br><span class="line"> </span><br><span class="line"> 结论：~(n) = -n-1  (无论n是正数还是负数)</span><br></pre></td></tr></table></figure>



<h4 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.剑指offer65题(利用位运算实现加法)</span><br></pre></td></tr></table></figure>



<h2 id="10-查找算法"><a href="#10-查找算法" class="headerlink" title="10.查找算法"></a>10.查找算法</h2><h4 id="1-二分查找算法"><a href="#1-二分查找算法" class="headerlink" title="1.二分查找算法"></a>1.二分查找算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.查找目标值的索引   如查找[5,7,8,10]的8位置，返回2，查找9，还是返回2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)&#123;</span><br><span class="line">                right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查找目标值索引的右边界  如查找[5,7,7,8,8,10]中8的右边界第一个值的索引即返回10对应的索引，查找7则返回第一个8的索引   (题目如剑指offer中53题，理解见图)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//与一般的二分查找区别在这里</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;=target)&#123;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211101211328241.png" alt="image-20211101211328241"></p>
<h4 id="2-动态规划-二分查找"><a href="#2-动态规划-二分查找" class="headerlink" title="2.动态规划+二分查找"></a>2.动态规划+二分查找</h4><blockquote>
<p>见leetcode 300题</p>
</blockquote>
<h2 id="11-集合框架"><a href="#11-集合框架" class="headerlink" title="11.集合框架"></a>11.集合框架</h2><h4 id="1-List—ArrayList-LinkedList的使用"><a href="#1-List—ArrayList-LinkedList的使用" class="headerlink" title="1.List—ArrayList,LinkedList的使用"></a>1.List—ArrayList,LinkedList的使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是一个很重要的点</span></span><br><span class="line">1.当需要对集合中的数据进行频繁的随机访问的时候，建议使用ArrayList</span><br><span class="line">2.当需要对集合进行频繁的插入和删除数据时，建议使用LinkedList</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList的方法，add方法默认从末端添加元素</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211102141245305.png" alt="image-20211102141245305"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList方法，add可以从开头或末尾添加元素</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211102141534247.png" alt="image-20211102141534247"></p>
<h2 id="12-数学"><a href="#12-数学" class="headerlink" title="12.数学"></a>12.数学</h2><h4 id="1-求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）"><a href="#1-求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）" class="headerlink" title="1.求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）"></a>1.求解一个数是不是一个能够完全平方的数，如16，9是，而10就不是（Leetcode367）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.方法1,暴力破解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.方法2.二分法</span></span><br><span class="line">如果num是完全平方数，就相当于是能从<span class="number">1</span>到num中间寻找一个数，这个数的平方等于num</span><br><span class="line">因此左边界是<span class="number">1</span>，右边界是num,然后进行二分查找。但是需要注意的是临时得到的中间数middle的平方可能会超出<span class="type">int</span>的范围，因此需要用<span class="type">long</span>类型来存储</span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="type">int</span> left=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> right=num;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">    <span class="type">int</span> middle=(right+left)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> square=(<span class="type">long</span>)middle*middle;</span><br><span class="line">    <span class="keyword">if</span>(square&gt;num)&#123;</span><br><span class="line">        right=middle-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(square&lt;num)&#123;</span><br><span class="line">        left=middle+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.方法3.数学。（利用一个完全平方数，能够由奇数相加得到）</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">4</span>=<span class="number">1</span>+<span class="number">3</span></span><br><span class="line"><span class="number">9</span>=<span class="number">1</span>+<span class="number">3</span>+<span class="number">5</span></span><br><span class="line"><span class="number">16</span>=<span class="number">1</span>+<span class="number">3</span>+<span class="number">5</span>+<span class="number">7</span></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">num -= x;</span><br><span class="line">x += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-矩阵快速幂（时间复杂度为O-logn-）解决斐波那契数列中使用（待看）"><a href="#2-矩阵快速幂（时间复杂度为O-logn-）解决斐波那契数列中使用（待看）" class="headerlink" title="2.矩阵快速幂（时间复杂度为O(logn)）解决斐波那契数列中使用（待看）"></a>2.矩阵快速幂（时间复杂度为O(logn)）解决斐波那契数列中使用（待看）</h4><h2 id="13-排序算法"><a href="#13-排序算法" class="headerlink" title="13.排序算法"></a>13.排序算法</h2><h4 id="1-内置的排序算法-比较器（Comparator）"><a href="#1-内置的排序算法-比较器（Comparator）" class="headerlink" title="1.内置的排序算法+比较器（Comparator）"></a>1.内置的排序算法+比较器（Comparator）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">java中的内置排序函数有Arrays和Collections类中的<span class="built_in">sort</span>函数，其中还可以自己定义排序的顺序，就是创建比较器对象，注意o1对象和o2对象比较顺序</span></span><br><span class="line">if(o1.get(i)&lt;o1.get(0))&#123;   //当这种情况发生时，如果想调整当前o1,o2的顺序，就返回正数，否则返回负数</span><br><span class="line">	return o1.get(0);  //将o1调整到o2之前</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	return -1;  //保持不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] nums=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Arrays.sort(nums, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1[<span class="number">0</span>]&gt;o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//因为要的是升序，但是o1大于o2所以应该调整顺序，所以返回正数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1[<span class="number">0</span>]&lt;o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//因为要的是升序，所以o1与o2已经是升序了，所以不变。o1，o2的顺序保持不变， </span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这是在第一维相等的情况下，比较第二维</span></span><br><span class="line">                <span class="keyword">if</span>(o1[<span class="number">1</span>]&gt;o2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1[<span class="number">1</span>]&lt;o2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(nums);</span><br><span class="line">    <span class="comment">//结果为：[1,2],[2,3],[2,6],[3,4],[5,2],[5,8],[6,1],[6,3]</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-快速排序-题目见剑指offer40"><a href="#2-快速排序-题目见剑指offer40" class="headerlink" title="2.快速排序(题目见剑指offer40)"></a>2.快速排序(题目见剑指offer40)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fastSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=i;</span><br><span class="line">    <span class="type">int</span> r=j;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[r]&gt;=arr[i])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[l]&lt;=arr[i])&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里其实判不判断l&lt;r都无所谓，只是进行了多一次交换，即便不满足，此时l==r，也不会有影响</span></span><br><span class="line">        <span class="type">int</span> temp=arr[r];</span><br><span class="line">        arr[r]=arr[l];</span><br><span class="line">        arr[l]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp=arr[i];</span><br><span class="line">    arr[i]=arr[l];</span><br><span class="line">    arr[l]=temp;</span><br><span class="line">    fastSort(arr,i,l-<span class="number">1</span>);</span><br><span class="line">    fastSort(arr,l+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优先队列（排序）"><a href="#3-优先队列（排序）" class="headerlink" title="3.优先队列（排序）"></a>3.优先队列（排序）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="comment">//                if(o1&gt;o2)&#123;</span></span><br><span class="line">        <span class="comment">//                    return o1-o2;</span></span><br><span class="line">        <span class="comment">//                &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//                    return o2-o1;</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//                if(o1&gt;o2)&#123;</span></span><br><span class="line">        <span class="comment">//                    //升序，因为o1是将要插入到优先队列中的元素，o2是队列中的头元素，</span></span><br><span class="line">        <span class="comment">//                    // 并且o1大于o2,所以返回1，直接放到后面</span></span><br><span class="line">        <span class="comment">//                    return 1;	   顺序变换    o1&gt;o2</span></span><br><span class="line">        <span class="comment">//                &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//                    return -1;  位置顺序不变  o1&lt;o2</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//                return o1-o2;  //升序</span></span><br><span class="line">        <span class="keyword">return</span> o2-o1;  <span class="comment">//降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] nums=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">			<span class="comment">//升序</span></span><br><span class="line">            <span class="keyword">if</span>(o1[<span class="number">0</span>]!=o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];  <span class="comment">//先根据第一维的数据进行排序，这是升序，如果换一下顺序就是降序</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pq.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size=pq.size();</span><br><span class="line">    <span class="comment">//注意在实际打印时的序列并不是有序的，而应该是依次取堆顶元素，这样取到的就是有序的</span></span><br><span class="line">    <span class="comment">//如果想让队列是有序的，可以先转化为数组再进行排序</span></span><br><span class="line">    <span class="comment">//Integer[] arr=new Integer[size];</span></span><br><span class="line">    <span class="comment">//Arrays.sort(pq.toArray(arr));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="type">int</span>[] arr=pq.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+arr[<span class="number">0</span>]+<span class="string">&quot; :&quot;</span>+arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(nums);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-归并排序-offer-51"><a href="#4-归并排序-offer-51" class="headerlink" title="4.归并排序(offer 51)"></a>4.归并排序(offer 51)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">利用对并排序求解逆序对（剑指offer 51题）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序的代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr=&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">67</span>,<span class="number">58</span>,<span class="number">12</span>,<span class="number">58</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Test</span>().mergeSort(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=arr.length-<span class="number">1</span>;</span><br><span class="line">    dfs(arr,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归划分</span></span><br><span class="line">    <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">    dfs(arr,l,m);</span><br><span class="line">    dfs(arr,m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//合并阶段</span></span><br><span class="line">    <span class="comment">//我们首先使用tmp数组存储要排序这一段数组</span></span><br><span class="line">    <span class="type">int</span>[] tmp=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= r; k++) &#123;</span><br><span class="line">        tmp[k]=arr[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再将左右有序的子树组合并为整个合起来有序的数组</span></span><br><span class="line">    <span class="comment">//用i,j来记录遍历左右子数组</span></span><br><span class="line">    <span class="type">int</span> i=l,j=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==m+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//代表左子数组已合并完，因此添加右子数组当前元素 tmp[j] ，并执行 j = j + 1；</span></span><br><span class="line">            arr[k]=tmp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==r+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//代表右子数组已合并完，因此添加左子数组当前元素tmp[i] ，并执行i=i+1；</span></span><br><span class="line">            arr[k]=tmp[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i]&gt;tmp[j])&#123;</span><br><span class="line">            <span class="comment">//当tmp[i&gt;tmp[j] 时： 添加右子数组当前元素tmp[j]，并执行j=j+1；</span></span><br><span class="line">            arr[k]=tmp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当tmp[i]≤tmp[j] 时： 添加左子数组当前元素tmp[i]，并执行i=i+1；</span></span><br><span class="line">            arr[k]=tmp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-堆排序（leetcode-215-解法见方法2）"><a href="#5-堆排序（leetcode-215-解法见方法2）" class="headerlink" title="5.堆排序（leetcode 215  解法见方法2）"></a>5.堆排序（leetcode 215  解法见方法2）</h4><blockquote>
<p>先按照顺序将数组元素组合成一个完全二叉树</p>
</blockquote>
<p><img src="https://assets.leetcode-cn.com/solution-static/215/1.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="comment">//建堆完毕后，nums【0】为最大元素。逐个删除堆顶元素，直到删除了k-1个。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//先将堆的最后一个元素与堆顶元素交换，由于此时堆的性质被破坏，需对此时的根节点进行向下调整操作。</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">//相当于删除堆顶元素，此时长度变为nums.length-2。即下次循环的i</span></span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="comment">//从最后一个父节点位置开始调整每一个节点的子树。数组长度为heasize，因此最后一个节点的位置为heapsize-1，所以父节点的位置为（heapsize-1-1)/2。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heapSize-<span class="number">2</span>)/ <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;      <span class="comment">//调整当前结点和子节点的顺序。</span></span><br><span class="line">        <span class="comment">//left和right表示当前父节点i的两个左右子节点。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, right = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="comment">//如果左子点在数组内，且比当前父节点大，则将最大值的指针指向左子点。</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; a[left] &gt; a[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果右子点在数组内，且比当前父节点大，则将最大值的指针指向右子点。</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最大值的指针不是父节点，则交换父节点和当前最大值指针指向的子节点。</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            <span class="comment">//由于交换了父节点和子节点，因此可能对子节点的子树造成影响，所以对子节点的子树进行调整。</span></span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-栈和队列"><a href="#14-栈和队列" class="headerlink" title="14.栈和队列"></a>14.栈和队列</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">剑指offer59_2</span></span><br></pre></td></tr></table></figure>

<h2 id="难题附录："><a href="#难题附录：" class="headerlink" title="难题附录："></a>难题附录：</h2><h3 id="1-lettcode-869-（关于回溯和预处理，重新排序看能否得到2次幂的数）"><a href="#1-lettcode-869-（关于回溯和预处理，重新排序看能否得到2次幂的数）" class="headerlink" title="1.lettcode 869.（关于回溯和预处理，重新排序看能否得到2次幂的数）"></a>1.lettcode 869.（关于回溯和预处理，重新排序看能否得到2次幂的数）</h3><h3 id="2-剑指Offer-35（复杂链表的复制）"><a href="#2-剑指Offer-35（复杂链表的复制）" class="headerlink" title="2.剑指Offer 35（复杂链表的复制）"></a>2.剑指Offer 35（复杂链表的复制）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意本题要求的是复制，因此原有的链表值和结构不能有改变</span></span><br><span class="line"><span class="comment">//本题的难点在于如果按照传统链表的方式进行遍历时，无法知道random指针指向的是哪里，</span></span><br><span class="line"><span class="comment">// 主要是不确定这个节点是否已经创建，因此需要先遍历一遍建立起已经创建的节点哈希表，再给构建的节点进行赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1 使用回溯+哈希表</span></span><br><span class="line">Map&lt;Node,Node&gt; hs=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node,Node&gt;();</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!hs.containsKey(head))&#123;</span><br><span class="line">        Node cp=<span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        hs.put(head,cp);</span><br><span class="line">        cp.next=copyRandomList(head.next);</span><br><span class="line">        cp.random=copyRandomList(head.random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hs.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2 使用哈希表，但是是顺序遍历方式，这样比回溯方法好理解一点</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// 4. 构建新链表的 next 和 random 指向</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 返回新链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法3：使用拼接+拆分的方法</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">        tmp.next = cur.next;</span><br><span class="line">        cur.next = tmp;</span><br><span class="line">        cur = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.random != <span class="literal">null</span>)</span><br><span class="line">            cur.next.random = cur.random.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">    cur = head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="literal">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">    <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）"><a href="#3-leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）" class="headerlink" title="3.leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）"></a>3.leetcode1218（最长定差子序列。使用动态规划，但是这题不是用数组进行解决，而是用Map作为dp来进行处理。也可以使用数组进行解决）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">dp[i]表示的意思就是以arr[i]为结尾的子序列的长度。因此有j&lt;i&amp;&amp;arr[i]-arr[j]=d时，dp[i]=dp[j]+<span class="number">1</span></span><br><span class="line">为了方便，我们可以直接使用dp[i]就表示是以i为结尾的子序列的长度，此时就有dp[i]=dp[i-d]+<span class="number">1.</span></span><br><span class="line">#动态规划解决</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubsequence</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> difference)</span> &#123;</span><br><span class="line">    <span class="comment">//暴力破解超时</span></span><br><span class="line">    <span class="comment">/*int max=0;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length&amp;&amp;((arr.length-i-1)&gt;=max); i++) &#123;</span></span><br><span class="line"><span class="comment">            int count=1;</span></span><br><span class="line"><span class="comment">            int pre=arr[i];</span></span><br><span class="line"><span class="comment">            for (int j = i+1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">                if((arr[j]-pre)==difference)&#123;</span></span><br><span class="line"><span class="comment">                    count++;</span></span><br><span class="line"><span class="comment">                    pre=arr[j];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(count&gt;max)&#123;</span></span><br><span class="line"><span class="comment">                max=count;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return max;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划解决,该题如果不使用map来进行处理，而还是用数组的话，还是需要用两层循环，因此依旧会超时</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//使用变量记录最大值，可以减去后面遍历map，求解最大值</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> val:arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val-difference))&#123;</span><br><span class="line">            map.put(val,map.get(val-difference)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(val,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=Math.max(ans,map.get(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#数组解决办法</span><br><span class="line"><span class="comment">//该题也可以使用数组来取代hash表来进行解决，使得可以一次性就将结果查询出来</span></span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">40009</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubsequence2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        hash[i + M] = hash[i - d + M] + <span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans, hash[i + M]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）"><a href="#4-leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）" class="headerlink" title="4.leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）"></a>4.leetcode474（使用动态规划解决满足1和0个数的最大子集里面的个数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">1</span>背包问题的，其中背包的容量是二维的情况</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  动态规划</span></span><br><span class="line"><span class="comment"> 	*  这里dp[j][k]表示数组子集中累加的0和1的个数满足最大j个0和k个1时的子集中的字符串的最大个数</span></span><br><span class="line"><span class="comment">   	*  dp[5][3]=4就是表示子集中最多5个0和3个1的字符串个数为4</span></span><br><span class="line"><span class="comment">    *  这里我们使用滚动的二维数组来进行解决问题。</span></span><br><span class="line"><span class="comment">    *  当遍历到第i个字符串时，第i个字符串中有a=count[i][0]个0，有b=count[i][1]个1.就会出现两种情况：</span></span><br><span class="line"><span class="comment">  	*                      只有在j&gt;=a并且k&gt;=b时，才有可能出现第i个字符串是子集中的结果</span></span><br><span class="line"><span class="comment">  	*                   所以在前提条件j&gt;=a并且k&gt;=b被满足的情况下，才有下面两种情况的讨论，否则就不变</span></span><br><span class="line"><span class="comment">  	*                      第一种：子集中包括第i个字符串，dp[j][k]=dp[j-a][k-b]+1</span></span><br><span class="line"><span class="comment">  	*                      第二种：子集中不包括第i个字符串，dp[j][k]就保持不变</span></span><br><span class="line"><span class="comment">  	*  因此得到递推表达式是 dp[j][k]=Math.max(dp[j][k],dp[j-a][k-b]+1)</span></span><br><span class="line"><span class="comment">  	*  最终得到的结果就是dp[m][n]的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//注意在进行遍历的时候需要从右到左的顺序，否则会导致覆盖后的数据又被后面的数据覆盖了，导致结果数变大</span></span><br><span class="line"><span class="comment">//遍历物品，这里也是使用滚动数组的解法，只是和0-1背包问题不同的是，这里的价值是二维的，物品也是二维的</span></span><br><span class="line">    <span class="comment">//可以对空间进行优化，对于统计字符串的数组，可以在需要知道0和1的时候，用变量求解出来</span></span><br><span class="line">        <span class="comment">//可以对时间也进行优化，在j&lt;a或者k&lt;b时，dp[j][k]肯定就是保持不变的情况，可以提前结束for循环</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> strs.length;</span><br><span class="line"><span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//每个字符串都是一个物品，而m,n是一个背包，只不过是一个二维的背包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">//a、b表示strs中第i个字符串中 0和1 的个数</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:strs[i].toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;=a ; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n; k &gt;=b ; k--) &#123;</span><br><span class="line">            dp[j][k]=Math.max(dp[j-a][k-b]+<span class="number">1</span>,dp[j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-leetcode322题（该题的重点在于初始化）"><a href="#5-leetcode322题（该题的重点在于初始化）" class="headerlink" title="5.leetcode322题（该题的重点在于初始化）"></a>5.leetcode322题（该题的重点在于初始化）</h3><h3 id="6-leetcode138题（动态规划，注意这里递推公式是怎样写的）"><a href="#6-leetcode138题（动态规划，注意这里递推公式是怎样写的）" class="headerlink" title="6.leetcode138题（动态规划，注意这里递推公式是怎样写的）"></a>6.leetcode138题（动态规划，注意这里递推公式是怎样写的）</h3><h3 id="7-leetcode213题动态规划题（打家劫舍题）"><a href="#7-leetcode213题动态规划题（打家劫舍题）" class="headerlink" title="7.leetcode213题动态规划题（打家劫舍题）"></a>7.leetcode213题动态规划题（打家劫舍题）</h3><h3 id="8-leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）"><a href="#8-leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）" class="headerlink" title="8.***leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）"></a>8.***leetcode337题动态规划题（打家劫舍与二叉树进行结合的题）</h3><h3 id="9-剑指offer36题（二叉搜索树）"><a href="#9-剑指offer36题（二叉搜索树）" class="headerlink" title="9.***剑指offer36题（二叉搜索树）"></a>9.***剑指offer36题（二叉搜索树）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二叉搜索树的性质：中序遍历是递增顺序的。</span><br></pre></td></tr></table></figure>

<h3 id="10-剑指offer的15天的题（三题都需要）需要重看一下（搜索-回溯的题）还有剑指offer68—II这道题"><a href="#10-剑指offer的15天的题（三题都需要）需要重看一下（搜索-回溯的题）还有剑指offer68—II这道题" class="headerlink" title="10.剑指offer的15天的题（三题都需要）需要重看一下（搜索+回溯的题）还有剑指offer68—II这道题"></a>10.剑指offer的15天的题（三题都需要）需要重看一下（搜索+回溯的题）还有剑指offer68—II这道题</h3><h3 id="11-剑指-Offer-64-求1-2-…-n-要求不能使用if-else-switch-A-B-C等结构"><a href="#11-剑指-Offer-64-求1-2-…-n-要求不能使用if-else-switch-A-B-C等结构" class="headerlink" title="11.剑指 Offer 64. 求1+2+…+n.要求不能使用if,else,switch,A?B:C等结构"></a>11.剑指 Offer 64. 求1+2+…+n.要求不能使用if,else,switch,A?B:C等结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重点掌握两种解决方法</span></span><br><span class="line">-位元算+快速乘法+高斯公式</span><br><span class="line">-位运算+递归解法</span><br></pre></td></tr></table></figure>

<h3 id="12-剑指offer16（求解数的整数次方）"><a href="#12-剑指offer16（求解数的整数次方）" class="headerlink" title="12.剑指offer16（求解数的整数次方）"></a>12.剑指offer16（求解数的整数次方）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重点掌握方法</span></span><br><span class="line">	-记忆化递归</span><br><span class="line">	-快速幂(重点掌握) 结合数的二进制来进行解决 </span><br></pre></td></tr></table></figure>

<h3 id="13-剑指Offer62-（求解圆圈中最后剩余的数字，约瑟夫环）"><a href="#13-剑指Offer62-（求解圆圈中最后剩余的数字，约瑟夫环）" class="headerlink" title="13.***剑指Offer62 （求解圆圈中最后剩余的数字，约瑟夫环）"></a>13.***剑指Offer62 （求解圆圈中最后剩余的数字，约瑟夫环）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该题的核心主要在于反推，主要题解见 https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</span> </span><br></pre></td></tr></table></figure>



<h3 id="14-leetcode677题"><a href="#14-leetcode677题" class="headerlink" title="14.leetcode677题"></a>14.leetcode677题</h3><h3 id="15-剑指offer20题待看，使用有限状态机进行解决"><a href="#15-剑指offer20题待看，使用有限状态机进行解决" class="headerlink" title="15.剑指offer20题待看，使用有限状态机进行解决"></a>15.剑指offer20题待看，使用有限状态机进行解决</h3><h3 id="16-leetcode423-学习这种解决问题的方法"><a href="#16-leetcode423-学习这种解决问题的方法" class="headerlink" title="16.leetcode423 学习这种解决问题的方法"></a>16.leetcode423 学习这种解决问题的方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">首先解决只存在一个未知数的方程求出这些方程中的未知数，再根据这些得到未知数的值代入到原来有多个未知数的方程中去，然后再依次进行求解。</span></span><br></pre></td></tr></table></figure>

<h3 id="17-剑指offer-38-回溯"><a href="#17-剑指offer-38-回溯" class="headerlink" title="17.剑指offer 38 回溯"></a>17.剑指offer 38 回溯</h3><h3 id="18-剑指offer-49-求解丑数"><a href="#18-剑指offer-49-求解丑数" class="headerlink" title="18.剑指offer 49 (求解丑数)"></a>18.剑指offer 49 (求解丑数)</h3><h3 id="19-剑指offer-60-（求解骰子的点数）"><a href="#19-剑指offer-60-（求解骰子的点数）" class="headerlink" title="19.剑指offer 60 （求解骰子的点数）"></a>19.剑指offer 60 （求解骰子的点数）</h3><h3 id="20-剑指offer-19-正则表达式匹配-动态规划"><a href="#20-剑指offer-19-正则表达式匹配-动态规划" class="headerlink" title="20.剑指offer 19 (正则表达式匹配 动态规划)"></a>20.剑指offer 19 (正则表达式匹配 动态规划)</h3><h3 id="21-剑指offer17-学会要掌握处理大数越界的问题"><a href="#21-剑指offer17-学会要掌握处理大数越界的问题" class="headerlink" title="21.剑指offer17 学会要掌握处理大数越界的问题"></a>21.剑指offer17 学会要掌握处理大数越界的问题</h3><h3 id="22-剑指offer-51-归并排序与逆序对"><a href="#22-剑指offer-51-归并排序与逆序对" class="headerlink" title="22.剑指offer 51 (归并排序与逆序对)"></a>22.剑指offer 51 (归并排序与逆序对)</h3><h3 id="23-剑指offer44题-（数字模拟）"><a href="#23-剑指offer44题-（数字模拟）" class="headerlink" title="23.剑指offer44题 （数字模拟）"></a>23.剑指offer44题 （数字模拟）</h3><h3 id="24-leetcode372（利用快速幂求解一个数的超级次方）"><a href="#24-leetcode372（利用快速幂求解一个数的超级次方）" class="headerlink" title="24.leetcode372（利用快速幂求解一个数的超级次方）"></a>24.leetcode372（利用快速幂求解一个数的超级次方）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以利用倒叙和正序的方法进行解题，正序的话就是使用秦九韶公式进行解决</span></span><br></pre></td></tr></table></figure>

<h3 id="25-leetcode1143-该题是典型的两维动态规划"><a href="#25-leetcode1143-该题是典型的两维动态规划" class="headerlink" title="25.leetcode1143	(该题是典型的两维动态规划)"></a>25.leetcode1143	(该题是典型的两维动态规划)</h3><h3 id="26-leetcode825-利用数学式子来进行解决问题-计数排序和排序"><a href="#26-leetcode825-利用数学式子来进行解决问题-计数排序和排序" class="headerlink" title="26.leetcode825(利用数学式子来进行解决问题)[计数排序和排序]"></a>26.leetcode825(利用数学式子来进行解决问题)[计数排序和排序]</h3><h3 id="27-leetcode394-（利用辅助栈来进行解决）"><a href="#27-leetcode394-（利用辅助栈来进行解决）" class="headerlink" title="27.leetcode394 （利用辅助栈来进行解决）"></a>27.leetcode394 （利用辅助栈来进行解决）</h3><h3 id="28-leetcode390-学习这种分析问题的做法，利用数学的方法进行解决"><a href="#28-leetcode390-学习这种分析问题的做法，利用数学的方法进行解决" class="headerlink" title="28.leetcode390(学习这种分析问题的做法，利用数学的方法进行解决)"></a>28.leetcode390(学习这种分析问题的做法，利用数学的方法进行解决)</h3><h3 id="29-leetcode-686题（上下界，字符串哈希的方法）"><a href="#29-leetcode-686题（上下界，字符串哈希的方法）" class="headerlink" title="29.leetcode 686题（上下界，字符串哈希的方法）"></a>29.leetcode 686题（上下界，字符串哈希的方法）</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/leetcode%E7%AC%94%E8%AE%B0/" data-id="clrv16wjg000pz5ku19wx78qz" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-typora/Java编程思想笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/typora/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java编程思想笔记"><a href="#Java编程思想笔记" class="headerlink" title="Java编程思想笔记"></a>Java编程思想笔记</h1><h2 id="第一章：对象导论"><a href="#第一章：对象导论" class="headerlink" title="第一章：对象导论"></a>第一章：对象导论</h2><h3 id="1-2-每个对象都有一个接口"><a href="#1-2-每个对象都有一个接口" class="headerlink" title="1.2 每个对象都有一个接口"></a>1.2 每个对象都有一个接口</h3><blockquote>
<ul>
<li>类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类就是一个数据类型。如所有浮点型数字具有相同的特性和行为集合。而程序员是通过定义类来适应问题，如定义Person类。</li>
<li>每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。接口包含了一些操作请求（方法），接口确定了对某一特定对象所能发出的请求</li>
</ul>
</blockquote>
<h3 id="1-4-被隐藏的具体实现"><a href="#1-4-被隐藏的具体实现" class="headerlink" title="1.4 被隐藏的具体实现"></a>1.4 被隐藏的具体实现</h3><blockquote>
<ul>
<li>访问控制的存在原因：<ol>
<li>让客户端程序员无法触及他们不应该触及的内容</li>
<li>允许类库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="1-5-复用具体实现"><a href="#1-5-复用具体实现" class="headerlink" title="1.5 复用具体实现"></a>1.5 复用具体实现</h3><blockquote>
<ul>
<li>&#x3D;&#x3D;组合（has a）&#x3D;&#x3D;：使用现有的类合成新类，如果组合是动态发生的，那么它通常被称为聚合。组合经常被视为“has a”(拥有)关系，如汽车拥有引擎一样</li>
</ul>
<p>注意：在创建新类时，应该首先考虑组合</p>
</blockquote>
<h3 id="1-6-继承（is-a）"><a href="#1-6-继承（is-a）" class="headerlink" title="1.6 继承（is a）"></a>1.6 继承（is a）</h3><blockquote>
<ul>
<li>虽然继承有时意味着在子类中添加新方法（Java中以extends表示继承），但并非总是如此，其中有一种使父类（基类、超类）和子类（导出类）之间产生差异的重要方式就是改变现有父类的方法的行为，这被称之为覆盖（overriding）</li>
<li>&#x3D;&#x3D;继承（is a）&#x3D;&#x3D;:如圆形是一个几何图形。经理是一个员工</li>
</ul>
</blockquote>
<h3 id="1-7-伴随多态的可互换对象"><a href="#1-7-伴随多态的可互换对象" class="headerlink" title="1.7 伴随多态的可互换对象"></a>1.7 伴随多态的可互换对象</h3><blockquote>
<ul>
<li>在Java中，使用动态绑定，不需要添加额外的关键字来实现多态。面向对象语言是采用<strong>后期绑定</strong>，被调用的代码只有直到运行的时候才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查，但是并不知道被执行的确切代码。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape类中有基类方法erase(),draw()</span></span><br><span class="line"><span class="comment">//Circle类，Square类继承了Shape类，并且重写了erase(),draw()方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape erase &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape erase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;circle erase &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle erase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square draw &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Square erase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Shape shape=<span class="keyword">new</span> <span class="title class_">Shape</span>();</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        Test t=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">//编译器在进行编译的时候，会判断传入的类型是否是Shape类或者是Shape类的子类,如果不是会直接报错</span></span><br><span class="line">        t.doSomething(shape);</span><br><span class="line">        <span class="comment">//运行的时候会判断该子类中是否复写了该方法，如果有就执行子类中的方法，如果没有就执行父类中的该方法</span></span><br><span class="line">        t.doSomething(circle);</span><br><span class="line">        t.doSomething(square);</span><br><span class="line">        <span class="comment">//注意：运行的时候，虽然执行的是子类中的方法，但是doSomething中的a仍然是使用的父类中的a</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">        <span class="comment">//编译器在这里会判断Shape类中是否有这样的方法，如果没有直接编译失败。</span></span><br><span class="line">        <span class="comment">//这里并不用确定这里要执行的具体代码是什么。运行时看子类中是否有这个方法，如果有就执行子类的</span></span><br><span class="line">        shape.erase();</span><br><span class="line">        shape.draw();</span><br><span class="line">        <span class="comment">//编译器会检查Shape类中是否有这样的字段,运行的时候看的就是父类中该字段</span></span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething &quot;</span>+shape.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Shape erase <span class="number">10</span></span><br><span class="line">Shape erase</span><br><span class="line">Shape draw</span><br><span class="line">doSomething <span class="number">10</span></span><br><span class="line">circle erase <span class="number">5</span></span><br><span class="line">Circle erase</span><br><span class="line">Circle draw</span><br><span class="line">doSomething <span class="number">10</span></span><br><span class="line">Square draw <span class="number">20</span></span><br><span class="line">Square erase</span><br><span class="line">Square draw</span><br><span class="line">doSomething <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8单根继承结构"><a href="#1-8单根继承结构" class="headerlink" title="1.8单根继承结构"></a>1.8单根继承结构</h3><blockquote>
<p>Java中所有的对象都继承自Object类。这样可以使垃圾回收器的实现变得容易得多，并且异常处理时也会容易很多。</p>
</blockquote>
<h3 id="1-9-容器"><a href="#1-9-容器" class="headerlink" title="1.9 容器"></a>1.9 容器</h3><blockquote>
<ul>
<li><p>容器：</p>
<ol>
<li>List</li>
<li>Set</li>
<li>Map</li>
<li>队列、栈、树等</li>
</ol>
</li>
<li><p><strong>参数化类型机制</strong>：在创建容器时，知道自己所保存的对象的类型，从而不需要向下转型以及消除错误的可能。</p>
</li>
<li><p>参数化类型就是一个编译器可以自动定制作用于特定类型上的类。</p>
</li>
<li><p>在Java中这个成为泛型。一对尖括号，中间包含类型的信息。如 ArrayList<Integer></p>
</li>
</ul>
</blockquote>
<h3 id="1-10-对象的创建和生命期"><a href="#1-10-对象的创建和生命期" class="headerlink" title="1.10 对象的创建和生命期"></a>1.10 对象的创建和生命期</h3><blockquote>
<ul>
<li>Java采用了<strong>动态内存</strong>分配。这样牺牲了一定的执行速度，但是带来了更大的灵活性。是在被称为<strong>堆</strong>的内存池中动态创建对象。对对象的声明周期一无所知，但是Java的垃圾回收机制可以自动发现不使用的对象并进行销毁。</li>
<li>c++是采用了在堆栈或静态存储期中创建对象。可以确定对象存活的时间，并且程序员自己可以去销毁它。但可能因为不正确处理带来内存泄漏。</li>
</ul>
</blockquote>
<h2 id="第二章：一切都是对象"><a href="#第二章：一切都是对象" class="headerlink" title="第二章：一切都是对象"></a>第二章：一切都是对象</h2><h3 id="2-1-用引用操作对象"><a href="#2-1-用引用操作对象" class="headerlink" title="2.1 用引用操作对象"></a>2.1 用引用操作对象</h3><blockquote>
<ul>
<li><p>引用：操作对象的标识符。可以拥有一个引用而不一定需要有一个对象与它关联。如String s;</p>
<p>其中s就是一个引用，而没有一个对象来与它关联。</p>
</li>
</ul>
</blockquote>
<h3 id="2-2-必须由你创建所有对象"><a href="#2-2-必须由你创建所有对象" class="headerlink" title="2.2 必须由你创建所有对象"></a>2.2 必须由你创建所有对象</h3><blockquote>
<p>程序运行时，对象是怎样进行放置安排的？特别是内存怎样分配的呢？</p>
<ul>
<li>寄存器：这是最快的存储区，不同于其他的存储区所在的位置，它位于存储器内部。寄存器数量有限。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（c++和c允许向变量一起建议寄存器的分配方式）</li>
<li>堆栈：位于通用RAM(随机访问存储器)中，但通过堆栈指针可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存，若向上移动，则释放那些内存。这是一种快速有效的分配存储的方法，仅次于寄存器。创建程序时，<strong>Java必须知道存储在堆栈内所有项的确切生命周期，以便上下移动指针</strong>。这限制了程序的灵活性。所以虽然<strong>某些Java数据存储于堆栈中——特别是对象引用，但是Java对象并不存于其中</strong>。</li>
<li>堆：<strong>一种通用的内存池（也位于RAM区），用于存放所有的Java对象</strong>。堆不同于堆栈的<strong>好处是：编译器不需要知道存储的数据在堆里存活多长时间</strong>。因此在堆里分配存储具有很大的灵活性。但同时也要付出一定的代价：用堆进行存储分配和清理可能要比用堆栈进行存储分配需要更多的时间。</li>
<li>常量存储：常量值通常直接存放在程序代码内部，有时在嵌入式系统中，常量本身会和其他部分隔离开，所以可以选择将其放在ROM（只读存储器）中。<strong>其中一个例子就是字符串池</strong>。所有字面常量字符串和具有字符串值得常量表达式都自动是内存限定得，并且会置于特殊得静态存储区中。</li>
<li>非RAM存储：<strong>如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子就是流对象和持久化对象。</strong>流对象中，对象被转化成字节流，通常发送给另一台机器。持久化对象中，对象存储与磁盘上。这种存储方式得技巧在于：把对象转化成可以存放在其他媒介上得事物，在需要时，可恢复成常规的，基于RAM的对象。Java提供了对轻量级持久化的支持，而诸如JDBC和Hibernate这样的机制提供了更加复杂的堆在数据库中存储和读取对象信息的支持。</li>
<li><strong>特例</strong>：基本类型。因为new是将对象存储在“堆”。<strong>对于基本类型，Java不用new来创建边练，而是创建一个并非是引用的“自动变量”。这个变量直接存储值，存储于堆栈中。</strong></li>
<li><strong>基本类型具有的包装器，使得可以在<font color='red'>堆中</font>创建一个非基本对象，用来表示对应的基本类型</strong>。</li>
<li>BigInteger和BigDecimal是两个高精度计算的类，没有对应的基本类型。</li>
</ul>
</blockquote>
<h3 id="2-4-创建新的数据类型：类"><a href="#2-4-创建新的数据类型：类" class="headerlink" title="2.4 创建新的数据类型：类"></a>2.4 创建新的数据类型：类</h3><blockquote>
<ul>
<li>类中可以设置两种类型的元素：字段（有时被称作数据成员）和方法（有时被称作成员函数）</li>
<li>类中的数据成员即使没有进行初始化，Java也会确保它获得一个默认值，即默认初始化。</li>
<li>但是如果是方法中的某个局部变量（即并非某个类的字段），并不会进行默认初始化，因此在使用前必须及进行初始化。（使用的话，会编译出错）</li>
</ul>
</blockquote>
<h3 id="2-5-方法、参数和返回值"><a href="#2-5-方法、参数和返回值" class="headerlink" title="2.5 方法、参数和返回值"></a>2.5 方法、参数和返回值</h3><blockquote>
<ul>
<li>int x&#x3D;a.f();    解释：调用方法的行为通常被称为发送消息给对象。在上面的例子中，消息是f(),对象是a。面向对象的程序设计通常简单地归纳为“向对象发送信息”</li>
<li>Java中任何传递对象的场合一样，传递的实际上也是引用，尽管传递的是对象，实际上传递的是对象的引用。</li>
</ul>
</blockquote>
<h3 id="2-6-构建一个Java程序"><a href="#2-6-构建一个Java程序" class="headerlink" title="2.6 构建一个Java程序"></a>2.6 构建一个Java程序</h3><blockquote>
<ul>
<li><font color='red'>static：使用的两种情形</font><ol>
<li>只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任和对象。</li>
<li>希望某个方法不与包含它的类的任何对象关联在一起。即即使没有创建对象，也能够调用这个方法。</li>
</ol>
</li>
<li>当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象关联在一起。所以**<font color='red'>即使从未创建某个类的任何对象，也可以调用其非static方法或者访问其static域。</font>**</li>
<li>通常，必须创建一个对象，并用它来访问数据或方法。因为非static域和方阿飞必须知道他们一起运作的特定对象。</li>
<li><strong>由于在用static 方法前不需要创建任何对象，所以对于static方法，不能简单的通过调用其他非static域或方法而没有指定某个命名对象，来直接访问非static域或方法（因为非static域或方法必须与某一特定对象关联）</strong></li>
<li>访问静态成员两种方式：<ol>
<li>通过类名来进行访问（这对于非静态成员就不行）</li>
<li>通过对象名来进行访问</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTest</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在即使创建了两个StaticTest对象，StaticTest.i也只有一份存储空间，这两个对象共享同一个i.非静态成员则是对每个对象有一个存储空间</span></span><br></pre></td></tr></table></figure>

<h2 id="第三章：操作符"><a href="#第三章：操作符" class="headerlink" title="第三章：操作符"></a>第三章：操作符</h2><h2 id="第四章：控制执行流程"><a href="#第四章：控制执行流程" class="headerlink" title="第四章：控制执行流程"></a>第四章：控制执行流程</h2><blockquote>
<p><font color='red'>switch用法</font></p>
<p>当switch后面的括号中如果是浮点数的话：会报错</p>
<p>Incompatible types. Found: ‘double’, required: ‘<font color='red'>char, byte, short, int, Character, Byte, Short, Integer, String, or an enum’</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (a)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当a为4时输出结果</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//当a为2时输出结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="第五章：初始化与清理"><a href="#第五章：初始化与清理" class="headerlink" title="第五章：初始化与清理"></a>第五章：初始化与清理</h2><h3 id="5-2-方法重载"><a href="#5-2-方法重载" class="headerlink" title="5.2 方法重载"></a>5.2 方法重载</h3><blockquote>
<ul>
<li>方法重载：这个针对的是在一个类里面，对具有相同方法名的方法，但是参数类型或个数不同的重载。（构造器也是，类名相同，里面的形式参数不同），值得注意的是参数的顺序不同也可以是一种重载</li>
<li>方法重写：是指在子类继承父类时，对父类中的方法进行重写。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>设计到基本数据类型的重载的时候<ol>
<li>如常数5作为int值传入的时候，如果有某个重载的方法接受int型参数，它就会被调用。</li>
<li>至于其他情况，如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。如int类型的实际参数类型，就会被提升至long,float,double。<font color='red'>byte类型就会被提升为short,int,long。</font></li>
<li>char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升为int型，long,float,double.</li>
<li>如果传入的实际参数大于重载方法的形式参数的话，就必须通过一个类型转换进行强转，否则编译器会报错。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="5-4-this关键字"><a href="#5-4-this关键字" class="headerlink" title="5.4 this关键字"></a>5.4 this关键字</h3><blockquote>
<ul>
<li>当希望在方法的内部获得对当前对象的引用，就可以使用this关键字。</li>
<li><font color='red'>this关键字</font>：只能在方法的内部使用，<font color='red'>表示对“调用方法的那个对象”的引用</font>。<ul>
<li>this关键字对于将当前对象传递给其他方法也很有用</li>
<li>在构造器中调用构造器（在一个构造器中调用另一个构造器），以避免重复代码<ul>
<li>一般情况下，this都是指这个对象或者当前对象。如果为this添加了参数列表，就有了不同的含义，这将产生对符合此参数列表的某个构造器的明确调用。如this(6,”hello”)。</li>
<li><font color='red'>在使用this调用构造器的时候，不能调用两次，并且调用的时候，必须将构造器调用置于最起始处（第一行），这也证实了this调用构造器语句必须在第一行，否则编译器会报错。</font></li>
<li>值得注意的是，只能在构造器方法体里面才能够调用另外一个构造器方法。在任何方法之外调用都会报错。Call to ‘this()’ must be first statement <font color='red'>in constructor body</font></li>
</ul>
</li>
<li>也可以使用this.s&#x3D;s来代表数据成员，避免与方法或者构造器中的变量产生歧义。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>static关键字</font>：static（静态）方法就是没有this的方法。在static方法的内部不能调用非静态方法，反过来是可以的（即在非静态方法中可以调用静态方法），在static方法内部，可以调用static域和static方法。static方法有时候又被称为<font color='red'>类方法</font>。</li>
</ul>
</blockquote>
<h3 id="5-5-清理：终结处理和垃圾回收"><a href="#5-5-清理：终结处理和垃圾回收" class="headerlink" title="5.5 清理：终结处理和垃圾回收"></a>5.5 清理：终结处理和垃圾回收</h3><blockquote>
<ul>
<li>Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：<font color='red'>假定你的对象（并非使用new）获得了一块特殊的内存区域。因为垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块特殊内存</font>。因此，为了应对这种情况，Java允许在类中定义一个finalize（）方法。</li>
<li><font color='red'>finalize()的工作原理</font>：<font color='red'>一旦垃圾回收器准备好释放占用的存储空间，将首先调用其finalize()方法</font>，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存</li>
<li>应该注意的以下几点：<ol>
<li>对象可能不被垃圾回收</li>
<li>垃圾回收并不等于“析构”</li>
<li>垃圾回收至于内存有关（使用垃圾回收器的唯一原因是为了回收程序不再使用的内存）</li>
</ol>
</li>
<li><font color='red'>finalize()函数的用途：</font><ul>
<li>注意：无论对象是如何创建的，垃圾回收器都会负责释放对象占据所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。（这种特殊情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式，本地方法目前只支持c和c++,如在非Java代码中，也许会调用到C的malloc()函数系列来分配存储空间，而且除了使用free()函数，否则存储空间永远将得不到释放，从而造成内存泄漏，free()是c和c++中的函数，所以需要在finalize()中用本地方法调用它）。但是要尽量避免使用finalize()函数</li>
<li>finalize()函数还可以作为终结条件验证</li>
</ul>
</li>
<li>特别注意的是：<font color='red'>无论是“垃圾回收”还是“终结（finalize）”,都不保证一定会发生，如果Java虚拟机并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以回复内存的。</font>因为finalize函数是发生在要进行垃圾回收之前执行。而垃圾回收是只有在内存濒临消耗完或者退出程序的时候才会被调用，所以也有可能不会执行。</li>
<li>System.gc()函数：用于强制进行垃圾回收和终结动作。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: initialization/TerminationCondition.java</span></span><br><span class="line"><span class="comment">// Using finalize() to detect an object that</span></span><br><span class="line"><span class="comment">// hasn&#x27;t been properly cleaned up.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">checkedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  Book(<span class="type">boolean</span> checkOut) &#123;</span><br><span class="line">    checkedOut = checkOut;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">checkIn</span><span class="params">()</span> &#123;</span><br><span class="line">    checkedOut = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//对于对终结条件的验证</span></span><br><span class="line">    <span class="keyword">if</span>(checkedOut)</span><br><span class="line">      System.out.println(<span class="string">&quot;Error: checked out&quot;</span>);</span><br><span class="line">    <span class="comment">// Normally, you&#x27;ll also do this:</span></span><br><span class="line">    <span class="comment">// super.finalize(); // Call the base-class version</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminationCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">novel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// Proper cleanup:</span></span><br><span class="line">    novel.checkIn();</span><br><span class="line">    <span class="comment">// Drop the reference, forget to clean up:</span></span><br><span class="line">    <span class="comment">//只有在没有具体声明对象的引用的时候，执行Sytem.gc()才会执行finalize()里面的方法</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// Force garbage collection &amp; finalization:</span></span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Error: checked out</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>垃圾回收机制的工作原理：<ul>
<li>其他系统中是采用引用计数的方式（计数值变为0时就释放对象）</li>
<li>在Java中是采用是更快的模式，依据这样的思想：对任何“活的对象”，一定能够追溯到其存活在堆栈或静态存储区之中的引用。由此，先在堆栈或静态存储区遍历引用，对于发现的每个引用，追踪它所引用的对象，然后是此对象的所有引用，如此反复就解决了对象自引用的问题。</li>
<li>Java虚拟机采用自适应的方式。找到活的对象的方式基于不同的虚拟机有不同方式：<ol>
<li>停止-复制。这个对于需要清理的对象（垃圾）很少的时候，就很浪费，因为复制式回收器仍然会将内存从一处复制到另一处。</li>
<li>标记-清扫。这里面不会发生复制动作，会先给对象进行标记，没有标记的对象就会被清理掉。适用于垃圾较少的情况。</li>
<li>上面这两种方式都会暂停运行程序。</li>
<li>Java虚拟机会进行监视，从而在上面这两种方式之间进行一个切换，所以称之为自适应技术。</li>
</ol>
</li>
<li>Java中还有很多附加技术用以提升速度。如即时编译器(JIT——just in time)，将程序全部或部分翻译成本地机器码，提高程序运行速度。<ol>
<li>一种方式是让即时编译器编译所有代码。存在的问题是这种加载动作会散落在整个程序生命周期，比较耗时，同时会增加可执行代码的长度（字节码文件要比即时编译器展开后的本地机器码小很多）。</li>
<li>一种方式是惰性评估。即时编译器只有在必要的时候才编译代码。从不会执行的代码压根不会被JIT所编译，其中Java HotSpot技术就采用了类似方法。代码每次被执行的时侯都会做一些优化，执行的次数越多速度也越快。</li>
</ol>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-7-构造器初始化"><a href="#5-7-构造器初始化" class="headerlink" title="5.7 构造器初始化"></a>5.7 构造器初始化</h3><blockquote>
<p>可以用构造器来进行初始化，但是这无法组织自动初始化（默认初始化）的进行，这个将在构造器被调用之前就发生了。如下面的内容，i首先会被置为0，再然后变成7.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    Test()&#123;i=<span class="number">7</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>初始化顺序</font><font color='red'>:</font></p>
<ul>
<li>在类的内部，成员变量的先后顺序决定了初始化的顺序。即使变量定义散布于成员方法之间，他们仍旧会在任何方法（包括构造器,也包括静态static方法）被调用之前得到初始化。</li>
<li>静态数据的初始化：<font color='red'>静态数据都只占用一份内存区域，static关键字不能应用于局部变量、类上，因此它只能作用于成员变量或成员方法</font>。</li>
<li><font color='red'>静态初始化只有在必要时刻才会进行</font>。如下面的如果不创建Table对象，也不引用Table.b1或Table.b2，那么静态的Bowl b1和b2用于都不会创建。<font color='red'>只有第一个Table对象创建（或者第一次访问静态数据）的时候，它们才会被初始化。此后静态对象不会再次被初始化</font>。而<font color='red'>非静态成员变量，每创建一个对象就都会被初始化一次</font>。如Cupboard类中的Bowl成员变量，每次new Cupboard()时，都会进行一次初始化。</li>
<li>初始化的顺序是<font color='red'>先静态对象</font>（前提是他们尚未因前面的对象创建而被初始化），<font color='red'>而后是非静态对象</font>。即便是在含有静态的main（）方法的类中也是如此。</li>
<li>其实构造器方法在某种意义上可以看成是静态方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bowl</span> &#123;</span><br><span class="line">  Bowl(<span class="type">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">&quot;Bowl(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">1</span>);</span><br><span class="line">  Table() &#123;</span><br><span class="line">    print(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">    bowl2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cupboard</span> &#123;</span><br><span class="line">  <span class="type">Bowl</span> <span class="variable">bowl3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">4</span>);</span><br><span class="line">  Cupboard() &#123;</span><br><span class="line">    print(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">    bowl4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInitialization</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Cupboard</span> <span class="variable">cupboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Bowl(1)</span></span><br><span class="line"><span class="comment">Bowl(2)</span></span><br><span class="line"><span class="comment">Table()</span></span><br><span class="line"><span class="comment">f1(1)</span></span><br><span class="line"><span class="comment">Bowl(4)</span></span><br><span class="line"><span class="comment">Bowl(5)</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">f2(1)</span></span><br><span class="line"><span class="comment">f3(1)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>显式的静态初始化：</font></p>
<ul>
<li>Java允许将多个静态初始化动作组织成一个特殊的“静态子句”（有时也叫静态代码块），这与其他静态初始化动作一样，这段代码只执行一次：当首次生成这个类的对象的时候，或者首次访问属于那个类的静态数据成员时（即便从未生成那个类的对象）</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spoon</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i=<span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cup</span> &#123;</span><br><span class="line">    Cup(<span class="type">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cup(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cups</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Cup cup1=<span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">        cup1 = <span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">1</span>);</span><br><span class="line">        cup2 = <span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">2</span>);  <span class="comment">//这个不会出现异常</span></span><br><span class="line">        <span class="comment">//下面这个会引起非法向前引用的编译异常</span></span><br><span class="line"><span class="comment">//        System.out.println(cup2);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Cup cup2=<span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">4</span>);</span><br><span class="line">    Cups() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cups()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExplicitStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        Cups.cup1.f(<span class="number">99</span>);  <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//static Cups cups1 = new Cups();  // (2)</span></span><br><span class="line">    <span class="comment">// static Cups cups2 = new Cups();  // (2)</span></span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Inside main()</span></span><br><span class="line"><span class="comment">Cup(3)</span></span><br><span class="line"><span class="comment">静态代码块</span></span><br><span class="line"><span class="comment">Cup(1)</span></span><br><span class="line"><span class="comment">Cup(2)</span></span><br><span class="line"><span class="comment">Cup(4)</span></span><br><span class="line"><span class="comment">f(99)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>非静态实例初始化：</p>
<ul>
<li>实例初始化子句是在构造器函数执行之前进行的。</li>
</ul>
</blockquote>
<h3 id="5-8-数组初始化"><a href="#5-8-数组初始化" class="headerlink" title="5.8 数组初始化"></a>5.8 数组初始化</h3><blockquote>
<p>如果是基本类型数组，在创建数组的时候，基本数据类型值会自动初始化成空值。</p>
<p>如：int[] arr&#x3D;new int[20];</p>
<p>​		System.out.print(arr);	&#x2F;&#x2F;输出0</p>
</blockquote>
<blockquote>
<p>如果创建了一个非基本类型的数组，那么你就创建了一个引用数组。但是这还没有完成初始化的工作。必须直到创建新的Integer对象，并把对象赋值给引用，初始化进程才算结束。</p>
<p>如：Integer[] arr&#x3D;new Integer[20];</p>
<p>​		System.out.print(arr[0]);	&#x2F;&#x2F;输出null</p>
<p>​		arr[0]&#x3D;12;     &#x2F;&#x2F;通过自动包装机制创建的</p>
</blockquote>
<h3 id="5-9-枚举类型（enum）"><a href="#5-9-枚举类型（enum）" class="headerlink" title="5.9 枚举类型（enum）"></a>5.9 枚举类型（enum）</h3><blockquote>
<p>如下面适用的形式一样：</p>
<p>在创建enum时，编译器会自动添加一些有用的特性。如</p>
<ol>
<li>创建toString()方法：方便显示某个enum实例的名字</li>
<li>创建ordinal()方法：用来表示某个特定变量的声明顺序</li>
<li>创建了static values()方法：用来按照enum常量的声明顺序，产生由这些常量值构成的数组</li>
</ol>
<ul>
<li>特别值得注意的是，enum有个特别实用的特性，即它可以在switch语句内使用</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Spiciness</span> &#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleEnumUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       	<span class="comment">//注意声明的方式</span></span><br><span class="line">        <span class="type">Spiciness</span> <span class="variable">howHot</span> <span class="operator">=</span> Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">MEDIUM</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Spiciness s : Spiciness.values())</span><br><span class="line">            System.out.println(s + <span class="string">&quot;, ordinal &quot;</span> + s.ordinal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">NOT, ordinal 0</span></span><br><span class="line"><span class="comment">MILD, ordinal 1</span></span><br><span class="line"><span class="comment">MEDIUM, ordinal 2</span></span><br><span class="line"><span class="comment">HOT, ordinal 3</span></span><br><span class="line"><span class="comment">FLAMING, ordinal 4</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在switch语句中使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Burrito</span> &#123;</span><br><span class="line">  Spiciness degree;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Burrito</span><span class="params">(Spiciness degree)</span> &#123; <span class="built_in">this</span>.degree = degree;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">      <span class="keyword">case</span> NOT:    System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> MILD:</span><br><span class="line">      <span class="keyword">case</span> MEDIUM: System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> HOT:</span><br><span class="line">      <span class="keyword">case</span> FLAMING:</span><br><span class="line">      <span class="keyword">default</span>:     System.out.println(<span class="string">&quot;maybe too hot.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Burrito</span></span><br><span class="line">      <span class="variable">plain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.NOT),</span><br><span class="line">      greenChile = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.MEDIUM),</span><br><span class="line">      jalapeno = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.HOT);</span><br><span class="line">    plain.describe();</span><br><span class="line">    greenChile.describe();</span><br><span class="line">    jalapeno.describe();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">This burrito is a little hot.</span></span><br><span class="line"><span class="comment">This burrito is maybe too hot.</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第六章：访问权限控制"><a href="#第六章：访问权限控制" class="headerlink" title="第六章：访问权限控制"></a>第六章：访问权限控制</h2><blockquote>
<ul>
<li><p>访问权限的控制的等级依次为：public、protected、包访问权限（没有关键词）、private</p>
</li>
<li><p>package关键字：将构建类库捆绑到一个内聚的类库单元中。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>控制对成员的访问权限的原因</font>:<ol>
<li>安全,让用户不要触碰到那些他们不应该触碰的部分,简化他们的理解</li>
<li>让类库设计者可以更改类的内部工作方式,而不必担心会对客户端程序员产生重大的影响.接口与实现分离</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="6-1-包：库单元"><a href="#6-1-包：库单元" class="headerlink" title="6.1 包：库单元"></a>6.1 包：库单元</h3><blockquote>
<p>当编写一个Java源代码文件的时候，此文件通常被称为编译单元（或者叫转译单元），每个编译单元都必须有一个后缀名.java。在编译单元内，只允许有一个public类。编译单元中的其他类（指的是没有修饰符的类）主要为主public类提供支持。</p>
<ul>
<li><font color='red'>细节1</font>：类只能被public，或者没有修饰符来修饰。如：<ol>
<li>public class A{}</li>
<li>class B{}</li>
</ol>
</li>
<li><font color='red'>细节2</font>：在对一个编译单元（.java文件）进行编译的时候，<font color='red'>在.java文件中的每一个类都会有一个.class文件</font>。名称都与类名称相同，只是后缀名变为.class文件</li>
</ul>
</blockquote>
<blockquote>
<p>类库实际上是一组类文件，每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字package。</p>
<ul>
<li><font color='red'>细节：如果使用package语句，它必须是文件中除注释以外的第一句程序代码</font>。在文件起始处写。如：<ul>
<li>package access;</li>
</ul>
</li>
</ul>
<p>任何想要使用某个包中的某个类时，有两种选择，即指定全类名或者结合import将该类导入。如：</p>
<ul>
<li>第一种方式：java.util.ArrayList list&#x3D;new java.util.ArrayList();</li>
<li>第二种方式：import java.util.ArrayList;        ArrayList list&#x3D;new ArrayList();</li>
</ul>
</blockquote>
<h3 id="6-2-Java访问权限修饰词"><a href="#6-2-Java访问权限修饰词" class="headerlink" title="6.2 Java访问权限修饰词"></a>6.2 Java访问权限修饰词</h3><h4 id="1-包访问权限"><a href="#1-包访问权限" class="headerlink" title="1. 包访问权限"></a>1. 包访问权限</h4><blockquote>
<ul>
<li><font color='red'>包访问权限可以修饰类，成员变量（域），成员方法，局部变量</font></li>
</ul>
<p>当前包中的所有其他类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。</p>
</blockquote>
<h4 id="2-public：接口访问权限"><a href="#2-public：接口访问权限" class="headerlink" title="2. public：接口访问权限"></a>2. public：接口访问权限</h4><blockquote>
<ul>
<li><font color='red'>public可以修饰类，成员变量，成员方法</font></li>
</ul>
</blockquote>
<h4 id="3-private-你无法访问"><a href="#3-private-你无法访问" class="headerlink" title="3. private:你无法访问"></a>3. private:你无法访问</h4><blockquote>
<ul>
<li>private可以修饰成员变量,成员方法,<font color='red'>注意不能修饰类</font></li>
<li>其中有一个用法就是单例设计模式</li>
<li>还有一个用法是,将成员变量进行私有化,通过提供共有的get&#x2F;set方法来进行修改和获取.</li>
<li><font color='red'>细节:如果基类中只有一个private修饰的构造器方法,那么该类就不允许被其他类继承</font></li>
</ul>
</blockquote>
<h4 id="4-protected-继承访问权限-包含了包访问权限"><a href="#4-protected-继承访问权限-包含了包访问权限" class="headerlink" title="4. protected:继承访问权限(包含了包访问权限)"></a>4. protected:继承访问权限(包含了包访问权限)</h4><blockquote>
<ul>
<li>protected可以修饰成员变量,成员方法,<font color='red'>注意不能修饰类</font></li>
<li>有时,基类的创建者会希望有某个特定成员,把对它的访问权限赋予派生类而不是所有类,这就需要protected来进行完成.</li>
<li><font color='red'>细节:前提是在子类与父类不在一个包中</font>,在派生类(子类)中,可以在子类的构造器方法中通过super()的方式来访问父类中用protected修饰的构造器方法.也可以通过子类的引用(实例对象)来访问父类中用protected修饰的成员变量和成员方法.但是值得注意的是,在子类中,<font color='red'>通过父类的引用</font>(实例对象并不能访问父类中的protected修饰的成员变量和成员方法.但是也不能直接使用父类的protected构造器方法,而是需要用super关键字</li>
<li>细节:如果子类和父类都在一个包中,则可以直接使用父类的protected构造器方法,也可以通过父类的引用访问父类的成员方法和成员变量</li>
</ul>
</blockquote>
<h3 id="6-3-接口和实现"><a href="#6-3-接口和实现" class="headerlink" title="6.3 接口和实现"></a>6.3 接口和实现</h3><blockquote>
<p>访问权限的控制被称为是具体实现的隐藏.把数据和方法包装进类中,以及具体实现的隐藏,常共同被称作是<font color='red'>封装,</font>其结果是一个同时带有特征和行为的数据类型.</p>
</blockquote>
<h3 id="6-4-类的访问权限"><a href="#6-4-类的访问权限" class="headerlink" title="6.4 类的访问权限"></a>6.4 类的访问权限</h3><blockquote>
<p>一个编译单元(.java文件)最多允许有一个主public类,如果有那么这个文件名就必须该主类名.如果没有主public类,都是包访问权限,那么该文件名就可以随意.</p>
</blockquote>
<p>细节:在正常情况下,类只能由public或者包访问权限修饰.但是事实上,内部类可以是由protected或者private进行修饰,这是一个特例.</p>
<blockquote>
<p>如果我们将一个类的构造器方法添加了private修饰符,那么其他类就无法创建该类的对象,但是现在别人可以该怎样使用它呢?</p>
</blockquote>
<p>方式一:通过一个公有方法返回该类的引用,该种方式允许创建多个该类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Soup1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Soup1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//通过一个公有方法返回该类的引用,该种方式允许创建多个该类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Soup1 <span class="title function_">makeSoup</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Soup1</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;方式二:单例设计模式&#x3D;&#x3D;  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Soup2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Soup2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//这里应该注意到的是,其他类只能通过类名调用下面公有的access方法才能获取到对象实例,并不能通过类名调用ps1成员变量来进行访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Soup2 ps1=<span class="keyword">new</span> <span class="title class_">Soup2</span>();</span><br><span class="line">   	<span class="comment">//这里通过提供一个共有方法返回一个私有的静态成员变量,每次调用该方法时,返回的都是同一个实例,因为该实例是一个静态成员,所以共享一份内存空间.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Soup2 <span class="title function_">access</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ps1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第七章：复用类"><a href="#第七章：复用类" class="headerlink" title="第七章：复用类"></a>第七章：复用类</h2><blockquote>
<ul>
<li>组合和继承：<ul>
<li>组合：是在一个新类中把另一个类的对象作为它的数据成员</li>
<li>继承：是新类按照现有的类的类型来进行创建，并添加自己的新代码</li>
<li>这两种方式的混用</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="7-2-继承语法"><a href="#7-2-继承语法" class="headerlink" title="7.2 继承语法"></a>7.2 继承语法</h3><blockquote>
<p>在一个编译单元（.java文件）中，可以有至多一个主public类中，可以有任意个类（包访问权限），并且<font color='red'>每个类中可以有主main方法</font>。所有一个文件中可以有多个main方法。并且这些main（）都可以作为程序主入口，看你选择哪个。即使有多个main(),在进行编译的时候也只有命令行所调用的那个类的main()方法会被调用。其他main()方法可以在被调用的main方法中被调用</p>
</blockquote>
<blockquote>
<p><font color='red'>在子类中，如果对父类中的方法进行了覆盖（overriding），那么要想在子类中访问父类中的这个方法时可以通过super关键字来进行访问，而不能通过子类的引用来进行访问</font>。当然这里也可以直接通过父类的引用来进行调用。Java用super表示超类的意思，当前类就是从超类继承来的。如super.test();</p>
</blockquote>
<blockquote>
<ul>
<li>&#x3D;&#x3D;重点关注&#x3D;&#x3D;：<ol>
<li>在一般情况下，对成员变量的初始化要先与该类中的方法（包括构造器方法）调用，所以这也是为什么先输出第一个示例先输出B(),再输出A()</li>
<li><font color='red'>在继承的情况下，创建子类对象时，会先进行执行子类构造器中的第一行，即调用基类构造器，执行完基类构造器后，再对子类中的成员变量进行初始化，再是子类构造器后面的语句了。</font></li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">###################################################################################</span><br><span class="line">一般情况下（没有继承） :注意输出顺序</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E05_SimpleInheritance</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br><span class="line"></span><br><span class="line">#####################################################################################</span><br><span class="line">在有继承的情况下：注意输出顺序</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="built_in">super</span>();</span><br><span class="line">     System.out.println(<span class="string">&quot;hello C()&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E05_SimpleInheritance</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">hello C()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在子类构造器中，必须要显式或者隐式的调用父类的构造器方法。<ol>
<li>当是显式的时候，就直接使用super()进行调用即可。可以同时传参</li>
<li><font color='red'>当是隐式的时候，则默认就会执行super()去调用父类中的无参构造函数</font>，所以此时父类中必须要有无参构造器，若没有就会报错。</li>
</ol>
</li>
<li>&#x3D;&#x3D;细节：&#x3D;&#x3D;对父类构造器的调用语句（使用super()的方式）只能写在第一行，并且只能调用一次（侧面证实了该语句只能写在第一行）。应该注意到的是，<font color='red'>即便使用了new 父类类名（）的方式，在子类中仍然还是需要使用super的方式进行调用。 </font></li>
</ul>
</blockquote>
<h3 id="7-3-代理（没太弄明白）"><a href="#7-3-代理（没太弄明白）" class="headerlink" title="7.3 代理（没太弄明白）"></a>7.3 代理（没太弄明白）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过不用继承的方式，让代理对象去操作要继承的对象</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;不用代理模式的代码：&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShipControls</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">turboBoost</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShip</span> <span class="keyword">extends</span> <span class="title class_">SpaceShipControls</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SpaceShip</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpaceShip</span> <span class="variable">protector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpaceShip</span>(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;使用代理模式的代码：&#x3D;&#x3D;</p>
<p>​	上面不使用代理模式的问题在于，SpaceshipControls的所有方法在Spaceship中都暴露了出来。而代理模式中就通过代理对象来对SpaceshipControls中的方法进行管理，所以Spaceship就不用对SpaceshipControls进行继承了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShipDelegation</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">SpaceShipControls</span> <span class="variable">controls</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SpaceShipControls</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SpaceShipDelegation</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Delegated methods:</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.back(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.down(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.forward(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.left(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.right(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turboBoost</span><span class="params">()</span> &#123;</span><br><span class="line">    controls.turboBoost();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">    controls.up(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpaceShipDelegation</span> <span class="variable">protector</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SpaceShipDelegation</span>(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<h3 id="7-7-向上转型"><a href="#7-7-向上转型" class="headerlink" title="7.7 向上转型"></a>7.7 向上转型</h3><blockquote>
<ul>
<li><font color='red'>将子类的引用转化为父类的引用我们称之为向上转型</font></li>
<li>值得注意的是：向上转型后的父类引用在进行调用方法的时候，编译的时候会先看父类中是否有该方法，如果有则编译通过，如果没有就编译失败。在运行的时候，会判断在子类中是否对该方法进行了覆盖，如果进行了覆盖，则调用的就是子类中的方法，如果子类中没有则就直接调用父类中的该方法。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Amphibian</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(Amphibian amphibian)</span>&#123;</span><br><span class="line">        System.out.println(amphibian+<span class="string">&quot;能游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;陆生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;水生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Frog</span> <span class="keyword">extends</span> <span class="title class_">Amphibian</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里通过将一个子类的引用传给父类的引用实现了向上转型</span></span><br><span class="line">        Amphibian amphibian=<span class="keyword">new</span> <span class="title class_">Frog</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//值得注意的是：向上转型后的父类引用在进行调用方法的时候，编译的时候会先看父类中是否有该方法（并且要求该方法能够被该子类继承，即如果是父类中的私有方法也不可以），如果有则编译通过，如果没有就编译失败。在运行的时候，会判断在子类中是否对该方法进行了覆盖，如果进行了覆盖，则调用的就是子类中的方法，如果子类中没有则就直接调用父类中的该方法。</span></span><br><span class="line">        amphibian.a();</span><br><span class="line">        amphibian.b();</span><br><span class="line">        Frog frog=<span class="keyword">new</span> <span class="title class_">Frog</span>();</span><br><span class="line">        swim(frog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙陆生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙水生的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(Amphibian amphibian)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;青蛙能游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-8-final关键字"><a href="#7-8-final关键字" class="headerlink" title="7.8 final关键字"></a>7.8 final关键字</h3><blockquote>
<p>根据上下文环境，final关键字的含义存在细微差别，但通常都是无法改变的。一般final可以作用于数据，方法和类</p>
</blockquote>
<h4 id="1-final数据"><a href="#1-final数据" class="headerlink" title="1. final数据"></a>1. final数据</h4><blockquote>
<ul>
<li><p>基本数据类型：</p>
<ul>
<li><p>对于final修饰基本类型数据，表明这个数据是一个常量</p>
</li>
<li><p>而用static和final共同修饰得数据，表明这个数据也是一个常量，只是所有对象共享一份存储空间。</p>
</li>
</ul>
</li>
<li><p>对象引用数据：</p>
<ul>
<li>final修饰得对象引用只是表明不能再被指向另一个新的对象。但是该对象引用的值仍然可以进行改变。</li>
<li>例如：一个final修饰的数据对象引用。这个数组里面的值仍然是可以改变的，只是不能再被指向另外一个新的数组对象。</li>
</ul>
</li>
<li><p>对于final修饰的域（数据成员），必须在域的定义处或者每个构造器中用表达式对final进行赋值（显式的），这正是final域在使用前总是被初始化的原因。</p>
</li>
<li><p>final参数：Java允许在参数列表中以声明的方式将参数指明为final,这就意味着你无法在方法中更改参数的类型。可以读final参数，但是无法修改，这一特性主要用来向匿名内部类传递数据。</p>
</li>
</ul>
</blockquote>
<h4 id="2-final方法"><a href="#2-final方法" class="headerlink" title="2. final方法"></a>2. final方法</h4><blockquote>
<p>使用final修饰方法，主要是将方法进行锁定，以防任何继承类修改它的含义。<font color='red'>所以final修饰的方法不可以被覆盖，确保了方法的行为不会发生改变。</font></p>
<ul>
<li>细节：final和private关键字<ul>
<li>类中所有的private方法都隐式地指定为final的。因为无法取用private方法，所以也就无法覆盖它了。可以对private方法添加final关键字。</li>
<li>如果父类中有一个private方法，而子类中以相同的名称生成一个public、protected或包访问权限的方法，此时并没有覆盖父类中该方法，仅是生成了一个新的方法。（这里面在向上转型调用该方法时会报错，说父类与子类该方法并不匹配）</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-final类"><a href="#3-final类" class="headerlink" title="3. final类"></a>3. final类</h4><blockquote>
<ul>
<li>当用final修饰类时，表明该类不能被继承，即不希望该类有子类。</li>
<li>final类的域（成员）可以根据需要确定是否定义为final,不论类是否定义为final,相同的规则都适用域定义为final的域。然而final类禁止被继承，所以final类中的所有方法都隐式指定为final的，因为无法覆盖他们。</li>
</ul>
</blockquote>
<h3 id="7-9-继承与初始化"><a href="#7-9-继承与初始化" class="headerlink" title="7.9 继承与初始化"></a>7.9 继承与初始化</h3><blockquote>
<ol>
<li>在运行一个类文件时，加载器会去加载该类，在加载的过程中，编译器会注意它有基类，于是就对它进行继续加载，这里不管是否打算产生一个该基类的对象，这都要发生。所以&#x3D;&#x3D;根基类中的static初始化&#x3D;&#x3D;即会被执行（在本例中是Insect类），再然后就是下一个导出类，依此类推。</li>
<li>至此，必要的类加载完毕，在这里应该注意的一点是如果调用的静态方法，则会先执行静态方法中的方法体内容，再进行本类中成员对象的创建，对象就可以创建了，首先对象中所有的基本数据类型都会被设为默认值，对象引用置为null。</li>
<li>然后，基类的构造器方法就会被调用，在本例中是被自动调用的，但也可以用super来指定对构造器的调用。基类构造器和导出类的构造器一样，以相同的顺序经历相同的过程。</li>
<li>&#x3D;&#x3D;在基类构造器完成之后，实例变量（即非static成员）按其次序被初始化。&#x3D;&#x3D;<font color='red'>在每一个类中，静态成员或者静态代码块先执行，再是实例变量，再是构造器方法。</font></li>
<li>&#x3D;&#x3D;最后构造器的其余部分被执行。&#x3D;&#x3D;</li>
</ol>
</blockquote>
<blockquote>
<p><font color='red'>加载类的动作仅发生一次（所以这也是为什么静态代码块只被执行一次）</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Insect</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> j;</span><br><span class="line">  Insect() &#123;</span><br><span class="line">    print(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    j = <span class="number">39</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span></span><br><span class="line">    printInit(<span class="string">&quot;static Insect.x1 initialized&quot;</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">printInit</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    print(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beetle</span> <span class="keyword">extends</span> <span class="title class_">Insect</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> printInit(<span class="string">&quot;Beetle.k initialized&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Beetle</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;k = &quot;</span> + k);</span><br><span class="line">    print(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span></span><br><span class="line">    printInit(<span class="string">&quot;static Beetle.x2 initialized&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Beetle constructor&quot;</span>);</span><br><span class="line">    <span class="type">Beetle</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Beetle</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">static Insect.x1 initialized</span></span><br><span class="line"><span class="comment">static Beetle.x2 initialized</span></span><br><span class="line"><span class="comment">Beetle constructor</span></span><br><span class="line"><span class="comment">i = 9, j = 0</span></span><br><span class="line"><span class="comment">Beetle.k initialized</span></span><br><span class="line"><span class="comment">k = 47</span></span><br><span class="line"><span class="comment">j = 39</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第八章：多态"><a href="#第八章：多态" class="headerlink" title="第八章：多态"></a>第八章：多态</h2><blockquote>
<ul>
<li><p>多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要他们是从同一种基类到处而来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。</p>
</li>
<li><p>多态（也称作动态绑定，后期绑定或运行时绑定）</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;Instrument play&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Piano</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;Piano play&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wind</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;Wind play&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(Instrument instrument)</span>&#123;</span><br><span class="line">        instrument.play();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        play(<span class="keyword">new</span> <span class="title class_">Instrument</span>);  <span class="comment">//没有进行向上转型</span></span><br><span class="line">        play(<span class="keyword">new</span> <span class="title class_">Piano</span>());	  <span class="comment">//向上转型</span></span><br><span class="line">        play(<span class="keyword">new</span> <span class="title class_">Wind</span>());	  <span class="comment">//向上转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Instrument play</span><br><span class="line">Piano play</span><br><span class="line">Wind play</span><br></pre></td></tr></table></figure>

<h3 id="8-2-转机"><a href="#8-2-转机" class="headerlink" title="8.2 转机"></a>8.2 转机</h3><blockquote>
<ul>
<li>将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做&#x3D;&#x3D;前期绑定&#x3D;&#x3D;。在面向过程语言中默认就是这种绑定方式。如c语言就只有这一种。</li>
</ul>
</blockquote>
<blockquote>
<p>上面程序(Test类中的play方法)令人迷惑的地方在于，编译器只有一个Instrument引用，它无法知道究竟调用哪个方法。</p>
<p>解决办法：&#x3D;&#x3D;后期绑定&#x3D;&#x3D;。它的含义就是在运行时根据对象的类型进行绑定。后期绑定又叫动态绑定或运行时绑定。</p>
</blockquote>
<blockquote>
<p>在Java中，除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。这意味着在通常情况下，我们不必判定是否应该进行后期绑定—它会自动发生。</p>
</blockquote>
<blockquote>
<p><font color='red'>特例1：</font>“覆盖”私有方法</p>
</blockquote>
<p><strong>下面这个代码执行不会出错</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;private f()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">PrivateOverride</span> <span class="variable">po</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Derived</span>();		<span class="comment">//因为这里private方法不能被覆盖，但是这里也不会报错，但是执行的是父类中的private方法</span></span><br><span class="line">    po.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;public f()&quot;</span>); &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">private f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>下面这个代码执行就会出错</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test824</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        Base b=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        b.a();  <span class="comment">//编译出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color='red'>特例2：</font>域与静态方法</p>
<ul>
<li><font color='red'>当子类对象向上转型赋给父类引用时，在使用父类引用访问子类和父类都有的成员变量时，会直接从当前父类域中获取</font>。因为域操作不是多态，即子类并不会将父类的成员变量覆盖掉，所以继承后子类中实际上包含了两个该成员变量，一个是它自己的还有是从父类中得到的。</li>
<li>静态方法也不具有多态性。静态方法是与类，而并非与单个的对象相关联的。因为静态方法也不允许被重载。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Base staticGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Base dynamicGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSub</span> <span class="keyword">extends</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">  <span class="comment">//这里虽然无法覆盖父类中的staticGet()方法，但是这里的访问权限，返回类型，参数类型也还是要满足重载的要求</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Derived staticGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Derived dynamicGet()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticPolymorphism</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StaticSuper</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticSub</span>(); <span class="comment">// Upcast</span></span><br><span class="line">    System.out.println(sup.staticGet());			<span class="comment">//注意调用的是父类中方法，</span></span><br><span class="line">    System.out.println(sup.dynamicGet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Base staticGet()</span></span><br><span class="line"><span class="comment">Derived dynamicGet()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-构造器与多态"><a href="#8-3-构造器与多态" class="headerlink" title="8.3 构造器与多态"></a>8.3 构造器与多态</h3><blockquote>
<p>在导出类（子类）的构造器主体中，如果没有明确指定调用某个基类构造器，它就会默认地调用默认构造器（无参构造器），如果不存在无参构造器，编译器就会报错。</p>
<ul>
<li>&#x3D;&#x3D;执行顺序：&#x3D;&#x3D;<ol>
<li>先会进行从根基类到下一个导出类的static初始化。再就是调用的static里面的方法体执行，再是该类中的非static成员创建，再就是从根基类到导出类的构造器，并且具体到每一个类中构造器执行，都是先非static成员创建，然后是构造器里面的方法执行。&#x3D;&#x3D;（总结为：先执行静态变量初始化以及非static成员赋上默认值（0，‘’，null这些的），再就是基类构造器执行，再就是本类非static成员初始化，再是执行本类的构造器里面的语句）&#x3D;&#x3D;</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  Meal() &#123; print(<span class="string">&quot;Meal()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bread</span> &#123;</span><br><span class="line">  Bread() &#123; print(<span class="string">&quot;Bread()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cheese</span> &#123;</span><br><span class="line">  Cheese() &#123; print(<span class="string">&quot;Cheese()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lettuce</span> &#123;</span><br><span class="line">  Lettuce() &#123; print(<span class="string">&quot;Lettuce()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lunch</span> <span class="keyword">extends</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  Lunch() &#123; print(<span class="string">&quot;Lunch()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PortableLunch</span> <span class="keyword">extends</span> <span class="title class_">Lunch</span> &#123;</span><br><span class="line">  PortableLunch() &#123; print(<span class="string">&quot;PortableLunch()&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sandwich</span> <span class="keyword">extends</span> <span class="title class_">PortableLunch</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Bread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bread</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Cheese</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cheese</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lettuce</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lettuce</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Sandwich</span><span class="params">()</span> &#123; print(<span class="string">&quot;Sandwich()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Sandwich</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Meal()</span></span><br><span class="line"><span class="comment">Lunch()</span></span><br><span class="line"><span class="comment">PortableLunch()</span></span><br><span class="line"><span class="comment">Bread()</span></span><br><span class="line"><span class="comment">Cheese()</span></span><br><span class="line"><span class="comment">Lettuce()</span></span><br><span class="line"><span class="comment">Sandwich()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>继承和清理</strong></p>
<ul>
<li>​	对象在销毁的时候应该和初始化的顺序相反，对于字段，则应该和声明的顺序相反。</li>
<li>在对基类中的清理方法进行覆盖时，别忘了要在后面调用基类的清理方法，否则，基类的清理动作不会发生。</li>
</ul>
</blockquote>
<blockquote>
<p>构造器内部的多态方法的行为：在执行类中的方法时，调用的类中的变量还未初始化</p>
<p>所以优化的方法是：最好尽量避免在构造器中调用方法。或者在构造器中只调用基类中的final方法（也适用于private方法，他们自动属于private方法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; print(<span class="string">&quot;Glyph.draw()&quot;</span>); &#125;</span><br><span class="line">  Glyph() &#123;</span><br><span class="line">    print(<span class="string">&quot;Glyph() before draw()&quot;</span>);</span><br><span class="line">    draw();</span><br><span class="line">    print(<span class="string">&quot;Glyph() after draw()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundGlyph</span> <span class="keyword">extends</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  RoundGlyph(<span class="type">int</span> r) &#123;</span><br><span class="line">    radius = r;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.RoundGlyph(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.draw(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyConstructors</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RoundGlyph</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Glyph() before draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.draw(), radius = 0</span></span><br><span class="line"><span class="comment">Glyph() after draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.RoundGlyph(), radius = 5</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-用继承进行设计"><a href="#8-5-用继承进行设计" class="headerlink" title="8.5 用继承进行设计"></a>8.5 用继承进行设计</h3><blockquote>
<p>通用的准则是：用继承表达行为间的差异，并用字段表达状态上的变化</p>
</blockquote>
<p><strong>状态模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HappyActor</span> <span class="keyword">extends</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123; print(<span class="string">&quot;HappyActor&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SadActor</span> <span class="keyword">extends</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123; print(<span class="string">&quot;SadActor&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stage</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HappyActor</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123; actor = <span class="keyword">new</span> <span class="title class_">SadActor</span>(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performPlay</span><span class="params">()</span> &#123; actor.act(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transmogrify</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Stage</span> <span class="variable">stage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stage</span>();</span><br><span class="line">    stage.performPlay();</span><br><span class="line">    stage.change();</span><br><span class="line">    stage.performPlay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HappyActor</span></span><br><span class="line"><span class="comment">SadActor</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>is-a：是只有在基类中已经存在的方法才可以在导出类中被覆盖</p>
<p>is-like-a：除了覆盖的那些方法，他还具有额外方法实现的其他特性，即基类中没有的方法</p>
</blockquote>
<blockquote>
<p>向下转型：是不安全的，所以需要进行一个类型转换，即便这样，Java仍然会在运行期间对其进行检查，如果转换类型失败，则会报类转型异常（ClassCastException）,这个属于运行时异常。（为了防止转换失败，可以适用instanceof进行一个判断后，再进行类型强转）</p>
<p>RTTI(运行时类型识别)：在运行期间对类型进行检查的行为。</p>
</blockquote>
<h2 id="第九章：接口"><a href="#第九章：接口" class="headerlink" title="第九章：接口"></a>第九章：接口</h2><h3 id="9-1-抽象类和抽象方法"><a href="#9-1-抽象类和抽象方法" class="headerlink" title="9.1 抽象类和抽象方法"></a>9.1 抽象类和抽象方法</h3><blockquote>
<p>包含抽象方法的类是叫做抽象类。</p>
<p>抽象类也可能会没有任何抽象方法。是为了阻止创建该类的任何对象。（不允许创建抽象类对象，但是可以有抽象类的引用，例如多态时使用。）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abs</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Abs</span><span class="params">()</span>&#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test9_1</span> <span class="keyword">extends</span> <span class="title class_">Abs</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Test9_1 t=<span class="keyword">new</span> <span class="title class_">Test9_1</span>();</span><br><span class="line">        t.fun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">0</span>    <span class="comment">//此时输出的是尚未进行初始化的i,i只是被赋予零值</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>抽象方法不能用private访问修饰符来进行修饰（即private和abstract不能连用）</p>
</blockquote>
<h3 id="9-2-接口"><a href="#9-2-接口" class="headerlink" title="9.2 接口"></a>9.2 接口</h3><blockquote>
<p>接口可以用public或者包访问权限（没有修饰符）进行修饰。<font color='red'>接口也可以包含域（数据成员），但是这些域隐式地是static和final的。接口中的方法默认就都是public修饰的，</font>因此实现了一个接口的类，在覆盖该接口中定义的方法的时候，必须定义为public，否则权限就会降低，编译器就会报错。</p>
</blockquote>
<h3 id="9-3-完全解耦"><a href="#9-3-完全解耦" class="headerlink" title="9.3 完全解耦"></a>9.3 完全解耦</h3><blockquote>
<p>&#x3D;&#x3D;策略设计模式&#x3D;&#x3D;：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法</p>
<ul>
<li>如下图代码所示：Precessor对象就是一个策略。策略就是传递进去的参数对象，它包含要执行的代码。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">  &#125;</span><br><span class="line">  Object <span class="title function_">process</span><span class="params">(Object input)</span> &#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Upcase</span> <span class="keyword">extends</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  String <span class="title function_">process</span><span class="params">(Object input)</span> &#123; <span class="comment">// Covariant return</span></span><br><span class="line">    <span class="keyword">return</span> ((String)input).toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Downcase</span> <span class="keyword">extends</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  String <span class="title function_">process</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((String)input).toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Splitter</span> <span class="keyword">extends</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  String <span class="title function_">process</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="comment">// The split() argument divides a String into pieces:</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.toString(((String)input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apply</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Processor p, Object s)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Using Processor &quot;</span> + p.name());</span><br><span class="line">    print(p.process(s));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&quot;Disagreement with beliefs is by definition incorrect&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    process(<span class="keyword">new</span> <span class="title class_">Upcase</span>(), s);</span><br><span class="line">    process(<span class="keyword">new</span> <span class="title class_">Downcase</span>(), s);</span><br><span class="line">    process(<span class="keyword">new</span> <span class="title class_">Splitter</span>(), s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Using Processor Upcase</span></span><br><span class="line"><span class="comment">DISAGREEMENT WITH BELIEFS IS BY DEFINITION INCORRECT</span></span><br><span class="line"><span class="comment">Using Processor Downcase</span></span><br><span class="line"><span class="comment">disagreement with beliefs is by definition incorrect</span></span><br><span class="line"><span class="comment">Using Processor Splitter</span></span><br><span class="line"><span class="comment">[Disagreement, with, beliefs, is, by, definition, incorrect]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>&#x3D;&#x3D;适配器设计模式&#x3D;&#x3D;：在设配器中的代码将接受你所拥有的接口，并产生你所需要的接口。</li>
<li>将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器模式：使得CharacterPairSwapper类可以通过适配器类SwapperAdapter与Processor接口进行交互，而不用来自身来实现该接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    Object <span class="title function_">process</span><span class="params">(Object input)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterPairSwapper</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> String <span class="title function_">swap</span><span class="params">(String s)</span> &#123;</span><br><span class="line"> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length() - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> sb.charAt(i);</span><br><span class="line"> <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> sb.charAt(i + <span class="number">1</span>);</span><br><span class="line"> sb.setCharAt(i, c2);</span><br><span class="line"> sb.setCharAt(i + <span class="number">1</span>, c1);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sb.toString();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapperAdapter</span> <span class="keyword">implements</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> CharacterPairSwapper.class.getSimpleName();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">process</span><span class="params">(Object input)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> CharacterPairSwapper.swap((String)input);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E11_Swapper</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> Apply.process(<span class="keyword">new</span> <span class="title class_">SwapperAdapter</span>(), <span class="string">&quot;1234&quot;</span>);</span><br><span class="line"> Apply.process(<span class="keyword">new</span> <span class="title class_">SwapperAdapter</span>(), <span class="string">&quot;abcde&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Using Processor CharacterPairSwapper</span></span><br><span class="line"><span class="comment">2143</span></span><br><span class="line"><span class="comment">Using Processor CharacterPairSwapper</span></span><br><span class="line"><span class="comment">badce</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="9-4-Java中的多重继承"><a href="#9-4-Java中的多重继承" class="headerlink" title="9.4 Java中的多重继承"></a>9.4 Java中的多重继承</h3><blockquote>
<ul>
<li>在继承和多重实现一起存在的时候，继承的具体类应该写在前面，后面跟着的才是接口（否则编译器会报错）。</li>
<li>细节：当继承而来的某个方法是将要实现的某个抽象方法时，在子类中可以不用再对接口中的该方法进行实现，就相当于直接使用父类中的该方法。</li>
<li>使用接口的原因：<ol>
<li>为了能够向上转型为多个基类型（以及由此而带来的灵活性）。</li>
<li>防止客户端程序员创建该类的对象。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="9-5-通过继承来扩展接口"><a href="#9-5-通过继承来扩展接口" class="headerlink" title="9.5 通过继承来扩展接口"></a>9.5 通过继承来扩展接口</h3><blockquote>
<ul>
<li><p>可以使用extends关键字，应用于继承接口。并且extends用于接口继承时，可以继承多个。</p>
<ul>
<li>如：public class c extends interface1,interface2{}</li>
</ul>
</li>
<li><p>将extends用于类时，就只能继承一个类。</p>
</li>
</ul>
</blockquote>
<h3 id="9-6-适配接口（这里还需要再看一下）"><a href="#9-6-适配接口（这里还需要再看一下）" class="headerlink" title="9.6 适配接口（这里还需要再看一下）"></a>9.6 适配接口（这里还需要再看一下）</h3><blockquote>
<ul>
<li>接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现。在简单的情况中，他的体现形式通常是一个接受接口类型的方法，而该接口的实现和向该方法传递的对象则取决于方法的使用者。</li>
<li>因此接口一种常见用法就是前面提到的策略设计模式。</li>
<li>还有一个就是适配器设计模式</li>
<li>在这种模式中，我们可以在任何现有类之上添加新的接口，所以这就一位让方法接受接受接口类型，是一种让任何类都可以对该方法进行适配的方式，这也是使用接口而不是类的强大之处。</li>
</ul>
</blockquote>
<h3 id="9-7-接口中的域"><a href="#9-7-接口中的域" class="headerlink" title="9.7 接口中的域"></a>9.7 接口中的域</h3><blockquote>
<ul>
<li>细节：在接口中的域不能是”空final”，即接口中的域必须被显式初始化。（被非常量表达式也是可以的）</li>
</ul>
</blockquote>
<h3 id="9-8-嵌套接口（没太理解）"><a href="#9-8-嵌套接口（没太理解）" class="headerlink" title="9.8 嵌套接口（没太理解）"></a>9.8 嵌套接口（没太理解）</h3><blockquote>
<ul>
<li>可以在接口中嵌套类或接口</li>
<li>同样，也可以在类中嵌套类或接口</li>
<li>此时，在类中被嵌套的类或接口可以用private修饰</li>
<li>在接口中被嵌套的类或接口只能用public修饰，并且默认就是public的</li>
</ul>
</blockquote>
<h3 id="9-9-接口与工厂"><a href="#9-9-接口与工厂" class="headerlink" title="9.9 接口与工厂"></a>9.9 接口与工厂</h3><blockquote>
<ul>
<li>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是&#x3D;&#x3D;工厂方法设计模式&#x3D;&#x3D;。</li>
<li>这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。理论上，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明得将某个实现替换为另一个实现。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Game</span> &#123; <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GameFactory</span> &#123; Game <span class="title function_">getGame</span><span class="params">()</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Checkers</span> <span class="keyword">implements</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">moves</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Checkers move &quot;</span> + moves);</span><br><span class="line">    <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckersFactory</span> <span class="keyword">implements</span> <span class="title class_">GameFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Game <span class="title function_">getGame</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Checkers</span>(); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chess</span> <span class="keyword">implements</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">moves</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVES</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Chess move &quot;</span> + moves);</span><br><span class="line">    <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChessFactory</span> <span class="keyword">implements</span> <span class="title class_">GameFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Game <span class="title function_">getGame</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Chess</span>(); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Games</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">(GameFactory factory)</span> &#123;</span><br><span class="line">    <span class="type">Game</span> <span class="variable">s</span> <span class="operator">=</span> factory.getGame();</span><br><span class="line">    <span class="keyword">while</span>(s.move())</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    playGame(<span class="keyword">new</span> <span class="title class_">CheckersFactory</span>());</span><br><span class="line">    playGame(<span class="keyword">new</span> <span class="title class_">ChessFactory</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Checkers move 0</span></span><br><span class="line"><span class="comment">Checkers move 1</span></span><br><span class="line"><span class="comment">Checkers move 2</span></span><br><span class="line"><span class="comment">Chess move 0</span></span><br><span class="line"><span class="comment">Chess move 1</span></span><br><span class="line"><span class="comment">Chess move 2</span></span><br><span class="line"><span class="comment">Chess move 3</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第十章：内部类"><a href="#第十章：内部类" class="headerlink" title="第十章：内部类"></a>第十章：内部类</h2><blockquote>
<ul>
<li><p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。</p>
</li>
<li><p>值得注意的是内部类与组合（将一个类引用作为另一个类的数据成员）是完全不同的概念。</p>
</li>
<li><p>内部类它还了解外围类，并能与之通信。</p>
</li>
</ul>
</blockquote>
<h3 id="10-1-创建内部类"><a href="#10-1-创建内部类" class="headerlink" title="10.1 创建内部类"></a>10.1 创建内部类</h3><blockquote>
<ul>
<li><p>创建内部类的方式：将类的定义至于外围类的里面</p>
</li>
<li><p>从外围类的非静态方法中创建内部类的方式如ship()方法中这样</p>
</li>
<li><p>而如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么就必须像在main()方法中一样，具体地致命这个对象的类型：OuterClassName.InnerClassName</p>
</li>
<li><p>在某种典型情况下，外部类中会有方法返回一个指向内部类的引用，就像在to()和contents()方法中看到的那样。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color='red'>细节</font>：<ol>
<li>编译器在对含有内部类的文件进行编译时，并不会产生内部类的.java</li>
<li>可以用内部类中的类名称作为另外一个新的外部类的名称。<ol>
<li>在这种情况下创建对象时需要指明。</li>
</ol>
</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel2</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    Destination(String whereTo) &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Destination <span class="title function_">to</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ship</span><span class="params">(String dest)</span> &#123;</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> contents();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> to(dest);</span><br><span class="line">    System.out.println(d.readLabel());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel2</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel2</span>();</span><br><span class="line">    p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    <span class="type">Parcel2</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel2</span>();</span><br><span class="line">    <span class="comment">// Defining references to inner classes:</span></span><br><span class="line">    Parcel2.<span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> q.contents();</span><br><span class="line">    <span class="comment">//下面这种写法也可以</span></span><br><span class="line">    <span class="comment">//Contents c = q.contents();</span></span><br><span class="line">    Parcel2.<span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> q.to(<span class="string">&quot;Borneo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="10-2-链接到外部类"><a href="#10-2-链接到外部类" class="headerlink" title="10.2 链接到外部类"></a>10.2 链接到外部类</h3><blockquote>
<ul>
<li>当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，<font color='red'>所以它能访问其外围对象的所有成员（成员变量和成员方法），而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。</font></li>
<li>原理：<ul>
<li>当某个外围类的对象创建了一个内部类的对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后在访问此外围类的成员时，就是用那个引用来选择外围类的成员。</li>
</ul>
</li>
<li>细节：在内部类是非static类时，内部类的对象只能在与其外围类的对象相关联的情况下才能被创建。构建内部类对象时，需要一个指向其外围类对象的引用，如果没有编译器就会报错。</li>
</ul>
</blockquote>
<h3 id="10-3-使用-this与-new"><a href="#10-3-使用-this与-new" class="headerlink" title="10.3 使用.this与.new"></a>10.3 使用.this与.new</h3><blockquote>
<ul>
<li><font color='red'>.this用法</font>：如果你需要在内部类中生成对外部类对象的引用，可以使用外部类的名字紧跟圆点和this。这样产生的引用自动地具有正确的类型。</li>
<li>如果是一般的this的话，访问的则是内部类的this</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotThis</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> DotThis <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> DotThis.<span class="built_in">this</span>;</span><br><span class="line">      <span class="comment">// A plain &quot;this&quot; would be Inner&#x27;s &quot;this&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Inner <span class="title function_">inner</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DotThis</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DotThis</span>();</span><br><span class="line">    DotThis.<span class="type">Inner</span> <span class="variable">dti</span> <span class="operator">=</span> dt.inner();</span><br><span class="line">    <span class="comment">//DotThis.Inner dti = dt。new Inner();  这是使用.new的方式获取内部类对象</span></span><br><span class="line">    dti.outer().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DotThis.f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>.new用法：有时可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用。如下面所示</li>
<li>因此在有了该种用法之后，就可以在外部类中不用提供返回内部类引用的方法获取到内部类对象。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotNew</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DotNew</span> <span class="variable">dn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DotNew</span>();</span><br><span class="line">    DotNew.<span class="type">Inner</span> <span class="variable">dni</span> <span class="operator">=</span> dn.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<h3 id="10-4-内部类和向上转型"><a href="#10-4-内部类和向上转型" class="headerlink" title="10.4 内部类和向上转型"></a>10.4 内部类和向上转型</h3><blockquote>
<p>在外围类中，可以通过内部类中的对象引用来访问内部类中的private成员变量和成员方法</p>
</blockquote>
<h3 id="10-5-在方法和作用域内的内部类"><a href="#10-5-在方法和作用域内的内部类" class="headerlink" title="10.5 在方法和作用域内的内部类"></a>10.5 在方法和作用域内的内部类</h3><blockquote>
<ol>
<li>一个定义在方法中的类</li>
<li>一个定义在作用域内的类，此作用域在方法的内部</li>
<li>一个实现了接口的匿名类</li>
<li>一个匿名类，它扩展了有非默认构造器的类</li>
<li>一个匿名类，它执行字段初始化</li>
<li>一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）</li>
</ol>
</blockquote>
<blockquote>
<p>案例1：一个定义在方法中的类，这又被称作局部内部类。PDestination该类是destination（）方法中的一部分，而不是Parcel5的一部分，所以在destination（）之外不能访问PDestination。值得注意的是，虽然在destination（）方法中定义了内部类，但并不意味者该方法执行完毕，方法里的内部类就不可用了。</p>
<p>&#x3D;&#x3D;细节：局部内部类不允许用public修饰&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel5</span> &#123;</span><br><span class="line">    <span class="comment">//这是一个方法</span></span><br><span class="line">  <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    	<span class="comment">//定义在方法中的类</span></span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">PDestination</span> <span class="keyword">implements</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> String label;</span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">PDestination</span><span class="params">(String whereTo)</span> &#123;</span><br><span class="line">        label = whereTo;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PDestination</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel5</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel5</span>();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    <span class="comment">//可以调用readLabel()方法，如果PDestination覆盖了该方法，执行时会执行PDestination中的方法体</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例2：当定义在作用域内时，如if(){一个内部类定义}。在作用域之外定义内部类，会编译出错</p>
<p>&#x3D;&#x3D;细节：作用域内部类不允许用public修饰&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>通过下面这个案例体会一下使用内部类的用处</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer5</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inner</span> <span class="keyword">implements</span> <span class="title class_">SimpleInterface</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;Outer5.Inner.f&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> SimpleInterface <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line"> <span class="keyword">public</span> Inner <span class="title function_">get2</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E11_HiddenInnerClass</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"> <span class="type">Outer5</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer5</span>();</span><br><span class="line"> <span class="type">SimpleInterface</span> <span class="variable">si</span> <span class="operator">=</span> out.get();</span><br><span class="line"> si = out.get2();</span><br><span class="line"> <span class="comment">// Won&#x27;t compile -- &#x27;Inner&#x27; not visible:</span></span><br><span class="line"> <span class="comment">//! Inner i1 = out.get2();</span></span><br><span class="line"> <span class="comment">//! Inner i2 = (Inner)si;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">///:~ </span></span><br></pre></td></tr></table></figure>

<h3 id="10-6-匿名内部类"><a href="#10-6-匿名内部类" class="headerlink" title="10.6 匿名内部类"></a>10.6 匿名内部类</h3><blockquote>
<p>语法：创建一个继承自Contents的匿名类的对象，通过new表达式返回的引用被自动向上转型为对Contents的引用。</p>
<p>案例3：一个匿名内部类</p>
</blockquote>
<p>&#x3D;&#x3D;简化形式：&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel7</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contents</span>() &#123; <span class="comment">// Insert a class definition</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;; <span class="comment">// Semicolon required in this case</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel7</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel7</span>();</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> p.contents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;上述匿名内部类的语法是下述形式的简化形式&#x3D;&#x3D;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel7b</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MyContents</span> <span class="keyword">implements</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyContents</span>(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel7b</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel7b</span>();</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> p.contents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例4：扩展了非默认构造器的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapping</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Wrapping</span><span class="params">(<span class="type">int</span> x)</span> &#123; i = x; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel8</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Wrapping <span class="title function_">wrapping</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// Base constructor call:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wrapping</span>(x) &#123; <span class="comment">// Pass constructor argument.</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;; <span class="comment">// Semicolon required</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel8</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel8</span>();</span><br><span class="line">    <span class="type">Wrapping</span> <span class="variable">w</span> <span class="operator">=</span> p.wrapping(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在匿名类中定义字段时，还能够对其执行初始化动作</p>
</blockquote>
<blockquote>
<p><font color='red'>细节：如果定义了一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用时final修饰的就像在destination()的参数中看到的那样。</font></p>
<p>案例5：一个匿名内部类，字段初始化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel9</span> &#123;</span><br><span class="line">  <span class="comment">// Argument must be final to use inside</span></span><br><span class="line">  <span class="comment">// anonymous inner class:</span></span><br><span class="line">  <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(<span class="keyword">final</span> String dest)</span> &#123;  <span class="comment">//参数必须要求是final的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> dest;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel9</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel9</span>();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在此例中，不要求变量i一定是final的，因为i被传递给匿名类的基类的构造器，他并不会在匿名类内部被直接使用。(注意这个例子和上面那个用了final的例子做一个比较)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Base constructor, i = &quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title function_">getBase</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Base</span>(i) &#123;</span><br><span class="line">      &#123; print(<span class="string">&quot;Inside instance initializer&quot;</span>); &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;In anonymous f()&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> getBase(<span class="number">47</span>);</span><br><span class="line">    base.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Base constructor, i = 47</span></span><br><span class="line"><span class="comment">Inside instance initializer</span></span><br><span class="line"><span class="comment">In anonymous f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例6：一个匿名内部类，实例初始化</p>
<p>对于匿名内部类来说，实例初始化的实际效果就是构造器。当然它也受到了限制，不能重载实例初始化方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel10</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Destination</span><br><span class="line">  <span class="title function_">destination</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="type">float</span> price)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> cost;</span><br><span class="line">      <span class="comment">// Instance initialization for each object:</span></span><br><span class="line">      <span class="comment">//实例初始化对象</span></span><br><span class="line">      &#123;  </span><br><span class="line">        cost = Math.round(price);</span><br><span class="line">        <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</span><br><span class="line">          System.out.println(<span class="string">&quot;Over budget!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> dest;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Parcel10</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel10</span>();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>, <span class="number">101.395F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Over budget!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;细节：&#x3D;&#x3D;匿名内部类与正规的继承相比有些受限，因为匿名内部类即可以扩展类，也可以实现接口，但是不能两者兼备，而且如果是实现接口，也只能实现一个接口。</p>
</blockquote>
<blockquote>
<ul>
<li>优先使用类而不是接口</li>
</ul>
</blockquote>
<h3 id="10-7-嵌套类"><a href="#10-7-嵌套类" class="headerlink" title="10.7 嵌套类"></a>10.7 嵌套类</h3><blockquote>
<p>如果不需要内部类对象与其外围类对象之间有联系（即普通的内部类对象隐式的保存了一个引用，指向创建它的外围类对象），那么可以将内部类声明为static.这通常称为嵌套类。</p>
</blockquote>
<blockquote>
<ul>
<li>嵌套类：<ol>
<li>要创建嵌套类的对象，并不需要其外围类的对象</li>
<li>不能从嵌套类的对象中访问非静态的外围类对象</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>嵌套类与普通的内部类的区别：<ol>
<li>普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含有这些东西。</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel11</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParcelContents</span> <span class="keyword">implements</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParcelDestination</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ParcelDestination</span><span class="params">(String whereTo)</span> &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;	</span><br><span class="line">    <span class="comment">// Nested classes can contain other static elements:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnotherLevel</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">      <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title function_">destination</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="comment">//在外围类的静态方法中，可以直接创建嵌套类的对象，这有点类似于在静态方法中调用静态方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ParcelDestination</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ParcelContents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> contents();</span><br><span class="line">    <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节：不论是嵌套类还是普通的内部类，都只会存在与其外围类的.java文件中。但是在编译后，每一个类都会有一个单独的.class文件。</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211213104800721.png" alt="image-20211213104800721"></p>
<blockquote>
<p>接口内部的类：正常情况下，不能在接口内部放置任何代码，但是嵌套类可以作为接口的一部分。放到接口中的类都自动是public和static的，甚至可以在内部类中实现其外围类接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassInInterface</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">howdy</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">ClassInInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">howdy</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Howdy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Test</span>().howdy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Howdy!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节：一个内部类被嵌套多少层并不重要，重要的是它能透明的访问所有它所嵌入的外围类的所有成员。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MNA</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">        g();</span><br><span class="line">        f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiNestingAccess</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MNA</span> <span class="variable">mna</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MNA</span>();</span><br><span class="line">    MNA.<span class="type">A</span> <span class="variable">mnaa</span> <span class="operator">=</span> mna.<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    MNA.A.<span class="type">B</span> <span class="variable">mnaab</span> <span class="operator">=</span> mnaa.<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    mnaab.h();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-8-为什么需要内部类"><a href="#10-8-为什么需要内部类" class="headerlink" title="10.8 为什么需要内部类"></a>10.8 为什么需要内部类</h3><blockquote>
<ol>
<li>每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</li>
<li>内部类提供了可以继承多个具体的、或抽象的类的能力，使多重继承的解决方案变得完整。（接口只是解决了部分问题）</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>使用内部类，还可以获得其他一些特性：<ol>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖与外围类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体。</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>闭包与回调</strong></p>
<ul>
<li>闭包：闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。可以看出&#x3D;&#x3D;内部类是面向对象的闭包&#x3D;&#x3D;，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。</li>
<li>回调：回调的价值在于它的灵活性———可以在运行时动态的决定需要调用什么方法。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内部类与控制框架</strong></p>
<ul>
<li>应用程序框架：就是被设计用以解决某类特定问题的一个类或一组类。</li>
</ul>
</blockquote>
<h3 id="10-9-内部类的继承"><a href="#10-9-内部类的继承" class="headerlink" title="10.9 内部类的继承"></a>10.9 内部类的继承</h3><blockquote>
<p>因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，会有点复杂。问题在于，那个指向外围类对象的“秘密的”引用必须被初始化，而在导出类中不再存在可连接的默认对象，所以需要使用特殊的语法。</p>
</blockquote>
<blockquote>
<p>这是普通的内部类继承</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner &#123;</span><br><span class="line">  <span class="comment">//! InheritInner() &#123;&#125; // Won&#x27;t compile</span></span><br><span class="line">  InheritInner(WithInner wi) &#123;</span><br><span class="line">    wi.<span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">WithInner</span> <span class="variable">wi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">    <span class="type">InheritInner</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是静态内部类的继承方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner &#123;</span><br><span class="line">  InheritInner() &#123;</span><br><span class="line">      <span class="comment">//直接使用super()就可</span></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">WithInner</span> <span class="variable">wi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">    <span class="type">InheritInner</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-10-内部类可以被覆盖吗"><a href="#10-10-内部类可以被覆盖吗" class="headerlink" title="10.10 内部类可以被覆盖吗"></a>10.10 内部类可以被覆盖吗</h3><blockquote>
<p>当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化，&#x3D;&#x3D;这两个内部类是完全独立的两个实体，各自在自己的命名空间内&#x3D;&#x3D;。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Egg</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Yolk y;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;Egg.Yolk()&quot;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">    y = <span class="keyword">new</span> <span class="title class_">Yolk</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEgg</span> <span class="keyword">extends</span> <span class="title class_">Egg</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;BigEgg.Yolk()&quot;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BigEgg</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">New Egg()</span></span><br><span class="line"><span class="comment">Egg.Yolk()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是如果明确地继承某个内部类是可以的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Egg2</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;Egg2.Yolk()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;Egg2.Yolk.f()&quot;</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Yolk</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yolk</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Egg2</span><span class="params">()</span> &#123; print(<span class="string">&quot;New Egg2()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertYolk</span><span class="params">(Yolk yy)</span> &#123; y = yy; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123; y.f(); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEgg2</span> <span class="keyword">extends</span> <span class="title class_">Egg2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> <span class="keyword">extends</span> <span class="title class_">Egg2</span>.Yolk &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123; print(<span class="string">&quot;BigEgg2.Yolk()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; print(<span class="string">&quot;BigEgg2.Yolk.f()&quot;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BigEgg2</span><span class="params">()</span> &#123; insertYolk(<span class="keyword">new</span> <span class="title class_">Yolk</span>()); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Egg2</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigEgg2</span>();</span><br><span class="line">    e2.g();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Egg2.Yolk()</span></span><br><span class="line"><span class="comment">New Egg2()</span></span><br><span class="line"><span class="comment">Egg2.Yolk()</span></span><br><span class="line"><span class="comment">BigEgg2.Yolk()</span></span><br><span class="line"><span class="comment">BigEgg2.Yolk.f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="10-11-局部内部类"><a href="#10-11-局部内部类" class="headerlink" title="10.11 局部内部类"></a>10.11 局部内部类</h3><blockquote>
<ul>
<li>可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为他不是外围类的一部分；但是<font color='red'>它可以访问当前代码块内的常量，以及此外围类的所有成员</font>。</li>
<li>使用局部类而不使用匿名内部类的情况：<ol>
<li>我们需要一个命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例化。</li>
<li>另外一个就是需要不止一个该内部类的对象。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="10-12-内部类标识符"><a href="#10-12-内部类标识符" class="headerlink" title="10.12 内部类标识符"></a>10.12 内部类标识符</h3><blockquote>
<ul>
<li><p>每个类都会产生一个.class文件，内部类也必须生成一个.class文件以包含他们的Class对象信息。这些类文件的命名有严格的规则，外围类的名字，加上“$”,再加上内部类的名字。</p>
</li>
<li><p>如果内部类是匿名的，编译器会简单的生成一个数字作为其标识符。 LocalInnerClass&amp;1.class</p>
</li>
<li><p>如果内部类是嵌套在别的内部类之中，只需将他们的名字加在其外围标识符与“$”的后面 LocalInnerClass$1LocalCounter.class</p>
</li>
</ul>
<p>如：Counter.class</p>
<p>​		LocalInnerClass&amp;1.class</p>
<p>​		LocalInnerClass$1LocalCounter.class</p>
<p>​		LocalInnerClass.class</p>
</blockquote>
<h2 id="第十一章：持有对象"><a href="#第十一章：持有对象" class="headerlink" title="第十一章：持有对象"></a>第十一章：持有对象</h2><blockquote>
<p>List,Set,Queue都继承自Collection.注意，&#x3D;&#x3D;map并不是继承自Collection接口&#x3D;&#x3D;</p>
</blockquote>
<h3 id="11-4-容器的打印"><a href="#11-4-容器的打印" class="headerlink" title="11.4 容器的打印"></a>11.4 容器的打印</h3><blockquote>
<p>对于一个数组，我们必须要使用Arrays.toString()来产生数组的可打印表示，但是打印容器无需任何帮助。</p>
</blockquote>
<blockquote>
<p>Collection打印出来的内容用方括号括住，每个元素用逗号隔开。Map则用大括号括住，键与值由等号联系。</p>
</blockquote>
<p><img src="C:\Users\helloworld\Desktop\java.png" alt="java"></p>
<h3 id="11-5-List"><a href="#11-5-List" class="headerlink" title="11.5 List"></a>11.5 List</h3><blockquote>
<ul>
<li>add()、get()</li>
<li>subList()方法：subList()所产生的列表的幕后就是初始列表，&#x3D;&#x3D;因此对所返回的列表的修改都会反映到初始列表中，反之亦然。。&#x3D;&#x3D;</li>
<li>retainAll()方法：是一种有效的交集操作。</li>
</ul>
</blockquote>
<h3 id="11-6-迭代器"><a href="#11-6-迭代器" class="headerlink" title="11.6 迭代器"></a>11.6 迭代器</h3><blockquote>
<p>引入：如果原本是对着List编码的，但是后来发现如果能够把相同的代码应用于Set，将会显得非常方便，如何能保证不重写代码就可以应用于不同类型的容器？</p>
</blockquote>
<blockquote>
<p>迭代器（也是一种设计模式）可以用于完成此目的。迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代器是一个轻量级对象：创建它的代价小。</p>
<ul>
<li><p>下标是从0开始的。</p>
</li>
<li><p>Java中的Iterator只能单向移动。这个Iterator只能用来：</p>
<ol>
<li>使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。</li>
<li>使用next()获得序列中的下一个元素。</li>
<li>使用hasNext()检查序列中是否还有元素。</li>
<li>使用remove()将迭代器新近返回的元素删除。（删除最近一次next()返回的元素）</li>
</ol>
</li>
<li><p>对迭代器进行修改的操作，最终也会导致原始容器内容的修改</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">//注意这里必须要求是ArrayList的对象，</span></span><br><span class="line">    List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//获取到该容器的迭代器</span></span><br><span class="line">    Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// A simpler approach, when possible:</span></span><br><span class="line">    <span class="keyword">for</span>(Pet p : pets)</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();	</span><br><span class="line">    <span class="comment">// An Iterator can also remove elements:</span></span><br><span class="line">    it = pets.iterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">        <span class="comment">//在调用remove方法之前，必须调用next()</span></span><br><span class="line">      it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Iterator的真正威力：能够将遍历序列的操作与序列底层的结构分离，正由于此，我们有时会说：迭代器同意了对容器的访问方式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossContainerIteration</span> &#123;</span><br><span class="line">    <span class="comment">//这里才是真正体现迭代器的威力</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Pet&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Pet&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Pet&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>ListIterator</strong></p>
<blockquote>
<p>ListIterator是一个更加强大的Iterator的子类型，<font color='red'>它只能用于各种List类的访问</font>。尽管Iterator只能向前移动，但是ListIterator可以双向移动。它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后元素。你可以通过调用listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就只想列表索引为n的元素处的ListIterator.</p>
<ul>
<li>set()方法也是修改最近一次next()或者previous()返回的方法。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">    ListIterator&lt;Pet&gt; it = pets.listIterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">      System.out.print(it.next() + <span class="string">&quot;, &quot;</span> + it.nextIndex() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.previousIndex() + <span class="string">&quot;; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// Backwards:</span></span><br><span class="line">    <span class="keyword">while</span>(it.hasPrevious())</span><br><span class="line">      System.out.print(it.previous().id() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(pets);	</span><br><span class="line">    it = pets.listIterator(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.set(Pets.randomPet());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;</span></span><br><span class="line"><span class="comment">7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="11-7-LinkedList"><a href="#11-7-LinkedList" class="headerlink" title="11.7 LinkedList"></a>11.7 LinkedList</h3><blockquote>
<p>可以使用LinkedList实现队列，栈或双端队列等结构</p>
</blockquote>
<h3 id="11-9-Set"><a href="#11-9-Set" class="headerlink" title="11.9  Set"></a>11.9  Set</h3><blockquote>
<ul>
<li>HashSet：快速查找，插入的顺序没有规律，使用的是散列函数</li>
<li>TreeSet：按照插入的元素升序排序，使用的是红-黑树数据结构 <ul>
<li>TreeSet继承自SortedSet。而SortedSet继承自Set</li>
</ul>
</li>
<li>LinkedHashSet：按照插入元素的顺序排序，查询速度也很快，所以也使用了散列。（继承自HashSet）</li>
</ul>
</blockquote>
<h3 id="11-12-Collection和Iterator"><a href="#11-12-Collection和Iterator" class="headerlink" title="11.12 Collection和Iterator"></a>11.12 Collection和Iterator</h3><blockquote>
<p>实现了Collection接口的类，具备了iterator()方法，所以就也需要提供Iterator的特性。</p>
<ul>
<li>当要实现一个不是Collection的外部类时，由于让它去实现Collection接口非常麻烦，因为要实现很多可能不必要的方法。，此时实现Iterator接口就非常有吸引力。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PetSequence</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> Pet[] pets = Pets.createArray(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonCollectionSequence</span> <span class="keyword">extends</span> <span class="title class_">PetSequence</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;Pet&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Pet&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; pets.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> Pet <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> pets[index++]; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">NonCollectionSequence</span> <span class="variable">nc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonCollectionSequence</span>();</span><br><span class="line">    InterfaceVsIterator.display(nc.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="11-13-foreach与迭代器"><a href="#11-13-foreach与迭代器" class="headerlink" title="11.13 foreach与迭代器"></a>11.13 foreach与迭代器</h3><blockquote>
<p>foreach语法不仅可以用于数组，还可以应用于所有的Collection对象，因为这些对象都实现了Iterable接口，该接口包含一个能够产生Iterator的iterator()方法，并且Iterator接口被foreach用来在序列中移动了。因此如果创建了任何实现Iterable的类，都可以将它用于foreach语句。</p>
<ul>
<li>&#x3D;&#x3D;细节：&#x3D;&#x3D;<ol>
<li>实现了Iterable接口的类就具备了foreach的能力</li>
<li>而实现Iterable接口，就需要实现提供I能够产生terator引用的iterator()方法</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IterableClass</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> String[] words = (<span class="string">&quot;And that is how &quot;</span> +</span><br><span class="line">    <span class="string">&quot;we know the Earth to be banana-shaped.&quot;</span>).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;String&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;String&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; words.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> words[index++]; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="keyword">new</span> <span class="title class_">IterableClass</span>())</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">And that is how we know the Earth to be banana-shaped.</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>能够用于foreach的不一定就都实现了Iterable接口，比如普通数组，就不能将一个数组对象传给Iterable接口引用。而必须通过显示转换。</p>
</blockquote>
<blockquote>
<p>Arrays.asList()方法：该方法产生的List对象会使用底层数组作为其物理实现，因此执行修改List的操作就也会修改原有的底层数组。所以如果不想原来的数组被修改，那么就应该在另一个副本中创建一个副本。</p>
<p>如：List<Integer> list&#x3D;new ArrayList(Arrays.asList(arr));此时对list内容的修改，不会影响到数组arr的内容。</p>
<p>​		List<Integer> list&#x3D;Arrays.asList(arr); 此时对list内容的修改也会影响到数组arr的内容。</p>
</blockquote>
<h2 id="第十二章：通过异常处理错误"><a href="#第十二章：通过异常处理错误" class="headerlink" title="第十二章：通过异常处理错误"></a>第十二章：通过异常处理错误</h2><h3 id="12-2-基本异常"><a href="#12-2-基本异常" class="headerlink" title="12.2 基本异常"></a>12.2 基本异常</h3><blockquote>
<ul>
<li>所有标准异常类都有两个构造器：一个是默认构造器，另一个是接受字符串参数作为参数，以便能把相关信息放入异常对象的构造器。</li>
<li>能够抛出任意类型的Throwable对象，它是异常类型的跟类。</li>
</ul>
</blockquote>
<h3 id="12-3-捕获异常"><a href="#12-3-捕获异常" class="headerlink" title="12.3 捕获异常"></a>12.3 捕获异常</h3><blockquote>
<ul>
<li><p>注意：在try块的内部，可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。</p>
</li>
<li><p>当用catch语句要捕获多个异常时，异常类型的父类（如Exception）要放在异常类型的子类（NullPointerException）后面进行捕获，否则会编译出错。</p>
</li>
</ul>
</blockquote>
<h3 id="12-4-创建自定义异常"><a href="#12-4-创建自定义异常" class="headerlink" title="12.4 创建自定义异常"></a>12.4 创建自定义异常</h3><blockquote>
<ul>
<li>要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。建立新的异常类型最简单的方法就是让编译器为你产生默认构造器。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己定义一个新的异常类型，继承自已有的异常类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritingExceptions</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> SimpleException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throw SimpleException from f()&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SimpleException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">InheritingExceptions</span> <span class="variable">sed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritingExceptions</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      sed.f();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SimpleException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Caught it!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Throw SimpleException from f()</span></span><br><span class="line"><span class="comment">Caught it!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">  <span class="comment">//继承了现有的机场类，并且定义了两个构造器方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span> &#123; <span class="built_in">super</span>(msg); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FullConstructors</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throwing MyException from f()&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throwing MyException from g()&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;Originated in g()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      f();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(MyException e) &#123;</span><br><span class="line">      e.printStackTrace(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      g();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(MyException e) &#123;</span><br><span class="line">      e.printStackTrace(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Throwing MyException from f()</span></span><br><span class="line"><span class="comment">MyException</span></span><br><span class="line"><span class="comment">        at FullConstructors.f(FullConstructors.java:11)</span></span><br><span class="line"><span class="comment">        at FullConstructors.main(FullConstructors.java:19)</span></span><br><span class="line"><span class="comment">Throwing MyException from g()</span></span><br><span class="line"><span class="comment">MyException: Originated in g()</span></span><br><span class="line"><span class="comment">        at FullConstructors.g(FullConstructors.java:15)</span></span><br><span class="line"><span class="comment">        at FullConstructors.main(FullConstructors.java:24)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>e1.printStackTrace(System.out); 在异常处理程序中，调用了子啊Throwable类声明（Exception即从此类继承）的printStackTrace()方法。他将打印“从方法调用处直到异常抛出处”的方法调用序列。这里信息就被发送到了System.out,并自动地捕获和显示在输出中。</li>
<li>但是如果调用默认版本：e1.printStackTrace();则信息将被输出到标准错误流。</li>
</ul>
</blockquote>
<p><strong>#这是默认的打印版本：</strong></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211216161902399.png" alt="image-20211216161902399"></p>
<p>#这是使用了System.out的方式</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211216162030348.png" alt="image-20211216162030348"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">NullPointerException</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestError</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test fun()&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TestError ts=<span class="keyword">new</span> <span class="title class_">TestError</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ts.fun();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MyException e1)&#123;</span><br><span class="line">            <span class="comment">//使用与不使用System.out的输出结果在上面</span></span><br><span class="line">            e1.printStackTrace(System.out);</span><br><span class="line">            System.out.println(<span class="string">&quot;进来没&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于异常类来说，Throwable类的getMessage()方法有点类似于toString()方法，所以当在定义完自己的异常类之后，可以对继承的Throwable类或者其子类中一些方法进行覆盖。</p>
</blockquote>
<h3 id="12-5-异常说明"><a href="#12-5-异常说明" class="headerlink" title="12.5 异常说明"></a>12.5 异常说明</h3><blockquote>
<p>异常说明：就是以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行响应的处理。属于方法声明的一部分，紧跟在形式参数列表之后。</p>
<ul>
<li>异常说明使用了附加的关键字throws，后面借一个所有潜在异常类型的列表。</li>
<li>形式如：void fun(int x1,…) throws 异常1，异常2{方法体内容}</li>
<li><font color='red'>细节：运行时异常（RuntimeException）可以不用显示声明（即用throws说明），或者catch也可以。而其他异常则必须进行异常说明或者进行捕获catch</font></li>
<li>可以声明方法将抛出异常，但是方法体内并不抛出异常（非运行时异常），此时会强制使用该方法的用户要像真的抛出异常那样使用这个方法（如必须对该声明的异常进行处理，要么抛出，要么捕获）</li>
</ul>
</blockquote>
<h3 id="12-6-捕获所有异常"><a href="#12-6-捕获所有异常" class="headerlink" title="12.6 捕获所有异常"></a>12.6 捕获所有异常</h3><blockquote>
<p>可以使用抛出异常的基类来进行捕获，这样就不用每一个都要进行捕获了，但是捕获基类的语句要写在导出类的后面，否则会出错。</p>
</blockquote>
<blockquote>
<p>printStackTrace()方法：这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一帧。细节：main()方法总是第一个进栈，所以在输出时就处于最后一个。(栈是先进后出结构)</p>
</blockquote>
<p><strong>重新抛出异常</strong></p>
<blockquote>
<ul>
<li><p>如果只是把当前异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。要想更新这个信息，可以调用fillInStackTrace()方法，这将返回一个Throwable对象。它是通过把当前调用栈信息填入原来那个异常对象而建立的。那么有关原来异常发生点的信息会丢失，剩下的是与新的抛出点有关的信息。</p>
</li>
<li><p>有可能在捕获异常之后抛出另一种异常，这么做的话，得到的效果类似于使用fillInStackTrace()，有关原来异发生点的信息将会丢失，剩下的是与新的抛出点有关的信息。</p>
</li>
</ul>
</blockquote>
<h3 id="12-7-Java标准异常"><a href="#12-7-Java标准异常" class="headerlink" title="12.7 Java标准异常"></a>12.7 Java标准异常</h3><blockquote>
<ul>
<li>Throwable这个Java类表示任何可以作为异常抛出的类。Throwable对象分为两种类型（指从Throwable继承而得到的类型）：Error(用来表示编译时和系统错误，除特殊情况外，一般不用关心)，Exception(是可以被抛出的基本类型)。而Exception又主要分为运行时异常（RuntimeException）和非运行时异常。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>运行时异常：他们会自动被虚拟机抛出，所以不必在异常说明中把他们列出来。他们也被称为不受检查异常。而其他类型的异常（非运行时异常）的异常处理是由编译器强制实施的。</li>
<li>如果运行时异常没有被捕获而直达main()，那么在程序退出前将调用异常的printStackTrace()方法</li>
</ul>
</blockquote>
<blockquote>
<p>运行时异常主要常见的有：NullPointerException。ArrayIndexOutofBoundsException。</p>
</blockquote>
<h3 id="12-8-用finally进行清理"><a href="#12-8-用finally进行清理" class="headerlink" title="12.8 用finally进行清理"></a>12.8 用finally进行清理</h3><p><strong>finally用来做什么</strong></p>
<blockquote>
<p>当要把除内存之外的资源恢复到他们的初始状态，就要用到finally子句。这种需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关</p>
</blockquote>
<blockquote>
<p>细节：当涉及到break和continue语句的时候，finally子句也会得到执行。</p>
</blockquote>
<p>在return中使用finally</p>
<blockquote>
<ul>
<li>因为finally子句总是会被执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。(&#x3D;&#x3D;finally语句总是会在return语句执行前就执行了&#x3D;&#x3D;)</li>
</ul>
</blockquote>
<blockquote>
<p>缺憾：异常丢失</p>
<ul>
<li>当有多层try块时，如果提前在finally块中执行了return语句的话，则在后面的catch语句就得不到执行，但应该注意的是后面的finally块仍然会被执行。</li>
</ul>
</blockquote>
<blockquote>
<p>细节：如果在finally语句中存在return语句，那么该方法后面的语句就都得不到调用，所以如果有，编译器就会报错。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test18</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;jjjj&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-9-异常的限制"><a href="#12-9-异常的限制" class="headerlink" title="12.9 异常的限制"></a>12.9 异常的限制</h3><blockquote>
<ul>
<li>当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常（或者父类抛出的异常的子类）。这个限制很重要，因为这意味着，当基类使用的代码应用到其派生类对象的时候，一样能够工作。（这个有点类似于限制覆盖方法时对返回值类型，形参有要求一样）</li>
<li>所以如果基类如果没有抛出异常，子类就也不能抛出异常</li>
</ul>
</blockquote>
<blockquote>
<p>细节：构造器方法也可以抛出异常（异常声明）</p>
<ul>
<li>细节：覆盖方法时对异常的限制，这个限制对构造器不能起作用。因为基类构造器必须以这样或那样的方式被调用（这里默认构造器将自动被调用），</li>
<li>但是派生类构造器的异常说明必须包括基类构造器的异常说明（必须是基类的异常或者其父类，与方法恰好相反）</li>
<li>派生类构造器不能捕获基类构造器抛出的异常。（因为super()语句永远在第一行执行）</li>
<li>所以，在某种意义上，在继承和覆盖的过程中，某个特定方法的异常说明的接口不是变大了而是变小了。这恰好和类接口在继承时的情形相反。</li>
</ul>
</blockquote>
<h3 id="12-10-构造器"><a href="#12-10-构造器" class="headerlink" title="12.10 构造器"></a>12.10 构造器</h3><blockquote>
<p>对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句</p>
<p>&#x3D;&#x3D;基本规则是：在创建要清理的对象之后，立即进入一个try-finally语句块&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cleanup</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputFile</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputFile</span>(<span class="string">&quot;Cleanup.java&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((s = in.getLine()) != <span class="literal">null</span>)</span><br><span class="line">          ; <span class="comment">// Perform line-by-line processing here...</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Caught Exception in main&quot;</span>);</span><br><span class="line">        e.printStackTrace(System.out);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.dispose();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;InputFile construction failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">dispose() successful</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="12-11-异常匹配"><a href="#12-11-异常匹配" class="headerlink" title="12.11 异常匹配"></a>12.11 异常匹配</h3><blockquote>
<ul>
<li><p>抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续寻找。</p>
</li>
<li><p>查找的时候并不要求完全匹配，派生类的对象也可以匹配基类的处理程序。如Exception可以接受RuntimeException的异常</p>
</li>
<li><p>如果把捕获基类的catch子句放在最前面，以此想把派生类的异常全给屏蔽掉，编译器会报错。</p>
</li>
</ul>
</blockquote>
<h3 id="12-12-其他可选方式"><a href="#12-12-其他可选方式" class="headerlink" title="12.12 其他可选方式"></a>12.12 其他可选方式</h3><blockquote>
<p>异常处理的一个重要原则是：只有在知道如何处理的情况下才捕获异常。</p>
</blockquote>
<h2 id="第十三章：字符串"><a href="#第十三章：字符串" class="headerlink" title="第十三章：字符串"></a>第十三章：字符串</h2><h3 id="13-2-重载“-”与StringBuilder"><a href="#13-2-重载“-”与StringBuilder" class="headerlink" title="13.2 重载“+”与StringBuilder"></a>13.2 重载“+”与StringBuilder</h3><blockquote>
<ul>
<li>String字符串在进行拼接时，实际上内部还是创建StringBuilder对象，调用该对象方法。</li>
<li>因此如果在进行频繁的拼接操作时，可以显式创建一个StringBuilder对象，这样减少了创建对象的过程以及利用垃圾回收机制回收中间对象的过程。</li>
<li>细节：StringBuilder是在jdk5引入的，之前用的是StringBuffer,后者是线程安全的，因此开销也会大些。</li>
</ul>
</blockquote>
<h3 id="13-5格式化输出"><a href="#13-5格式化输出" class="headerlink" title="13.5格式化输出"></a>13.5格式化输出</h3><blockquote>
<ul>
<li>format()方法与printf()是等价的，它们只需要一个简单的格式化字符串，加上一串参数即可，每个参数对应一个格式修饰符。</li>
<li>format()方法可以用于PrintStream或PrintWriter对象，其中也包括System.out对象。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFormat</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5.332542</span>;</span><br><span class="line">    <span class="comment">// The old way:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Row 1: [&quot;</span> + x + <span class="string">&quot; &quot;</span> + y + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="comment">// The new way:</span></span><br><span class="line">    System.out.format(<span class="string">&quot;Row 1: [%d %f]\n&quot;</span>, x, y);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;Row 1: [%d %f]\n&quot;</span>, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542]</span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542]</span></span><br><span class="line"><span class="comment">Row 1: [5 5.332542]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>Fomatter类</strong></p>
<blockquote>
<p>在Java中，所有新的格式化功能都由java.util.Formatter类处理。可以将Fomatter看作一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。</p>
</blockquote>
<blockquote>
<p>String.format()方法，以生成格式化的String对象。这是一个static方法，它接受与Formatter.format()方法一样的参数，但返回一个String对象 。</p>
</blockquote>
<h3 id="13-6-正则表达式（需要重点关注）"><a href="#13-6-正则表达式（需要重点关注）" class="headerlink" title="13.6 正则表达式（需要重点关注）"></a>13.6 正则表达式（需要重点关注）</h3><blockquote>
<ul>
<li>在Java中，字符串操作还主要集中于String,StringBuffer和StringTokenizer类，与正则表达式相比，他们只能提供相对简单的功能。</li>
<li>正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索。一旦找到了匹配这些模式的部分，你就能够随心所欲的对他们进行处理。正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题：匹配、选择、编辑以及验证。</li>
</ul>
</blockquote>
<blockquote>
<p>应用正则表达式的最简单的途径，就是利用String类内建的功能。例如，你可以检查一个String是否匹配如上所述的正则表达式：</p>
<ul>
<li>规则：<ul>
<li>-?：表示要找一个数字，它可能有一个负号在最前面</li>
<li>-?\d+：表示“可能有一个负号，后面跟着一位或多位数字”</li>
<li>\\：表示要插入一个普通的反斜杠</li>
<li>\d：表示想表示一个数字</li>
<li>(-|\+)?：表示可能以一个加号或减号开头   （因为+在正则表达式中有特殊的意义，所以必须使用\进行转义，使之成为一个普通字符）</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerMatch</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;-1234&quot;</span>.matches(<span class="string">&quot;-?\\d+&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;5678&quot;</span>.matches(<span class="string">&quot;-?\\d+&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;+911&quot;</span>.matches(<span class="string">&quot;-?\\d+&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;+911&quot;</span>.matches(<span class="string">&quot;(-|\\+)?\\d+&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>String类还自带了一个非常有用的正则表达式工具，split()方法，其功能是将字符串从正则表达式匹配的地方切开。</p>
<ul>
<li>规则：<ul>
<li>\W：他表示是一个非单词字符（如果W小写，\w,则表示一个单词字符）</li>
<li>\W+：他表示是一个或多个非单词字符（如果W小写，\w,则表示一个单词字符）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>String类自带的最后一个正则表达式工具是替换。你可以只替换正则表示式第一个匹配的子串，或是替换所有匹配的地方。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Replacing</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Splitting.knights;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(s.replaceFirst(<span class="string">&quot;f\\w+&quot;</span>, <span class="string">&quot;located&quot;</span>));</span><br><span class="line">    print(s.replaceAll(<span class="string">&quot;shrubbery|tree|herring&quot;</span>,<span class="string">&quot;banana&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Then, when you have located the shrubbery, you must cut down the mightiest tree in the forest... with... a herring!</span></span><br><span class="line"><span class="comment">Then, when you have found the banana, you must cut down the mightiest banana in the forest... with... a banana!</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;Pattern和Matcher&#x3D;&#x3D;</p>
<blockquote>
<p>下面演示了这两个类的用法</p>
<ul>
<li>find()</li>
<li>matches()</li>
<li>start()</li>
<li>end()</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRegularExpression</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      print(<span class="string">&quot;Usage:\njava TestRegularExpression &quot;</span> +</span><br><span class="line">        <span class="string">&quot;characterSequence regularExpression+&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Input: \&quot;&quot;</span> + args[<span class="number">0</span>] + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String arg : args) &#123;</span><br><span class="line">      print(<span class="string">&quot;Regular expression: \&quot;&quot;</span> + arg + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(arg);</span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(args[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">        print(<span class="string">&quot;Match \&quot;&quot;</span> + m.group() + <span class="string">&quot;\&quot; at positions &quot;</span> +</span><br><span class="line">          m.start() + <span class="string">&quot;-&quot;</span> + (m.end() - <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Input: &quot;abcabcabcdefabc&quot;</span></span><br><span class="line"><span class="comment">Regular expression: &quot;abcabcabcdefabc&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abcabcabcdefabc&quot; at positions 0-14</span></span><br><span class="line"><span class="comment">Regular expression: &quot;abc+&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 0-2</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 3-5</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 6-8</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 12-14</span></span><br><span class="line"><span class="comment">Regular expression: &quot;(abc)+&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abcabcabc&quot; at positions 0-8</span></span><br><span class="line"><span class="comment">Match &quot;abc&quot; at positions 12-14</span></span><br><span class="line"><span class="comment">Regular expression: &quot;(abc)&#123;2,&#125;&quot;</span></span><br><span class="line"><span class="comment">Match &quot;abcabcabc&quot; at positions 0-8</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第十四章：类型信息"><a href="#第十四章：类型信息" class="headerlink" title="第十四章：类型信息"></a>第十四章：类型信息</h2><blockquote>
<p><strong>运行时类型信息使得你可以在程序运行时发现和使用类型信息</strong></p>
<ul>
<li>Java是如何让我们在运行时识别对象和类的信息的。主要有两种方式：<ol>
<li>传统的RTTI,他假定我们在编译时已经知道了所有的类型。</li>
<li>另一种是反射机制，它允许我们在运行时发现和使用类的信息</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="14-2-Class对象"><a href="#14-2-Class对象" class="headerlink" title="14.2 Class对象"></a>14.2 Class对象</h3><blockquote>
<p>要理解RTTI在Java中的工作原理，首先需要知道类型信息在运行时是如何表示的。这项工作由Class对象的特殊对象来完成，它包含了与类有关的信息。Class对象就是用来创建类的所有的常规对象的。Java使用Class对象来执行其RTTI.Class类拥有大量的使用RTTI的其他方式。</p>
</blockquote>
<blockquote>
<p>使用Class.forName()来获取到某个类的Class对象的引用</p>
<p>细节：这里name是要用到带上包名的如javase.Hello,即使用全限定类名（包含包名）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;jinlaile&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;javase.Hello&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;没有发现&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(c.getName());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果已经拥有了该类的对象，则可以通过调用继承自Object类中的getClass()方法来获取该Class对象。</p>
</blockquote>
<blockquote>
<p>getInterfaces()：确定由该对象表示的类或接口实现的接口。</p>
<p>getSuperclass()：返回 <code>类</code>表示此所表示的实体（类，接口，基本类型或void）的超类 <code>类</code></p>
<p>getSimpleName()：来产生不包含包名的类名</p>
<p>getCanonicalName()：来产生全限定类名（包含包名）</p>
<p>newInstance()：是实现虚拟构造器的一种途径。可以不用new创建对象的一种方式。（该类必须有默认构造器）</p>
<p>getDeclaredFields()：返回此类或接口上所有的字段类对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HasBatteries</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Waterproof</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shoots</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Toy</span> &#123;</span><br><span class="line">  <span class="comment">// Comment out the following default constructor</span></span><br><span class="line">  <span class="comment">// to see NoSuchMethodError from (*1*)</span></span><br><span class="line">  Toy() &#123;&#125;</span><br><span class="line">  Toy(<span class="type">int</span> i) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FancyToy</span> <span class="keyword">extends</span> <span class="title class_">Toy</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">HasBatteries</span>, Waterproof, Shoots &#123;</span><br><span class="line">  FancyToy() &#123; <span class="built_in">super</span>(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToyTest</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(Class cc)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Class name: &quot;</span> + cc.getName() +</span><br><span class="line">      <span class="string">&quot; is interface? [&quot;</span> + cc.isInterface() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    print(<span class="string">&quot;Simple name: &quot;</span> + cc.getSimpleName());</span><br><span class="line">    print(<span class="string">&quot;Canonical name : &quot;</span> + cc.getCanonicalName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      c = Class.forName(<span class="string">&quot;typeinfo.toys.FancyToy&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Can&#x27;t find FancyToy&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printInfo(c);	</span><br><span class="line">    <span class="keyword">for</span>(Class face : c.getInterfaces())</span><br><span class="line">      printInfo(face);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">up</span> <span class="operator">=</span> c.getSuperclass();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Requires default constructor:</span></span><br><span class="line">      obj = up.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InstantiationException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Cannot instantiate&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalAccessException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Cannot access&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printInfo(obj.getClass());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.FancyToy is interface? [false]</span></span><br><span class="line"><span class="comment">Simple name: FancyToy</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.FancyToy</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.HasBatteries is interface? [true]</span></span><br><span class="line"><span class="comment">Simple name: HasBatteries</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.HasBatteries</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.Waterproof is interface? [true]</span></span><br><span class="line"><span class="comment">Simple name: Waterproof</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.Waterproof</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.Shoots is interface? [true]</span></span><br><span class="line"><span class="comment">Simple name: Shoots</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.Shoots</span></span><br><span class="line"><span class="comment">Class name: typeinfo.toys.Toy is interface? [false]</span></span><br><span class="line"><span class="comment">Simple name: Toy</span></span><br><span class="line"><span class="comment">Canonical name : typeinfo.toys.Toy</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>类字面常量</strong></p>
<p>Java还提供了另一种方法生成对Class对象的引用，即使用类字面常量。将如Person.class;</p>
<ul>
<li><p>好处：</p>
<ul>
<li>这样做更简单，而且更安全，因为它在编译时就会受到检查（不需要使用try-catch进行捕获），并且根除了对forName()方法的调用，所以也更高效。</li>
<li>该常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型，另外对于基本数据类型的包装器类，还有一个标准字段TYPE.TYPE是一个引用，指向对应的基本数据类型的Class对象。</li>
</ul>
</li>
<li><p>细节：当使用.class来创建对Class对象的引用时，不会自动地初始化Class对象。初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行。</p>
</li>
<li><p>为了使用类做的&#x3D;&#x3D;准备工作步骤&#x3D;&#x3D;：</p>
<ol>
<li>加载：这是由类加载器执行的。（类加载器是JVM的一部分）该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个Class对象。</li>
<li>链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并非如果必需的话，将解析这个类创建的对其他类的所有引用。</li>
<li>初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Initable</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">staticFinal</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">staticFinal2</span> <span class="operator">=</span></span><br><span class="line">    ClassInitialization.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Initializing Initable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Initable2</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticNonFinal</span> <span class="operator">=</span> <span class="number">147</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Initializing Initable2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Initable3</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticNonFinal</span> <span class="operator">=</span> <span class="number">74</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Initializing Initable3&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitialization</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">initable</span> <span class="operator">=</span> Initable.class;</span><br><span class="line">    System.out.println(<span class="string">&quot;After creating Initable ref&quot;</span>);</span><br><span class="line">    <span class="comment">// Does not trigger initialization:</span></span><br><span class="line">    System.out.println(Initable.staticFinal);</span><br><span class="line">    <span class="comment">// Does trigger initialization:</span></span><br><span class="line">    System.out.println(Initable.staticFinal2);</span><br><span class="line">    <span class="comment">// Does trigger initialization:</span></span><br><span class="line">    System.out.println(Initable2.staticNonFinal);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">initable3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Initable3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After creating Initable3 ref&quot;</span>);</span><br><span class="line">    System.out.println(Initable3.staticNonFinal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">After creating Initable ref</span></span><br><span class="line"><span class="comment">47</span></span><br><span class="line"><span class="comment">Initializing Initable</span></span><br><span class="line"><span class="comment">258</span></span><br><span class="line"><span class="comment">Initializing Initable2</span></span><br><span class="line"><span class="comment">147</span></span><br><span class="line"><span class="comment">Initializing Initable3</span></span><br><span class="line"><span class="comment">After creating Initable3 ref</span></span><br><span class="line"><span class="comment">74</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Class<T></p>
<p>Class&lt;?&gt;优于平凡的Class,即便它们是等价的。</p>
<p>Class&lt;? extends T&gt;为了创建一个Class引用，它被限定为某种类型，或该类型的任何子类型，你需要将通配符与extends关键字结合，创建一个范围。因此这与仅仅声明Class<Number>不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedClassReferences</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; bounded = <span class="type">int</span>.class;</span><br><span class="line">    bounded = <span class="type">double</span>.class;</span><br><span class="line">    bounded = Number.class;</span><br><span class="line">    <span class="comment">// Or anything else derived from Number.</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//Class&lt;Number&gt; c2=int.class;  //该种方式会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<p>当将泛型语法用于Class对象时，会发生一件有趣的事：newInstance()将返回该对象的确切类型，而不是平凡的Class那样返回的Object.</p>
<p>Class&lt;? extends T&gt;而如果和extends结合了，则返回的则是T.   </p>
</blockquote>
<h3 id="14-3-类型转换前先做检查"><a href="#14-3-类型转换前先做检查" class="headerlink" title="14.3 类型转换前先做检查"></a>14.3 类型转换前先做检查</h3><blockquote>
<p>RTTI在Java中还有第三种形式，就是关键字instanceof,它返回一个布尔值。告诉我们对象是不是某个&#x3D;&#x3D;特定类型&#x3D;&#x3D;的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">	((Dog)x).bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>动态的instanceof.Class.isInstanceof方法提供了一种动态的测试对象的途径。该方法返回<code>true</code>如果指定<code>Object</code>参数为非空并且可以转换为通过此表示的引用类型<code>类</code>对象</p>
</blockquote>
<h3 id="14-5-instanceof与Class的等价性"><a href="#14-5-instanceof与Class的等价性" class="headerlink" title="14.5 instanceof与Class的等价性"></a>14.5 instanceof与Class的等价性</h3><blockquote>
<p>子类对象或引用 instaceof 父类时会返回真</p>
<p>instanceof和isInstance()指的是“你是这个类吗，或者你是这个类的派生类吗”</p>
<p>而equals()和&#x3D;&#x3D;则比较的是实际的Class对象，而没有考虑继承，只是指是这个确切的类型吗或者不是</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FamilyVsExactType</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Testing x of type &quot;</span> + x.getClass());</span><br><span class="line">    print(<span class="string">&quot;x instanceof Base &quot;</span> + (x <span class="keyword">instanceof</span> Base));</span><br><span class="line">    print(<span class="string">&quot;x instanceof Derived &quot;</span>+ (x <span class="keyword">instanceof</span> Derived));</span><br><span class="line">    print(<span class="string">&quot;Base.isInstance(x) &quot;</span>+ Base.class.isInstance(x));</span><br><span class="line">    print(<span class="string">&quot;Derived.isInstance(x) &quot;</span> +</span><br><span class="line">      Derived.class.isInstance(x));</span><br><span class="line">    print(<span class="string">&quot;x.getClass() == Base.class &quot;</span> +</span><br><span class="line">      (x.getClass() == Base.class));</span><br><span class="line">    print(<span class="string">&quot;x.getClass() == Derived.class &quot;</span> +</span><br><span class="line">      (x.getClass() == Derived.class));</span><br><span class="line">    print(<span class="string">&quot;x.getClass().equals(Base.class)) &quot;</span>+</span><br><span class="line">      (x.getClass().equals(Base.class)));</span><br><span class="line">    print(<span class="string">&quot;x.getClass().equals(Derived.class)) &quot;</span> +</span><br><span class="line">      (x.getClass().equals(Derived.class)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">Base</span>());</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">Derived</span>());</span><br><span class="line">  &#125;	</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Testing x of type class typeinfo.Base</span></span><br><span class="line"><span class="comment">x instanceof Base true</span></span><br><span class="line"><span class="comment">x instanceof Derived false</span></span><br><span class="line"><span class="comment">Base.isInstance(x) true</span></span><br><span class="line"><span class="comment">Derived.isInstance(x) false</span></span><br><span class="line"><span class="comment">x.getClass() == Base.class true</span></span><br><span class="line"><span class="comment">x.getClass() == Derived.class false</span></span><br><span class="line"><span class="comment">x.getClass().equals(Base.class)) true</span></span><br><span class="line"><span class="comment">x.getClass().equals(Derived.class)) false</span></span><br><span class="line"><span class="comment">Testing x of type class typeinfo.Derived</span></span><br><span class="line"><span class="comment">x instanceof Base true</span></span><br><span class="line"><span class="comment">x instanceof Derived true</span></span><br><span class="line"><span class="comment">Base.isInstance(x) true</span></span><br><span class="line"><span class="comment">Derived.isInstance(x) true</span></span><br><span class="line"><span class="comment">x.getClass() == Base.class false</span></span><br><span class="line"><span class="comment">x.getClass() == Derived.class true</span></span><br><span class="line"><span class="comment">x.getClass().equals(Base.class)) false</span></span><br><span class="line"><span class="comment">x.getClass().equals(Derived.class)) true</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="14-6-反射：运行时的类信息"><a href="#14-6-反射：运行时的类信息" class="headerlink" title="14.6 反射：运行时的类信息"></a>14.6 反射：运行时的类信息</h3><blockquote>
<ul>
<li>Class类与java.lang.reflect类库一起对反射的概念进行了支持。，该类库包含了Field,Method以及Constructor类。这些类型的对象是由jvm在运行的时候创建的，用以表示未知类里对应的成员。</li>
<li>这样就可以使用Constructor创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。</li>
<li>还可以调用getFields()和getMethods()以及getConstructors()等很便利的方法，以返回表示字段、方法以及构造器的对象的数组</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>RTTI和反射之间真正的区别在于：<ul>
<li>对于RTTI来说，编译器在编译时打开和检查.class文件，换句话说，我们可以用普通方式调用对象的所有方法。</li>
<li>而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件的。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="14-7-动态代理"><a href="#14-7-动态代理" class="headerlink" title="14.7 动态代理"></a>14.7 动态代理</h3><blockquote>
<p>代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替实际对象的对象。这些操作通常涉及与实际对象的通信，因此代理通常充当着中间人的角色。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MethodSelector</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Object proxied;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MethodSelector</span><span class="params">(Object proxied)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.proxied = proxied;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Object</span><br><span class="line">  <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">  <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;interesting&quot;</span>))</span><br><span class="line">      print(<span class="string">&quot;Proxy detected the interesting method&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SomeMethods</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">boring1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">boring2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">interesting</span><span class="params">(String arg)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">boring3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementation</span> <span class="keyword">implements</span> <span class="title class_">SomeMethods</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boring1</span><span class="params">()</span> &#123; print(<span class="string">&quot;boring1&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boring2</span><span class="params">()</span> &#123; print(<span class="string">&quot;boring2&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interesting</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;interesting &quot;</span> + arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boring3</span><span class="params">()</span> &#123; print(<span class="string">&quot;boring3&quot;</span>); &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectingMethods</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SomeMethods proxy= (SomeMethods)Proxy.newProxyInstance(</span><br><span class="line">      SomeMethods.class.getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; SomeMethods.class &#125;,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MethodSelector</span>(<span class="keyword">new</span> <span class="title class_">Implementation</span>()));</span><br><span class="line">    proxy.boring1();</span><br><span class="line">    proxy.boring2();</span><br><span class="line">    proxy.interesting(<span class="string">&quot;bonobo&quot;</span>);</span><br><span class="line">    proxy.boring3();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">boring1</span></span><br><span class="line"><span class="comment">boring2</span></span><br><span class="line"><span class="comment">Proxy detected the interesting method</span></span><br><span class="line"><span class="comment">interesting bonobo</span></span><br><span class="line"><span class="comment">boring3</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="第十五章：泛型"><a href="#第十五章：泛型" class="headerlink" title="第十五章：泛型"></a>第十五章：泛型</h2><h2 id="第十六章：数组"><a href="#第十六章：数组" class="headerlink" title="第十六章：数组"></a>第十六章：数组</h2><h2 id="第十七章：容器深入研究"><a href="#第十七章：容器深入研究" class="headerlink" title="第十七章：容器深入研究"></a>第十七章：容器深入研究</h2><h2 id="第十八章：Java-I-O系统"><a href="#第十八章：Java-I-O系统" class="headerlink" title="第十八章：Java I&#x2F;O系统"></a>第十八章：Java I&#x2F;O系统</h2><h2 id="第十九章：枚举类型"><a href="#第十九章：枚举类型" class="headerlink" title="第十九章：枚举类型"></a>第十九章：枚举类型</h2><h2 id="第二十章：注解"><a href="#第二十章：注解" class="headerlink" title="第二十章：注解"></a>第二十章：注解</h2><h2 id="第二十一章：并发"><a href="#第二十一章：并发" class="headerlink" title="第二十一章：并发"></a>第二十一章：并发</h2><blockquote>
<p>因为web服务器经常包含多个处理器，而并发是充分利用这些处理器的理想方式。</p>
</blockquote>
<h3 id="21-1-并发的多面性"><a href="#21-1-并发的多面性" class="headerlink" title="21.1 并发的多面性"></a>21.1 并发的多面性</h3><blockquote>
<p>并发编程令人困惑的一个主要原因是：使用并发时需要解决的问题有多个，而实现并发的方式也有多种，并且在这两者之间没有明显的映射关系（通常只有模糊的界限）</p>
</blockquote>
<blockquote>
<p>并发解决的问题大体上可以分为“速度”和“设计可管理性”两种</p>
</blockquote>
<p><strong>21.1.1 更快的执行</strong></p>
<blockquote>
<p>并发是用于多处理器编程的基本工具。速度提高是以多核处理器的形式而不是更快的芯片的形式出现的，</p>
</blockquote>
<blockquote>
<ul>
<li><p>如果你有一台多处理器的机器，那么就可以在这些处理器之间分布多个任务，从而可以极大地提高吞吐量。这是使用强有力的多处理器Web服务器的常见情况，在为每个请求分配一个线程的程序中，它可以将大量的用户请求分布到多个CPU上。</p>
</li>
<li><p>但是并发是提高运行在单处理器上的程序的性能。</p>
</li>
<li><p>事实上，从性能角度看，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。（因为在单处理器上运行并发程序开销会更大，增加了上下文切换的代价【从一个任务切换到另一个任务】）</p>
</li>
<li><p>在单处理器系统中的性能提高的常见示例是事件驱动的编程。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>实现并发最直接的方式是操作系统级别使用进程。操作系统会将进程相互隔离开，因此他们不会彼此干涉，这使得使用进程编程相对容易一些。与此相反的是，像Java使用的这种并发系统会共享诸如内存和I&#x2F;O这样的资源，因此编写多线程程序最基本的困难在于协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。</li>
</ul>
</blockquote>
<blockquote>
<p>Java采取了更加创痛的方式，在顺序语言的基础上提供对线程的支持，与在多任务操作系统中分叉外部进程不同，线程机制是在由执行程序表示的单一的进程中创建任务，这种方式产生的一个好处是操作系统的透明性。</p>
</blockquote>
<p><strong>21.1.2 改进代码设计</strong></p>
<blockquote>
<ul>
<li><p>对于线程数量不够的处理方式是协作多线程。Java的线程机制是抢占式的，这表示调度机制对周期性地终端线程，将上下文切换到i给你一个线程，从而为每个线程都提供时间片，使得每个县册灰姑娘都会分配到数量合理的时间去驱动它的任务。</p>
</li>
<li><p>通常线程使你能够创建更加松散耦合的设计。</p>
</li>
</ul>
</blockquote>
<h3 id="21-2-基本的线程机制"><a href="#21-2-基本的线程机制" class="headerlink" title="21.2 基本的线程机制"></a>21.2 基本的线程机制</h3><blockquote>
<ul>
<li>并发编程是我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务（也被称为子任务），zh哦那个的每一个都将由执行线程来驱动。一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个人物都好像有其自己的CPU一样。&#x3D;&#x3D;其底层机制是切分CPU时间。&#x3D;&#x3D;</li>
<li>线程的一大好处是代码不必知道它是运行在具有一个还是多个CPU的机器上。</li>
<li>多任务和多线程时使用多处理器系统的最合理方式</li>
</ul>
</blockquote>
<p><strong>21.2.1 定义任务</strong></p>
<blockquote>
<ul>
<li>线程可以驱动任务，因此你需要&#x3D;&#x3D;一种描述任务的方式，这可以由Runnable接口来提供，要想定义任务，只需实现Runnable接口并编写run()方法，使得该任务可以执行你的命令&#x3D;&#x3D;。例如，下面的LiftOff任务将显式发射之前的倒计时.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiftOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> countDown=<span class="number">10</span>; <span class="comment">//default</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> taskCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id=taskCount++;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiftOff</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiftOff</span><span class="params">(<span class="type">int</span> countDown)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.countDown=countDown;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">status</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id+<span class="string">&quot;(&quot;</span>+(countDown&gt;<span class="number">0</span>?countDown:<span class="string">&quot;LiftOff!&quot;</span>)+<span class="string">&quot;),&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(status());</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在run()中对&#x3D;&#x3D;静态方法Thread.yield()的调用是对线程调度器（Java线程机制的一部分，可以将CPU从一个线程转义给另一个线程）的一种建议&#x3D;&#x3D;，它在声明：“我已经执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机”。这是可选的，这是为了能够看到任务换进换出的证明。（线程切换）</p>
</li>
<li><p>下面示例中，这个任务的run()不是由单独的线程驱动的，它是在main()中直接带哦用的（实际上，这里仍旧使用了线程，即总是分配给main()的那个线程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        LiftOff launch=<span class="keyword">new</span> <span class="title class_">LiftOff</span>();</span><br><span class="line">        launch.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x3D;&#x3D;当从Runnable导出一个类是，它必须具有run()方法，但是这个方法并无特殊之处——即它不会产生任何内在的线程能力。要实现线程行为，你必须显式的将一个任务附着到线程上。&#x3D;&#x3D;</p>
</li>
</ul>
</blockquote>
<p><strong>21.2.2 Thread类</strong></p>
<blockquote>
<ul>
<li>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器，下面的示例展示了如何使用Thread来驱动LiftOff对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicThreads</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for LiftOff&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">Waiting for LiftOff</span></span><br><span class="line"><span class="comment">#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Thread构造器只需要一个Runnable对象。&#x3D;&#x3D;调用Thread对象的start()方法为该线程执行必需的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务&#x3D;&#x3D;。可以看到Wating for LiftOff消息在倒计时完成之前就出现了。这是因为LiftOff.run()是由不同的线程的执行的，因此你仍旧可以执行main()线程中的其他操作。（这种能力并不局限于main()线程，任何线程都可以启动另一个线程）</li>
<li>可以很容易的添加更多的线程去驱动更多的任务。下面，你可以看到所有任务彼此之间是如何相互呼应的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoreBasicThreads</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LiftOff</span>()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting for liftOff&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">Waiting for LiftOff</span></span><br><span class="line"><span class="comment">#0(9), #1(9), #2(9), #3(9), #4(9), #0(8), #1(8), #2(8), #3(8), #4(8), #0(7), #1(7), #2(7), #3(7), #4(7), #0(6), #1(6), #2(6), #3(6), #4(6), #0(5), #1(5), #2(5), #3(5), #4(5), #0(4), #1(4), #2(4), #3(4), #4(4), #0(3), #1(3), #2(3), #3(3), #4(3), #0(2), #1(2), #2(2), #3(2), #4(2), #0(1), #1(1), #2(1), #3(1), #4(1), #0(Liftoff!), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的输出说明不同任务的执行在线程被换进换出时混在了一起。这种交换是由线程调度器自动控制的。如果在你的机器上有多个处理器，线程调度器将会在这些处理器之间默默地分发进程。</li>
<li>当main()创建Thread对象时，它并没有捕获任何对这些对象的引用。在使用普通对象时，这对于垃圾回收来说是一场公平的游戏，但是在使用Thread时，情况就不同了。每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且&#x3D;&#x3D;在它的任务退出其run()并死亡之前，垃圾回收器无法清除它&#x3D;&#x3D;。你可以从输出中看到，这些任务确实运行到了结束，因此，&#x3D;&#x3D;一个线程会创建一个单独的执行线程，在对start()的调用完成之后，它仍旧会在继续存在。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<p><strong>21.2.3 使用Executor</strong></p>
<blockquote>
<ul>
<li>JavaSE5的java.util.concurrent包中的&#x3D;&#x3D;执行器&#x3D;&#x3D;（Executor）将为你管理Thread对象，从而简化了并发编程。Excecutor在客户端和任务执行之间提供了一个间接层；与客户端直接执行任务不同这个中介对象将执行任务。Executor在JavaSE5&#x2F;6中是启动任务的优选方法。</li>
<li>可以使用Executor来代替在MoreBasicThreads.java中显式地创建Thread对象。ListOff对象知道如何运行具体的任务，与命令设计模式一样，它暴露了要执行的单一方法。ExecutorService(具有服务生命周期的Executor,例如关闭)知道如何构建恰当的上下文来执行Runnable对象。</li>
<li>在下面的实例中，&#x3D;&#x3D;CachedThreadPool将为每个任务都创建一个线程&#x3D;&#x3D;。注意，ExecutorService对象时使用静态的Executor方法创建的，这个方法可以确定其Executor类型：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">LiftOff</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务。</li>
<li>对shutdown()方法的调用可以防止新任务被提交给这个Executor,当前线程（在本例中，即驱动main()的线程）将继续运行在shutdown()被调用之前提交的所任务。这个程序将在Executor中的所有任务完成之后尽快退出。</li>
<li>可以将前面的CachedThreadPool替换为不同类型的Executor.&#x3D;&#x3D;FixedThreadPool使用了有限的线程集来执行所提交的任务。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//构造器参数就是线程的数量</span></span><br><span class="line">        ExecutorService exec=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(itn i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有了FixedThreadPool，你就可以一次性预先执行代价高昂的线程分配，因而也就可以限制线程的数量。</li>
<li>尽管本书将使用CachedThreadPool，但是也应该考虑在产生线程的代码中使用FixedThreadPool.CachedThreadPool在程序执行过程中通常会创建于所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式会引发问题是，才需要切换到FixedThreadPool.</li>
<li>SingleThreadExecutor就像是线程数量为1的FixedThreadPool.(它提供了一种重要的并发保证，其他线程额不会被并发调用。这会改变任务的加锁需求)。如果向SinglethreadExecutor提交了多个任务，那么么这些任务将排队，每个人物都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。SingleThreadExecutor会序列化所有提交给它的任务，并会维护它自己（隐藏）的悬挂任务队列。在下面的实例中，可以看到每个任务都是按照他们被提交的顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadExecutor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ExecutorService exec=Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!), #1(9), #1(8), #1(7), #1(6), #1(5), #1(4), #1(3), #1(2), #1(1), #1(Liftoff!), #2(9), #2(8), #2(7), #2(6), #2(5), #2(4), #2(3), #2(2), #2(1), #2(Liftoff!), #3(9), #3(8), #3(7), #3(6), #3(5), #3(4), #3(3), #3(2), #3(1), #3(Liftoff!), #4(9), #4(8), #4(7), #4(6), #4(5), #4(4), #4(3), #4(2), #4(1), #4(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;可以使用SingleThreadExecutor来运行很多个线程，以确保任意时刻在任何线程中都只有唯一的任务在运行&#x3D;&#x3D;，你不需要在共享资源上处理同步。有时候更好的解决方案是在资源上处理同步（后面学习），但是SingleThreadExecutor可以让你省区只是为了维持某些事物的原型而进行的各种努力。通过序列化任务，你可以消除对序列化对象的需求。</li>
</ul>
</blockquote>
<p><strong>21.2.4 从任务中产生返回值</strong></p>
<blockquote>
<ul>
<li>Runnable是执行工作的独立任务，但是它不返回任何值。&#x3D;&#x3D;如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口&#x3D;&#x3D;。在JavaSE5中引入的Callable是一个具有类型参数的泛型，&#x3D;&#x3D;它的类型参数表示的是从方法call()（而不是run()）中返回的值，并且必须使用executorService.submit()方法调用它&#x3D;&#x3D;，下面是一个实例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskWithResult</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TaskWithResult</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;result of TaskWithResult &quot;</span> + id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    ArrayList&lt;Future&lt;String&gt;&gt; results =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      results.add(exec.submit(<span class="keyword">new</span> <span class="title class_">TaskWithResult</span>(i)));</span><br><span class="line">    <span class="keyword">for</span>(Future&lt;String&gt; fs : results)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// get() blocks until completion:</span></span><br><span class="line">        System.out.println(fs.get());</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(ExecutionException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">result of TaskWithResult 0</span></span><br><span class="line"><span class="comment">result of TaskWithResult 1</span></span><br><span class="line"><span class="comment">result of TaskWithResult 2</span></span><br><span class="line"><span class="comment">result of TaskWithResult 3</span></span><br><span class="line"><span class="comment">result of TaskWithResult 4</span></span><br><span class="line"><span class="comment">result of TaskWithResult 5</span></span><br><span class="line"><span class="comment">result of TaskWithResult 6</span></span><br><span class="line"><span class="comment">result of TaskWithResult 7</span></span><br><span class="line"><span class="comment">result of TaskWithResult 8</span></span><br><span class="line"><span class="comment">result of TaskWithResult 9</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。你可以用isDone()方法来查询Future是否已经完成。当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果。你也可以不用isDone()进行检查就直接调用get(),在这种情况下，get()将阻塞，直至结果准备就绪。</li>
</ul>
</blockquote>
<p><strong>21.2.5 休眠</strong></p>
<blockquote>
<ul>
<li>影响任务行为的一种简单方法是调用sleep(),这将使任务中止来执行给定的时间。</li>
<li>对sleep()的调用可以抛出InterruptedException异常，并且你可以看到，它在run()中被捕获。&#x3D;&#x3D;因为异常不能跨线程传播会main(),所以必须在本地处理所有在任务内部产生的异常。&#x3D;&#x3D;</li>
<li>除了使用Thread.sleep()方法。JavaSE5引入了更加显式的sleep版本，作为TimeUnit类的一部分，因此可以提供更好的可阅读性，TimeUnit还可以被用来执行转换</li>
<li>如TimeUnit.MILLISECONDS.sleep(100);效果通Thread.sleep(100);</li>
</ul>
</blockquote>
<p><strong>21.2.6 优先级</strong></p>
<blockquote>
<ul>
<li>线程的优先级将线程的重要性传递给了调度器。尽管CPU处理现有县城及的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。然而，这并不意味这优先权较低的线程将得不到执行（也就是说，优先权不会导致死锁）。优先权较低的线程仅仅是执行的频率较低。</li>
<li>在绝大数时间里，所有线程都应该以默认的优先级运行。试图操纵现车给优先级通常是一种错误。</li>
<li>下面是一个演示优先级等级的实例，&#x3D;&#x3D;你可以用getPriority()来读取现有线程的优先级，并且在任何时刻都可以通过setPriority()来修改它。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePriorities</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> d; <span class="comment">// No optimization</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimplePriorities</span><span class="params">(<span class="type">int</span> priority)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.priority = priority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread() + <span class="string">&quot;: &quot;</span> + countDown;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().setPriority(priority);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// An expensive, interruptable operation:</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        d += (Math.PI + Math.E) / (<span class="type">double</span>)i;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">          Thread.<span class="keyword">yield</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">if</span>(--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimplePriorities</span>(Thread.MIN_PRIORITY));</span><br><span class="line">    exec.execute(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimplePriorities</span>(Thread.MAX_PRIORITY));</span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (70% match)</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 4</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 3</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 2</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6,10,main]: 1</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-3,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-2,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-1,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-5,1,main]: 5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-4,1,main]: 5</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Thread.toString()方法来打印线程的名称、线程的优先级以及线程所属的线程组。你可以通过构造器来自己设置这个名称。这里是自动生成的名称，如ppol-1-thred-1,pool-1-thred-2等。</li>
<li>通过调用Thread.currentThread()来获得对驱动该任务的Thread对象的引用。</li>
<li>优先级是在run()的开头部分设定的，在构造器中设置他们不会有任何好处，因为executor在此刻还没有开始执行任务。</li>
<li>变量d是用volatile修饰的，以努力确保不进行任何编译器优化。</li>
<li>尽管JDK有10个优先级，但它与多数操作系统不饿能映射得很好，唯一可移植得方法是当调整优先级得时候，只是用MAX_PRIORITY、NORM_PRIORITY和MIN_PRIORITY三种级别。</li>
</ul>
</blockquote>
<p><strong>21.2.7 让步</strong></p>
<blockquote>
<p>让步是通过Thread.yield()方法来完成的，这个只是建议并不是强制，所以大体上对于重要的控制或在调整应用时，都不能依赖于yield().</p>
</blockquote>
<p><strong>21.2.8 后台线程</strong></p>
<blockquote>
<ul>
<li>所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程。并且这种线程并不属于程序中不可或缺的部分。因此，&#x3D;&#x3D;当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程&#x3D;&#x3D;。反过来说，只要有任何非后台线程还在执行，程序就不会终止。比如，执行main()的就是一个非后台线程。</li>
<li>必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        print(Thread.currentThread() + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;sleep() interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SimpleDaemons</span>());</span><br><span class="line">      daemon.setDaemon(<span class="literal">true</span>); <span class="comment">// Must call before start()</span></span><br><span class="line">      daemon.start();</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;All daemons started&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">All daemons started</span></span><br><span class="line"><span class="comment">Thread[Thread-0,5,main] SimpleDaemons@530daa</span></span><br><span class="line"><span class="comment">Thread[Thread-1,5,main] SimpleDaemons@a62fc3</span></span><br><span class="line"><span class="comment">Thread[Thread-2,5,main] SimpleDaemons@89ae9e</span></span><br><span class="line"><span class="comment">Thread[Thread-3,5,main] SimpleDaemons@1270b73</span></span><br><span class="line"><span class="comment">Thread[Thread-4,5,main] SimpleDaemons@60aeb0</span></span><br><span class="line"><span class="comment">Thread[Thread-5,5,main] SimpleDaemons@16caf43</span></span><br><span class="line"><span class="comment">Thread[Thread-6,5,main] SimpleDaemons@66848c</span></span><br><span class="line"><span class="comment">Thread[Thread-7,5,main] SimpleDaemons@8813f2</span></span><br><span class="line"><span class="comment">Thread[Thread-8,5,main] SimpleDaemons@1d58aae</span></span><br><span class="line"><span class="comment">Thread[Thread-9,5,main] SimpleDaemons@83cc67</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过调用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程。</li>
<li>你应该意识到后台进程在不执行finally子句的情况下就会终止其run()方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADaemon</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      print(<span class="string">&quot;Starting ADaemon&quot;</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via InterruptedException&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      print(<span class="string">&quot;This should always run?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonsDontRunFinally</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ADaemon</span>());</span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    t.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Starting ADaemon</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当运行这个程序时，将看到finally子句就不会执行。但是如果注释掉对setDaemon()的调用，就会看到fiinally的调用，就会看到finally的执行。</li>
<li>&#x3D;&#x3D;当最后一个非后台线程终止时，后台线程会突然终止。因此一旦main()退出，jvm就会立即关闭所有的后台进程。&#x3D;&#x3D;而不会有任何你希望出现的确认形式。因为你不能以优雅的方式来关闭后台线程，所以它们呢几乎不是一种好的思想。非后台的Executor通常是一种更好的方式，因为Executor控制的所有任务可以同时被关闭，关闭并且以有序的方式执行。</li>
</ul>
</blockquote>
<p><strong>21.2.9 编码的变体</strong></p>
<blockquote>
<ul>
<li>在前面的示例中，任务类都实现了Runnable.在非常简单的情况下，你可能会希望使用直接从Thread继承这种可替换的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> threadCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleThread</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//store the thread name</span></span><br><span class="line">        <span class="built_in">super</span>(Integer.toString(++threadCount));</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>+getName()+<span class="string">&quot;(&quot;</span>+countDown+<span class="string">&quot;),&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span>(--countDown==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SimpleThread</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过调用适当的Thread构造器为Thread对象赋予具体的名称，这个名称可以通过使用getName()从toString()中获得。</li>
<li>另一种可能会看到的管用法是自管理的Runnable:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfManaged</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SelfManaged</span><span class="params">()</span> &#123; t.start(); &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName() +</span><br><span class="line">      <span class="string">&quot;(&quot;</span> + countDown + <span class="string">&quot;), &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      System.out.print(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">if</span>(--countDown == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SelfManaged</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Thread-0(5), Thread-0(4), Thread-0(3), Thread-0(2), Thread-0(1), Thread-1(5), Thread-1(4), Thread-1(3), Thread-1(2), Thread-1(1), Thread-2(5), Thread-2(4), Thread-2(3), Thread-2(2), Thread-2(1), Thread-3(5), Thread-3(4), Thread-3(3), Thread-3(2), Thread-3(1), Thread-4(5), Thread-4(4), Thread-4(3), Thread-4(2), Thread-4(1),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这与从Thread继承并没有什么特别的差异，但是实现接口使得可以继承另一个不同的类。</li>
</ul>
</blockquote>
<p><strong>21.2.10 术语</strong></p>
<blockquote>
<ul>
<li>在Java中，Thread类自身并不执行任何操作，它只是驱动赋予它的任务，但在线程研究中总是不变得使用线程执行这项或那项动作的语言。</li>
<li>我将尝试着在描述将要执行的工作时使用术语“任务”，只有在我引用到驱动任务的具体机制时，才使用线程。</li>
</ul>
</blockquote>
<p><strong>21.2.11 加入一个线程</strong></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复&#x3D;&#x3D;。（即t.isAlive()返回为假）【如下面的Joiner这个线程在Sleeper线程t上调用t.join()】</li>
<li>也可以在调用join()时带上一个超时参数（单位可以是秒，或者毫秒，纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。</li>
<li>对join()方法的调用可以被中断，做法时在调用线程上调用interrupt()方法，这时需要用到try-catch子句</li>
<li>下面这个例子演示了所有这些操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sleeper</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> duration;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sleeper</span><span class="params">(String name,<span class="type">int</span> sleepTime)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        duration=sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//线程正常情况下处于非中断状态，即 isInterrupted()返回false</span></span><br><span class="line">            sleep(duration);   <span class="comment">//但是在执行完sleep、wait这些方法时就会进入中断状态</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            print(getName()+<span class="string">&quot; was interrupted.&quot;</span>+<span class="string">&quot;isInterrupted():&quot;</span>+isInterrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print(getName()+<span class="string">&quot; has awakened&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Joiner</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sleeper sleeper;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Joiner</span><span class="params">(String name,Sleeper sleeper)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.sleeper=sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sleeper.join();  <span class="comment">//joiner这个线程自身会被挂起，要等到 sleeper线程执行结束后太进行执行</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            print(<span class="string">&quot;Interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        print(getName()+<span class="string">&quot; join completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joining</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Sleeper sleepy=<span class="keyword">new</span> <span class="title class_">Sleeper</span>(<span class="string">&quot;Sleepy&quot;</span>,<span class="number">1500</span>),grumpy=<span class="keyword">new</span> <span class="title class_">Sleeper</span>(<span class="string">&quot;Grumpy&quot;</span>,<span class="number">1500</span>);</span><br><span class="line">        Joiner dopey=<span class="keyword">new</span> <span class="title class_">Joiner</span>(<span class="string">&quot;Dopey&quot;</span>,sleepy),doc=<span class="keyword">new</span> <span class="title class_">Joiner</span>(<span class="string">&quot;Doc&quot;</span>,grumpy);</span><br><span class="line">        <span class="comment">//打破当前线程的中断状态，并返回一个中断异常</span></span><br><span class="line">        grumpy.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**Output:</span></span><br><span class="line"><span class="comment">Grumpy was interrupted. isInterrupted():false</span></span><br><span class="line"><span class="comment">Doc join completed</span></span><br><span class="line"><span class="comment">Sleepy has awakened</span></span><br><span class="line"><span class="comment">Dopey join completed</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:/~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Sleeper是一个Thread类型，它要休眠一段时间，这段时间是通过构造器传进来的参数所指定的。在run()中,sleep()方法有可能在指定的时间期满时返回，但也有可能中断。在catch子句中，将根据isInterrupted()的返回值报告这个中断。&#x3D;&#x3D;当另一个线程在该线程上调用interrupt()时，将给该线程设定一个标志，表明该线程已经被中断。然而，异常被捕获时将清理这个标志，所以在catch子句中，在一场被捕获的时候这个标志总是为假&#x3D;&#x3D;。除异常之外，这个标志还可用于其他情况，比如线程可能会检查其中断状态。</li>
<li>JavaSE5的java.util.concurrent类库包含诸如CyclicBarrier(后面会展示)这样的工具，他们可能比最初的线程类库中的join()更加合适。</li>
</ul>
</blockquote>
<p><strong>21.2.12 建立有响应的页面</strong></p>
<p><strong>21.2.13 线程组</strong></p>
<blockquote>
<p>线程组是一个线程集合。最好把线程组看成是一次不成功的尝试，你只要忽略它就好了。</p>
</blockquote>
<p><strong>21.2.14 捕获异常</strong></p>
<blockquote>
<ul>
<li>由于线程的本质特性，使得你不能捕获从线程中逃逸的异常，一旦一场逃出任务的run()方法，它就会向外传播到控制台。除非采取特殊的步骤捕获这种错误的异常。在JavaSE5之前，可以使用i安承祖来捕获这些异常，但是有了Java SE5，就可以用Executor来解决这个问题。</li>
<li>下面的任务总是会抛出一个异常，该异常会传播到其run()方法的外部，并且main()展示了你运行它时所发生的事情。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面这个会报错。如果把main主体放入try-catch中也是没有作用的。</li>
<li>为了解决这个问题，我们要修改Executor产生线程的方式。Thread.UncaughtExceptionHandler是Java SE5中的新接口，它允许你再每个Thread对象上给附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;run() by &quot;</span> + t);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;caught &quot;</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span> + <span class="string">&quot; creating new Thread&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    System.out.println(<span class="string">&quot;created &quot;</span> + t);</span><br><span class="line">    t.setUncaughtExceptionHandler(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptureUncaughtException</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">HandlerThreadFactory</span>());</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread2</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">HandlerThreadFactory@de6ced creating new Thread</span></span><br><span class="line"><span class="comment">created Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">eh = MyUncaughtExceptionHandler@1fb8ee3</span></span><br><span class="line"><span class="comment">run() by Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">eh = MyUncaughtExceptionHandler@1fb8ee3</span></span><br><span class="line"><span class="comment">caught java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在程序中添加了额外的跟踪机制，用来验证工厂创建的线程会传递给UncaughtExceptionHandler。现在可以看到，未捕获的异常是通过uncaughtException来捕获的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方式是在Thread类中设置一个静态域，并将这个处理器设置为默认的未捕获异常处理器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t,Throwable e)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;caught &quot;</span>+e);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SettingDefaultHandler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>());</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**output:</span></span><br><span class="line"><span class="comment">caught java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">*/</span>/~</span><br></pre></td></tr></table></figure>

<ul>
<li>这个处理器只有在不存在线程专有的未捕获异常处理器的情况下才会被调用。系统会检查线程专有版本，如果没有发现，则检查线程组是否有其专有的uncaughtException()方法，如果也没有，再调用defaultUncaughtExceptionHandler.</li>
</ul>
</blockquote>
<h3 id="21-3-共享受限资源"><a href="#21-3-共享受限资源" class="headerlink" title="21.3  共享受限资源"></a>21.3  共享受限资源</h3><p><strong>21.3.1 不正确的访问资源</strong></p>
<blockquote>
<p>我们可以发现，在Java中，递增不是原子性的操作</p>
</blockquote>
<p><strong>21.3.2 解决共享资源竞争</strong></p>
<blockquote>
<ul>
<li>对于并发工作，你需要某种方式来防止两个任务访问相同的资源，至少在关键阶段不能出现这种情况。</li>
<li>防止这种冲突的方法就是当资源被一个任务使用时，在其上加上锁。</li>
<li>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。这意味着在给定时刻只允许一个任务访问共享资源。&#x3D;&#x3D;通常这是通过在代码前面加上一条锁语句来实现的。因为锁语句产生了一种相排斥的效果，所以这种机制常常称为互斥量（mutex）&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;Java以提供关键字synchronized的形式，为防止资源冲突提供了内置支持。&#x3D;&#x3D;当任务要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，然后获取锁，执行代码，释放锁。</li>
<li>共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入&#x2F;输出端口，或者是打印机。要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为synchronized。如果某个任务处于一个对标记为synchronized的方法的调用中，那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。</li>
<li>对于某个特定对象来说，其所有synchronized方法共享同一个锁，这可以用来放置多个任务同时访问被编码为对象内存。</li>
<li>注意，&#x3D;&#x3D;在使用并发时，将域设置为private是非常重要的&#x3D;&#x3D;，否则，synchronized关键字就不能放置其他任务直接访问域，这样就会产生冲突。</li>
<li>一个任务可以多次获得对象的锁。</li>
<li>针对每个类，也有一个类（作为类的Class对象的一部分），所以synchronized static方法可以在类的范围内防止对static数据的并发访问。</li>
<li>你应该什么时候同步（synchronized）呢？可以运用Brian的同步规则：<ul>
<li>如果&#x3D;&#x3D;你正在写一个变量，它可能接下来将被另一个线程读取&#x3D;&#x3D;，或者&#x3D;&#x3D;正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步&#x3D;&#x3D;，并且，&#x3D;&#x3D;读写线程都必须用相同的监视器锁同步&#x3D;&#x3D;。</li>
</ul>
</li>
<li>如果在你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。如果只同步一个方法，那么其他方法将会随意地忽略这个对象锁，并可以在无任何惩罚地情况下被调用。这是很重要地一点：每个访问临界共享资源地方法都必须被同步，否则它们就不会正确地工作。</li>
<li>示例可以见练习11</li>
</ul>
</blockquote>
<p><strong>使用显式地Lock对象</strong></p>
<blockquote>
<ul>
<li><p>JavaSE5地java.util.concurrent类库还包含有定义在java.util.concurrent.locks中地显式地互斥机制</p>
</li>
<li><p>Lock对象必须被显式地创建、锁定和释放，因此它与内建地锁形式相比，代码缺乏优雅性。但是，对于解决某些类型地问题来说，它更加灵活。</p>
</li>
<li><p>示例见：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title class_">IntGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentEvenValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      Thread.<span class="keyword">yield</span>(); <span class="comment">// Cause failure faster</span></span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    EvenChecker.test(<span class="keyword">new</span> <span class="title class_">MutexEvenGenerator</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MutexEvenGenerator添加了一个被相互调用地锁，并使用lock()和unlock()方法在next()内部创建了临界资源。当你在使用Lock对象时，将这里地惯用写法内部化非常重要：紧接着地对lock()地调用，你必须放置在finally子句中带有unlock()的try-finally语句中。注意，return语句必须在try子句中出现，以确保unlock()不会过早发生，从而将数据暴露给了第二个任务。</li>
<li>如果在使用synchronized关键字时，如果某些事务失败了，那么就会抛出一个异常。但是你没有机会去做任何清理动作，以维护系统使其处于良好状态。有了显式的Lock对象，你就可以使用finally子句将维护系统在正确的状态。</li>
<li>大体上，当你使用synchronized关键字时，需要写的代码量更少，并且用户错误出现的可能性也会降低，因此通常只有解决特殊问题时，才使用显式的Lock对象。例如，用synchronized关键字蹦年尝试和获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后放弃它，要实现这些，你必须使用concurrent类库。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttemptLocking</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">untimed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">captured</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;tryLock(): &quot;</span> + captured);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(captured)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">captured</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      captured = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;tryLock(2, TimeUnit.SECONDS): &quot;</span> +</span><br><span class="line">        captured);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(captured)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AttemptLocking</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AttemptLocking</span>();</span><br><span class="line">    al.untimed(); <span class="comment">// True -- lock is available</span></span><br><span class="line">    al.timed();   <span class="comment">// True -- lock is available</span></span><br><span class="line">    <span class="comment">// Now create a separate task to grab the lock:</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      &#123; setDaemon(<span class="literal">true</span>); &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        al.lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;acquired&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    Thread.<span class="keyword">yield</span>(); <span class="comment">// Give the 2nd task a chance</span></span><br><span class="line">    al.untimed(); <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">    al.timed();   <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">tryLock(): true</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class="line"><span class="comment">acquired</span></span><br><span class="line"><span class="comment">tryLock(): false</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): false</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显式的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁来说，还赋予了你更细粒度的控制力。这对于实现专有同步结构是很有用的，例如用于遍历链接列表中的节点的节点传递的加锁机制（也称为锁耦合），这种遍历代码必须在释放当前节点的锁之前捕获下一个节点的锁</li>
</ul>
</blockquote>
<p><strong>21.3.3 原子性与易变性</strong></p>
<blockquote>
<ul>
<li>在有关Java线程的讨论中，一个常不正确的知识是“原子操作不需要进行同步控制”。&#x3D;&#x3D;原子操作是不能被线程调度机制中断的操作；&#x3D;&#x3D;一旦操作开始，那么它一定可以在可能发生的上下文切换之前（切换到其他线程执行）执行完毕。&#x3D;&#x3D;依赖于原子性是很棘手且很危险的。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;原子性可以应用于除long和double之外的所有基本类型之上的简单操作&#x3D;&#x3D;。对于读取和写入除long和double之外的基本类型变量这样的操作，可以保证他们会被当做不可分（原子）的操作来操作内存。但是jvm可以将64位（long和double变量）的读取和写入当作两个分离的32位操作来执行，这就产生了一个读取和写入操作中间发生上下文切换，从而导致不同的任务可以看到不正确结果的可能性。&#x3D;&#x3D;但是当你定义long或double变量时，如果使用volatile关键字，就会获得（简单的赋值于返回操作的）原子性&#x3D;&#x3D;。</li>
<li>原子操作可由线程机制来保证其不可中断，但是这是一种过于简化的机制，有时看起来应该是安全的原子操作，实际上也可能不安全。&#x3D;&#x3D;因此不要尝试用原子操作来替换同步。&#x3D;&#x3D;</li>
<li>多处理器系统（现在以多核处理器的形式出现，即在单个芯片上有多个CPU），相对于单处理器系统而言，可视性问题远比原子性问题多得多。</li>
<li>一个任务做出的修改，即使在不中断的意义上讲是原子性的，对其他任务也可能是不可视的（例如修改只是暂时性地存储在本地处理器地缓存中），因此不同地任务对应用地状态有不同的视图。另一方面，&#x3D;&#x3D;同步机制强制在处理器系统中，一个任务做出的修改必须在应用中是可视的。如果没有同步机制，那么修改时可视将无法确定。&#x3D;&#x3D;</li>
<li>volatile关键字还确保了应用中的可视性。如果你讲一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。即便使用本地缓存，情况也确实如此，volatile域会立即被写入到主存中，而读取操作就大声在主存中。</li>
<li>理解原子性和易变性是不同的概念这一点很重要。在非volatile域上的操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值。如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。&#x3D;&#x3D;同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来保护，那就不必将其设置为是volatile的&#x3D;&#x3D;。</li>
<li>一个任务所作的任何写入操作对这个任务来说都是可视的，因此如果它只需要在这个任务内部可视，那么你就不需要将其设置为volatile的。</li>
<li>当一个域的值依赖于它之前的值（例如递增一个计数器），volatile就无法工作了。如果某个某个域的值受到其他域的值的限制，那么volatile也无法工作，例如Range类的lower和upper边界就必须遵循lower&lt;&#x3D;upper的限制。</li>
<li>&#x3D;&#x3D;使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域&#x3D;&#x3D;。因此我们的第一选择还应该是使用synchronized关键字，这是最安全的方式。</li>
<li>什么才是原子操作呢？<ul>
<li>对域中的值做赋值和返回操作通常都是原子性的。</li>
</ul>
</li>
<li>基本上，如果一个域可能会被多个任务同时访问，或者这些任务中至少有一个是写入任务，那么你就应该将这个域设置为volatile的。</li>
</ul>
</blockquote>
<p><strong>21.3.4 原子类</strong></p>
<blockquote>
<ul>
<li>Java SE5引入了诸如AtomicInteger,AtomicLong,AtomicReference等特殊的原子性变量类，他们提供下面形式的原子性条件更新操作：<ul>
<li>boolean compareAndSet(expectedValue,updateVaule);</li>
</ul>
</li>
<li>这些类被调整为可以使用在某些现代处理器上的而可获得的、并且是在机器级别上的原子性，，可以同时使用这些而消除了synchronized关键字。</li>
<li>应该强调的是，Atomic类被设计用来用来构建java.util.concurrent中的类，因此只有在特殊情况下才在自己的代码中使用。通常依赖于锁要更安全一些（要么是synchronized关键字，要么是显式的Lock对象）</li>
</ul>
</blockquote>
<p><strong>21.3.5 临界区</strong></p>
<blockquote>
<ul>
<li>有时，你只是希望防止多个线程同时防问方法内部的部分代码，而不是防止访问整个方法。通过这种方式分离出来的代码被称为临界区（critical section）,它也使用synchronized关键字建立。这里，synchronized被用来指定某个对象，此对象的锁被用来对花括号内代码进行同步控制：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject)&#123;   <span class="comment">//这里面一般放类对象this</span></span><br><span class="line">	<span class="comment">//This code can be accessed by only one task at a time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这也被称为同步控制快，在进入此段代码前，必须得到syncObject对象的锁。如果其他线程已经得到这个锁，那么就得等到锁被释放以后，才能进入临界区。</li>
<li>通过使用同步控制块，而不是对整个方法进行同步控制，可以使多个任务访问对象的时间性能得到显著提高，所以对象不加锁的时间更长。这也是宁愿使用同步控制快而不是整个方法进行同步控制的典型原因：使得其他线程能更多的访问（在安全的情况下尽可能多）。</li>
<li>还可以使用显式的Lock对象来创建临界区</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synchronize the entire method:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitPairManager1</span> <span class="keyword">extends</span> <span class="title class_">PairManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      p.incrementX();</span><br><span class="line">      p.incrementY();</span><br><span class="line">      store(getPair());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use a critical section:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitPairManager2</span> <span class="keyword">extends</span> <span class="title class_">PairManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    Pair temp;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      p.incrementX();</span><br><span class="line">      p.incrementY();</span><br><span class="line">      temp = getPair();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    store(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExplicitCriticalSection</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">PairManager</span></span><br><span class="line">      <span class="variable">pman1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExplicitPairManager1</span>(),</span><br><span class="line">      pman2 = <span class="keyword">new</span> <span class="title class_">ExplicitPairManager2</span>();</span><br><span class="line">    CriticalSection.testApproaches(pman1, pman2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">pm1: Pair: x: 15, y: 15 checkCounter = 174035</span></span><br><span class="line"><span class="comment">pm2: Pair: x: 16, y: 16 checkCounter = 2608588</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主要重要的点是在ExplicitPairManager2中的store()方法在临界区外</li>
</ul>
</blockquote>
<p><strong>21.3.6 在其它对象上同步</strong></p>
<blockquote>
<ul>
<li>synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象：synchronized(this),在这种方式中，如果获得了synchronized块上的锁，那么该对象其他的synchronized方法和临界区就不能被调用了。因此，如果在this上同步，临界区的效果就会直接缩小在同步的范围内。</li>
<li>有时必须在另一个对象上同步，但是如果你这么做，就必须确保所有相关的任务都是在同一个对象上同步的。下面的示例演示了两个任务可以同时进入同一个对象，只要这个对象上的方法是在不同的锁上同步的即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DualSynch</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">syncObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">      Thread.<span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(syncObject) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        print(<span class="string">&quot;g()&quot;</span>);</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncObject</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DualSynch</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DualSynch</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ds.f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    ds.g();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">g()</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>DualSync.f()（通过同步整个方法）在this同步，而g()有一个在syncObject上同步的syncchronized块。因此这两个同步是相互独立的。通过在main()中创建调用f()的Thread对这一个点进行了演示，因为main()线程是被用爱调用g()的。从输出中可以看到，这两个方式在同时运行，因此任何一个方法都没有因为对另一个方法的同步而阻塞。</p>
</li>
<li><p>当使用synchronized临界区时，通过不同的syncObject对象来进行演示，这是重点。</p>
</li>
<li><p>下面这个练习是使用显式对象，来演示在其他对象上同步。重点在于使用不同的锁对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test16</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj2=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> Object obj3=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock locka=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Lock lockb=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Lock lockc=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            locka.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            locka.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lockb.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockb.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lockc.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lockc.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exec16</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test16 test16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exec16</span><span class="params">(Test16 test16)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.test16=test16;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        test16.funA();</span><br><span class="line"><span class="comment">//        Thread.yield();</span></span><br><span class="line">        test16.funB();</span><br><span class="line"><span class="comment">//        Thread.yield();</span></span><br><span class="line">        test16.funC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exec16Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Test16 t=<span class="keyword">new</span> <span class="title class_">Test16</span>();</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Exec16</span>(t));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>21.3.7 线程本地存储</strong></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。&#x3D;&#x3D;因此，如果你有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储块。主要是，他们可以使得你可以将状态与线程关联起来。</li>
<li>创建和管理线程本地存储可以由java.lang.ThreadLocal类来实现，如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Accessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Accessor</span><span class="params">(<span class="type">int</span> idn)</span> &#123; id = idn; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      ThreadLocalVariableHolder.increment();</span><br><span class="line">      System.out.println(<span class="built_in">this</span>);</span><br><span class="line">      Thread.<span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">      ThreadLocalVariableHolder.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalVariableHolder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(<span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    value.set(value.get() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value.get(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">Accessor</span>(i));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);  <span class="comment">// Run for a while</span></span><br><span class="line">    exec.shutdownNow();         <span class="comment">// All Accessors will quit</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">#0: 9259</span></span><br><span class="line"><span class="comment">#1: 556</span></span><br><span class="line"><span class="comment">#2: 6694</span></span><br><span class="line"><span class="comment">#3: 1862</span></span><br><span class="line"><span class="comment">#4: 962</span></span><br><span class="line"><span class="comment">#0: 9260</span></span><br><span class="line"><span class="comment">#1: 557</span></span><br><span class="line"><span class="comment">#2: 6695</span></span><br><span class="line"><span class="comment">#3: 1863</span></span><br><span class="line"><span class="comment">#4: 963</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象的内容，其中，get()方法将返回与其线程相关联的对象的副本，而set()会将参数插入到为其线程存储的对象种，并返回存储中原有的对象。上面increment()和get()方法在ThreadLocalVariableHolder种演示了这一点。注意，increment()和get()方法都不是synchronized的，因为ThreadLocal保证不会出现竞争条件</li>
</ul>
</blockquote>
<h3 id="21-4-终结任务"><a href="#21-4-终结任务" class="headerlink" title="21.4 终结任务"></a><strong>21.4 终结任务</strong></h3><p><strong>21.4.2 在阻塞时终结</strong></p>
<blockquote>
<ul>
<li>slepp()是一种情况，它使任务从执行状态变为被阻塞状态，而有时你必须终止被阻塞的状态。</li>
</ul>
</blockquote>
<p><strong>线程状态</strong></p>
<blockquote>
<p>一个线程可以处于以下四种状态之一：</p>
<ol>
<li>&#x3D;&#x3D;新建（new）:&#x3D;&#x3D;当线程被创建时，它只会短暂的处于这种状态。此时它已经分配了必需的系统资源，并执行了初始化。此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。</li>
<li>&#x3D;&#x3D;就绪（Runnable）&#x3D;&#x3D;:在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程，它就可以运行；这不同于死亡和阻塞状态。</li>
<li>&#x3D;&#x3D;阻塞（Blocked）&#x3D;&#x3D;:线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间。直到线程重新进入了就绪状态，它才有可能执行操作。</li>
<li>&#x3D;&#x3D;死亡（Dead）&#x3D;&#x3D;:处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已结束，或不再是可运行的。任务死亡的方式通常时从run()方法返回，但是任务的线程还可以被中断，你将要看到这一点。</li>
</ol>
</blockquote>
<p><strong>进入阻塞状态</strong></p>
<blockquote>
<p>一个任务进入阻塞状态，可能有如下原因：</p>
<ol>
<li>通过调用sleep(millseconds)是任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。</li>
<li>通过调用wait()是现成挂起。直到线程得到了notify()或notifyAll()消息（或者在JavaSE5的java.util.concurrent类库中等价的signal()或signalAll()消息），线程才会进行就绪状态。</li>
<li>任务在等待某个输入&#x2F;输出完成。</li>
<li>任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。</li>
</ol>
</blockquote>
<p><strong>21.4.3 中断</strong></p>
<blockquote>
<ul>
<li>在Runable.run()方法的中间打断它，与等待该方法到达棘手的多。因为当打断被阻塞的任务时，可能需要清理资源。</li>
<li>Thread类包含interrupt()方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态。如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptException.当抛出该异常或者该任务调用Thread.interrupted()时，中断状态将被复位。所以Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SleepBlocked</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;InterruptedException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Exiting SleepBlocked.run()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOBlocked</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> InputStream in;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">IOBlocked</span><span class="params">(InputStream is)</span> &#123; in = is; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      print(<span class="string">&quot;Waiting for read():&quot;</span>);</span><br><span class="line">      in.read();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        print(<span class="string">&quot;Interrupted from blocked I/O&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Exiting IOBlocked.run()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedBlocked</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) <span class="comment">// Never releases lock</span></span><br><span class="line">      Thread.<span class="keyword">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SynchronizedBlocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        f(); <span class="comment">// Lock acquired by this thread</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Trying to call f()&quot;</span>);</span><br><span class="line">    f();</span><br><span class="line">    print(<span class="string">&quot;Exiting SynchronizedBlocked.run()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interrupting</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span></span><br><span class="line">    Executors.newCachedThreadPool();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Runnable r)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    Future&lt;?&gt; f = exec.submit(r);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    print(<span class="string">&quot;Interrupting &quot;</span> + r.getClass().getName());</span><br><span class="line">    f.cancel(<span class="literal">true</span>); <span class="comment">// Interrupts if running</span></span><br><span class="line">    print(<span class="string">&quot;Interrupt sent to &quot;</span> + r.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">SleepBlocked</span>());</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">IOBlocked</span>(System.in));</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">SynchronizedBlocked</span>());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    print(<span class="string">&quot;Aborting with System.exit(0)&quot;</span>);</span><br><span class="line">    System.exit(<span class="number">0</span>); <span class="comment">// ... since last 2 interrupts failed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (95% match)</span></span><br><span class="line"><span class="comment">Interrupting SleepBlocked</span></span><br><span class="line"><span class="comment">InterruptedException</span></span><br><span class="line"><span class="comment">Exiting SleepBlocked.run()</span></span><br><span class="line"><span class="comment">Interrupt sent to SleepBlocked</span></span><br><span class="line"><span class="comment">Waiting for read():</span></span><br><span class="line"><span class="comment">Interrupting IOBlocked</span></span><br><span class="line"><span class="comment">Interrupt sent to IOBlocked</span></span><br><span class="line"><span class="comment">Trying to call f()</span></span><br><span class="line"><span class="comment">Interrupting SynchronizedBlocked</span></span><br><span class="line"><span class="comment">Interrupt sent to SynchronizedBlocked</span></span><br><span class="line"><span class="comment">Aborting with System.exit(0)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面的每个任务都表示了一种不同类型的阻塞。SleepBlock是可终端的阻塞示例，而IOBlocked和SynchronizedBlocked是不可中断的阻塞示例。所以证明了I&#x2F;O和在synchronized块上的等待是不可中断的，但是通过浏览代码，也可以预见到这一点——无论是I&#x2F;O还是尝试调用synchronized方法，都不需要任何InterruptedException处理器。</p>
</li>
<li><p>从输出中可以看到，你能够中断对sleep()的调用（或者任何要求抛出InterruptedException的调用）。但是你不能中断正在试图获取synchronized锁或者试图执行I&#x2F;O操作的线程。这令人烦恼，特别是在创建执行I&#x2F;O的任务时，因为这意味着I&#x2F;O具有锁住你的多线程程序的潜在可能性。特别是对基于Web的程序，这更是关乎利害。</p>
</li>
<li><p>对于这类问题，有一个略显笨拙但是有时确实行之有效的解决方案，即&#x3D;&#x3D;关闭任务在其上发生阻塞的底层资源&#x3D;&#x3D;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseResource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">socketInput</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).getInputStream();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">IOBlocked</span>(socketInput));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">IOBlocked</span>(System.in));</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    print(<span class="string">&quot;Shutting down all threads&quot;</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    print(<span class="string">&quot;Closing &quot;</span> + socketInput.getClass().getName());</span><br><span class="line">    socketInput.close(); <span class="comment">// Releases blocked thread</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    print(<span class="string">&quot;Closing &quot;</span> + System.in.getClass().getName());</span><br><span class="line">    System.in.close(); <span class="comment">// Releases blocked thread</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (85% match)</span></span><br><span class="line"><span class="comment">Waiting for read():</span></span><br><span class="line"><span class="comment">Waiting for read():</span></span><br><span class="line"><span class="comment">Shutting down all threads</span></span><br><span class="line"><span class="comment">Closing java.net.SocketInputStream</span></span><br><span class="line"><span class="comment">Interrupted from blocked I/O</span></span><br><span class="line"><span class="comment">Exiting IOBlocked.run()</span></span><br><span class="line"><span class="comment">Closing java.io.BufferedInputStream</span></span><br><span class="line"><span class="comment">Exiting IOBlocked.run()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在shutdownNow()被调用之后，以及在两个输入流撒谎给你调用close()之前的延迟强调的是一旦底层资源被关闭，任务将接触阻塞。interrupt()看起来发生在关闭Socket而不是关闭System.in的时刻。这是由18章介绍的各种nio类提供了更人性化的I&#x2F;O中断。被阻塞的nio通道会自动地响应中断。</p>
</li>
<li><p>如你所见，&#x3D;&#x3D;还可以通过关闭底层资源以释放锁&#x3D;&#x3D;，尽管和种做法一般不是必需地。注意使用execute()来启动两个任务，并调用e.shutdownNow()将可以很容易地终止所有事物，而对于捕获上面实例中地Future，只有将中断发送给一个线程，同时不发送给另一个线程时才是必需地。</p>
</li>
</ul>
</blockquote>
<p><strong>被互斥所阻塞</strong></p>
<blockquote>
<ul>
<li>就像在Interrupting.java中看到地，如果你尝试着在一个对象上调用其synchronized方法，而这个对象地锁已经被其他任务所获得，那么调用任务将被挂起（阻塞），直至这个锁可获得。下面的示例说明了同一个互斥可以如何能被同一个任务多次获得：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiLock</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      print(<span class="string">&quot;f1() calling f2() with count &quot;</span> + count);</span><br><span class="line">      f2(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      print(<span class="string">&quot;f2() calling f1() with count &quot;</span> + count);</span><br><span class="line">      f1(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MultiLock</span> <span class="variable">multiLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiLock</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        multiLock.f1(<span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 9</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 8</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 7</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 6</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 5</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 4</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 3</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 2</span></span><br><span class="line"><span class="comment">f1() calling f2() with count 1</span></span><br><span class="line"><span class="comment">f2() calling f1() with count 0</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在main()中创建了一个调用f()地Thread,然后f1()和f2()互相调用直至count变为0.由于这个任务已经在第一个对f1()的调用中获得了multiLock对象锁，因此同一个任务将在对f2()的调用中再次获取这个锁，依次类推，这么做是有意义的，因为一个任务应该能够调用在同一个对象中的其他的synchronized方法，而这个任务已经持有锁了。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>就像前面在不可中断的I&#x2F;O中所观察到的那样，无论在任何时刻，只要任务以不可中断的方式被阻塞，那么都有潜在的会锁柱程序的可能。&#x3D;&#x3D;Java SE5并发库中添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力，这与在synchronized方法或临界区上阻塞的任务完全不同&#x3D;&#x3D;。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockedMutex</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BlockedMutex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Acquire it right away, to demonstrate interruption</span></span><br><span class="line">    <span class="comment">// of a task blocked on a ReentrantLock:</span></span><br><span class="line">    lock.lock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// This will never be available to a second task</span></span><br><span class="line">      lock.lockInterruptibly(); <span class="comment">// Special call  用来获取锁定，</span></span><br><span class="line">      print(<span class="string">&quot;lock acquired in f()&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Interrupted from lock acquisition in f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blocked2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="type">BlockedMutex</span> <span class="variable">blocked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockedMutex</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Waiting for f() in BlockedMutex&quot;</span>);</span><br><span class="line">    blocked.f();</span><br><span class="line">    print(<span class="string">&quot;Broken out of blocked call&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interrupting2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Blocked2</span>());</span><br><span class="line">    t.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Issuing t.interrupt()&quot;</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Waiting for f() in BlockedMutex</span></span><br><span class="line"><span class="comment">Issuing t.interrupt()</span></span><br><span class="line"><span class="comment">Interrupted from lock acquisition in f()</span></span><br><span class="line"><span class="comment">Broken out of blocked call</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>BlockedMutex类有一个构造器，它要获取所拆挂那件对象上自身的Lock，并且从不释放这个锁。出于这个原因，如果你试图从第二个任务中调用f()（不同于创建这个BlockedMutex的任务），那么将会总是因Mutex不可获得而被阻塞。在Blocked2中，run()方法总是总是在调用blocked.f()的地方停止。当运行这个程序时，你将会看到，与I&#x2F;O调用不同，interrupt()可以打破被互斥所阻塞的调用。</li>
</ul>
</blockquote>
<p><strong>21.4.4 检查中断</strong></p>
<blockquote>
<ul>
<li>注意：当你在线程上调用interrupt()时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时（如前面所见，除了不可中断的I&#x2F;O或被阻塞的synchronized方法之外，在其余的例外情况下，你无可事事）。因此，如果你调用interrupt()已停止某个任务，那么在run()循环碰巧没有产生任何阻塞调用的情况下，你的任务将需要第二种方式来退出。</li>
<li>这种机会是由中断状态来表示的，其状态可以通过调用interrupted()来设置。你可以通过调用interrupted来检查中断状态，这不仅可以告诉你interrupt()是否被调用过，而且还可以清除中断状态。清除中断状态可以确保并发结构不会就，某个任务被中断这个问题通知你两次，你可以经由单一的InterruptedException或单一的成功的Thread.interrupted()测试来得到这种通知。如果想要再次检查以了解是否被中断，则可以在调用Thread.interrupted()时将结果存储起来，</li>
</ul>
</blockquote>
<h3 id="21-5-线程之间的协作"><a href="#21-5-线程之间的协作" class="headerlink" title="21.5 线程之间的协作"></a>21.5 线程之间的协作</h3><blockquote>
<ul>
<li>正如前面所见到的，当使用线程来同时运行多个任务时，可以通过使用锁（互斥）来同步两个任务的行为，从而使得一个任务不会干涉另一个任务的资源。</li>
<li>接下来时&#x3D;&#x3D;学习如何使任务彼此之间可以协作，以使得任务可以一起取解决某个问题&#x3D;&#x3D;。现在的问题不是彼此之间的干涉，而是彼此之间的协调，因为这类问题中，某些部分必须在其他部分被解决之前解决。在这些任务中，某些可以并行执行，但是某些步骤需要所有的任务都结束之后才能开动。</li>
<li>当任务协作时，关键问题是这些任务之间的握手。为了实现这种握手，我们使用了相同的基础特性：互斥。在这种情况下，互斥能够确保只有一个任务可以响应某个信号。，这样就可以根除任何可能的竞争条件。在互斥之上，我们为任务添加了一种途径，可以将自身挂起，直至某些外部条件发生变化，表示是时候让这个任务向前开动了为止。</li>
<li>在本节，我们将浏览任务间的握手，这种握手可以通过Object的方法wait()和notify()来安全地实现。Java SE5并发类库换提供了具有await()和signal()方法的Condition对象。</li>
</ul>
</blockquote>
<p><strong>21.5.1 wait()与notifyAll()</strong></p>
<blockquote>
<ul>
<li><p>wait()使你可以等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。通常，这种条件由另一个任务来改变。因此wait()会在等待外部世界产生变化的时候将任务挂起，并且只有在notify()或notifyAll()发生时，即表示发生了某些感兴趣的事物。这个任务才会被唤醒并去检查所产生的变化。因此，wait()提供了一种在任务之间对活动同步的方式。</p>
</li>
<li><p>&#x3D;&#x3D;调用sleep()的时候并没有被释放，调用yield()也属于这种情况&#x3D;&#x3D;，理解这一点很重要。另一方面，当一个任务在方法里遇到了&#x3D;&#x3D;对wait()的调用的时候，线程的执行被挂起，对象上的锁被释放&#x3D;&#x3D;。因为wait()将释放锁，这就意味着另一个任务可以获得这个锁，因此在该对象（现在是未锁顶的）中的其他synchronized方法可以在wait()期间被调用。这一点至关重要，因为这些其他的方法通常将会产生改变，而这种改变正是使被挂起的任务重新唤醒所感兴趣的变化。因此，&#x3D;&#x3D;当你调用wait()时，就是在声明：“我已经刚刚做完能做的所有事情，因此我要在这里等待，但是我希望其他的synchronized操作在条件适合的情况下能够执行。”&#x3D;&#x3D;</p>
</li>
<li><p>有两种形式的wait().第一种版本接受毫秒数作为参数，含义与sleep()方法里参数的意思相同，都是指“在此期间暂停”，但是与sleep()不同的是，对于wait()而言：</p>
<ol>
<li>在wait()期间对象锁是释放的。</li>
<li>可以通过notify(),notifyAll(),或者令时间到期，从wait()中恢复执行。</li>
</ol>
</li>
<li><p>第二种，也是更常用形式的wait()不接受任何参数。这种wait()将无限等待下去，直到线程接受到notify()或者notifyAll()消息</p>
</li>
<li><p>这些方法是基类Object的一部分。因为这些方法操作的锁也是所有对象的一部分，所以，你可以把wait()放进任何同步控制方法里，而不用考虑这个类是继承自Thread还是实现了Runnable接口。实际上，只能在同步控制方法或同步控制块里调用wait()，notify(),notifyAll()（因为不用操作锁，所以sleep()可以在非同步控制方法里调用）。如果在非同步控制方法里调用这些方法，程序能通过编译，但运行的时候，将得到IllegalMonitorStateException异常，并伴随着一些含糊的消息，比如“当前线程不是拥有者”。消息的意思是，调用这个方法钱必需拥有获取（获取）对象的锁。</p>
</li>
<li><p>可以让另一个对象执行某种操作以维护其自己的锁。要这么做的话，必需首先得到对象的锁。如果要向对象x发送notifyAll()，那么就必须在能够取得x的锁的同步控制快中这么做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(x)&#123;</span><br><span class="line">	x.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面有一个讲解的示例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">waxOn</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waxed</span><span class="params">()</span> &#123;</span><br><span class="line">    waxOn = <span class="literal">true</span>; <span class="comment">// Ready to buff</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buffed</span><span class="params">()</span> &#123;</span><br><span class="line">    waxOn = <span class="literal">false</span>; <span class="comment">// Ready for another coat of wax</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForWaxing</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">while</span>(waxOn == <span class="literal">false</span>)</span><br><span class="line">      wait();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForBuffing</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">while</span>(waxOn == <span class="literal">true</span>)</span><br><span class="line">      wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOn</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOn</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        printnb(<span class="string">&quot;Wax On! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.waxed();</span><br><span class="line">        car.waitForBuffing();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax On task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOff</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        car.waitForWaxing();</span><br><span class="line">        printnb(<span class="string">&quot;Wax Off! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.buffed();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax Off task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaxOMatic</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOff</span>(car));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOn</span>(car));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// Run for a while...</span></span><br><span class="line">    exec.shutdownNow(); <span class="comment">// Interrupt all tasks</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (95% match)</span></span><br><span class="line"><span class="comment">Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax On task</span></span><br><span class="line"><span class="comment">Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax Off task</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>前面的示例强调你必须用一个检查感兴趣的条件的while循环包围wait()。这很重要，因为：<ul>
<li>你可能有多个任务出于相同的原因在等待同一个锁，而第一个唤醒任务可能会改变这种状况（即使你没有这么做，有人也会通过继承你的类去这么做）。如果属于这种情况，那么这个任务应该被再次挂起，直至感兴趣的条件发生变化。</li>
<li>在这个任务从其wait()中被唤醒的时刻，有可能会有某个其他的任务已经做出了改变，从而使得这个任务在此时不能执行，或者执行其操作已显得无关紧要。此时，应该通过再次调用wait()来将其重新挂起。</li>
<li>也有可能某些任务出于不同的原因在等待你的对象上的锁（在这种情况下必须使用notifyAll()）。在这种情况下，你需要检查是否已经由正确的原因唤醒，如果不是，就再次调用wait()</li>
</ul>
</li>
<li>因此，其本质就是要检查所感兴趣的特定条件，并在条件不满足的情况下返回到wait()中，惯用的方法就是使用while来编写这种代码。</li>
</ul>
</blockquote>
<p><strong>错失的信号</strong></p>
<blockquote>
<p>当两个线程使用notify()&#x2F;wait()或notifyAll()&#x2F;wait()进行协作时，有可能会错过某个信号。假设T1是通知T2的线程，而这两个线程都是使用下面（有缺陷的）方式实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T1:</span><br><span class="line"><span class="keyword">synchronized</span>(shareMonitor)&#123;</span><br><span class="line">	&lt;setup condition <span class="keyword">for</span> T2&gt;</span><br><span class="line">	shareMonitor.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2:</span><br><span class="line"><span class="keyword">while</span>(someCondition)&#123;</span><br><span class="line">	<span class="comment">//Point1</span></span><br><span class="line">	<span class="keyword">synchronized</span>(sharedMonitor)&#123;</span><br><span class="line">		sharedMonitor.wait();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><setup condition for T2>是防止T2调用wait()的一个操作，当然前提是T2还没有调用wait()。</li>
<li>假设T2对someCondition求值并发现其为true.在Point1里，线程调度器可能切换到了T1,而T1将执行其设置，然后调用notify()。当T2继续执行时，此时对于T2来说，时机已经太晚了，以至于不能意识到条件已经发生了变化，因此会盲目进入到wait()。此时notify()将错失，而T2也将无限的等待这个已经发送过的信号，从而产生死锁。</li>
<li>该问题的解决方案是防止在someCondition变量上产生竞争条件。下面是T2正确的执行方式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(sharedMonitor)&#123;</span><br><span class="line">	<span class="keyword">while</span>(someCondition)&#123;</span><br><span class="line">		sharedMonitor.wait();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在，如果T1首先执行，当控制返回T2时，它将发现条件发生了变化，从而不会进入wait().反过来，如果T2首先执行，那它将进入wait(),并且稍后会有T1唤醒，因此，信号不会错失。</li>
</ul>
</blockquote>
<p><strong>21.5.2 notify()与notifyAll()</strong></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;因为在技术上，可能有多个任务在单个Car对象上处于wait()状态，因此调用notifyAll()比只调用notify()要更安全&#x3D;&#x3D;。但是，上面程序的结构只会有一个任务实际处于wait()状态，因此你可以使用notify()来代替notifyAll()。</li>
<li>使用notify()而不是notifyAll()是一种优化，使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒，因此如果你希望用notify()，就必须保证唤醒的是恰当的任务。另外，为了使用notify()，所有任务必须等待相同的条件，因为如果你有多个任务在等待不同的条件，那么你就不会指代是否唤醒了恰当的任务。如果使用notify()，当条件发生变化时，必须只有一个任务从中受益。最后，这些限制对所有可能存在的子类都必须总是起作用的。如果这些规则中有任何一条不满足，那么你就必须使用notifyAll()而不是notify()。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Blocker</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitingCall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">          <span class="comment">//这里会有多个任务被挂起。</span></span><br><span class="line">        wait();</span><br><span class="line">        System.out.print(Thread.currentThread() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">// OK to exit this way</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">prod</span><span class="params">()</span> &#123; notify(); &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">prodAll</span><span class="params">()</span> &#123; notifyAll(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Blocker</span> <span class="variable">blocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blocker</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; blocker.waitingCall(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="comment">// A separate Blocker object:</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Blocker</span> <span class="variable">blocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blocker</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; blocker.waitingCall(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyVsNotifyAll</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">Task2</span>());</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">prod</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prod) &#123;</span><br><span class="line">          System.out.print(<span class="string">&quot;\nnotify() &quot;</span>);</span><br><span class="line">          Task.blocker.prod();</span><br><span class="line">          prod = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.print(<span class="string">&quot;\nnotifyAll() &quot;</span>);</span><br><span class="line">          Task.blocker.prodAll();</span><br><span class="line">          prod = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">400</span>, <span class="number">400</span>); <span class="comment">// Run every .4 second</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// Run for a while...</span></span><br><span class="line">    timer.cancel();</span><br><span class="line">    System.out.println(<span class="string">&quot;\nTimer canceled&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;Task2.blocker.prodAll() &quot;</span>);</span><br><span class="line">    Task2.blocker.prodAll();</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\nShutting down&quot;</span>);</span><br><span class="line">    exec.shutdownNow(); <span class="comment">// Interrupt all tasks</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main]</span></span><br><span class="line"><span class="comment">notify() Thread[pool-1-thread-1,5,main]</span></span><br><span class="line"><span class="comment">notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread-2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main]</span></span><br><span class="line"><span class="comment">Timer canceled</span></span><br><span class="line"><span class="comment">Task2.blocker.prodAll() Thread[pool-1-thread-6,5,main]</span></span><br><span class="line"><span class="comment">Shutting down</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>浏览Blocker中的prod()和prodAll()，就会发现这是有意义的。这些方法是synchronized的，这意味着他们将获取自身的锁，因此当它们调用notify()或notifyAll()时，只在这个锁上调用是符合逻辑的——因此，将脂环星在等待这个特定锁的任务。</li>
</ul>
</blockquote>
<p><strong>21.5.3 生产者与消费者</strong></p>
<blockquote>
<ul>
<li>有一个饭店，他有一个厨师和一个服务员。这个服务员必须等待厨师准备好膳食。当厨师准备好时，他会通知服务员，之后服务员上菜，然后返回继续等待。这是一个任务协作的示例：厨师代表生产者，而服务员代表消费者。两个任务必须在膳食被生产和消费时进行握手，而系统必须以有序的方式关闭。下面是对这个叙述建模的代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> orderNum;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Meal</span><span class="params">(<span class="type">int</span> orderNum)</span> &#123; <span class="built_in">this</span>.orderNum = orderNum; &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Meal &quot;</span> + orderNum; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitPerson</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaitPerson</span><span class="params">(Restaurant r)</span> &#123; restaurant = r; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(restaurant.meal == <span class="literal">null</span>)</span><br><span class="line">            wait(); <span class="comment">// ... for the chef to produce a meal</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">&quot;Waitperson got &quot;</span> + restaurant.meal);</span><br><span class="line">        <span class="keyword">synchronized</span>(restaurant.chef) &#123;</span><br><span class="line">          restaurant.meal = <span class="literal">null</span>;</span><br><span class="line">          restaurant.chef.notifyAll(); <span class="comment">// Ready for another</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;WaitPerson interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chef</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Chef</span><span class="params">(Restaurant r)</span> &#123; restaurant = r; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(restaurant.meal != <span class="literal">null</span>)</span><br><span class="line">            wait(); <span class="comment">// ... for the meal to be taken</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++count == <span class="number">10</span>) &#123;</span><br><span class="line">          print(<span class="string">&quot;Out of food, closing&quot;</span>);</span><br><span class="line">          restaurant.exec.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">        printnb(<span class="string">&quot;Order up! &quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(restaurant.waitPerson) &#123;</span><br><span class="line">          restaurant.meal = <span class="keyword">new</span> <span class="title class_">Meal</span>(count);</span><br><span class="line">          restaurant.waitPerson.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Chef interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line">  Meal meal;</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">  <span class="type">WaitPerson</span> <span class="variable">waitPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitPerson</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="type">Chef</span> <span class="variable">chef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chef</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Restaurant</span><span class="params">()</span> &#123;</span><br><span class="line">    exec.execute(chef);</span><br><span class="line">    exec.execute(waitPerson);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Restaurant</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 1</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 2</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 3</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 4</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 5</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 6</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 7</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 8</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 9</span></span><br><span class="line"><span class="comment">Out of food, closing</span></span><br><span class="line"><span class="comment">WaitPerson interrupted</span></span><br><span class="line"><span class="comment">Order up! Chef interrupted</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在前面的示例中，对于一个任务而言，只有一个单一的地点用于存放对象，从而使得另一个任务稍后可以使用这个对象。但是，在典型的生产者-消费者实现中，应使用先进先出队列来存储被生产和消费的对象。</li>
</ul>
</blockquote>
<p><strong>使用显式的Lock和Condition对象</strong></p>
<blockquote>
<ul>
<li>在Java SE5的java.util.concurrent类库中还有额外的显式工具可以用来重写WaxOMatic.java。使用互斥并允许任务挂起的基本类是Condition,你可以通过在Condition上调用await()来挂起一个任务。当外部条件发生变化，意味着某个任务应该继续执行时，你可以通过调用signal()来同这个任务，从而唤醒一个任务，或者调用signalAll()来唤醒所有在这个Condition上被其自身挂起的任务（与使用notifyAll相比，signallAll是更安全的方式）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">waxOn</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waxed</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      waxOn = <span class="literal">true</span>; <span class="comment">// Ready to buff</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buffed</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      waxOn = <span class="literal">false</span>; <span class="comment">// Ready for another coat of wax</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitForWaxing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(waxOn == <span class="literal">false</span>)</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitForBuffing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(waxOn == <span class="literal">true</span>)</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOn</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOn</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        printnb(<span class="string">&quot;Wax On! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.waxed();</span><br><span class="line">        car.waitForBuffing();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax On task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaxOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaxOff</span><span class="params">(Car c)</span> &#123; car = c; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        car.waitForWaxing();</span><br><span class="line">        printnb(<span class="string">&quot;Wax Off! &quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.buffed();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Ending Wax Off task&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaxOMatic2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOff</span>(car));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">WaxOn</span>(car));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax Off task</span></span><br><span class="line"><span class="comment">Exiting via interrupt</span></span><br><span class="line"><span class="comment">Ending Wax On task</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在Car的构造器中，单个的Lock将产生一个Condition对象，这个对象被用来管理任务间的通信。但是，这个Condition对象不包含任何有关处理状态的信息，因此你需要管理额外的表示处理状态的信息，即boolean wanOn.</li>
<li>每个对lock()的调用都必须紧跟一个try-finally子句，用来保证在所有情况下都可以释放锁。在使用内建版本时，任务在可以调用await(),signal()或signalAll()之前，必须拥有这个锁。</li>
</ul>
</blockquote>
<p><strong>21.5.4 生产者-消费者与队列</strong></p>
<blockquote>
<ul>
<li>wait()与notifyAll()方法以一种非常低级的方式解决了任务互操作问题，即每次交互时都握手。在许多情况下，可以瞄向更高的抽象级别，&#x3D;&#x3D;使用同步队列来解决任务协作问题，同步队列在任何时刻都只允许一个任务插入或移除元素。&#x3D;&#x3D;在java.util.concurrent.BlockingQueue接口中提供了这个队列，这个接口有大量的标准实现。通常可以使用LinkedBlockingQueue,它是一个无界队列，还可以使用ArrayBlockingQueue,它具有固定的尺寸，因此你可以在它被阻塞之前，向其中放置有限数量的元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LiftOffRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> BlockingQueue&lt;LiftOff&gt; rockets;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">LiftOffRunner</span><span class="params">(BlockingQueue&lt;LiftOff&gt; queue)</span> &#123;</span><br><span class="line">    rockets = queue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(LiftOff lo)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rockets.put(lo);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Interrupted during put()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="type">LiftOff</span> <span class="variable">rocket</span> <span class="operator">=</span> rockets.take();</span><br><span class="line">        rocket.run(); <span class="comment">// Use this thread</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">&quot;Waking from take()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;Exiting LiftOffRunner&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBlockingQueues</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getkey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Compensate for Windows/Linux difference in the</span></span><br><span class="line">      <span class="comment">// length of the result produced by the Enter key:</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)).readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(java.io.IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getkey</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    print(message);</span><br><span class="line">    getkey();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">  <span class="title function_">test</span><span class="params">(String msg, BlockingQueue&lt;LiftOff&gt; queue)</span> &#123;</span><br><span class="line">    print(msg);</span><br><span class="line">    <span class="type">LiftOffRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiftOffRunner</span>(queue);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runner);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      runner.add(<span class="keyword">new</span> <span class="title class_">LiftOff</span>(<span class="number">5</span>));</span><br><span class="line">    getkey(<span class="string">&quot;Press &#x27;Enter&#x27; (&quot;</span> + msg + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">    print(<span class="string">&quot;Finished &quot;</span> + msg + <span class="string">&quot; test&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="string">&quot;LinkedBlockingQueue&quot;</span>, <span class="comment">// Unlimited size</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;LiftOff&gt;());</span><br><span class="line">    test(<span class="string">&quot;ArrayBlockingQueue&quot;</span>, <span class="comment">// Fixed size</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;LiftOff&gt;(<span class="number">3</span>));</span><br><span class="line">    test(<span class="string">&quot;SynchronousQueue&quot;</span>, <span class="comment">// Size of 1</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;LiftOff&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>各个人物由main()放置到了BlockingQueue中，并且由LiftOffRunner从BlockingQueue中取出。注意，LiftOffRunner可以忽略同步问题，因为它们已经由BlockingQueue解决了。</li>
</ul>
</blockquote>
<p><strong>21.5.5 任务间使用管道进行输入&#x2F;输出</strong></p>
<blockquote>
<ul>
<li>通过输入&#x2F;输出在线程间进行通信通常很有用。提供县城额功能的类库以“管道”的形式对线程间的输入&#x2F;输出提供了支持。它们在Java输入&#x2F;输出类库中的对应物就是PipedWriter类（允许任务向管道写）和PipedReader类（允许不同任务从同一个管道中读取）。管道基本上是一个阻塞队列，存在于多个引入BlockingQueue之前的Java版本中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="type">PipedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">  <span class="keyword">public</span> PipedWriter <span class="title function_">getPipedWriter</span><span class="params">()</span> &#123; <span class="keyword">return</span> out; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">          out.write(c);</span><br><span class="line">          TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      print(e + <span class="string">&quot; Sender write exception&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(e + <span class="string">&quot; Sender sleep interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> PipedReader in;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Receiver</span><span class="params">(Sender sender)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    in = <span class="keyword">new</span> <span class="title class_">PipedReader</span>(sender.getPipedWriter());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// Blocks until characters are there:</span></span><br><span class="line">        printnb(<span class="string">&quot;Read: &quot;</span> + (<span class="type">char</span>)in.read() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      print(e + <span class="string">&quot; Receiver read exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipedIO</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>();</span><br><span class="line">    <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>(sender);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(sender);</span><br><span class="line">    exec.execute(receiver);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (65% match)</span></span><br><span class="line"><span class="comment">Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read: G, Read: H, Read: I, Read: J, Read: K, Read: L, Read: M, java.lang.InterruptedException: sleep interrupted Sender sleep interrupted</span></span><br><span class="line"><span class="comment">java.io.InterruptedIOException Receiver read exception</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Sender和Receiver代表了需要互相通信两个任务，Sender创建了一个PipedWriter,它是一个单独的对象。但是对于Receiver,PipedReader的建立必须在构造器中与一个PipedWriter相关联。Sender把数据放进Writer。</li>
<li>在shutdownNow()被调用时，可以看到PipedReader与普通I&#x2F;O之间最重要的差异——PipedReader是可中断的。如果你将将in.read()调用修改为System.in.read()，那么interrupt()将不能打断read()调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CharQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Character&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">CharQueue</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharQueue</span>();</span><br><span class="line">    <span class="keyword">public</span> CharQueue <span class="title function_">getQueue</span><span class="params">()</span> &#123; <span class="keyword">return</span> out; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                    out.put(c);</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e + <span class="string">&quot; Sender interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CharQueue in;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Receiver</span><span class="params">(Sender sender)</span> &#123; in = sender.getQueue(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// Blocks until characters are there:</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Read: &quot;</span> + in.take() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e + <span class="string">&quot; Reader interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E30_SendReceive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>();</span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>(sender);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(sender);</span><br><span class="line">        exec.execute(receiver);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read:</span></span><br><span class="line"><span class="comment">G, Read: H, Read: I, Read: J, Read: K, Read: L, Read: M,</span></span><br><span class="line"><span class="comment">Read: N, Read: O, Read: P, Read: Q,</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException Reader interrupted</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException: sleep interrupted Sender</span></span><br><span class="line"><span class="comment">interrupted</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="21-6-死锁"><a href="#21-6-死锁" class="headerlink" title="21.6 死锁"></a>21.6 死锁</h3><blockquote>
<ul>
<li>哲学家就餐问题。</li>
<li>当下列四个条件满足时，就会产生死锁：<ul>
<li>互斥条件。任务使用的资源中至少有一个是不能共享的。这里一根筷子一次只能欸一个哲学家使用。</li>
<li>至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源。ye就是说，要发生死锁，哲学家必须拿着一根筷子并且等待另一根</li>
<li>资源不能被任务抢占，任务必须把资源释放当作普通事件。哲学家很有礼貌，它们不会从其他哲学家那里抢筷子</li>
<li>必须有循环等待，这时一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，直到有一个任务在等待第一个任务所持有的资源，使得大家都被锁住。因为哲学家们默认都是先得到右边的筷子，然后得到左边的筷子，所以发生了循环等待。</li>
</ul>
</li>
<li>打破死锁的方法就是消除存在的循环等待问题。然而如果让最后一个哲学家是先拿左边的筷子，后拿右边的筷子就可以消除。</li>
</ul>
</blockquote>
<h3 id="21-7-新类库中的构件"><a href="#21-7-新类库中的构件" class="headerlink" title="21.7 新类库中的构件"></a>21.7 新类库中的构件</h3><blockquote>
<ul>
<li>Java SE5的java.util.concurrent引入了大量设计来解决并发问题的新类。</li>
</ul>
</blockquote>
<p><strong>21.7.1 CountDownLatch</strong></p>
<blockquote>
<ul>
<li>他被用用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。</li>
<li>可以向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()的方法都将阻塞，直至这个计数值到达0.其他任务在结束其工作时，可以在该对象上调用countDown()来减少这个计数值。&#x3D;&#x3D;CountDownLatch被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用CyclicBarrier.&#x3D;&#x3D;</li>
<li>调用countDown()的任务在产生这个调用时并没有被阻塞，只有对awit()的调用会被阻塞，直至计数值到达0.</li>
<li>CountDownLatch的典型用法是将一个程序分为n个互相独立的可解决任务，并创建值为0的CountDownLatch。当每个任务完成时，都会在这个锁存器上调用countDown()。等待问题被解决的任务在这个锁存器上调用await()，将它们自己拦住，直至锁存器计数结束。下面是演示这种奇数的一个框架示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskPortion</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> counter++;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">  TaskPortion(CountDownLatch latch) &#123;</span><br><span class="line">    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork();</span><br><span class="line">      latch.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">      <span class="comment">// Acceptable way to exit</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">2000</span>));</span><br><span class="line">    print(<span class="built_in">this</span> + <span class="string">&quot;completed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%1$-3d &quot;</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Waits on the CountDownLatch:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitingTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> counter++;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">  WaitingTask(CountDownLatch latch) &#123;</span><br><span class="line">    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      latch.await();</span><br><span class="line">      print(<span class="string">&quot;Latch barrier passed for &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">      print(<span class="built_in">this</span> + <span class="string">&quot; interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;WaitingTask %1$-3d &quot;</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// All must share a single CountDownLatch object:</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">WaitingTask</span>(latch));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> <span class="title class_">TaskPortion</span>(latch));</span><br><span class="line">    print(<span class="string">&quot;Launched all tasks&quot;</span>);</span><br><span class="line">    exec.shutdown(); <span class="comment">// Quit when all tasks complete</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* (Execute to see output) */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>TaskPortion将随机地休眠一段时间，以模拟这部分工作地完成，而WaitingTask表示系统中必须等待地部分，它要等待到问题地初始部分完成为止。所有任务都使用了在main()种定义地同一个单一地CountDownLatch。</li>
</ul>
</blockquote>
<p><strong>21.7.2 CyclicBarrier</strong></p>
<blockquote>
<ul>
<li>CyclicBarrier适用于这样地情况：你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成（看起来有些像join()）。它使得所有的并行任务都将在栅栏处列队，因此可以一致地向前移动。&#x3D;&#x3D;这非常像CountDownLatch,只是CountDownLatch是只触发一次地事件，而CyclicBarrier可以多次重用。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<p><strong>21.7.3 DelayQueue</strong></p>
<blockquote>
<ul>
<li>这是一个无界的BlockingQueue,用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素，并且poll()将返回null(正因为这样，你不能将null放置到这种队列中)</li>
<li>下面是一个示例，其中的Delayed对象自身就是任务，而DelayedTaskConsumer将最紧急的任务（到期时间最长的任务）从队列中取出，然乎运行它。注意，&#x3D;&#x3D;这样DelayQueue就成为了优先级队列的一种变体。&#x3D;&#x3D;</li>
<li>从输出的顺序可以看到，任务创建的顺序对执行顺序没有任何影响，任务是按照所期望的延迟顺序执行的。</li>
</ul>
</blockquote>
<p><strong>21.7.4 PriorityBlockingQueue</strong></p>
<blockquote>
<ul>
<li>这是一个很基础的优先队列，它具有可阻塞的读取操作。下面是一个示例，其中在优先级队列中的对象是按照优先级顺序从队列中出现的任务。PrioritedTask被赋予了一个优先级数字，以此来提供这种顺序。</li>
<li>与前一个示例相同，PrioritizedTask对象的创建序列被记录在sequence List中，用于和实际执行顺序比较。run()方法将休眠一小段时间，然后大一i你对象信息，而EndSentinel提供了和前面相同的功能，要确保它是队列中最后一个对象。而且这种队列提供了同步的功能。因此不需要有显式的同步。</li>
</ul>
</blockquote>
<p><strong>21.7.6 Semaphore</strong></p>
<blockquote>
<ul>
<li>正常的锁（来自concurrent.locks或内建的synchronized锁）在任何时刻都只允许一个任务访问一项资源，而计数信号量允许n个任务同时访问这个资源。你还可以将信号量看作是在向外分发使用资源的“许可证”，尽管实际上没有使用任何许可证对象。</li>
<li>作为一个示例，请考虑对象池的概念，它管理着数量有限的对象，当要使用对象时可以签出它们，而在用户使用完毕时，可以将它们签回。这种功能可以封装到一个泛型类中。</li>
</ul>
</blockquote>
<p><strong>21.7.7 Exchanger</strong></p>
<blockquote>
<ul>
<li>Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，他们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。Exchanger的典型应用场景是：一个任务在创建对象，这些对象的而生产代价很高昂，二零一个任务在消费这些对象。通过这种方式，可以有更多的对象在被创建的同时被消费。</li>
</ul>
</blockquote>
<h3 id="21-8-仿真"><a href="#21-8-仿真" class="headerlink" title="21.8 仿真"></a>21.8 仿真</h3><h3 id="21-9-性能调优"><a href="#21-9-性能调优" class="headerlink" title="21.9 性能调优"></a>21.9 性能调优</h3><blockquote>
<ul>
<li>在Java SE的java.util.concurrent类库中存在着数量庞大的用于性能提高的类。当你细读concurrent类库时就会发现很难辨认哪些类适用于常规应用（例如BlockingQueue）,而哪些类只适用于提高性能。</li>
</ul>
</blockquote>
<p><strong>21.9.1 比较各类互斥技术</strong></p>
<blockquote>
<ul>
<li>既然Java包括老式的synchronized关键字和Java SE5中新的Lock和Atomic类，那么比较这些不同的方式，更多地理解它们各自的价值和适用范围，就会显得很有意义。</li>
<li>适用Lock通常会比适用synchronized要高效的多，而且synchronized的开销看起来变化范围更大，而Lock相对比较一致。但是通常，为了代码阅读的高效性，适用synchronized的方式更多一点。而Lock和Atomic则适用的更少。</li>
</ul>
</blockquote>
<p><strong>21.9.2 免锁容器</strong></p>
<blockquote>
<ul>
<li><p>容器是所有编程中的基础工具，这其中自然也包括并发编程。处于这个原因，像Vector和Hashtable这类早期容器具有许多synchronized方法，当他们用于非多线程的应用程序中时，便会导致不可接受的开销。</p>
</li>
<li><p>Java SE5特别添加了新的容器，通过使用更灵巧的技术来消除加锁，从而提高线程安全的性能。</p>
</li>
<li><p>&#x3D;&#x3D;这些免锁容器背后的通用策略是&#x3D;&#x3D;：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。修改是在容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到 这个修改了。</p>
</li>
<li><p>在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而原数组将保留在原地，使得赋值的数组在被修改时，读取操作可以安全地执行。当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改。</p>
</li>
<li><p>CopyOnWriteArrayList的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationWxception，因此不必编写特殊的代码去防范这种异常，就想你之前必须坐的那样。</p>
</li>
<li><p>CopyOnWriteArraySet将使用CopyOnWriteArrayList来实现其免锁行为。</p>
</li>
<li><p>ConcurrentHashMap和ConcurrentLinkedQueue使用了类似的技术，允许并发的读取和写入，但是容器中只有部分内容而不是整个容器可以被复制和修改。然而，任何修改在完成之前，读取者仍旧不能看到它们。ConcurrentHashMap不会抛出ConcurrentModificationWxception。</p>
</li>
</ul>
</blockquote>
<p><strong>乐观锁</strong></p>
<blockquote>
<p>只要你主要是从免锁容器中读取，那么它就会比其synchronized对应物快许多，因为获取和释放锁的开销被省掉了。如果需要向免锁容器中执行少量写入，那么情况也仍旧如此。</p>
</blockquote>
<p><strong>比较各种Map实现</strong></p>
<blockquote>
<ul>
<li>我们可以使用相同的框架来得到synchronizedHashMap和ConcurrentHashMap在性能方面的比较结果。向ConcurrentHashMap添加写入者的影响甚至还不如CopyOnWriteArrayList明显，这是因为ConcurrentHashMap使用了一种不同的技术，它可以明显地最小化写入所造成的影响。</li>
</ul>
</blockquote>
<p><strong>21.9.3 乐观加锁</strong></p>
<blockquote>
<p>在正常情况下将使用互斥（synchronized或Lock）来放置多个任务同时修改一个对象，但是这里我们是乐观的，因为我们保持数据为未锁定状态，并希望没有任何其他任务插入修改它。所有这些又都是以性能的名义执行的——通过使用Atomic来替代synchronized或Lock,可以获得性能上的好处。</p>
</blockquote>
<p><strong>21.9.4 ReadWriteLock</strong></p>
<blockquote>
<ul>
<li>ReadWriteLock对向数据结构相对不频繁的写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为主。</li>
<li>ReadWriteLock是否能够提高程序的性能是完全不可确定的，它取决于诸如数据被读取的频率与被修改的频率相比较的结果，读取和写入操作的时间，有多少线程竞争以及是否在都哦系处理机器上运行等因素。最终，唯一可以了解是否能带来好处就是通过做实验。</li>
</ul>
</blockquote>
<h3 id="21-10-活动对象"><a href="#21-10-活动对象" class="headerlink" title="21.10 活动对象"></a>21.10 活动对象</h3><blockquote>
<p>有一种可替换的方式被称为活动对象或行动者。之所以称这些对象是活动的，是因为每个对象都维护者它自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中的一个。因此有了活动对象，我们就可以串行化消息而不是方法，这意味着不再需要防备一个任务在其循环的中间被中断这种问题了。</p>
</blockquote>
<h3 id="21-11-总结"><a href="#21-11-总结" class="headerlink" title="21.11 总结"></a>21.11 总结</h3><blockquote>
<ul>
<li>线程的一个额外好处是它们提供了轻量级的执行上下文切换（大约100条指令），而不是重量级的进程上下文切换（要上千条指令）。因为一个给定进程内的所有进程共享相同的内存空间，轻量级的上下文切换只是改变了程序的执行序列和局部变量。进程切换（重量级的上下文切换）必须改变所有内存空间。</li>
<li>多线程的主要缺陷有：<ul>
<li>等待共享资源的时候性能低</li>
<li>需要处理线程的额外CPU花费</li>
<li>糟糕的程序设计导致不必要的复杂度</li>
<li>有可能产生一些病态行为，如饿死，竞争，死锁和活锁（多个运行各自任务的线程使得整体无法完成）</li>
<li>不同平台导致的不一致性</li>
</ul>
</li>
<li>因为多个线程可能共享一个资源，比如一个对象的内存，而且你必须确定多个线程不会同时读取和改变这个资源，这就是线程产生的最大难题。</li>
</ul>
</blockquote>
<blockquote>
<p>创建Java对象的五种方式：</p>
<ol>
<li>使用new关键字</li>
<li>使用Class类的newInstance方法</li>
<li>使用Constructor类的newInstance方法</li>
<li>使用clone方法</li>
<li>使用反序列化</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/typora/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/" data-id="clrv16wjh000rz5ku64092n44" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; zurück</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 10px;">个人</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/27/test/">test</a>
          </li>
        
          <li>
            <a href="/2024/01/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/06/15/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/15/git%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/15/etcdRaft%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Kevin he<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>