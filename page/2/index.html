<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>侬的杂货铺</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="侬的杂货铺">
<meta property="og:url" content="https://kdhello07.github.io/page/2/index.html">
<meta property="og:site_name" content="侬的杂货铺">
<meta property="og:locale">
<meta property="article:author" content="Kevin he">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="侬的杂货铺" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">侬的杂货铺</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术、阅读、分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kdhello07.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-MySQL学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/27/MySQL%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-06-26T16:00:00.000Z" itemprop="datePublished">2022-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/27/MySQL%E5%AD%A6%E4%B9%A0/">MySQL学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>MySQL学习</p>
<h2 id="1-数据库概述"><a href="#1-数据库概述" class="headerlink" title="1.数据库概述"></a>1.数据库概述</h2><h3 id="1-RDBMS与非RDBMS"><a href="#1-RDBMS与非RDBMS" class="headerlink" title="1.RDBMS与非RDBMS"></a>1.RDBMS与非RDBMS</h3><blockquote>
<p>关系型数据库：</p>
<ul>
<li>这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）</li>
<li>关系型数据库以行和列的形式存储数据库，以便于用户理解，这一系列的行和列被称为表，一组表组成了一个库</li>
<li>表与表之间的数据记录有关系。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。</li>
<li>优势：<ul>
<li>复杂查询<ul>
<li>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询</li>
</ul>
</li>
<li>事务支持<ul>
<li>使得对于安全性能很高的数据访问要求得以实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>非关系型数据库：</p>
<ul>
<li>非关系型数据库可看成传统关系型数据库的功能，基于键值对存储数据，不需要经过SQL层的解析，性能非常高。</li>
<li>NoSQL泛指非关系型数据库，包含有键值型数据库（redis）、文档型数据库(mongodb,couchdb)、搜索引擎(Elasticsearch,solr)和列存储(Hbase)，还包括图形数据库(neo4j)。</li>
</ul>
</blockquote>
<h2 id="2-逻辑架构"><a href="#2-逻辑架构" class="headerlink" title="2.逻辑架构"></a>2.逻辑架构</h2><h3 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1.逻辑架构剖析"></a>1.逻辑架构剖析</h3><h4 id="1-1-服务器处理客户端请求"><a href="#1-1-服务器处理客户端请求" class="headerlink" title="1.1 服务器处理客户端请求"></a>1.1 服务器处理客户端请求</h4><blockquote>
<ul>
<li>首先MySQL是典型的C&#x2F;S架构，即client&#x2F;server架构，&#x3D;&#x3D;服务端程序使用的是mysqld&#x3D;&#x3D;.不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。</li>
<li>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例</li>
</ul>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513100530485.png" alt="image-20220513100530485"></p>
<h4 id="1-2-Connectors"><a href="#1-2-Connectors" class="headerlink" title="1.2 Connectors"></a>1.2 Connectors</h4><blockquote>
<ul>
<li>指的是不同语言中与SQL的交互，MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL server建立TCP连接，之后按照其定义好的协议进行交互。或者比较方便的办法调用SDK,&#x3D;&#x3D;比如jdbc&#x3D;&#x3D;。但通过SDK来访问MySQL，&#x3D;&#x3D;本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互。&#x3D;&#x3D;</li>
<li>接下来的&#x3D;&#x3D;MySQL  server结构可以分为如下的三层&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h4 id="1-3-第一层：连接层"><a href="#1-3-第一层：连接层" class="headerlink" title="1.3 第一层：连接层"></a>1.3 第一层：连接层</h4><blockquote>
<ul>
<li>系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接</li>
<li>经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的&#x3D;&#x3D;账号密码做身份认证、权限获取&#x3D;&#x3D;<ul>
<li>之后的权限判断逻辑，都依赖于此时获取的权限</li>
</ul>
</li>
<li>MySQL 服务器有专门的tcp连接池，来控制连接数。同时还有一个线程池。</li>
<li>所以连接管理的职责是负责认证、管理链接、获取权限信息</li>
</ul>
</blockquote>
<h4 id="1-4-第二层：服务层"><a href="#1-4-第二层：服务层" class="headerlink" title="1.4 第二层：服务层"></a>1.4 第二层：服务层</h4><blockquote>
<p>主要完成大多数的核心服务功能。如sql接口，并完成缓存的查询，SQL的分析和优化以及部分内置函数的执行。</p>
</blockquote>
<h4 id="1-5-第三层：引擎层"><a href="#1-5-第三层：引擎层" class="headerlink" title="1.5 第三层：引擎层"></a>1.5 第三层：引擎层</h4><blockquote>
<p>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作。</p>
</blockquote>
<h4 id="1-6-存储层"><a href="#1-6-存储层" class="headerlink" title="1.6 存储层"></a>1.6 存储层</h4><blockquote>
<p>所有的数据，数据库，表的定义，表的每一行内容，索引，都是存储在文件系统上，以文件的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB,也支持不适用文件系统直接管理设备。</p>
</blockquote>
<h4 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h4><blockquote>
<p>连接层：客户端与服务器端建立连接，客户端发送SQL至服务器端</p>
<p>SQL层（服务层）：对SQL语句进行查询处理，与数据库文件的存储方式无关</p>
<p>存储引擎层：与数据库文件打交道，负责数据的存储和读取</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513103317152.png" alt="image-20220513103317152"></p>
<h3 id="2-SQL执行流程"><a href="#2-SQL执行流程" class="headerlink" title="2.SQL执行流程"></a>2.SQL执行流程</h3><h4 id="2-1MySQL中的SQL执行流程"><a href="#2-1MySQL中的SQL执行流程" class="headerlink" title="2.1MySQL中的SQL执行流程"></a>2.1MySQL中的SQL执行流程</h4><img src="https://img.php.cn/upload/image/852/939/165/1634208004776032.png" alt="3.png" style="zoom: 67%;" />

<blockquote>
<ol>
<li><p>查询缓存：server如果在查询缓存中发现了这条SQL语句，就会直接将结果返回给客户端，如果没有，就进入到解析器阶段，需要注意的是，因为查询缓存往往效率不高，所以在mysql8.0之后就抛弃了这个功能。【之前执行过的SQL语句及其执行结果，以key-value的形式存储】【去除的原因是查询缓存命中率不高】</p>
</li>
<li><pre><code class="mysql">mysql&gt; show global variables like &quot;%query_cache_type%&quot;;
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_type | OFF   |
+------------------+-------+
1 row in set (3.16 sec)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 解析器：在解析器中对SQL语句进行语法分析、语义分析。【判断输入MySQL语句是否满足MySQL语法，满足生成语法树】</span><br><span class="line"></span><br><span class="line">4. 优化器：在优化器中会确定SQL语句的执行路径，比如是根据全表检索还是索引检索等。==一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。==</span><br><span class="line"></span><br><span class="line">4. 执行器：此时就会进入执行器阶段。在执行需要判断该用户是否具备权限。如果不具备就返回错误。如果具备权限，就执行SQL查询并返回结果。如果设置了查询缓存，就将查询结果进行缓存。后面会调用存储引擎，在存储引擎层会去调用底层的文件系统，从而对数据进行增删改查操作</span><br><span class="line"></span><br><span class="line">#### 2.2MySQL中SQL执行原理</span><br><span class="line"></span><br><span class="line">**1.确认profiling是否开启**</span><br><span class="line"></span><br><span class="line">了解查询语句底层执行的过程：select  @@profiling;  或者 show variables like &#x27;%profiling%&#x27;;  查看是否开启计划。开启它可以让MySQL手机在SQL执行时所需要的资源情况，命令如下</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql&gt; select  @@profiling;</span><br><span class="line">+-------------+</span><br><span class="line">| @@profiling |</span><br><span class="line">+-------------+</span><br><span class="line">|           0 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;show variables like &#x27;%profiling%&#x27;;</span><br><span class="line"></span><br><span class="line">--- 暂时开启profiling功能。没开启时为0</span><br><span class="line">mysql&gt; set profiling=1;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;%profiling%&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | ON    |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+----------+------------+-----------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                             |</span><br><span class="line">+----------+------------+-----------------------------------+</span><br><span class="line">|        1 | 0.01186325 | show variables like &#x27;%profiling%&#x27; |</span><br><span class="line">|        2 | 0.00930475 | SELECT DATABASE()                 |</span><br><span class="line">|        3 | 0.00115075 | SELECT DATABASE()                 |</span><br><span class="line">|        4 | 0.00158900 | show databases                    |</span><br><span class="line">|        5 | 0.00338675 | show tables                       |</span><br><span class="line">|        6 | 0.00810150 | show tables                       |</span><br><span class="line">|        7 | 0.01930125 | select * from employees           |</span><br><span class="line">|        8 | 0.00282050 | select * from employees           |</span><br><span class="line">+----------+------------+-----------------------------------+</span><br><span class="line">8 rows in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 7对应的是上面query_ID为7的语句执行时间和流程</span><br><span class="line">mysql&gt; show profile for query 7;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.000159 |</span><br><span class="line">| checking permissions | 0.000761 |</span><br><span class="line">| Opening tables       | 0.000109 |</span><br><span class="line">| init                 | 0.000083 |</span><br><span class="line">| System lock          | 0.000186 |</span><br><span class="line">| optimizing           | 0.000550 |</span><br><span class="line">| statistics           | 0.000082 |</span><br><span class="line">| preparing            | 0.000066 |</span><br><span class="line">| executing            | 0.000051 |</span><br><span class="line">| Sending data         | 0.016321 |</span><br><span class="line">| end                  | 0.000067 |</span><br><span class="line">| query end            | 0.000479 |</span><br><span class="line">| closing tables       | 0.000069 |</span><br><span class="line">| freeing items        | 0.000167 |</span><br><span class="line">| cleaning up          | 0.000152 |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">15 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;可以在MySQL5.7中开启查询缓存 【注意：在MySQL8.0及以上不存在查询缓存】&#x3D;&#x3D;</p>
<ul>
<li><p>使用vim命令打开  &#x2F;etc&#x2F;my.cnf 文件，将query_cache_type &#x3D; 1 添加进去。并重启mysql服务&#x3D;&#x3D;systemctl restart mysqld&#x3D;&#x3D;</p>
</li>
<li><pre><code class="bash">[root@dmtsai ~]# vim /etc/my.cnf
#重启MySQL服务
[root@dmtsai ~]# systemctl restart mysqld
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在添加完查询缓存后</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  mysql&gt; show profiles;</span><br><span class="line">  +----------+------------+---------------------------+</span><br><span class="line">  | Query_ID | Duration   | Query                     |</span><br><span class="line">  +----------+------------+---------------------------+</span><br><span class="line">  |        1 | 0.00352875 | select @@profiling        |</span><br><span class="line">  |        2 | 0.00404500 | select * from departments |</span><br><span class="line">  |        3 | 0.00067225 | select * from departments |</span><br><span class="line">  +----------+------------+---------------------------+</span><br><span class="line">  3 rows in set, 1 warning (0.00 sec)</span><br><span class="line">      </span><br><span class="line">  mysql&gt; show profile for query 2;</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  | Status                         | Duration |</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  | starting                       | 0.000111 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000061 |</span><br><span class="line">  | starting                       | 0.000056 |</span><br><span class="line">  | checking query cache for query | 0.000130 |</span><br><span class="line">  | checking permissions           | 0.000378 |</span><br><span class="line">  | Opening tables                 | 0.000110 |</span><br><span class="line">  | init                           | 0.000077 |</span><br><span class="line">  | System lock                    | 0.000138 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000057 |</span><br><span class="line">  | System lock                    | 0.000079 |</span><br><span class="line">  | optimizing                     | 0.000058 |</span><br><span class="line">  | statistics                     | 0.000074 |</span><br><span class="line">  | preparing                      | 0.000518 |</span><br><span class="line">  | executing                      | 0.000060 |</span><br><span class="line">  | Sending data                   | 0.000271 |</span><br><span class="line">  | end                            | 0.000066 |</span><br><span class="line">  | query end                      | 0.000067 |</span><br><span class="line">  | closing tables                 | 0.000474 |</span><br><span class="line">  | freeing items                  | 0.000090 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000051 |</span><br><span class="line">  | freeing items                  | 0.000096 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000806 |</span><br><span class="line">  | freeing items                  | 0.000057 |</span><br><span class="line">  | storing result in query cache  | 0.000056 |</span><br><span class="line">  | cleaning up                    | 0.000107 |</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  25 rows in set, 1 warning (0.00 sec)</span><br><span class="line">      </span><br><span class="line">  mysql&gt; show profile for query 3;</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  | Status                         | Duration |</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  | starting                       | 0.000085 |</span><br><span class="line">  | Waiting for query cache lock   | 0.000043 |</span><br><span class="line">  | starting                       | 0.000040 |</span><br><span class="line">  | checking query cache for query | 0.000045 |</span><br><span class="line">  | checking privileges on cached  | 0.000055 |</span><br><span class="line">  | checking permissions           | 0.000071 |</span><br><span class="line">  | sending cached result to clien | 0.000164 |</span><br><span class="line">  | cleaning up                    | 0.000171 |</span><br><span class="line">  +--------------------------------+----------+</span><br><span class="line">  8 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>还可以使用show profile查询其他内容 例如</p>
</li>
<li><pre><code class="mysql">mysql&gt; show profile cpu,block io for query 2;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.数据库缓冲池（buffer pool）[了解即可]</span><br><span class="line"></span><br><span class="line">&gt; - ==InnoDB 存储引擎==是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页</span><br><span class="line">&gt;   面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操</span><br><span class="line">&gt;   作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 ==占用内存来作为数据缓冲池== ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访</span><br><span class="line">&gt;   问。</span><br><span class="line">&gt; - 这样做的好处是可以让磁盘活动最小化，从而 ==减少与磁盘直接进行 I/O 的时间== 。要知道，这种策略对提</span><br><span class="line">&gt;   升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。  </span><br><span class="line"></span><br><span class="line">#### 3.1缓冲池 VS 查询缓存</span><br><span class="line"></span><br><span class="line">**缓冲池和查询缓存是一个东西吗？不是**</span><br><span class="line"></span><br><span class="line">##### **1.缓冲池**</span><br><span class="line"></span><br><span class="line">- 首先我们需要了解在InnoDB存储引擎中，缓冲池都包括了哪些。</span><br><span class="line"></span><br><span class="line">- 在InnoDB存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存</span><br><span class="line"></span><br><span class="line">![image-20220602103847544](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220602103847544.png)</span><br><span class="line"></span><br><span class="line">**缓存池的重要性**</span><br><span class="line"></span><br><span class="line">- 将整个页加载到内存中后就可以进行读写访问了，在进行完读写操作之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。</span><br><span class="line">- 帮我们消除了CPU和磁盘之间的鸿沟</span><br><span class="line"></span><br><span class="line">**缓存原则**：</span><br><span class="line"></span><br><span class="line">- 位置*频次原则，可以帮我们对I/O访问效率进行优化</span><br><span class="line"></span><br><span class="line">- 首先位置决定效率，提供缓存就是为了在内存中可以直接访问数据</span><br><span class="line">- 其次，频次决定优先级顺序，因为缓冲池的大小是有限的，比如磁盘200G，但是内存只有16G，缓冲池大小只有1G，因此需要优先对使用频次高的数据加载到缓冲池</span><br><span class="line"></span><br><span class="line">**缓冲池的预读特性：**</span><br><span class="line"></span><br><span class="line">了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：预读</span><br><span class="line"></span><br><span class="line">缓冲池的作用就是提升I/O效率，而我们进行读取数据的时候存在一个局部性原理，也就是说我们使用了一些数据，大概率还回使用它周围的一些数据，因此采用预读的机制提前加载。可以较少未来可能的磁盘I/O操作</span><br><span class="line"></span><br><span class="line">##### **2.查询缓存**</span><br><span class="line"></span><br><span class="line">- 查询缓存是提前把查询结果缓存起来，不是缓存查询计划，而是查询对应的结果。</span><br><span class="line">- 因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</span><br><span class="line">- 缓存池服务于数据库整体的I/O操作，他们的共同点都是通过缓存的机制来提升效率</span><br><span class="line"></span><br><span class="line">#### 3.2 缓冲池如何读取数据</span><br><span class="line"></span><br><span class="line">&gt; 缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面</span><br><span class="line">&gt; 是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进</span><br><span class="line">&gt; 行读取。  </span><br><span class="line"></span><br><span class="line">![image-20220602105502773](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220602105502773.png)</span><br><span class="line"></span><br><span class="line">**如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？**</span><br><span class="line"></span><br><span class="line">- 当对数据库中的记录进行修改时，首先会修改缓冲池中页面里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。缓冲池会用一种checkpoint机制将数据回写到磁盘上，提升数据库整体性能。</span><br><span class="line"></span><br><span class="line">#### 3.3查看/设置缓冲池的大小</span><br><span class="line"></span><br><span class="line">&gt; - 如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大小。命令如下：  </span><br><span class="line">&gt;</span><br><span class="line">&gt; ```mysql</span><br><span class="line">&gt; mysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br><span class="line">&gt; +-------------------------+-----------+</span><br><span class="line">&gt; | Variable_name           | Value     |</span><br><span class="line">&gt; +-------------------------+-----------+</span><br><span class="line">&gt; | innodb_buffer_pool_size | 134217728 |</span><br><span class="line">&gt; +-------------------------+-----------+</span><br><span class="line">&gt; 1 row in set (0.03 sec)</span><br><span class="line">&gt; </span><br><span class="line">&gt; mysql&gt; set global innodb_buffer_pool_size = 268435456;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="3-4多个buffer-pool实例"><a href="#3-4多个buffer-pool实例" class="headerlink" title="3.4多个buffer pool实例"></a>3.4多个buffer pool实例</h4><ul>
<li><p>为了提高并发度，在多线程环境下，只有单个实例加锁影响性能</p>
</li>
<li><p>我们看下如何查看缓冲池的个数，使用命令：  </p>
</li>
<li><pre><code class="mysql">show variables like &#39;innodb_buffer_pool_instances&#39;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的：</span><br><span class="line">- 也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。  </span><br><span class="line"></span><br><span class="line">注意：实例个数也不是越多越好，因为管理实例需要一定的开销</span><br><span class="line"></span><br><span class="line">#### 3.5引申问题</span><br><span class="line"></span><br><span class="line">如果在将数据写回到磁盘时，发生了故障，此时应该怎么办，即使用回滚.利用redo log、undo log</span><br><span class="line"></span><br><span class="line">## 3.存储引擎</span><br><span class="line"></span><br><span class="line">&gt; - 为了管理方便，人们把 连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</span><br><span class="line">&gt; - MySQL中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型。其实存储引擎以前叫做表处理器，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作</span><br><span class="line"></span><br><span class="line">### 1.查看存储引擎</span><br><span class="line"></span><br><span class="line">查看mysql提供什么引擎</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql&gt;show engines;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220602112200974.png" alt="image-20220602112200974"></p>
<h3 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2.设置系统默认的存储引擎"></a>2.设置系统默认的存储引擎</h3><p>查看默认的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%storage_engine%&quot;;</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| Variable_name                    | Value  |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| default_storage_engine           | InnoDB |</span><br><span class="line">| default_tmp_storage_engine       | InnoDB |</span><br><span class="line">| disabled_storage_engines         |        |</span><br><span class="line">| internal_tmp_disk_storage_engine | InnoDB |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">4 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;%storage_engine%&quot;;</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| Variable_name                    | Value  |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| default_storage_engine           | InnoDB |</span><br><span class="line">| default_tmp_storage_engine       | InnoDB |</span><br><span class="line">| disabled_storage_engines         |        |</span><br><span class="line">| internal_tmp_disk_storage_engine | InnoDB |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">4 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改默认的存储引擎，暂时生效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set default_storage_engine=MyISAM;</span><br></pre></td></tr></table></figure>

<p>或者修改 &#x2F;etc&#x2F;my.cnf文件，永久更改</p>
<h3 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3.设置表的存储引擎"></a>3.设置表的存储引擎</h3><blockquote>
<p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 不同的表设置不同的存储引擎 ，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。  </p>
</blockquote>
<h3 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4.引擎介绍"></a>4.引擎介绍</h3><h4 id="4-1-InnoDB引擎：具备外键支持功能的事务存储引擎"><a href="#4-1-InnoDB引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB引擎：具备外键支持功能的事务存储引擎"></a>4.1 InnoDB引擎：具备外键支持功能的事务存储引擎</h4><ul>
<li>MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。</li>
<li>InnoDB是MySQL的 <strong>默认事务型引擎</strong> ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务<br>的完整提交(Commit)和回滚(Rollback)。</li>
<li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li>
<li>&#x3D;&#x3D;除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。&#x3D;&#x3D;  </li>
<li>InnoDB是 为&#x3D;&#x3D;处理巨大数据量的最大性能设计&#x3D;&#x3D;   </li>
<li>数据文件结构：（在《第02章_MySQL数据目录》章节已讲）<ul>
<li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li>
<li>表名.ibd 存储数据和索引</li>
</ul>
</li>
<li>对比MyISAM的存储引擎， &#x3D;&#x3D;InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和&#x3D;&#x3D;<br>&#x3D;&#x3D;索引。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据&#x3D;&#x3D;， 对内存要求较<br>高 ，而且内存大小对性能有决定性的影响。</li>
</ul>
<h4 id="4-2-MyISAM引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM引擎：主要的非事务处理存储引擎"></a>4.2 MyISAM引擎：主要的非事务处理存储引擎</h4><ul>
<li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但&#x3D;&#x3D;MyISAM 不支持事务、行级锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。&#x3D;&#x3D;</li>
<li>5.5之前默认的存储引擎</li>
<li>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li>
<li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高  </li>
<li>数据文件结构：（在《第02章_MySQL数据目录》章节已讲）【数据与索引分开存储】<ul>
<li>表名.frm 存储表结构</li>
<li>表名.MYD 存储数据 (MYData)</li>
<li>表名.MYI 存储索引 (MYIndex)</li>
</ul>
</li>
<li>应用场景：只读应用或者以读为主的业务</li>
</ul>
<h4 id="4-3InnoDB与MyISAM对比"><a href="#4-3InnoDB与MyISAM对比" class="headerlink" title="4.3InnoDB与MyISAM对比"></a>4.3InnoDB与MyISAM对比</h4><table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发操作</td>
<td>行锁，操作时只锁一行，不对其他行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>自带系统表使用</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>关注点</td>
<td>性能：节省资源，消耗少，简单业务</td>
<td>事务：并发写、事务、更大资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>默认使用</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody></table>
<h4 id="4-4Archive-引擎：用于数据存档"><a href="#4-4Archive-引擎：用于数据存档" class="headerlink" title="4.4Archive 引擎：用于数据存档"></a>4.4Archive 引擎：用于数据存档</h4><h4 id="4-5Blackhole引擎：不会保存写入的操作"><a href="#4-5Blackhole引擎：不会保存写入的操作" class="headerlink" title="4.5Blackhole引擎：不会保存写入的操作"></a>4.5Blackhole引擎：不会保存写入的操作</h4><h4 id="4-6-CSV引擎：存储数据时，以逗号分割各个数据项-可以作为数据交换使用"><a href="#4-6-CSV引擎：存储数据时，以逗号分割各个数据项-可以作为数据交换使用" class="headerlink" title="4.6 CSV引擎：存储数据时，以逗号分割各个数据项.可以作为数据交换使用"></a>4.6 CSV引擎：存储数据时，以逗号分割各个数据项.可以作为数据交换使用</h4><h4 id="4-7Memory引擎"><a href="#4-7Memory引擎" class="headerlink" title="4.7Memory引擎"></a>4.7Memory引擎</h4><p><strong>概述：</strong></p>
<ul>
<li>Memory采用的逻辑介质是 内存 ， 响应速度很快 ，但是当mysqld守护进程崩溃的时候 数据会丢失 。另<br>外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。</li>
</ul>
<p><strong>主要特征：</strong></p>
<ul>
<li>Memory同时 支持哈希（HASH）索引 和 B+树索引 。</li>
<li>Memory表至少比MyISAM表要 快一个数量级 。</li>
<li>MEMORY 表的大小是受到限制 的。表的大小主要取决于两个参数，分别是 max_rows 和max_heap_table_size 。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默<br>认为16MB，可以按需要进行扩大。</li>
<li>数据文件与索引文件分开存储。</li>
<li>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。</li>
</ul>
<h2 id="4-索引的数据结构"><a href="#4-索引的数据结构" class="headerlink" title="4.索引的数据结构"></a>4.索引的数据结构</h2><h3 id="1-为什么要使用索引"><a href="#1-为什么要使用索引" class="headerlink" title="1.为什么要使用索引"></a>1.为什么要使用索引</h3><ul>
<li>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的号码，便可快速定位到需要的文章。MySQL中也是一样，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。</li>
<li>建索引的目的是为了减少磁盘I&#x2F;O的次数，加快查询速率</li>
</ul>
<h3 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2.索引及其优缺点"></a>2.索引及其优缺点</h3><h4 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h4><ul>
<li><p>索引（Index）是帮助MySQL高效获取数据的数据结构</p>
</li>
<li><p><strong>索引的本质：</strong>索引是数据结构。可以简单理解为排好序的快速查找数据结构。满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现<strong>高级查找算法</strong></p>
</li>
<li><p>索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256个字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
</li>
</ul>
<h4 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h4><ul>
<li>提高数据检索的效率，<strong>降低数据库的I&#x2F;O成本</strong>，这是最主要的原因</li>
<li>通过创建唯一索引，可以保证数据库表中每一行<strong>数据的唯一性</strong></li>
<li><strong>可以加速表和表之间的连接</strong>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</li>
<li>在使用分组和排序子句进行数据查询时，可以<strong>显著减少查询中分组和排序的时间</strong>，降低了CPU的消耗。</li>
</ul>
<h4 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h4><ul>
<li>创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加</li>
<li>索引需要占据磁盘空间，除了数据表需要占数据空间之外，每一个索引还要占一定的物理空间</li>
<li>虽然索引大大提高了查询速度，同时也会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
<li>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</li>
</ul>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
</blockquote>
<h3 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3.InnoDB中索引的推演"></a>3.InnoDB中索引的推演</h3><h4 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h4><p>先来看一个精确匹配的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 where 列名 = XXX</span><br></pre></td></tr></table></figure>

<p><strong>1.在一个页中的查找</strong></p>
<p>由于目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li>以主键为搜索条件<ul>
<li>可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li>
</ul>
</li>
<li>以其他列作为搜索条件<ul>
<li>因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种请开给你下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。这种查找的效率是非常低的。</li>
</ul>
</li>
</ul>
<p><strong>2.在很多页中查找</strong></p>
<ul>
<li>在很多页中查找记录的话可以分为两个步骤：<ul>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ul>
</li>
</ul>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页 沿着 双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。  </p>
<h4 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h4><p>建一个表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">-&gt; c1 INT,</span><br><span class="line">-&gt; c2 INT,</span><br><span class="line">-&gt; c3 CHAR(1),</span><br><span class="line">-&gt; PRIMARY KEY(c1)</span><br><span class="line">-&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure>

<ul>
<li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。目录项记录</li>
<li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li>
<li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li>
<li>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p><strong>B+Tree</strong></p>
<ul>
<li>一般情况下，我们 用到的B+树都不会超过4层 ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速定位记录。</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220603104134628.png" alt="image-20220603104134628"></p>
<h4 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h4><p>索引按照物理实现方式，索引可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或辅助索引</p>
<p><strong>1.聚簇索引</strong></p>
<p>聚簇索引并不是一种单独的索引类型，而是一种&#x3D;&#x3D;数据存储方式（所有的用户记录都存储在了叶子节点）&#x3D;&#x3D;，也就是所谓的&#x3D;&#x3D;索引即数据，数据即索引。&#x3D;&#x3D;</p>
<blockquote>
<p>术语聚簇表示数据行和相邻的键值聚簇的存储在一起。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：<ul>
<li>页内 的记录是按照主键的大小顺序排成一个 单向链表 。</li>
<li>各个存放 <strong>用户记录的页</strong> 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。</li>
<li>存放 <strong>目录项记录的页</strong> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键<br>大小顺序排成一个 双向链表 。</li>
</ul>
</li>
<li>B+树的 <strong>叶子节点</strong> 存储的是完整的用户记录。</li>
<li>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</li>
</ul>
<blockquote>
<p>我们把具有上面这两种特性的B+树称为<strong>聚簇索引</strong>，所有完整的用户记录都存放在这个<strong>聚簇索引</strong>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用<strong>INDEX</strong>语句去创建，<strong>InnoDB</strong>存储引擎会<strong>自动</strong>的为我们创建聚簇索引。</p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li><strong>数据访问更快</strong> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于<strong>主键的 排序查找 和 范围查找 速度</strong>非常快</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 <strong>节省了大量的io操作 。</strong></li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>插入速度严重依赖于插入顺序</strong> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，<strong>我们一般都会定义一个自增的ID列为主键</strong></li>
<li><strong>更新主键的代价很高</strong> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新</li>
<li><strong>二级索引访问需要两次索引查找</strong> ，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而myIsam并不支持聚簇索引</li>
<li>由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键</li>
<li>如果没有定义主键，Inoodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引</li>
<li>为了充分利用聚簇索引的聚簇的特性，所以Innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id,比如UUID,MD5,HASH，字符串列作为主键无法保证数据的顺序增长。</li>
</ul>
<p><strong>2.二级索引（辅助索引、非聚簇索引）</strong></p>
<p>上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果想以别的列作为搜索条件该怎么半呢？肯定不能从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以多建几颗B+树，不同的B+树种的数据采用不同的排序规则。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220603112122592.png" alt="image-20220603112122592"></p>
<p><strong>概念：回表</strong> </p>
<ul>
<li><p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值（c1列的值），所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 <strong>聚簇索引</strong> 中再查一遍，这个过程称为 回表 。也就是根据c2列的值查询一条完整的用户记录需要使用到 <strong>2 棵</strong>B+树！</p>
</li>
<li><p>问题：为什么我们还需要<strong>一次 回表 操作</strong>呢？直接把完整的用户记录放到叶子节点不OK吗？  </p>
</li>
<li><p>回答：</p>
<ul>
<li>如果把完整的用户记录放到叶子节点是可以不用回表。但是太占地方了，相当于每建立一颗B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费时间了</li>
</ul>
</li>
<li><p>因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（secondary index）,或者辅助索引。由于我们使用的是C2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引</p>
</li>
<li><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p>
</li>
</ul>
<p><strong>小结</strong>：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<ul>
<li>聚簇索引的<strong>叶子节点存储的是我们的数据记录</strong>，<strong>非聚簇索引的叶子节点存储的是数据位置（主键值，根据主键值回到聚簇索引中来查找数据）</strong>。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li><strong>一个表只能有一个聚簇索引</strong>，因为只能有一种排序存储的方式，但可以有多个<strong>非聚簇索引</strong>，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的<strong>查询效率高</strong>，但如果对数据进行插入、删除、更新等操作，效率就会比非聚簇索引低。</li>
</ul>
<p><strong>3.联合索引</strong></p>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：</p>
<ul>
<li><p>先把各个记录和页按照c2列进行排序</p>
</li>
<li><p>在记录的c2列相同的情况下，采用c3列进行排序</p>
</li>
<li><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立 联合索引 只会建立如上图一样的1棵B+树。</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
</li>
</ul>
<h4 id="3-4-InnoDB的B-树索引的注意事项"><a href="#3-4-InnoDB的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB的B+树索引的注意事项"></a>3.4 InnoDB的B+树索引的注意事项</h4><p><strong>1.根页面位置万年不动</strong></p>
<p>实际上B+树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个B+树索引（聚簇索引不是认为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个根节点中</li>
<li>当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页</li>
</ul>
<p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会在移动，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<p><strong>2.内节点【非叶子节点】中目录项记录的唯一性</strong></p>
<p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分组成的。</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号【对应的是数据项记录的页号 &#x2F;第一层的目录项记录的页号】</li>
</ul>
<p><strong>3.一个页面最少存储2条记录</strong> </p>
<ul>
<li>这是因为B+树的本质就是一个多层级目录，没经过一个目录会过滤掉很多无效的子目录，直到最后访问到存储真实数据的目录。如果一个页面只存储一条记录，这样子建目录过滤没有意义。</li>
</ul>
<h3 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4.MyISAM中的索引方案"></a>4.MyISAM中的索引方案</h3><ul>
<li>即使Innodb和MyISAM支持的默认索引是B+tree索引。但是Memory引擎支持的默认索引是Hash索引，</li>
<li>其中MyISAM引擎使用B+tree作为索引结构，叶子节点的data域存放的是数据记录的地址</li>
</ul>
<p><strong>4.1MyISAM中的原理</strong></p>
<ul>
<li>我们知道InnoDB中索引即数据，也就是聚簇索引的那颗B+树的叶子节点中已经把所有完整用户记录都包含了，而MyISAM的索引方案虽然也是使用树形结构，但是却将索引和数据分开存储。<ul>
<li>将表中的记录按照记录的插入顺序单独存放在一个文件中，称之为数据文件，这个文件并不划分为若干个数据页，有多少巨鹿就往这个文件中塞多少记录就成了，由于在插入数据的时候并没有可以按照主键排序，所以我们并不能在这些数据上进行二分查找。</li>
<li>使用MyISAM存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中，MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值+数据记录地址的组合。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在col1上建立索引</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604093604533.png" alt="image-20220604093604533"></p>
<blockquote>
<p>在col2上建立索引</p>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604093707392.png" alt="image-20220604093707392"></p>
<blockquote>
<p>从上面两张图可以看出来，MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主键索引和二级索引在结构上几乎没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。</p>
</blockquote>
<p><strong>4.3 MyISAM与InnoDB对比</strong></p>
<p>MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的，小结两种引擎中索引的区别：</p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。</p>
<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数据记录的地址。</p>
<p>③ InnoDB的非聚簇索引data域存储相应记录 <strong>主键的值</strong> ，而MyISAM索引记录的是 <strong>地址</strong> 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p>
<p>④ MyISAM的回表操作是十分 <strong>快速</strong> 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后<strong>再去聚簇索引里找记录</strong>，虽然说也不慢，但还是比不上直接用地址去访问。</p>
<p>⑤ InnoDB要求表 <strong>必须有主键</strong> （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。  </p>
<p><strong>小结</strong></p>
<p>知道索引结构后对于正确使用和优化索引都非常有帮助，例如</p>
<ul>
<li>知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有的二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</li>
<li>用非单调的字段作为主键在InnoDB中不是好主意，因为InnoDB数据文件本身是一颗B+tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+树的特性而频繁的分裂调整，十分低效，而是用自增字段为主键是一个非常好的选择。</li>
</ul>
<h3 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5.索引的代价"></a>5.索引的代价</h3><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li>空间上的代价<ul>
<li>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</li>
</ul>
</li>
<li>时间上的代价<br>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</li>
</ul>
<blockquote>
<p>一个表上索引建的越多，就会占用越多的存储空间，在增删改查记录的时候性能就越差，为了能建立又好又少的索引，我们得学学这些索引在哪些条件下不起作用的。</p>
</blockquote>
<h3 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6.MySQL数据结构选择的合理性"></a>6.MySQL数据结构选择的合理性</h3><ul>
<li>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更大，为了较少索引在内存的占用，数据库索引是存储在外部磁盘上的，当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只嗯呢逐一加载，那么MySQL衡量查询效率的标准就是磁盘I&#x2F;O次数。</li>
</ul>
<h4 id="6-1hash结构"><a href="#6-1hash结构" class="headerlink" title="6.1hash结构"></a>6.1hash结构</h4><ul>
<li><p>Hash结构效率高，那为什么索引结构要设计成树型呢？  </p>
<ul>
<li>Hash索引仅能满足（&#x3D;） 和（&lt;&gt;）和IN查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为O(n)，而树型的有序特性，依然能够保持O(log2N)的高效率</li>
<li>Hash索引还有一个缺陷，数据的存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新弄排序</li>
<li>对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询</li>
<li>对于等值查询来说，通常hash索引的效率高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。例如对于性别列。</li>
</ul>
</li>
<li><p>hash索引只支持在Memory引擎。</p>
</li>
<li><p>另外InnoDB本身不支持hash索引，但是提供自适应hash索引，如果一个数据经常被访问，那么可以将这个数据页的地址存放到hash表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#可以查看是否开启了自适应hash</span><br><span class="line">mysql&gt; show variables like &quot;%adaptive_hash_index%&quot;;</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">| Variable_name                    | Value |</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">| innodb_adaptive_hash_index       | ON    |</span><br><span class="line">| innodb_adaptive_hash_index_parts | 8     |</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">2 rows in set (0.60 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-2平衡二叉树（AVL）"><a href="#6-2平衡二叉树（AVL）" class="headerlink" title="6.2平衡二叉树（AVL）"></a>6.2平衡二叉树（AVL）</h4><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604102814977.png" alt="image-20220604102814977"></p>
<p>我们能够发现，当数据量大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度（M&gt;2）。所以我们需要把树从瘦高变成矮胖</p>
<h4 id="6-3-B-Tree"><a href="#6-3-B-Tree" class="headerlink" title="6.3 B-Tree"></a>6.3 B-Tree</h4><p>B树的英文是Balance Tree，也就是多路平衡二叉树。简写为B-Tree，它的高度远小于平衡二叉树的高度。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604102844788.png" alt="image-20220604102844788"></p>
<p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，M称为B树的阶，每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包括了x个关键字，那么指针数就是x+1。对于大量的索引数据来说，采用B树的结构是非常合适的。</p>
<p><strong>小结：</strong></p>
<ol>
<li>B树的插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li><strong>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据</strong>，搜索有可能在非叶子节点结束</li>
<li>其搜索性能等价于在关键字全集内作一次二分查找</li>
</ol>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220604103838143.png" alt="image-20220604103838143"></p>
<h4 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h4><p>B+树也是一种多路搜索树，基于B树做出了改进，主流的DBMS都支持B+树的索引方式。比如MySQL，相比于B-Tree，B+Tree适合文件索引系统。</p>
<p>B+Tree和B-Tree的差异：</p>
<ul>
<li>B+树有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数+1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <strong>非叶子节点既保存索引，也保存数据记录 。</strong></li>
<li>B+Tree<strong>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接</strong></li>
</ul>
<blockquote>
<p>B+树的中间节点并不直接存储数据，这样的好处有哪些呢？</p>
<ul>
<li><strong>B+树的查询效率更稳定</strong>，因为每次都需要查找到叶子节点才结束，而对于B-Tree结构来说，有时候查询到非叶子节点就结束了</li>
<li><strong>B+树的查询效率更高</strong>，这是因为通常B+树比B树更矮胖（阶数更大，深度更低，查询所需的磁盘I&#x2F;O会更少，同样的磁盘页大小，B+树可以存放更多的节点关键字（因为B树的非叶子节点中也会存储数据，所以能够容纳的叉就会少一些，也就是子节点会更少一些，所以也就比B+tree更高一些）。</li>
<li>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B+树高</strong>，这是因为所有关键字都出现B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树种则需要通过中序遍历才能完成查询范围的查找</li>
</ul>
</blockquote>
<ul>
<li>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</li>
<li>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</li>
</ul>
<p>&#x3D;&#x3D;思考题：为了减少I&#x2F;O，索引树会一次性加载吗？&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小页会很大，超过几个G</li>
<li>当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页（块），因为磁盘页对应着索引树的节点。</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;思考题：B+树的存储能力如何？为何说一般查找记录，最多只需1-3次磁盘I&#x2F;O&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中一个节点）中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值也就是说一个深度为3的B+Tree索引可以存储 1000 * 1000 * 1000 &#x3D; 10亿条记录（这里也假定一个数据页也存储了1000条记录）</li>
<li>实际情况中每个节点可能不能填充满，因此在数据库中 B+Tree的高度一般都在2-4层，MySQL的InnoDB存储引擎在设计是将根节点常驻在内存的，也就是说查找某一键值的行记录最多只需要1-3次磁盘I&#x2F;O操作</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>B+树的磁盘读写代价更低</li>
<li>B+树的查询效率更加稳定</li>
<li>B+树的查询速度更快</li>
<li>针对查询范围，B+树的速度更快</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;思考题：Hash 索引与 B+ 树索引的区别&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>Hash索引不支持范围查询，而B+树可以，这是因俄日hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表</li>
<li>hash索引不支持联合索引的最左侧原则。如针对两个列进行建立索引时，hash索引是将索引键合并后在一起计算hash值，所以不会针对每个索引单独计算hash值，因此如果用到联合索引的一个或几个索引时，联合索引无法使用</li>
<li>hash索引不支持order by排序。同理hash索引也不支持模糊查询。</li>
<li>InnoDB不支持hash索引</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？&#x3D;&#x3D;  </p>
<p>针对InnoDB和MyISAM存储引擎，都会默认采用B+树索引，无法使用Hash索引。InnoDB提供的自适应Hash是不需要手动指定的。如果时Memory&#x2F;heap和NDB存储引擎，是可以进行选择Hash索引的。</p>
<h4 id="6-7-R树"><a href="#6-7-R树" class="headerlink" title="6.7 R树"></a>6.7 R树</h4><p>仅支持geometry数据类型，解决了这种高维空间搜索问题</p>
<h4 id="6-8-小结"><a href="#6-8-小结" class="headerlink" title="6.8 小结"></a>6.8 小结</h4><ul>
<li>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间，降低数据库写操作的性能，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利（提升查询效率）和弊（维护索引所需的代价）</li>
<li>在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但是数据量大的时候不使用索引是不可想象的，毕竟索引的本质是帮助我们提升数据检索的效率。</li>
</ul>
<h2 id="5-InnoDB数据存储结构"><a href="#5-InnoDB数据存储结构" class="headerlink" title="5.InnoDB数据存储结构"></a>5.InnoDB数据存储结构</h2><h3 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1.数据库的存储结构：页"></a>1.数据库的存储结构：页</h3><ul>
<li>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。不过不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如Merory都不用磁盘来存储数据</li>
<li>由于<strong>InnoDB是MySQL的默认存储引擎</strong>，所以主要剖析InnoDB存储引擎的数据存储结构。</li>
</ul>
<h4 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h4><ul>
<li>InnoDB将数据分为若干个页，InnoDB中页的大小默认为16KB.</li>
<li>以页作为磁盘和内存之间交互的基本单位，也就是说一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中，也就是说，在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page）,数据库I&#x2F;O操作的最小单位是页，一个页中可以存储多个行记录。</li>
</ul>
<blockquote>
<p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I&#x2F;O操作）只能处理一行数据，效率会非常低。</p>
</blockquote>
<h4 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h4><p>各个页之间可以&#x3D;&#x3D;不通过物理结构上相连&#x3D;&#x3D;，只要通过&#x3D;&#x3D;双向链表相关联&#x3D;&#x3D;即可。每个数据页中的记录会按照&#x3D;&#x3D;主键值从小到大的顺序组成一个单向链表&#x3D;&#x3D;，每个数据页都会为存储在它里边的记录生成一个&#x3D;&#x3D;页目录&#x3D;&#x3D;，在通过主键查找某条记录的时候可以在&#x3D;&#x3D;页目录中使用二分法&#x3D;&#x3D;快速定位到槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<h4 id="1-3-页的大小"><a href="#1-3-页的大小" class="headerlink" title="1.3 页的大小"></a>1.3 页的大小</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%innodb_page_size%&quot;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| innodb_page_size | 16384 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.60 sec)</span><br></pre></td></tr></table></figure>

<h4 id="1-4-页的上层结构"><a href="#1-4-页的上层结构" class="headerlink" title="1.4 页的上层结构"></a>1.4 页的上层结构</h4><p>另外在数据库中，缓存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示</p>
<p>区：是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页，因为InnoDB中的页大小默认是16KB，所以一个区的大小是64 * 16KB&#x3D; 1MB</p>
<p>段：有一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会创建相应的段，</p>
<p>表空间：是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间。</p>
<h3 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2.页的内部结构"></a>2.页的内部结构</h3><ul>
<li>页如果按类型划分的话，常见的有数据页（保存B+树节点），系统页，undo页和事务数据页等。数据页是我们最常使用的页。</li>
<li>数据页的16KB大小的存储空间被划分为7个部分，<ul>
<li>文件头：38字节，描述页的信息</li>
<li>页头：56字节，页的状态信息</li>
<li>最大和最小记录：26字节，这是两个虚拟的行记录</li>
<li>用户记录：不确定，存储行记录内容</li>
<li>空闲记录：不确定页中还没有被使用的空间</li>
<li>页目录：不确定，存储用户记录的相对位置</li>
<li>文件尾：8字节，检验页是否完整</li>
</ul>
</li>
</ul>
<p>第一部分：文件头和文件尾</p>
<ul>
<li><p>&#x3D;&#x3D;被删除的记录为什么还在页中存储呢？&#x3D;&#x3D;</p>
<ul>
<li>是利用了属性标记【在行记录头中】，标记着当前记录是否删除，占用一个二进制位。你以为他删除了，可它还在真是的磁盘上，这些被删除的记录之所以不立即从从磁盘上溢出，是因为移除他们之后，其他的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新纪录插入到表中的话，可能把这些记录被删除的记录占用的存储空间覆盖掉。</li>
</ul>
</li>
<li><h2 id="使用页目录，二分法查找-将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为已删除的记录-第一组，也就是最小记录所在的分组只有一个记录-最后一组，就是最大记录所在的分组，会有1-8记录-其余的组记录数量在4-8条之间"><a href="#使用页目录，二分法查找-将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为已删除的记录-第一组，也就是最小记录所在的分组只有一个记录-最后一组，就是最大记录所在的分组，会有1-8记录-其余的组记录数量在4-8条之间" class="headerlink" title="使用页目录，二分法查找- 将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为已删除的记录- 第一组，也就是最小记录所在的分组只有一个记录- 最后一组，就是最大记录所在的分组，会有1-8记录- 其余的组记录数量在4-8条之间"></a>使用页目录，二分法查找<br>- 将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为已删除的记录<br>- 第一组，也就是最小记录所在的分组只有一个记录<br>- 最后一组，就是最大记录所在的分组，会有1-8记录<br>- 其余的组记录数量在4-8条之间</h2><ul>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的偏移量也被称之为槽，每个槽相当于指针指向了不同组的最后一条记录。</li>
</ul>
</li>
</ul>
<h2 id="6-索引的创建与设计原则"><a href="#6-索引的创建与设计原则" class="headerlink" title="6.索引的创建与设计原则"></a>6.索引的创建与设计原则</h2><h3 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1.索引的声明与使用"></a>1.索引的声明与使用</h3><h4 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h4><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。这些索引的结构都是B+Tree数据结构</p>
<ul>
<li>从&#x3D;&#x3D;功能逻辑上&#x3D;&#x3D;来说，索引主要有4种，分别是普通索引、唯一索引、主键索引、全文索引</li>
<li>按照&#x3D;&#x3D;物理实现&#x3D;&#x3D;方式，索引可以分为2种：聚簇索引和非聚簇索引</li>
<li>按照&#x3D;&#x3D;作用字段个数&#x3D;&#x3D;进行划分，分成单列索引和联合索引</li>
</ul>
<p><strong>1.普通索引</strong></p>
<p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在<strong>任何数据类型</strong>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p>
<p><strong>2.唯一性索引</strong></p>
<p>使用UNIQUE可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。</p>
<p>例如，在student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的，通过唯一性索引可以更快速地确定某条记录。</p>
<p><strong>3.主键索引</strong></p>
<p>主键索引就是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE，一张表里&#x3D;&#x3D;最多只有一个&#x3D;&#x3D;主键索引。</p>
<p>&#x3D;&#x3D;why?&#x3D;&#x3D;这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p>
<p><strong>4.单列索引</strong></p>
<p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引，只要保证该索引只对应一个字段即可。一个表可以有&#x3D;&#x3D;多个单列索引。&#x3D;&#x3D;</p>
<p><strong>5.多列（联合，组合）索引</strong></p>
<p>多列索引是在表的&#x3D;&#x3D;多个字段组合&#x3D;&#x3D;上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用这些字段中的第一个字段时才会被使用。例如，在表中的字段id,name和gender上建立一个多列索引idx_id_name_gender,只有查询条件中使用了字段id时该索引才会被使用。使用组合索引时&#x3D;&#x3D;遵循最左前缀集合&#x3D;&#x3D;。</p>
<p><strong>6.全文索引</strong></p>
<p>全文索引（也称全文检索）是目前搜索引擎中使用的一种关键技术。它能够利用【分词技术】等多种算法只能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<p>使用参数FULLTEXT可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在CHAR.VARCHAR或TEXT类型及其系列类型的字段上，&#x3D;&#x3D;查询数据量比较大的字符串类型的字段时，使用全文索引可以提高查询速度。&#x3D;&#x3D;</p>
<p>全文索引典型的有两种类型：自然语言的全文索引 和 布尔全文索引。</p>
<p><strong>7.补充：空间索引</strong></p>
<p>使用参数SPATIAL可以设置索引为空间索引。空间索引只能建立在空间数据类型上。这样可以提高系统获取空间数据的效率。MySQL的空间数据类型包括：GEOMETRY,POINT,POLYGON等目前只有MyISAM引擎支持空间检索，而且索引的字段不能为空值。</p>
<p><strong>小结：不同的存储引擎支持的索引类型也不一样</strong> </p>
<ul>
<li>InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash索引； </li>
<li>MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引； </li>
<li>Memory ：支持 B-tree、Hash 等索引，不支持 Full-text 索引； </li>
<li>NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引；</li>
<li>Archive ：不支持 B-tree、Hash、Full-text 等索引；</li>
</ul>
<h4 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h4><p>MySQL支持多种方法在单个或多个列上创建索引，在创建表的定义语句CREATE TABLE中指定索引，使用ALTER TABLE语句在存在的表上创建索引，或者使用CREATE INDEX语句在已存在的表上添加索引</p>
<p><strong>1.创建表的时候创建索引</strong></p>
<p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束，外键约束或唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 隐式的方式创建索引。在声明有主键约束、唯一性约束、外键约束的字段上，会自动地添加相关地索引</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">dept_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dept_name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">emp_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">emp_name VARCHAR(20) UNIQUE,</span><br><span class="line">dept_id INT,</span><br><span class="line">CONSTRAINT emp_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果显式创建表时创建索引的话，基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br><span class="line"></span><br><span class="line"># KEY 也表达的索引的意思</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">-- 显式创建索引</span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line"># 1.创建普通的索引</span><br><span class="line">CREATE TABLE book(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明索引 【普通索引】</span><br><span class="line">INDEX idx_bname(book_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#通过命令查看索引</span><br><span class="line"># 方式1：</span><br><span class="line">SHOW CREATE TABLE book;</span><br><span class="line"></span><br><span class="line"># 方式2：</span><br><span class="line">SHOW INDEX FROM book;</span><br><span class="line"></span><br><span class="line">-- 性能分析工具：EXPLAIN.看是否使用了索引</span><br><span class="line">EXPLAIN SELECT * FROM book where book_name = &#x27;mysql&#x27;;</span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2.创建唯一索引</span><br><span class="line">CREATE TABLE book1(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明索引</span><br><span class="line">UNIQUE INDEX uk_idx_cmt(COMMENT)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查看索引</span><br><span class="line">SHOW INDEX FROM book1;</span><br><span class="line"></span><br><span class="line">INSERT INTO book1(book_id,book_name,COMMENT) VALUES(1,&#x27;mysql high&#x27;,&quot;welcome study&quot;);</span><br><span class="line"></span><br><span class="line">&gt; 1062 - Duplicate entry &#x27;welcome study&#x27; for key &#x27;uk_idx_cmt&#x27;INSERT INTO </span><br><span class="line"># 下面语句执行会报上面的错误，不满足唯一索引的要求</span><br><span class="line"></span><br><span class="line"># 注意在添加数据时，要保证唯一性，但是可以添加null值</span><br><span class="line">INSERT INTO book1(book_id,book_name,COMMENT) VALUES(2,&#x27;mysql high&#x27;,&quot;welcome study&quot;);</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line">-- 3.创建唯一索引</span><br><span class="line">-- 通过定义主键约束的方式定义主键索引</span><br><span class="line"></span><br><span class="line">CREATE TABLE book2(</span><br><span class="line">book_id INT PRIMARY KEY,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SHOW INDEX from book2;</span><br><span class="line"></span><br><span class="line"># 通过删除主键约束的方式删除主键索引</span><br><span class="line">ALTER TABLE book2 DROP PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line">-- 4.创建单列索引</span><br><span class="line">CREATE TABLE book3(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明单列索引</span><br><span class="line">UNIQUE INDEX idx_bname(book_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查询索引 如果是单列索引的话 其中Seq_in_index的值为1</span><br><span class="line">SHOW INDEX from book3;</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line"></span><br><span class="line">-- 5.创建联合索引</span><br><span class="line">CREATE TABLE book4(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明联合索引</span><br><span class="line">INDEX mul_idx_bname(book_id,book_name,info)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查询索引 如果是单列索引的话 其中Seq_in_index的值为1</span><br><span class="line">SHOW INDEX from book4;</span><br><span class="line"></span><br><span class="line"># 此时就会用到建立的联合索引，这里必须要遵循最左前缀原则</span><br><span class="line">EXPLAIN SELECT * from book4 WHERE book_id = 1001 AND book_name = &#x27;mysql&#x27;;</span><br><span class="line"></span><br><span class="line"># 此时这种查询就不会用到索引，因为必须要从Seq_in_index小的字段进行查询</span><br><span class="line">EXPLAIN SELECT * from book4 WHERE info = &quot;hello&quot; AND book_name = &#x27;mysql&#x27;;</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line">-- 6.创建全文索引</span><br><span class="line">CREATE TABLE book5(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">-- 声明全文索引</span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查询索引</span><br><span class="line">SHOW INDEX from book5;</span><br><span class="line"></span><br><span class="line">-- 建立全文索引后的查询就不同于like查询</span><br><span class="line">EXPLAIN SELECT * FROM book5 WHERE info like &quot;%mysql%&quot;;</span><br><span class="line"></span><br><span class="line">-- 全文索引用match + against方式查询  下面这种方式的查询效率比上面哪种方式要快很多</span><br><span class="line">EXPLAIN SELECT * FROM book5 WHERE MATCH(info) AGAINST (&quot;mysql&quot;);</span><br><span class="line"></span><br><span class="line">-- 注意</span><br><span class="line">1. 使用全文索引前，搞清楚版本支持情况</span><br><span class="line">2. 全文索引比like+%快N倍，但是可能存在精度问题</span><br><span class="line">3. 如果需要全文索引的大量数据，建议先添加数据，再创建索引</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line">-- 7.创建空间索引</span><br><span class="line">CREATE TABLE book6(</span><br><span class="line">geo GEOMETRY NOT NULL,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">)ENGINE=MyISAM;</span><br><span class="line"></span><br><span class="line">CREATE TABLE book7(</span><br><span class="line">geo GEOMETRY NOT NULL,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX from book6;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>查看联合索引的结果图，主要是Seq_in_index的值</li>
<li>Seq_in_index主要是优先按照Seq_in_index小的进行匹配</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220605151441808.png" alt="image-20220605151441808"></p>
<p><strong>2.在已经创建的表上创建索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-- 在已经拆挂那件的表上创建索引</span><br><span class="line">CREATE TABLE book8(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX from book8;</span><br><span class="line"></span><br><span class="line"># 1.alter table  ... ADD INDEX...    添加普通索引</span><br><span class="line">ALTER TABLE book8 ADD INDEX idx_cmt(COMMENT);</span><br><span class="line"></span><br><span class="line"># 添加唯一索引</span><br><span class="line">ALTER TABLE book8 ADD UNIQUE INDEX uk_idx_bname(book_name);</span><br><span class="line"></span><br><span class="line"># 添加联合索引</span><br><span class="line">ALTER TABLE book8 ADD INDEX mul_bid_idx_bname_info(book_id,book_name,info);</span><br><span class="line"></span><br><span class="line">CREATE TABLE book9(</span><br><span class="line">book_id INT,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">AUTHORS VARCHAR(100),</span><br><span class="line">info VARCHAR(100),</span><br><span class="line">COMMENT VARCHAR(100),</span><br><span class="line">year_publication YEAR</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX from book9;</span><br><span class="line"># 2. CREATE INDEX ... ON ... 添加普通索引</span><br><span class="line">CREATE INDEX idx_cmt ON book9(COMMENT);</span><br><span class="line"></span><br><span class="line"># 添加唯一索引</span><br><span class="line">CREATE UNIQUE INDEX uk_idx_bname ON book9(book_name);</span><br><span class="line"></span><br><span class="line"># 添加联合索引</span><br><span class="line">CREATE INDEX mul_bid_idx_bname_info ON book9(book_id,book_name,info);</span><br></pre></td></tr></table></figure>

<p><strong>3.删除索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1.ALTER TABLE ... DROP INDEX ...索引的删除</span><br><span class="line"># 注意这种方式与alter table添加索引的方式相对</span><br><span class="line">ALTER TABLE book9 DROP INDEX idx_cmt;</span><br><span class="line"></span><br><span class="line"># 2.DROP INDEX ... ON ...  </span><br><span class="line">DROP INDEX uk_idx_bname ON book9;</span><br><span class="line"></span><br><span class="line"># 删除表中的某一个列，列中对应的索引也会有相应变化</span><br><span class="line">ALTER TABLE book9 DROP COLUMN book_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<p>添加AUTO_INCREMENT约束字段的唯一索引不能被删除</p>
</blockquote>
<blockquote>
<p>提示：</p>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h3 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2.MySQL8.0索引新特性"></a>2.MySQL8.0索引新特性</h3><h4 id="2-1支持降序索引"><a href="#2-1支持降序索引" class="headerlink" title="2.1支持降序索引"></a>2.1支持降序索引</h4><ul>
<li>在MySQL8.0以前，索引默认都是升序。8.0之后开始支持降序索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line">INDEX idx_a_b(a ASC,b DESC)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h4><ul>
<li>在MySQL8.0版本之前，只能通过显式的方式删除索引。有时需要多次的索引的创建与删除，数据量过大，会消耗系统过多的资源。</li>
<li>从MySQL8.0之后开始支持隐藏索引，只需要将待删除的索引设置为隐藏索引，是查询优化器不在使用这个索引（即使使用force index(强制使用索引)，优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。&#x3D;&#x3D;这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。&#x3D;&#x3D;</li>
<li>同时，如果你想&#x3D;&#x3D;验证某个索引删除之后的查询性能影响&#x3D;&#x3D;，就可以按时先隐藏该索引</li>
</ul>
<blockquote>
<p>注意：主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引</p>
</blockquote>
<p>索引默认是可见的，在使用CREATE TABLE,CREATE INDEX或者ALTER TABLE 等语句时可以通过VISIABLE或者INVISIABLE关键词设置索引的可见性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line"># 创建不可见索引</span><br><span class="line">INDEX idx_a_b(a,b) INVISIABLE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 2.创建不可见索引</span><br><span class="line">ALTER TABLE book7 ADD UNIQUE INDEX uk_idx_bname(book_name) invisiable;</span><br><span class="line"></span><br><span class="line"># 3. 创建不可见索引</span><br><span class="line">CREATE INDEX idx_year_pub ON book7(year_publication) invisiable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改索引的可见性</span><br><span class="line">ALTER TABLE book7 Alter INDEX idx_year_pub visiable;  -- 由不可见——》可见</span><br><span class="line">ALTER TABLE book7 Alter INDEX idx_year_pub invisiable;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>当索引被隐藏时，它的内容仍然适合正常索引一样实时更新的。如果一个索引需要长期背影仓，那么可以将其删除，因为索引的存在会影响插入，更新和删除的性能</p>
</blockquote>
<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助</p>
<p>使隐藏索引对查询优化器可见</p>
<h3 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3.索引的设计原则"></a>3.索引的设计原则</h3><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上拆挂那件索引和创建什么类型的索引。&#x3D;&#x3D;索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍&#x3D;&#x3D;。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p>
<h4 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a><strong>3.1 数据准备</strong></h4><p>第1步：创建数据库、创建表</p>
<p>第2步：数据的准备。创建存储函数、存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">-- 执行sql文件</span><br><span class="line">/*</span><br><span class="line"> Navicat Premium Data Transfer</span><br><span class="line"></span><br><span class="line"> Source Server         : vmware</span><br><span class="line"> Source Server Type    : MySQL</span><br><span class="line"> Source Server Version : 50737</span><br><span class="line"> Source Host           : 192.168.1.128:3306</span><br><span class="line"> Source Schema         : atguigudb1</span><br><span class="line"></span><br><span class="line"> Target Server Type    : MySQL</span><br><span class="line"> Target Server Version : 50737</span><br><span class="line"> File Encoding         : 65001</span><br><span class="line"></span><br><span class="line"> Date: 05/06/2022 19:41:24</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for course</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `course`;</span><br><span class="line">CREATE TABLE `course`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `course_id` int(11) NOT NULL,</span><br><span class="line">  `course_name` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 101 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of course</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `course` VALUES (1, 10065, &#x27;XQkCgb&#x27;);</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for student_info</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `student_info`;</span><br><span class="line">CREATE TABLE `student_info`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `student_id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `course_id` int(11) NOT NULL,</span><br><span class="line">  `class_id` int(11) NULL DEFAULT NULL,</span><br><span class="line">  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 67599 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of student_info</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `student_info` VALUES (50300, 197628, &#x27;pCRzZz&#x27;, 10036, 10042, &#x27;2022-06-05 19:34:50&#x27;);</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Procedure structure for insert_course</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP PROCEDURE IF EXISTS `insert_course`;</span><br><span class="line">delimiter ;;</span><br><span class="line">CREATE PROCEDURE `insert_course`(IN `max_num` int)</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE i INT DEFAULT 0;   </span><br><span class="line"> SET autocommit = 0;    #设置手动提交事务</span><br><span class="line"> REPEAT  #循环</span><br><span class="line"> SET i = i + 1;  #赋值</span><br><span class="line"> INSERT INTO course (course_id, course_name ) VALUES (rand_num(10000,10100),rand_string(6));  </span><br><span class="line"> UNTIL i = max_num  </span><br><span class="line"> END REPEAT;  </span><br><span class="line"> COMMIT;  #提交事务</span><br><span class="line">END</span><br><span class="line">;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Procedure structure for insert_stu</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP PROCEDURE IF EXISTS `insert_stu`;</span><br><span class="line">delimiter ;;</span><br><span class="line">CREATE PROCEDURE `insert_stu`(IN `max_num` int)</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE i INT DEFAULT 0;   </span><br><span class="line">	 SET autocommit = 0;    #设置手动提交事务</span><br><span class="line">	 REPEAT  #循环</span><br><span class="line">	 SET i = i + 1;  #赋值</span><br><span class="line">	 INSERT INTO student_info (course_id, class_id ,student_id ,name ) VALUES (rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));  </span><br><span class="line">	 UNTIL i = max_num  </span><br><span class="line">	 END REPEAT;  </span><br><span class="line">	 COMMIT;  #提交事务</span><br><span class="line">END</span><br><span class="line">;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Function structure for rand_num</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP FUNCTION IF EXISTS `rand_num`;</span><br><span class="line">delimiter ;;</span><br><span class="line">CREATE FUNCTION `rand_num`(`from_num` int,`to_num` int)</span><br><span class="line"> RETURNS int(11)</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE i INT DEFAULT 0;  </span><br><span class="line">	SET i = FLOOR(from_num +RAND()*(to_num - from_num+1))   ;</span><br><span class="line">	RETURN i;  </span><br><span class="line">END</span><br><span class="line">;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Function structure for rand_string</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP FUNCTION IF EXISTS `rand_string`;</span><br><span class="line">delimiter ;;</span><br><span class="line">CREATE FUNCTION `rand_string`(`n` int)</span><br><span class="line"> RETURNS varchar(255) CHARSET utf8mb4</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE chars_str VARCHAR(100) DEFAULT &#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">	DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	WHILE i &lt; n DO </span><br><span class="line">       SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">       SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END</span><br><span class="line">;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第3步：执行存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_course(100);</span><br><span class="line">CALL insert_stu(1000000);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a><strong>3.2 哪些情况适合创建索引</strong></h4><p><strong>1.字段的数值有唯一性的限制</strong></p>
<ul>
<li><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果某个字段时唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。</p>
</li>
<li><p>例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p>
</li>
</ul>
<blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p>
<p>说明：不要意味唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的</p>
</blockquote>
<p><strong>2.频繁作为WHERE查询条件的字段</strong></p>
<p>某个字段在select语句的where条件中经常出现，就可以添加索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># student_id字段上没有索引的</span><br><span class="line">SELECT course_id, class_id, NAME, create_time, student_id</span><br><span class="line">FROM student_info</span><br><span class="line">WHERE student_id = 67602;  #查询耗时 0.547s  547ms</span><br><span class="line"></span><br><span class="line">#给student_id添加索引</span><br><span class="line">CREATE INDEX idx_stu_id ON student_info(student_id);</span><br><span class="line"></span><br><span class="line"># student_id字段上添加索引后</span><br><span class="line">SELECT course_id, class_id, NAME, create_time, student_id</span><br><span class="line">FROM student_info</span><br><span class="line">WHERE student_id = 67604;  #查询耗时 0.051s  51ms</span><br></pre></td></tr></table></figure>



<p><strong>3.经常GROUP BY和ORDER BY的列</strong></p>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。  </p>
<p>比如，按照student_id对学生选修的课程进行分组，显示不同的student_id和课程数量，显示100个即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># student_id字段上添加索引后</span><br><span class="line">SELECT student_id,count(*) AS num FROM student_info GROUP BY student_id LIMIT 100; # 0.046s</span><br><span class="line"></span><br><span class="line">#删除索引后</span><br><span class="line">-- ALTER TABLE student_info DROP INDEX idx_stu_id;</span><br><span class="line">DROP INDEX idx_stu_id ON student_info;</span><br><span class="line"></span><br><span class="line"># student_id字段上添加索引后</span><br><span class="line">SELECT student_id,count(*) AS num FROM student_info GROUP BY student_id LIMIT 100; # 1.114s</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 先添加两个单列索引</span><br><span class="line">ALTER TABLE student_info ADD INDEX idx_sid(student_id); </span><br><span class="line"></span><br><span class="line">ALTER TABLE student_info ADD INDEX idx_cre_time(create_time); </span><br><span class="line"></span><br><span class="line"># 在查询时会优先进行group by操作，再进行order by。因此在匹配索引时，也是优先匹配froup by对应的列的索引。</span><br><span class="line">SELECT student_id,count(*) AS num FROM student_info GROUP BY student_id ORDER BY create_time DESC LIMIT 100;</span><br><span class="line"></span><br><span class="line">-- 对于下面的联合索引，在进行上面的查询操作会生效。</span><br><span class="line">#添加联合索引</span><br><span class="line">ALTER TABLE student_info</span><br><span class="line">ADD INDEX idx_sid_cre_time(student_id,create_time DESC);</span><br><span class="line"></span><br><span class="line">#在删除上面那个联合索引后，添加下面这个联合索引，再进行查询时，匹配的索引就是上面的单列索引 idx_sid。这与联合索引中的Seq_in_index有关</span><br><span class="line">ALTER TABLE student_info</span><br><span class="line">ADD INDEX idx_sid_cre_time(create_time desc，student_id);</span><br></pre></td></tr></table></figure>



<p><strong>4.UPDATE、DELETE的WHERE条件列</strong></p>
<p>当我们对某条数据进行UPDATE或者DELETE操作的时候，是否也需要对WHERE的条件列创建索引呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#name列上没有索引</span><br><span class="line">UPDATE student_info SET student_id = 10002</span><br><span class="line">WHERE NAME = &#x27;48932483749832hihhffd&#x27;;  # 1.01s</span><br><span class="line"></span><br><span class="line">#添加索引</span><br><span class="line">ALTER TABLE student_info ADD INDEX idx_name(NAME);</span><br><span class="line"></span><br><span class="line">UPDATE student_info SET student_id = 10003</span><br><span class="line">WHERE NAME = &#x27;48932483749832hihhffd&#x27;;  # 0.001s</span><br></pre></td></tr></table></figure>

<p>对数据按照某个条件进行查询后再进行UPDATE或DELETE的操作，如果对WHERE字段创建了索引，就能大幅提升效率。&#x3D;&#x3D;原理是因为我们需要先根据WHERE条件检索出来这条记录，然后再对它进行更新或删除。&#x3D;&#x3D;如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p>
<p><strong>5.DISTINCT字段需要创建索引</strong></p>
<ul>
<li><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>
</li>
<li><p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多   。</p>
</li>
</ul>
<p><strong>6.多表JOIN连接操作时，创建索引注意事项</strong></p>
<ul>
<li>首先， 连接表的数量尽量不要超过 3 张 ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</li>
<li>其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</li>
<li>最后， 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在<br>student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。  </li>
<li></li>
</ul>
<p><strong>7.使用列的类型小的创建索引</strong></p>
<p>这里所说的类型大小指的就是该类型表示的数据范围的大小。</p>
<p>这个建议对于主键来说更为适用。因为不仅聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。</p>
<p><strong>8.使用字符串前缀创建索引</strong></p>
<p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引的时候，那就意味着在对应的B+树中有那么两个问题，</p>
<ul>
<li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引占用的存储空间越大</li>
<li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间</li>
</ul>
<p>我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。即节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table shop(address varchar(120) not null);</span><br><span class="line"></span><br><span class="line">alter table shop add index(address(12));</span><br></pre></td></tr></table></figure>

<p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？  </p>
<p>先看一下字段在全部数据中的选择度  ？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct address) / count(*) from shop;</span><br></pre></td></tr></table></figure>

<p>通过不同长度去计算，与全表的选择性对比  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度</span><br><span class="line">count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度</span><br><span class="line">count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度</span><br><span class="line">count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度</span><br><span class="line">from shop;</span><br></pre></td></tr></table></figure>

<p>引申另一个问题：索引前缀对排序的影响</p>
<blockquote>
<p>如果使用了索引列前缀，比方说前边只把address列的前12个字符放到了二级索引中，下边的这个查询可能就有点尴尬</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from shop</span><br><span class="line">order by address</span><br><span class="line">limit 12;</span><br></pre></td></tr></table></figure>

<p>因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，&#x3D;&#x3D;也就是使用索引列前缀的方式无法支持使用索引排序&#x3D;&#x3D;，只能使用文件排序。</p>
</blockquote>
<p><strong>拓展：Alibaba《Java开发手册》</strong></p>
<ul>
<li>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</li>
<li>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达90% 以上 ，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</li>
</ul>
<p><strong>9.区分度高（散列性高）的列适合作为索引</strong></p>
<ul>
<li>列的基数指的是某一列中不重复数据的个数</li>
<li>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</li>
<li>最好为列的基数大的列建立索引，为计数太小列的建立索引效果可能不好。</li>
</ul>
<p>拓展：联合索引把区分度高的列放在前面</p>
<p><strong>10.使用最频繁的列放到联合索引的左侧</strong></p>
<p>最左前缀匹配原则，可以增加联合索引的使用率</p>
<p><strong>11.在多个字段都要创建索引的情况下，联合索引由于单值索引</strong></p>
<h4 id="3-3-限制索引的数目"><a href="#3-3-限制索引的数目" class="headerlink" title="3.3 限制索引的数目"></a>3.3 限制索引的数目</h4><ul>
<li>因为每个索引都需要占用磁盘空间</li>
<li>索引会影响DML的性能，数据的变更，索引也会进行调整和更新，会造成负担</li>
<li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生出一个最好的执行计划，如果同时有多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li>
</ul>
<h4 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h4><p><strong>1.在where中使用不到的字段，不要设置索引</strong></p>
<ul>
<li>索引的价值是快速定位，如果起不到定位的作用是不需要创建索引的</li>
</ul>
<p><strong>2.数据量小的表最好不要使用索引</strong></p>
<p><strong>3.有大量重复数据的列上不要建立索引</strong></p>
<p>例如对于性别这样的列，因为它的区分度低。</p>
<ul>
<li>索引的价值是帮助快速定位。如果想要定位的数据有很多，那么索引就失去了它的使用价值。</li>
</ul>
<blockquote>
<p>结论：当数据重复度大，比如高于10%的时候，也不需要对这个字段使用索引</p>
</blockquote>
<p><strong>4.避免对经常更新的表创建过多的索引</strong></p>
<ul>
<li>虽然提高了查询速度，同时却会降低更新表的速度</li>
</ul>
<p><strong>5.不建议用无序的值作为索引</strong></p>
<p>例如身份证，UUID（在索引比较时需要转为ASCII，并且插入时可能造成页分裂），MD5,HASH,无序长字符串</p>
<p><strong>6.删除不再使用或者很少使用的索引</strong></p>
<p>为了减少索引对更新操作的影响</p>
<p><strong>7.不要定义冗余或重复的索引</strong></p>
<ul>
<li>冗余索引<ul>
<li>比如 index(a,b,c)相当于 index(a),index(a,b),index(a,b,c)</li>
<li>维护冗余索引只会增加维护的成本</li>
</ul>
</li>
<li>重复索引<ul>
<li>例如 unique index(a) 与index(a)</li>
</ul>
</li>
</ul>
<h4 id="3-5小结"><a href="#3-5小结" class="headerlink" title="3.5小结"></a>3.5小结</h4><ul>
<li>索引是一把双刃剑，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。</li>
<li>所以要实际情况选择索引</li>
</ul>
<h2 id="7-性能分析工具的使用"><a href="#7-性能分析工具的使用" class="headerlink" title="7.性能分析工具的使用"></a>7.性能分析工具的使用</h2><p>在数据库调优中，我们的目标就是响应时间快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p>
<h3 id="1-数据库服务器的优化步骤"><a href="#1-数据库服务器的优化步骤" class="headerlink" title="1.数据库服务器的优化步骤"></a>1.数据库服务器的优化步骤</h3><ul>
<li>当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。</li>
<li>整个流程划分成了 观察（Show status） 和 行动（Action） 两个部分。字母 S 的部分代表观察（会使<br>用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</li>
</ul>
<h3 id="2-查看系统性能参数"><a href="#2-查看系统性能参数" class="headerlink" title="2.查看系统性能参数"></a>2.查看系统性能参数</h3><p>在MySQL中，可以使用SHOW STATUS语句查询一些MySQL数据库服务器的性能参数、执行频率。</p>
<p>SHOW STATUS语句语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL | SESSION] STATUS LIKE &#x27;参数&#x27;</span><br></pre></td></tr></table></figure>

<p>一些常用的性能常数如下：</p>
<p>一些常用的性能参数如下：</p>
<ul>
<li>Connections：连接MySQL服务器的次数。 </li>
<li>Uptime：MySQL服务器的上线时间。</li>
<li>Slow_queries：慢查询的次数。 </li>
<li>Innodb_rows_read：Select查询返回的行数 </li>
<li>Innodb_rows_inserted：执行INSERT操作插入的行数 </li>
<li>Innodb_rows_updated：执行UPDATE操作更新的行数 </li>
<li>Innodb_rows_deleted：执行DELETE操作删除的行数</li>
<li>Com_select：查询操作的次数。 </li>
<li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 </li>
<li>Com_update：更新操作的次数。 </li>
<li>Com_delete：删除操作的次数。</li>
</ul>
<p>若查询MySQL服务器的连接次数，则可执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHOW STTUS LIKE &#x27;Connections&#x27;;</span><br><span class="line"></span><br><span class="line">SHOW STTUS LIKE &#x27;Slow_queries&#x27;;</span><br><span class="line">其他的参数类似</span><br></pre></td></tr></table></figure>

<h3 id="3-统计SQL的查询成本：last-query-cost"><a href="#3-统计SQL的查询成本：last-query-cost" class="headerlink" title="3.统计SQL的查询成本：last_query_cost"></a>3.统计SQL的查询成本：last_query_cost</h3><ul>
<li>一条SQL查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择成本最小的一个作为最终执行的执行计划。</li>
<li>如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的&#x3D;&#x3D;last_query_cost&#x3D;&#x3D;变量值来得到当前查询的成本。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本对应的是SQL语句所&#x3D;&#x3D;需要读取的页的数量。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student_info where student_id &gt; 199000</span><br><span class="line">mysql&gt; show status like &quot;last_query_cost&quot;;</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Last_query_cost | 6915.609000 |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student_info where student_id &gt; 199900;</span><br><span class="line">mysql&gt; show status like &quot;last_query_cost&quot;;</span><br><span class="line">+-----------------+------------+</span><br><span class="line">| Variable_name   | Value      |</span><br><span class="line">+-----------------+------------+</span><br><span class="line">| Last_query_cost | 712.209000 |</span><br><span class="line">+-----------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们发现页的数量是刚才差不多10倍左右，但是查询的效率并没有明显的变化，实际上这两个SQL查询的时间基本上一样，就是因为采用了&#x3D;&#x3D;顺序读取的方式将页面一次性加载到缓冲池中&#x3D;&#x3D;，然后再进行查找。虽然页数量（last_query_cost）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。</p>
<p><strong>适用场景：</strong>它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候</p>
<blockquote>
<p>SQL查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p>
<ul>
<li>&#x3D;&#x3D;位置决定效率。&#x3D;&#x3D;如果页就在数据库&#x3D;&#x3D;缓冲池&#x3D;&#x3D;中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li>&#x3D;&#x3D;批量决定效率&#x3D;&#x3D;。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms）,而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存的随机读取。</li>
</ul>
<p>遇到I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到&#x3D;&#x3D;缓冲池&#x3D;&#x3D;中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
</blockquote>
<h3 id="4-定位执行慢的SQL：慢查询日志"><a href="#4-定位执行慢的SQL：慢查询日志" class="headerlink" title="4.定位执行慢的SQL：慢查询日志"></a>4.定位执行慢的SQL：慢查询日志</h3><ul>
<li>MySQL的慢查询日志，用来记录在MySQL中响应时间超过阈值的语句，具体指执行时间超过long_query_time值得SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</li>
<li>它的主要作用是，帮助我们发现哪些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统地整体效率。当我们地数据库服务器发生阻塞，运行变慢地时候，检查一下慢查询日志，找到哪些慢查询，对解决问日很有帮助。</li>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要地话，一般不建议启动该参数。。因为开启慢查询日志或多或少地会影响性能。</li>
<li>慢查询日志支持将日志记录写入文件</li>
</ul>
<h4 id="4-1-开启慢查询日志参数"><a href="#4-1-开启慢查询日志参数" class="headerlink" title="4.1.开启慢查询日志参数"></a>4.1.开启慢查询日志参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 默认是关闭的</span><br><span class="line">mysql&gt; show variables like &quot;%slow_query_log%&quot;;</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                                                               |</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                                                                 |</span><br><span class="line">| slow_query_log_file | D:\program\mysql-5.7.37-winx64\mysql-5.7.37-winx64\sqlData\DESKTOP-CB9TIM0-slow.log |</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 将慢查询日志进行开启</span><br><span class="line">mysql&gt; set global slow_query_log = on;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;%slow_query_log%&quot;;</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                                                               |</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">| slow_query_log      | ON                                                                                  |</span><br><span class="line">| slow_query_log_file | D:\program\mysql-5.7.37-winx64\mysql-5.7.37-winx64\sqlData\DESKTOP-CB9TIM0-slow.log |</span><br><span class="line">+---------------------+-------------------------------------------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>2.修改long_query_time的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;long_query_time&quot;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改long_query_time的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global long_query_time = 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;long_query_time&quot;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set long_query_time = 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;long_query_time&quot;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>也可以在配置文件 my.cnf文件 中修改这些内容  </p>
<h4 id="4-2-查看慢查询数目"><a href="#4-2-查看慢查询数目" class="headerlink" title="4.2 查看慢查询数目"></a>4.2 查看慢查询数目</h4><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status like &quot;%slow_queries%&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-案例演示"><a href="#4-3-案例演示" class="headerlink" title="4.3 案例演示"></a>4.3 案例演示</h4><p><strong>1.建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`stuno` INT NOT NULL,</span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`age` INT(3) DEFAULT NULL,</span><br><span class="line">`classId` INT(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY(`id`)</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>2.创建函数（这个同上面两个存储函数）</p>
<p><strong>3.创建存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `insert_stu1`(IN `START` int,IN `max_num` int)</span><br><span class="line">BEGIN</span><br><span class="line">	#Routine body goes here...</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	SET autocommit = 0; # 设置手动提交事务</span><br><span class="line">	REPEAT</span><br><span class="line">	SET i = i + 1;</span><br><span class="line">	INSERT INTO student (stuno,NAME,age,classId) values((START + i),rand_string(6),rand_num(10,100),rand_num(10,1000));</span><br><span class="line">	UNTIL i = max_num</span><br><span class="line">	END REPEAT;</span><br><span class="line">	COMMIT;  # 提交事务</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>4.调用存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#调用刚刚创建的存储过程生成数据,4000000条记录，从100001号开始</span><br><span class="line">CALL insert_stu1(100001,4000000);</span><br></pre></td></tr></table></figure>

<p><strong>5.分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &quot;slow_queries&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>除了上述变量之外，控制慢查询日志的还有一个系统变量：min_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过long_query_time的值，那么，这个查询就被记录到慢查询日志中。</li>
<li>这个值默认是0。这样只要查询的执行时间超过10秒钟，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中来。，也可以根据需要到 my.ini文件中修改。</li>
</ul>
<h4 id="4-5-慢查询日志分析工具：mysqldumpslow"><a href="#4-5-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="4.5 慢查询日志分析工具：mysqldumpslow"></a>4.5 慢查询日志分析工具：mysqldumpslow</h4><ul>
<li><p>在生产环境中，如果要手工分析，显然是个体力活，MySQL提供了日志分析工具 mysqldumpslow</p>
</li>
<li><p>查看mysqldumpslow的帮助信息</p>
</li>
<li><pre><code class="bash"># 这是在windows环境下查看mysqldumpslow的方法
$ perl mysqldumpslow.pl -help

# 这是使用mysqldumpslow工具来定位慢查询SQL
# 举例：我们想要按照查询时间排序，查看前五条 SQL 语句
D:\program\mysql-5.7.37-winx64\mysql-5.7.37-winx64\bin&gt;perl mysqldumpslow.pl -s t -t 5 D:\program\mysql-5.7.37-winx64\mysql-5.7.37-winx64\sqlData\DESKTOP-CB9TIM0-slow.log
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysqldumpslow 命令的具体参数如下：</span><br><span class="line"></span><br><span class="line">- -a: 不将数字抽象成N，字符串抽象成S</span><br><span class="line">- -s: 是表示按照何种方式排序：</span><br><span class="line">- c: 访问次数</span><br><span class="line">- l: 锁定时间</span><br><span class="line">- r: 返回记录</span><br><span class="line">- t: 查询时间</span><br><span class="line">- al:平均锁定时间</span><br><span class="line">- ar:平均返回记录数</span><br><span class="line">- at:平均查询时间 （默认方式）</span><br><span class="line">- ac:平均查询次数</span><br><span class="line">- -t: 即为返回前面多少条的数据；、</span><br><span class="line">- -g: 后边搭配一个正则匹配模式，大小写不敏感的；  </span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">#得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="4-6-关闭慢查询日志"><a href="#4-6-关闭慢查询日志" class="headerlink" title="4.6 关闭慢查询日志"></a>4.6 关闭慢查询日志</h4><p>MySQL服务器停止慢查询日志功能有两种方法</p>
<p><strong>方式1：永久性方式</strong></p>
<p>修改my.cnf或my.ini文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=OFF</span><br><span class="line">或者，把slow_query_log一项注释掉 或 删除</span><br><span class="line">#slow_query_log =OFF</span><br><span class="line"></span><br><span class="line"># 再重启MySQL服务，执行如下语句查询慢日志功能。</span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;; #查询慢查询日志所在目录</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;; #查询超时时长</span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<p>使用set语句来设置</p>
<p>1）停止MySQL慢查询日志功能，具体SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=off;</span><br></pre></td></tr></table></figure>

<p>2）重启MySQL服务，使用show语句查询慢查询日志 功能信息，具体sql如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%slow&quot;;</span><br><span class="line"># 以及</span><br><span class="line">show variables like &quot;%long_query_time%&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linux重启mysql服务命令</span></span><br><span class="line">$ systemctl restart mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows重启  注意要在管理员身份下操作</span></span><br><span class="line">C:\Windows\system32&gt;net stop mysql</span><br><span class="line">MySQL 服务正在停止..</span><br><span class="line">MySQL 服务已成功停止。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;net start mysql</span><br><span class="line">MySQL 服务正在启动 .</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure>

<h4 id="4-7-删除慢查询日志"><a href="#4-7-删除慢查询日志" class="headerlink" title="4.7 删除慢查询日志"></a>4.7 删除慢查询日志</h4><ul>
<li><p>可以手动删除慢查询日志文件</p>
</li>
<li><p>使用命令mysqladmin flush-logs来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件</p>
</li>
<li><pre><code class="bash">$ mysqladmin -uroot -p flush-logs slow
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 注意新建的日志文件只包括在这之后的慢查询日志内容，如果需要之前的必须要进行备份</span><br><span class="line"></span><br><span class="line">### 5.查看SQL执行成本：SHOW  PROFILE</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql&gt; show profils;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;profils&#x27; at line 1</span><br><span class="line"></span><br><span class="line">#显式查询执行成本</span><br><span class="line">mysql&gt; show profiles;</span><br><span class="line">+----------+------------+---------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                       |</span><br><span class="line">+----------+------------+---------------------------------------------+</span><br><span class="line">|        1 | 0.00416575 | show variables like &quot;profiling&quot;             |</span><br><span class="line">|        2 | 2.40017375 | select * from student where name = &quot;JnoEfp&quot; |</span><br><span class="line">|        3 | 0.00058675 | show profils                                |</span><br><span class="line">+----------+------------+---------------------------------------------+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 查询特定子句的执行情况</span><br><span class="line">mysql&gt; show profile for query 2;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.004304 |</span><br><span class="line">| checking permissions | 0.000082 |</span><br><span class="line">| Opening tables       | 0.007239 |</span><br><span class="line">| init                 | 0.000542 |</span><br><span class="line">| System lock          | 0.000016 |</span><br><span class="line">| optimizing           | 0.000012 |</span><br><span class="line">| statistics           | 0.000012 |</span><br><span class="line">| preparing            | 0.000008 |</span><br><span class="line">| executing            | 0.000002 |</span><br><span class="line">| Sending data         | 2.387753 |</span><br><span class="line">| end                  | 0.000011 |</span><br><span class="line">| query end            | 0.000011 |</span><br><span class="line">| closing tables       | 0.000009 |</span><br><span class="line">| freeing items        | 0.000147 |</span><br><span class="line">| cleaning up          | 0.000027 |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">15 rows in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 查询带cpu,io这些指标的情况</span><br><span class="line">mysql&gt; show profile cpu,block io for query 2;</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| starting             | 0.004304 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| checking permissions | 0.000082 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| Opening tables       | 0.007239 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| init                 | 0.000542 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| System lock          | 0.000016 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| optimizing           | 0.000012 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| statistics           | 0.000012 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| preparing            | 0.000008 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| executing            | 0.000002 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| Sending data         | 2.387753 | 2.203125 |   0.390625 |         NULL |          NULL |</span><br><span class="line">| end                  | 0.000011 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| query end            | 0.000011 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| closing tables       | 0.000009 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| freeing items        | 0.000147 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| cleaning up          | 0.000027 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">15 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>日常开发需注意的结论：</p>
<ul>
<li>converting  HEAP to MyISAM; 查询结果太大，内存不够，数据往磁盘上搬了</li>
<li>creating temp table：创建临时表，先拷贝数据到临时表，用完后再删除临时表</li>
<li>copying  to  tmp table  on disk：把内存中临时表复制到磁盘上</li>
<li>locked</li>
</ul>
<p>如果show profile诊断结果中出现了以上4条结果中的任何一条，则需要进行优化</p>
<h3 id="6-分析查询工具：EXPLAIN"><a href="#6-分析查询工具：EXPLAIN" class="headerlink" title="6.分析查询工具：EXPLAIN"></a>6.分析查询工具：EXPLAIN</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><ul>
<li><p>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。这两个工具分析结果是一样的。</p>
</li>
<li><p>MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为最优的，这部分最耗费时间）</p>
</li>
<li><p>这个执行计划展示了接下来具体执行查询的方式，比如夺标连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，看懂EXPLAIN语句的各个输出项，可以有针对性的提升我们查询语句的性能。</p>
</li>
</ul>
<p>1.能做什么？</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>那些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<h4 id="6-2-基本语法"><a href="#6-2-基本语法" class="headerlink" title="6.2 基本语法"></a>6.2 基本语法</h4><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT select_options</span><br><span class="line">或者</span><br><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>

<p>在执行的时候，只是去查询了执行计划，数据库里面并没有真正的执行，例如执行删除，数据仍然在数据库里面</p>
<p>如果我们想看某个查询的执行计划的话，可以在具体的查询语句前边加一个EXPLAIN，就像这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220606200451913.png" alt="image-20220606200451913"></p>
<h4 id="6-3-数据准备"><a href="#6-3-数据准备" class="headerlink" title="6.3 数据准备"></a>6.3 数据准备</h4><p><strong>1.建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE s1 (</span><br><span class="line">id INT AUTO_INCREMENT,</span><br><span class="line">key1 VARCHAR(100),</span><br><span class="line">key2 INT,</span><br><span class="line">key3 VARCHAR(100),</span><br><span class="line">key_part1 VARCHAR(100),</span><br><span class="line">key_part2 VARCHAR(100),</span><br><span class="line">key_part3 VARCHAR(100),</span><br><span class="line">common_field VARCHAR(100),</span><br><span class="line">PRIMARY KEY (id),</span><br><span class="line">INDEX idx_key1 (key1),</span><br><span class="line">UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">INDEX idx_key3 (key3),</span><br><span class="line">INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE s2 (</span><br><span class="line">id INT AUTO_INCREMENT,</span><br><span class="line">key1 VARCHAR(100),</span><br><span class="line">key2 INT,</span><br><span class="line">key3 VARCHAR(100),</span><br><span class="line">key_part1 VARCHAR(100),</span><br><span class="line">key_part2 VARCHAR(100),</span><br><span class="line">key_part3 VARCHAR(100),</span><br><span class="line">common_field VARCHAR(100),</span><br><span class="line">PRIMARY KEY (id),</span><br><span class="line">INDEX idx_key1 (key1),</span><br><span class="line">UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">INDEX idx_key3 (key3),</span><br><span class="line">INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p><strong>2.创建存储函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` FUNCTION `rand_string1`(n INT) RETURNS varchar(255) CHARSET utf8mb4</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">WHILE i &lt; n DO</span><br><span class="line">SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN return_str;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>如果不允许创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global log_bin_trust_function_creators=1;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `insert_s1`(IN min_num INT (10),IN max_num INT (10))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i = i + 1;</span><br><span class="line">INSERT INTO s1 VALUES(</span><br><span class="line">(min_num + i),</span><br><span class="line">rand_string1(6),</span><br><span class="line">(min_num + 30 * i + 5),</span><br><span class="line">rand_string1(6),</span><br><span class="line">rand_string1(10),</span><br><span class="line">rand_string1(5),</span><br><span class="line">rand_string1(10),</span><br><span class="line">rand_string1(10));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `insert_s2`(IN min_num INT (10),IN max_num INT (10))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i = i + 1;</span><br><span class="line">INSERT INTO s2 VALUES(</span><br><span class="line">(min_num + i),</span><br><span class="line">rand_string1(6),</span><br><span class="line">(min_num + 30 * i + 5),</span><br><span class="line">rand_string1(6),</span><br><span class="line">rand_string1(10),</span><br><span class="line">rand_string1(5),</span><br><span class="line">rand_string1(10),</span><br><span class="line">rand_string1(10));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>4.调用存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 调用存储过程往表中添加数据</span><br><span class="line"># 往两张表中各添加10000条数据</span><br><span class="line">CALL insert_s1(10001,10000);</span><br><span class="line"></span><br><span class="line">CALL insert_s2(10001,10000);</span><br></pre></td></tr></table></figure>

<h4 id="6-4-EXPLAIN各列作用"><a href="#6-4-EXPLAIN各列作用" class="headerlink" title="6.4 EXPLAIN各列作用"></a>6.4 EXPLAIN各列作用</h4><h5 id="1-table"><a href="#1-table" class="headerlink" title="1.table"></a><strong>1.table</strong></h5><p>不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）  </p>
<h5 id="2-id"><a href="#2-id" class="headerlink" title="2.id"></a><strong>2.id</strong></h5><p>我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比如下边这个查询语句  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">######查询优化器可能对涉及子查询的查询语句进行重写,转变为多表查询的操作########</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">#Union去重</span><br><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br><span class="line"></span><br><span class="line"># UNION ALL不用去重,所以不会生成临时表</span><br><span class="line">EXPLAIN SELECT * FROM s1  UNION ALL SELECT * FROM s2;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ul>
<h5 id="3-select-type"><a href="#3-select-type" class="headerlink" title="3.select_type"></a><strong>3.select_type</strong></h5><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220606203721478.png" alt="image-20220606203721478"></p>
<h5 id="4-partition"><a href="#4-partition" class="headerlink" title="4.partition"></a>4.partition</h5><p><strong>5.type</strong> *</p>
<p>执行计划的一条记录就代表着MySQL对某个表的执行查询时的访问方法，又称访问类型，其中的type列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到type列的值是ref，表明MySQL即将使用ref访问方法来执行对s1表的查询。</p>
<p>&#x3D;&#x3D;完整的访问方法如下：system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ，index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL 。&#x3D;&#x3D;  </p>
<p>性能分析工具的使用：待看</p>
<h2 id="8-索引优化与查询优化"><a href="#8-索引优化与查询优化" class="headerlink" title="8.索引优化与查询优化"></a>8.索引优化与查询优化</h2><p>都有哪些维度可以进行数据库调优？简言之：</p>
<ul>
<li>索引失效，没有充分利用到索引——索引建立</li>
<li>关联查询太多join(设计缺陷或不得已的需求)——SQL优化</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li>
<li>数据过多——分库分表</li>
</ul>
<p>SQL查询优化主要可以分为物理查询优化和逻辑查询优化两大块</p>
<ul>
<li>物理查询优化是通过&#x3D;&#x3D;索引和表连接方式&#x3D;&#x3D;等技术来进行优化，这里重点掌握索引的使用</li>
<li>逻辑查询优化就是通过&#x3D;&#x3D;SQL等价变换&#x3D;&#x3D;提升查询效率，直白点说就是换一种查询写法执行效率可能更高</li>
</ul>
<h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1.数据准备"></a>1.数据准备</h3><h3 id="2-索引失效案例"><a href="#2-索引失效案例" class="headerlink" title="2.索引失效案例"></a>2.索引失效案例</h3><p>MySQL中提高性能的一个最有效的方式就是对数据表设计合理的索引。其实用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销，它不是基于规则，也不是基于语义。怎么样开销小就怎么来。另外SQL语句是否使用索引，跟数据库版本、数据量、数据选择都都有关系。</p>
<h4 id="1-全值匹配"><a href="#1-全值匹配" class="headerlink" title="1.全值匹配"></a><strong>1.全值匹配</strong></h4><ul>
<li>不要写不加查询条件地查询语句</li>
</ul>
<h4 id="2-最佳左前缀匹配规则"><a href="#2-最佳左前缀匹配规则" class="headerlink" title="2.最佳左前缀匹配规则"></a><strong>2.最佳左前缀匹配规则</strong></h4><ul>
<li>这个主要针对的是联合索引，是从左至右开始进行匹配的，如果最左边没有则直接没有。</li>
<li>注意这与我们选择的顺序没有关系，即语句中写的旁边的name与age的顺序没有关系。<ul>
<li>比如 select * from student where age &#x3D; 1 and  name&#x3D;’hello’;</li>
</ul>
</li>
<li>必须要从左至右进行匹配，如果有一个不匹配，则只使用了前面匹配到的部分（只会使用到联合索引的一部分）</li>
</ul>
<h4 id="3-主键插入顺序"><a href="#3-主键插入顺序" class="headerlink" title="3.主键插入顺序"></a><strong>3.主键插入顺序</strong></h4><ul>
<li>尽可能地让主键值依次递增，例如 让主键列具备auto_increment。</li>
</ul>
<h4 id="4-计算、函数、类型转换（自动或手动）导致索引失败"><a href="#4-计算、函数、类型转换（自动或手动）导致索引失败" class="headerlink" title="4.计算、函数、类型转换（自动或手动）导致索引失败"></a><strong>4.计算、函数、类型转换（自动或手动）导致索引失败</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 此语句比下一条语句 能够使用上索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br><span class="line"></span><br><span class="line"># 因为使用了函数，所以就用不上索引了，在执行时是从数据库中一条一条地拿数据去进行比较</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br><span class="line"></span><br><span class="line"># 索引会失效，因为会先逐条拿数据进行计算后再进行比较</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;</span><br><span class="line"></span><br><span class="line"># 会用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno = 900000;</span><br><span class="line"></span><br><span class="line"># 未使用到索引   name=123发生类型转换，索引失效。</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;</span><br><span class="line"></span><br><span class="line"># 使用到索引 </span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="5-范围条件右边的列索引失效"><a href="#5-范围条件右边的列索引失效" class="headerlink" title="5.范围条件右边的列索引失效"></a><strong>5.范围条件右边的列索引失效</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 范围条件右边的列索引失效，指的是name字段，注意classId这个列的索引用上了。这主要是针对一个拥有（age,classId,name）这个联合索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student</span><br><span class="line">WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ;</span><br><span class="line"></span><br><span class="line">#如果我们要使三个字段的索引全部生效，可以把联合索引的位置建成（age,name,classId）,将范围条件的列放在最右边，这样就能全部起作用了</span><br></pre></td></tr></table></figure>

<h4 id="6-不等于（-或者）索引失效"><a href="#6-不等于（-或者）索引失效" class="headerlink" title="6.不等于（!&#x3D;或者&lt;&gt;）索引失效"></a><strong>6.不等于（!&#x3D;或者&lt;&gt;）索引失效</strong></h4><ul>
<li>在8.0失效了</li>
</ul>
<h4 id="7-is-null可以使用索引，is-not-null无法使用索引"><a href="#7-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="7.is null可以使用索引，is not null无法使用索引"></a><strong>7.is null可以使用索引，is not null无法使用索引</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注意使用count时 索引就不失效了</span><br><span class="line"></span><br><span class="line"># 索引不失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE count(*) from student WHERE age IS NOT NULL;</span><br><span class="line"></span><br><span class="line"># 索引失效了</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * from student WHERE age IS NOT NULL;</span><br></pre></td></tr></table></figure>



<ul>
<li>结论：最好在设计数据表的时候就将字段设置为NOT NULL约束，比如你可以将INT类型的字段，默认设置为0，将字符类型的默认设置为空字符串（’ ‘）</li>
<li>拓展：同理，在查询中使用not like也无法使用索引，导致全表扫描</li>
</ul>
<h4 id="8-like以通配符-开头索引失效"><a href="#8-like以通配符-开头索引失效" class="headerlink" title="8.like以通配符%开头索引失效"></a><strong>8.like以通配符%开头索引失效</strong></h4><ul>
<li>因此页面搜索引擎中严禁左模糊或全模糊</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#索引失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * from student WHERE NAME LIKE &#x27;%abc&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#不失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * from student WHERE NAME LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="9-OR-前后存在非索引的列，索引失效"><a href="#9-OR-前后存在非索引的列，索引失效" class="headerlink" title="9.OR 前后存在非索引的列，索引失效"></a><strong>9.OR 前后存在非索引的列，索引失效</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br></pre></td></tr></table></figure>

<h4 id="10-数据库和表的字符集统计使用utf8mb4"><a href="#10-数据库和表的字符集统计使用utf8mb4" class="headerlink" title="10.数据库和表的字符集统计使用utf8mb4"></a><strong>10.数据库和表的字符集统计使用utf8mb4</strong></h4><p>统一使用utf8mb4(5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较浅需要进行转换会造成索引失效。</p>
<p>一般性建议：</p>
<ul>
<li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前query中过滤性更好的字段在索引字段顺序中，位置越靠前越好</li>
<li>在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引</li>
<li>在选择组合索引的时候，如果某个字段可能出现范围查询的时候，尽量把这个字段放在索引次序的最后面</li>
</ul>
<h3 id="3-关联查询优化"><a href="#3-关联查询优化" class="headerlink" title="3.关联查询优化"></a>3.关联查询优化</h3><h4 id="3-1左外连接"><a href="#3-1左外连接" class="headerlink" title="3.1左外连接"></a>3.1左外连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># type表是驱动表，book表是被驱动表</span><br><span class="line"># 左外连接</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br><span class="line"></span><br><span class="line">#给被驱动表添加索引，可以避免全表扫描</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from student LEFT JOIN class ON student.name = class.className;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                                              |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499126 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | class   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   9952 |   100.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220607162534461.png" alt="image-20220607162534461"></p>
<h4 id="3-2内连接"><a href="#3-2内连接" class="headerlink" title="3.2内连接"></a>3.2内连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在进行内连接的时候，优化器有权利来决定谁是驱动表与谁是被驱动表。这个主要取决于谁的数据量大。</span><br><span class="line"># 数据量小的作为驱动表</span><br><span class="line">EXPLAIN SELECT * from student INNER JOIN class ON student.name = class.className;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对于内连接来讲，如果表的连接条件中只能由一个字段有索引，则有索引的字段所在的表会被作为被驱动表出现。</li>
<li>在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表，也就是小表驱动大表。</li>
</ul>
<h4 id="3-3-join语句原理"><a href="#3-3-join语句原理" class="headerlink" title="3.3 join语句原理"></a>3.3 join语句原理</h4><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环（nested Loop Join）。如果关联表的数据量很大，则join关联的执行时间会非常长。在MySQL5.5以后的版本中，&#x3D;&#x3D;MySQL通过引入BNLJ算法来优化嵌套执行&#x3D;&#x3D;</p>
<p><strong>1.驱动表和被驱动表</strong></p>
<p>驱动表就是主表，被驱动表就是从表，非驱动表</p>
<ul>
<li>对于内连接来说</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  *  FROM  A  JOIN B  ON ...</span><br></pre></td></tr></table></figure>

<p>A一定是驱动表吗？不一定，优化器会根据你查询语句做优化，决定先查哪张表，先查询的那张表就是驱动表，反之就是被驱动表。通过EXPLAIN关键字来查看。</p>
<ul>
<li>对于外连接来说</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT  *  FROM  A  LEFT  JOIN B  ON ...</span><br><span class="line"></span><br><span class="line">SELECT  *  FROM  B  RIGHT  JOIN A  ON ...</span><br></pre></td></tr></table></figure>

<p>通常大家会认为A就是驱动表，B就是被驱动表，但也未必，测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE a(</span><br><span class="line">f1 INT,</span><br><span class="line">f2 INT,</span><br><span class="line">INDEX(f1)</span><br><span class="line">)ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE b(</span><br><span class="line">f1 INT,</span><br><span class="line">f2 INT</span><br><span class="line">)ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO a VALUES(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);</span><br><span class="line">INSERT INTO b VALUES(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试1  因为后面的where语句的原因，这里面的驱动表是b,被驱动表是a。因为a有索引。【主要是查询后的结果集a更小】</span><br><span class="line"># 查询优化器是帮我们把这个左外连接转化为了内连接 </span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON (a.f1 = b.f1) WHERE (a.f2 = b.f2);</span><br><span class="line"></span><br><span class="line">#测试2  此时索引会失效a还是作为驱动表</span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON (a.f1 = b.f1) AND (a.f2 = b.f2);</span><br><span class="line"></span><br><span class="line"># 测试3  内连接 默认都是内连接  此时也是a为被驱动表</span><br><span class="line">EXPLAIN SELECT * FROM a JOIN b ON (a.f1 = b.f1) WHERE (a.f2 = b.f2);</span><br></pre></td></tr></table></figure>

<p><strong>2.Simple Nested-Loop join(简单嵌套循环连接)</strong></p>
<ul>
<li>算法相当简单，从表A中取出一条数据1，遍历表B,将匹配到的数据放到result，以此类推，驱动表A中的每一条记录与被驱动表中的记录进行判断</li>
<li>可以看到这种方式效率还是比较低的，所以就出现了后面的两种对Nested-Loop Join优化算法</li>
</ul>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表【A,驱动表】扫描次数</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A(A表中的记录数)</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A+A*B</td>
</tr>
<tr>
<td>JOIN比较次数</td>
<td>B*A</td>
</tr>
<tr>
<td>回表读取记录数</td>
<td>0 【因为没有索引，所以不涉及到回表操作】</td>
</tr>
</tbody></table>
<p><strong>3.Index Nested_Loop Join(索引嵌套循环连接)</strong></p>
<ul>
<li>Index Nested——Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大地减少了对内层表的匹配次数</li>
<li>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）</li>
</ul>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表【A,驱动表】扫描次数</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A(A表中的记录数)</td>
<td>0</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A+A*B</td>
<td>A+B(match)</td>
</tr>
<tr>
<td>JOIN比较次数</td>
<td>B*A</td>
<td>A*Index(Height)【索引扫描的层数】</td>
</tr>
<tr>
<td>回表读取记录数</td>
<td>0 【因为没有索引，所以不涉及到回表操作】</td>
<td>B(match) [如果需要的话]</td>
</tr>
</tbody></table>
<ul>
<li>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行依次回表查询，相比，被驱动表的索引是主键索引，效率会更高</li>
</ul>
<p><strong>4.Block Nested-Loop Join(块嵌套循环连接)</strong></p>
<ul>
<li>如果存在索引，那么会使用index的方式进行join，如果join的列没有所有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的数据都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载中匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested_Loop Join的方式</li>
<li>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了&#x3D;&#x3D;join buffer缓冲区&#x3D;&#x3D;，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的&#x3D;&#x3D;每一条记录一次性和join buffer中的所有驱动表记录&#x3D;&#x3D;进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>这里缓存的不只是关联表的列，select后面的列也会缓存起来</p>
<p>在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列</p>
</blockquote>
<p>参数设置：</p>
<ul>
<li>block_nested_loop：通过查看block_nested_loop状态。默认是开启的</li>
<li>join_buffer_size:驱动表的数据能不能一次性加载完，要看join buffer能不能存储所有的数据，默认情况下join_buffer_size&#x3D;256K..</li>
</ul>
<p><strong>5.join小结</strong></p>
<p>&#x3D;&#x3D;1.整体效率比较：INLJ&gt;BNLJ&gt;SNLJ&#x3D;&#x3D;</p>
<p>2.永远用小&#x3D;&#x3D;结果集&#x3D;&#x3D;驱动大结果集（其本质是减少&#x3D;&#x3D;外层循环&#x3D;&#x3D;的数据数量）（小的度量单位指的是表行数*每行大小）</p>
<p>3.为被驱动表匹配的条件增加索引（减少内存表的循环匹配次数）</p>
<p>4.增加join buffer size的大小（一次缓存的数据越多，那么内存包的扫描次数就越少）</p>
<p>5.减少驱动表不必要的字段查询（字段越少，join  buffer所缓存的数据就越多）</p>
<p><strong>6.Hash Join</strong></p>
<ul>
<li><p>这是MySQL8.0新特性</p>
</li>
<li><p>从MySQL8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash  join</p>
</li>
<li><p>Nested Loop：对于被连接的数据子集较小的情况，Nested Loop是一个较好的选择</p>
</li>
<li><p>Hash Join是做&#x3D;&#x3D;大数据集连接&#x3D;&#x3D;时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立&#x3D;&#x3D;散列表&#x3D;&#x3D;，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p>
<ul>
<li>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I&#x2F;O的性能</li>
<li>它能够很好的工作于没有索引的达标和并行查询的环境中，并提高最好的性能。大多数人都说它是join的重型升降机。&#x3D;&#x3D;Hash Join只能应用于等值连接&#x3D;&#x3D;（如where A.col1 &#x3D; B.COL2），这是由Hash的特点决定的</li>
</ul>
</li>
</ul>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li>保证被驱动表的JOIN字段已经创建了索引</li>
<li>需要JOIN 的字段，数据类型保持绝对一致。</li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
<h3 id="4-子查询优化"><a href="#4-子查询优化" class="headerlink" title="4.子查询优化"></a>4.子查询优化</h3><ul>
<li><p>MySQL从4.1版本开始支持子查询，使用子查询可以继续宁select语句的嵌套查询，即一个select查询的结果作为另一个select语句的条件。&#x3D;&#x3D;子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作&#x3D;&#x3D;。</p>
</li>
<li><p>子查询虽然可以帮助我们通过一个SQL语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：</p>
<ul>
<li>执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表<br>中查询记录。查询完毕后，再 撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</li>
<li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会<br>受到一定的影响。</li>
<li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li>
</ul>
</li>
<li><p>在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询 不需要建立临时表 ，其 速度比子查询要快 ，如果查询中使用索引的话，性能就会更好。</p>
</li>
</ul>
<blockquote>
<p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#不推荐使用</span><br><span class="line">EXPLAIN SELECT * FROM student stu1</span><br><span class="line">WHERE stu1.stuno IN (</span><br><span class="line">	SELECT monitor</span><br><span class="line">	FROM class c</span><br><span class="line">	WHERE monitor IS NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#将上面语句改造成多表查询</span><br><span class="line">EXPLAIN SELECT * FROM student stu1 JOIN class c ON stu1.stuno = c.monitor WHERE c.monitor IS NOT NULL; </span><br></pre></td></tr></table></figure>

<h3 id="5-排序索引"><a href="#5-排序索引" class="headerlink" title="5.排序索引"></a>5.排序索引</h3><ul>
<li>问题：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</li>
<li>回答：<ul>
<li>在MySQL中，支持两种排序方式，分别是FileSort和Index排序<ul>
<li>Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高</li>
<li>FileSort排序则一般在&#x3D;&#x3D;内存中&#x3D;&#x3D;进行排序，&#x3D;&#x3D;占用CPU较多&#x3D;&#x3D;。如果待排结果较大，会产生临时文件IO到磁盘进行排列的情况，频率较低。</li>
</ul>
</li>
</ul>
</li>
<li>优化建议：<ul>
<li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，&#x3D;&#x3D;&#x3D;&#x3D;目的是在 WHERE 子句中 避免全表扫<br>描&#x3D;&#x3D; ，在 ORDER BY 子句 避免使用 FileSort 排序 。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 删除除主键之外的索引</span><br><span class="line">CALL proc_drop_index(&quot;atguigudb2&quot;,&quot;student&quot;);</span><br><span class="line">CALL proc_drop_index(&quot;atguigudb2&quot;,&quot;class&quot;);</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM student;</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM class;</span><br><span class="line"></span><br><span class="line"># 过程1 </span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classId;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classId  LIMIT 10;</span><br><span class="line"></span><br><span class="line"># 创建索引</span><br><span class="line">CREATE INDEX idx_age_classId_name ON student (age,classId,NAME);</span><br><span class="line"></span><br><span class="line"># 不限制 索引失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classId;</span><br><span class="line"></span><br><span class="line"># 加上 limit限制，会使用索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classId  LIMIT 10;</span><br></pre></td></tr></table></figure>

<ul>
<li>order by时规则不一致，索引失效（顺序错【最左前缀匹配】不索引：方向反，不索引【这里的方向指的是字段是升序还是降序，要不排序的字段全降序或者全升序】）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line">order by 能使用索引最左前缀</span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a,b</span><br><span class="line">- ORDER BY a,b,c</span><br><span class="line">- ORDER BY a DESC,b DESC,c DESC</span><br><span class="line">如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br><span class="line">不能使用索引进行排序</span><br><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>案例实战</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt; 101000 ORDER BY NAME;</span><br><span class="line"></span><br><span class="line"># 方案1：为了去掉filesort我们可以把索引建成</span><br><span class="line">CREATE INDEX idx_age_name ON student(age,NAME);</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt; 101000 ORDER BY NAME;</span><br><span class="line"></span><br><span class="line">#方案2：</span><br><span class="line">CREATE INDEX idx_age_stuno_name ON student(age,stuno,NAME);</span><br><span class="line"># 再次执行，虽然使用filesort进行排序，但是查询效果比上面不用filesort的效果好。这是因为where条件已经过滤掉了大部分数据，所以就不用在order by字段上再进行索引，可以直接通过filesort就行</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt; 101000 ORDER BY NAME;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：</p>
<ul>
<li>两个索引同时存在，mysql自动选择最优的方案。（对于这个例子，mysql选择idx_age_stuno_name）。但是， 随着数据量的变化，选择的索引也会随之变化的 。</li>
<li>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li>
</ul>
</blockquote>
<p>思考：这里我们使用如下索引，是否可行？  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_age_stuno_name ON student;</span><br><span class="line"># 针对上面的例子，使用下面的索引也是可以的，与上面那个联合索引效果一样</span><br><span class="line">CREATE INDEX idx_age_stuno ON student(age,stuno);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Filesort算法，双路排序和单路排序</strong></li>
</ul>
<p>排序的字段若不在索引列上，则filesort会有两种算法：双路排序和单路排序</p>
<p>&#x3D;&#x3D;双路排序（慢）&#x3D;&#x3D;</p>
<ul>
<li>&#x3D;&#x3D;MySQL 4.1之前是使用双路排序&#x3D;&#x3D; ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和&#x3D;&#x3D;order by列&#x3D;&#x3D; ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li>
<li>从磁盘取排序字段，在buffer进行排序，再从 磁盘取其他字段 。</li>
</ul>
<p>取一批数据，要对&#x3D;&#x3D;磁盘进行两次扫描&#x3D;&#x3D;，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。  </p>
<p>&#x3D;&#x3D;单路排序（快）&#x3D;&#x3D;</p>
<p>从磁盘读取查询需要的 &#x3D;&#x3D;所有列&#x3D;&#x3D; ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输<br>出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空<br>间， 因为它把每一行都保存在内存中了。  </p>
<p><strong>结论及引申出的问题：</strong></p>
<ul>
<li>由于单路是后出的，总体而言好过双路</li>
<li>但是用单路有问题：<ul>
<li>在sort_buffer中，单路比多路多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次IO</li>
<li>单路本来想省一次IO操作，反而导致了大量的IO操作反而得不偿失。</li>
</ul>
</li>
</ul>
<p><strong>优化策略：</strong></p>
<p>1.尝试提高sort_buffer_size，默认是1M</p>
<ul>
<li><pre><code class="mysql">show variables like &quot;%sort_buffer_size&quot;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.尝试提高max_length_for_sort_data</span><br><span class="line"></span><br><span class="line">- 默认大小也是1M,.提高这个参数，会增加用改进算法的概率。</span><br><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  show variables like &quot;%max_length_for_sort_data%&quot;;  #默认是1024字节</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>但是如果设的太高，数据总容量超出sort_buffer_size就会增大，从而导致一个低的CPU利用率。ruguo 超过了就使用双路的。</p>
</li>
</ul>
<p>3.Order by 时select * 是一个大忌。最好只Query需要的字段。  </p>
<ul>
<li>两种算法的数据都有可能超出sort_buffer_size的容量，超出之后，会创建tmp文件进行合并排序，导致多次io,但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size.</li>
</ul>
<h3 id="6-group-by优化"><a href="#6-group-by优化" class="headerlink" title="6.group by优化"></a>6.group by优化</h3><ul>
<li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则。</li>
<li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</li>
<li>where效率高于having，能写在where限定的条件就不要写在having中了</li>
<li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li>
</ul>
<h3 id="7-优化分页查询"><a href="#7-优化分页查询" class="headerlink" title="7.优化分页查询"></a>7.优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头痛的问题就是limit 2000000,10，此时需要MySQL排序前2000010记录，仅仅返回2000000-2000010条的记录，其他记录丢弃，查询排序的代价非常大</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student LIMIT 2000000,10;</span><br><span class="line"></span><br><span class="line"># 优化思路1</span><br><span class="line"># 在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</span><br><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a where t.id = a.id;</span><br><span class="line"></span><br><span class="line"># 优化思路2</span><br><span class="line"># 该方案适用于主键自增的表，可以把limit查询转换成某个位置的查询</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure>

<h3 id="8-优先覆盖索引"><a href="#8-优先覆盖索引" class="headerlink" title="8.优先覆盖索引"></a>8.优先覆盖索引</h3><h4 id="8-1-什么是覆盖索引？"><a href="#8-1-什么是覆盖索引？" class="headerlink" title="8.1 什么是覆盖索引？"></a>8.1 什么是覆盖索引？</h4><ul>
<li>理解方式一：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。&#x3D;&#x3D;一个索引包含了满足查询结果的数据就叫做覆盖索引。&#x3D;&#x3D;</li>
<li>理解方式二：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</li>
<li>简单说就是， &#x3D;&#x3D;索引列+主键 包含 SELECT 到 FROM之间查询的列 。&#x3D;&#x3D;</li>
</ul>
<h4 id="8-2-覆盖索引的利弊"><a href="#8-2-覆盖索引的利弊" class="headerlink" title="8.2 覆盖索引的利弊"></a>8.2 覆盖索引的利弊</h4><p><strong>好处：</strong></p>
<ul>
<li>&#x3D;&#x3D;避免Innodb表进行索引的二 次查询（回表）&#x3D;&#x3D;<ul>
<li>innodb是以聚簇索引的顺序来存储的，对于innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需要通过主键进行二次查询才能获取我们真实所需要的数据</li>
<li>在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率。</li>
</ul>
</li>
<li>可以把随机IO变成顺序IO加快查询效率<ul>
<li>因为回表后的主键存储的记录在聚簇索引中，所以在回表时是一种随机读取的IO.</li>
<li>由于覆盖索引是按键值的顺序存储的，所以是顺序IO</li>
<li>由于覆盖索引可以减少树的搜索次数，显著提升查询性能。</li>
</ul>
</li>
</ul>
<p><strong>弊端：</strong></p>
<ul>
<li>索引字段的维护 总是有代价的。因此，在建立多余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</li>
</ul>
<h3 id="9-如何给字符串加索引"><a href="#9-如何给字符串加索引" class="headerlink" title="9.如何给字符串加索引"></a>9.如何给字符串加索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 普通索引，不加前缀索引，就是整个字符串长度</span><br><span class="line">mysql&gt; alter table teacher add index index1(email);</span><br><span class="line"># 前缀索引</span><br><span class="line">mysql&gt; alter table teacher add index index2(email(6));</span><br></pre></td></tr></table></figure>

<p>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。前面已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。  </p>
<blockquote>
<p>结论：</p>
<p>使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。  </p>
</blockquote>
<h3 id="10-索引下推"><a href="#10-索引下推" class="headerlink" title="10.索引下推"></a>10.索引下推</h3><h4 id="10-1-使用前后对比"><a href="#10-1-使用前后对比" class="headerlink" title="10.1 使用前后对比"></a>10.1 使用前后对比</h4><p>Index Condition Pushdown(ICP)是MySQL5.6中的新特性，是一种在存储引擎层使用索引过滤数据的优化方式。</p>
<ul>
<li>如果没有ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给MySQL服务器，由服务器评估where后面的条件是否保留行</li>
<li>启用ICP后，如果部分where条件可以仅使用索引中的列进行筛选，则MySQL服务器会把这部分where条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有满足这一条件时才从表中读取行。<ul>
<li>好处：ICP可以减少存储引擎必须访问基表的次数和MySQL服务器必须访问存储引擎的次数</li>
<li>但是，ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 举例2</span><br><span class="line">CREATE INDEX idx_zip_last_first ON people(zipcode,lastname,firstname);</span><br><span class="line"></span><br><span class="line"># 在没有索引下推的情况下，就只有使用联合索引中的zipcode字段进行查询后，其中lastname LIKE &quot;%张%&quot;不符合索引的情况，以及address也不符合，所以假设查询出10000条数据后就进行回表操作</span><br><span class="line"></span><br><span class="line"># 但是在有索引下推的情况下，虽然对于这个%张%这个过滤条件用不到索引，但是在索引下推的情况下，就可以zipcode过滤完后的结果里面使用lastname=&quot;%张%&quot;这个过滤条件后再去进行回表</span><br><span class="line">EXPLAIN SELECT * FROM people WHERE zipcode = &#x27;100001&#x27; AND lastname LIKE &quot;%张%&quot; AND address LIKE &quot;%北京市%&quot;；</span><br></pre></td></tr></table></figure>

<h4 id="10-2-ICP的开启和关闭"><a href="#10-2-ICP的开启和关闭" class="headerlink" title="10.2  ICP的开启和关闭"></a>10.2  ICP的开启和关闭</h4><ul>
<li><p>默认情况下启用索引条件下推，可以通过系统变量 optimizer——switch控制：index_condition_pushdown</p>
</li>
<li><pre><code class="mysql">#关闭索引下推
set optimizer_switch = &#39;index_condition_pushdown=off&#39;;

# 打开索引下推
set optimizer_switch = &#39;index_condition_pushdown=on&#39;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用了，在extra里面就会有 use index condition</span><br><span class="line"></span><br><span class="line">#### 10.3 ICP的使用条件</span><br><span class="line"></span><br><span class="line">- 如果表访问的类型为range，ref，eq_ref和ref_or_null可以使用ICP</span><br><span class="line"></span><br><span class="line">- ICP可以用于InnoDB和MyISAM表</span><br><span class="line"></span><br><span class="line">- 只能用于二级索引(secondary index)</span><br><span class="line">- 并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录</span><br><span class="line">  到server端做where过滤。</span><br><span class="line">-  MySQL 5.6版本的不支持分区表的ICP功能，5.7版本的开始支持。</span><br><span class="line">- 当SQL使用覆盖索引时，不支持ICP优化方法。  </span><br><span class="line"></span><br><span class="line">### 11.普通索引 VS 唯一索引</span><br><span class="line"></span><br><span class="line">#### 11.1 查询过程</span><br><span class="line"></span><br><span class="line">假设，执行查询的语句是 select id from test where k=5。</span><br><span class="line"></span><br><span class="line">- 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</span><br><span class="line"></span><br><span class="line">- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</span><br><span class="line"></span><br><span class="line">那么，这个不同带来的性能差距会有多少呢？答案是， 微乎其微 。  </span><br><span class="line"></span><br><span class="line">#### 11.2 更新过程</span><br><span class="line"></span><br><span class="line">- 为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下==change buffer==。</span><br><span class="line">- 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下， **InooDB会将这些更新操作缓存在change buffer中 ，这样就不需要从磁盘中读入这个数据页了**。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</span><br><span class="line">- 将change buffer中的操作应用到原数据页，得到最新结果的过程称为 ==merge== 。除了 ==访问这个数据页 会触发merge==外，系统有 ==后台线程会定期 merge==。在 数据库==正常关闭==（shutdown） 的过程中，也会执行merge操作。</span><br><span class="line">- 如果能够将更新操作先记录在change buffer， ==减少读磁盘== ，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 ==避免占用内存== ，提高内存利用率。</span><br><span class="line">- ==唯一索引的更新就不能使用change buffer ，实际上也只有普通索引可以使用==。  </span><br><span class="line"></span><br><span class="line">#### 11.3 change buffer的使用场景</span><br><span class="line"></span><br><span class="line">- 普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是对 ==更新性能 的影响==。所以，==建议你 尽量选择普通索引== 。</span><br><span class="line">- 在实际使用中会发现， ==普通索引 和 change buffer 的配合使用==，对于 数据量大 的表的更新优化还是很明显的。</span><br><span class="line">-  如果**所有的更新后面，都马上 伴随着对这个记录的查询** ，那么你应该 关闭change buffer 。而在其他情况下，change buffer都能提升更新性能。</span><br><span class="line">- 由于唯一索引用不上change buffer的优化机制，因此如果 业务可以接受 ，从性能角度出发建议优先考虑非唯一索引。但是如果&quot;业务可能无法确保&quot;的情况下，怎么处理呢？</span><br><span class="line">- 首先， **业务正确性优先** 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能问题。如果业务不能保证，或者**业务就是要求数据库来做约束，那么没得选，必须创建唯一索引**。</span><br><span class="line">- 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一个排查思路。</span><br><span class="line">- 然后，在一些**“ 归档库 ”**的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。**要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。**  </span><br><span class="line"></span><br><span class="line">### 12.其他查询优化策略</span><br><span class="line"></span><br><span class="line">#### 12.1 EXISTS 和 IN的区分</span><br><span class="line"></span><br><span class="line">**问题：**</span><br><span class="line"></span><br><span class="line">不太理解那种情况下应该使用EXISTS，那种情况下应该用IN，选择的标准是看能否使用表的索引吗？</span><br><span class="line"></span><br><span class="line">**回答：**</span><br><span class="line"></span><br><span class="line">索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</span><br><span class="line"></span><br><span class="line">比如下面这样：</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">select * from A where cc IN (select cc from B);</span><br><span class="line"></span><br><span class="line">select * from A where exists (select * from B where B.cc = A.cc);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>当A小于B时，用EXISTS。因为exists的实现，相当于外表循环，实现的逻辑类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in A</span><br><span class="line">	<span class="keyword">for</span>	j in B</span><br><span class="line">		<span class="keyword">if</span> j.cc == i.cc then</span><br></pre></td></tr></table></figure>

<p>当B小于A时用IN,因为实现的逻辑类似于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in B</span><br><span class="line">	<span class="keyword">for</span>	j in A</span><br><span class="line">		<span class="keyword">if</span> j.cc == i.cc then</span><br></pre></td></tr></table></figure>

<p>哪个表小就用哪个表来驱动，A表小就用EXISTS,B表小就用IN.</p>
<h4 id="12-2-COUNT-与COUNT-具体字段-效率"><a href="#12-2-COUNT-与COUNT-具体字段-效率" class="headerlink" title="12.2 COUNT(*)与COUNT(具体字段)效率"></a>12.2 COUNT(*)与COUNT(具体字段)效率</h4><p>问题：在 MySQL 中统计数据表的行数，可以使用三种方式： SELECT COUNT(*) 、 SELECT COUNT(1) 和<br>SELECT COUNT(具体字段) ，使用这三者之间的查询效率是怎样的？  </p>
<p><strong>环节1：</strong>count(* )和count(1)都是对所有结果进行COUNT，COUNT(*) 和count(1)本质上没有区别（可能执行时间上有细微差别，但差不多）。如果有where子句，则是对所有符合筛选条件的数据进行统计。如果没有where子句，则是对数据表的数据行数进行 统计。</p>
<p><strong>环节2：</strong>如果是myisam引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张myisam的数据表都有一个meta信息存储了row_count的值，而一致性则由&#x3D;&#x3D;表级锁&#x3D;&#x3D;来保证。</p>
<p>如果是Innodb存储引擎，因为Innodb支持事务，采用&#x3D;&#x3D;行级锁和MVCC机制&#x3D;&#x3D;，所以无法像myisam一样，维护一个row_count变量，因此需要采用扫描全表，是O(n)的复杂度，进行循环+计数的方式来完成统计</p>
<p><strong>环节3：</strong>在innodb引擎中，&#x3D;&#x3D;如果采用count(具体字段)来统计数据行数，要尽量采用二级索引&#x3D;&#x3D;。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于count(*)和count(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。</p>
<p>如果有多个二级索引，会使用key_length小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引，来进行统计。</p>
<h4 id="12-3-关于select"><a href="#12-3-关于select" class="headerlink" title="12.3  关于select *"></a>12.3  关于select *</h4><ul>
<li>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因:<ul>
<li>MySQL 在解析的过程中，会通过 查询数据字典 将”*”按序转换成所有列名，这会大大的耗费资源和时<br>间。</li>
<li>无法使用 &#x3D;&#x3D;覆盖索引&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h4 id="12-4-LIMIT-1对优化的影响"><a href="#12-4-LIMIT-1对优化的影响" class="headerlink" title="12.4 LIMIT 1对优化的影响"></a>12.4 LIMIT 1对优化的影响</h4><ul>
<li>针对的是会扫描全表的SQL语句，如果你可以确定结果只有一条，那么加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，这样就会加快查询速度</li>
<li>如数据表已对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上limit 1了</li>
</ul>
<h4 id="12-5-多使用commit"><a href="#12-5-多使用commit" class="headerlink" title="12.5 多使用commit"></a>12.5 多使用commit</h4><ul>
<li>只要有可能，在程序中尽量多使用commit，这样程序的性能得到提高，需求也会因为所释放的资源而减少。</li>
<li>COMMIT所释放的资源：<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo&#x2F;undo log buffer中的空间</li>
<li>管理上述3种资源中的内部花费</li>
</ul>
</li>
</ul>
<h3 id="13-淘宝数据库，主键如何设计的？"><a href="#13-淘宝数据库，主键如何设计的？" class="headerlink" title="13.淘宝数据库，主键如何设计的？"></a>13.淘宝数据库，主键如何设计的？</h3><p>聊一个实际问题：淘宝的数据库，主键是如何设计的？</p>
<p>某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的MySQL军规。其中，一个最明显的错误就是关于MySQL的主键设计。</p>
<p>大部分人的回答如此自信：用8字节的 BIGINT 做主键，而不要用INT。 错 ！  </p>
<p>这样的回答，只站在了数据库这一层，而没有 &#x3D;&#x3D;从业务的角度&#x3D;&#x3D; 思考主键。主键就是一个自增ID吗？站在2022年的新年档口，用自增做主键，架构设计上可能 连及格都拿不到 。  </p>
<h4 id="13-1-自增ID的问题"><a href="#13-1-自增ID的问题" class="headerlink" title="13.1 自增ID的问题"></a>13.1 自增ID的问题</h4><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点，总体来看存在以下几方面的问题：</p>
<p><strong>1.可靠性不高</strong></p>
<p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL8.0才修复。</p>
<p><strong>2.安全性不高</strong></p>
<p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;user&#x2F;1&#x2F;这样的接口，可以非常容易猜测用户ID的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p>
<p><strong>3.性能差</strong></p>
<p>自增ID的性能较差，需要在数据库服务器端生成。</p>
<p><strong>4.交互多</strong></p>
<p>业务还需要额外执行一次类似 last_insert_id( )的函数才能直到刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多一条SQL，就多一次性能上的开销</p>
<p><strong>5.局部唯一性</strong></p>
<p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直是噩梦。</p>
<h4 id="13-2-业务字段做主键"><a href="#13-2-业务字段做主键" class="headerlink" title="13.2 业务字段做主键"></a>13.2 业务字段做主键</h4><p>为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键，那么，怎么为这个表设置主键，才能达到我们理想的目标呢？这里我们考虑业务字段做主键。</p>
<p>但是因为种种原因，业务字段尽量用作主键，毕竟作为项目设计的计数人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现</p>
<blockquote>
<p>注意：刚开始的时候，很容易犯这样的错误。</p>
</blockquote>
<h4 id="13-3-淘宝的主键设计"><a href="#13-3-淘宝的主键设计" class="headerlink" title="13.3 淘宝的主键设计"></a>13.3 淘宝的主键设计</h4><p>例如订单号，作为订单表的主键。</p>
<p>订单号是19位的长度，且订单的最后5位都是一样的，都是08113。且订单号的千米那14位部分都是单调递增的。</p>
<p>大胆猜测，淘宝的订单ID设计应该是：</p>
<p>订单ID &#x3D; 时间 + 去重字段 + 用户ID后6位尾号</p>
<p>这样的设计能做到全局唯一，且对分布式系统查询极其友好。</p>
<h4 id="13-4-推荐的主键设计"><a href="#13-4-推荐的主键设计" class="headerlink" title="13.4 推荐的主键设计"></a>13.4 推荐的主键设计</h4><p>非核心业务：对应表的主键自增ID，如告警，日志，监控等信息</p>
<p>核心业务：主键设计至少应该是全局唯一且单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能</p>
<p>这里推荐最简单的一种主键设计：UUID</p>
<p>&#x3D;&#x3D;UUID的特点：&#x3D;&#x3D;</p>
<p>全局唯一，占用36字节，数据无序，插入性能差</p>
<p>认识UUID:</p>
<ul>
<li>为什么UUID是全局唯一的？</li>
<li>为什么UUID占用36个字节？</li>
<li>为什么UUID是无序的？</li>
</ul>
<p>MySQL数据库的UUID组成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID = 时间 + UUID版本(16字节)-时钟序列（4字节）-MAC地址（12字节）</span><br></pre></td></tr></table></figure>

<p>为什么UUID是全局唯一的？</p>
<ul>
<li><p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降低到1&#x2F;100ns。  </p>
</li>
<li><p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p>
</li>
</ul>
<p>为什么UUID占用36个字节？</p>
<ul>
<li>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</li>
</ul>
<p>为什么UUID是随机无序的呢？</p>
<ul>
<li>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</li>
</ul>
<p><strong>改造UUID</strong></p>
<p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p>
<p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p>
<p>可以通过MySQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MySQL也提供了bin_to_uuid函数进行<br>转化：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @uuid = UUID();</span><br><span class="line">SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意上面的操作要放在MySQL8.0版本中进行</li>
<li>通过函数uuid_to_bin(@uuid,true)将UUID转化位有序UUID了。全局唯一 + 单调递增，这不就是我们想要的主键。</li>
</ul>
<p><strong>4.有序UUID性能测试</strong></p>
<blockquote>
<p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局唯一的实现</p>
<p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等，这样的主键设计就更为考验架构师的水平了</p>
</blockquote>
<p>如果不是MySQL8.0怎么办？</p>
<ul>
<li>手动赋值字段做主键！</li>
<li>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</li>
<li>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</li>
<li>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当 前会员编号的最大值。</li>
<li>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进 行操作，就解决了各门店添加会员时会员编号冲突的问题。</li>
</ul>
<h2 id="9-数据库的设计规范"><a href="#9-数据库的设计规范" class="headerlink" title="9.数据库的设计规范"></a>9.数据库的设计规范</h2><h3 id="1-为什么需要数据库设计"><a href="#1-为什么需要数据库设计" class="headerlink" title="1.为什么需要数据库设计"></a>1.为什么需要数据库设计</h3><p>我们在设计数据表的时候，要考虑很多问题。比如：</p>
<ul>
<li>用户都需要什么数据？需要在数据表中保存哪些数据？</li>
<li>如何保证数据表中数据的正确性，当插入、删除、更新的时候该进行怎样的约束检查？</li>
<li>如何降低数据表的数据冗余度，保证数据表不会因为用户量的增长而迅速扩张？</li>
<li>如何让负责数据库维护人员更方便地使用数据库</li>
<li>使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能千差万别</li>
</ul>
<p>现实情况中，面临的场景：</p>
<ul>
<li>当数据库运行了一段时间之后，我们才发现数据表设计的有问题，重新调整数据表的结构，就需要做数据迁移，还有可能影响程序的业务逻辑，以及网站正常的访问。</li>
</ul>
<p>如果是糟糕的数据库设计可能会造成以下问题：</p>
<ul>
<li>数据冗余，信息重复，存储空间浪费</li>
<li>数据更新、插入、删除的异常</li>
<li>无法正确表示信息</li>
<li>丢失有效信息</li>
<li>程序性能差</li>
</ul>
<p>良好的数据设计原则有以下特点：</p>
<ul>
<li>节省数据的存储空间</li>
<li>能够保证数据的完整性</li>
<li>方便进行数据库应用系统的开发</li>
</ul>
<p>总之，开始设置数据库的时候，我们就是需要重视数据表的设计。为了建立冗余较小，结构合理的数据库，设计数据库时必须遵循一定的准则。</p>
<h3 id="2-范式"><a href="#2-范式" class="headerlink" title="2.范式"></a>2.范式</h3><h4 id="2-1范式简介"><a href="#2-1范式简介" class="headerlink" title="2.1范式简介"></a>2.1范式简介</h4><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。  </p>
<p>范式的英文名称是Normal Form，简称NF,范式是关系数据库理论的基础</p>
<h4 id="2-2-范式都包括哪些"><a href="#2-2-范式都包括哪些" class="headerlink" title="2.2 范式都包括哪些"></a>2.2 范式都包括哪些</h4><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。  </p>
<p>数据库的范式设计越高阶，冗余度越低，同时高阶的范式一定符合低阶范式的要求。</p>
<p>一般来说，在关系型数据库设计中，最高也就遵循到BCNF，普遍还是3NF。但也不绝对，有时候为了提高某些性能，我们还需要破坏范式规则，也就是反规范化。</p>
<h4 id="2-3-键和相关属性的概念"><a href="#2-3-键和相关属性的概念" class="headerlink" title="2.3 键和相关属性的概念"></a>2.3 键和相关属性的概念</h4><p>范式的定义会使用到主键和候选键，数据库中的键（key）由一个或者多个属性组成。数据库中常用的几种键和属性的定义：</p>
<ul>
<li>超键：能唯一标识元组的属性集叫做超键</li>
<li>候选键：如果超键不包括多余的属性，那么这个超键就是候选键</li>
<li>主键：用户可以从候选键中选择一个作为主键</li>
<li>外键：如果数据表R1中的某个属性不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键</li>
<li>主属性：包含在任意候选键中的属性成为主属性</li>
<li>非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性</li>
</ul>
<p>通常，我们也将候选键称之为“码”，把主键也称为主码，因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分</p>
<p><strong>举例：</strong></p>
<ul>
<li>这里有两个表：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</span><br><span class="line">球队表(team) ：球队编号 | 主教练 | 球队所在地 </span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;超键 ：&#x3D;&#x3D;对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</p>
<p>&#x3D;&#x3D;候选键 ：&#x3D;&#x3D;就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</p>
<p>&#x3D;&#x3D;主键 ：&#x3D;&#x3D;我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</p>
<p>&#x3D;&#x3D;外键 ：&#x3D;&#x3D;球员表中的球队编号。</p>
<p>&#x3D;&#x3D;主属性 、 非主属性 ：&#x3D;&#x3D;在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性  </p>
<h4 id="2-4-第一范式（1NF）"><a href="#2-4-第一范式（1NF）" class="headerlink" title="2.4 第一范式（1NF）"></a>2.4 第一范式（1NF）</h4><p>第一范式主要是确保数据表中每个字段的值必须具有&#x3D;&#x3D;原子性&#x3D;&#x3D;，也就是说数据表中每个字段的值为不可再次拆分的最小数据单元。</p>
<p>我们在设计某个字段的时候，对于字段X来说，不能把字段X字段拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求</p>
<p>属性的原子性是主观的。【根据实际需求来进行决定】</p>
<h4 id="2-5第二范式（2NF）"><a href="#2-5第二范式（2NF）" class="headerlink" title="2.5第二范式（2NF）"></a>2.5第二范式（2NF）</h4><p>第二范式要求，在满足第一范式的基础上，还要&#x3D;&#x3D;满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段都必须完全依赖主键，不能只依赖主键的一部分&#x3D;&#x3D;。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以拓展替换为候选键）【非主属性完全依赖于主键】，【解决了部分函数依赖的问题】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</span><br></pre></td></tr></table></figure>

<p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(球员编号) → (姓名，年龄)</span><br><span class="line">(比赛编号) → (比赛时间, 比赛场地)</span><br></pre></td></tr></table></figure>

<p>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？  </p>
<ul>
<li>数据冗余 ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</li>
<li>插入异常 ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。</li>
<li>删除异常 ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。</li>
<li>更新异常 ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况。</li>
</ul>
<blockquote>
<p>1NF告诉我们字段属性是需要原子性的，而1NF告诉我们一张表就是一个独立的对象，一张表指标大一个意思。</p>
</blockquote>
<blockquote>
<p>小结：第二范式（2NF）要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离形成一个新的实体，新的实体与原实体之间是一对多的关系。</p>
</blockquote>
<h4 id="2-6第三范式（3NF）"><a href="#2-6第三范式（3NF）" class="headerlink" title="2.6第三范式（3NF）"></a>2.6第三范式（3NF）</h4><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，&#x3D;&#x3D;要求数据表中的所有非主键字段不能依赖于其他非主键字段。&#x3D;&#x3D;（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在A-&gt;B-&gt;C的决定关系），通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。 【解决了传递函数依赖的问题】</p>
<p>这里的主键可以拓展为候选键。</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>是否是主键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT</td>
<td>是</td>
<td>商品主键id （主键）</td>
</tr>
<tr>
<td>category_id</td>
<td>INT</td>
<td>否</td>
<td>商品类别id</td>
</tr>
<tr>
<td>category_name</td>
<td>VARCHAR(30)</td>
<td>否</td>
<td>商品类别名称</td>
</tr>
<tr>
<td>goods_name</td>
<td>VARCHAR(30)</td>
<td>否</td>
<td>商品名称</td>
</tr>
<tr>
<td>price</td>
<td>DECIMAL(10,2)</td>
<td>否</td>
<td>商品价格</td>
</tr>
</tbody></table>
<p>商品类别名称依赖于商品类别编号，不符合第三范式。  </p>
<blockquote>
<p>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于键，依赖于整个键，并且除了键别无他物”  </p>
</blockquote>
<h4 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h4><p>关于数据表的设计，有三个范式要遵循</p>
<ul>
<li>第一范式，确保每列保持原子性<ul>
<li>数据库的每一列都是不可分割的源自数据项，不可再分的最小数据单元，而不能是集合，数组，记录等非原子数据项</li>
</ul>
</li>
<li>第二范式，确保每列都和主键完全依赖<ul>
<li>尤其在复合主键的情况下，非主键部分不应该依赖于部分主键</li>
</ul>
</li>
<li>第三范式，确保每列都和主键列直接相关，而不是间接相关</li>
</ul>
<p><strong>范式的优点：</strong>数据的标准化有助于消除数据库中的数据冗余，第三范式（3NF）通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡</p>
<p><strong>范式的缺点：</strong>范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多，越精细，数据的的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能是一些索引策略失效。</p>
<p>范式只是提出了设计的标准，实际设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际应用中，要灵活运用。</p>
<blockquote>
<p>范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要将&#x3D;&#x3D;范式和反范式&#x3D;&#x3D;混合使用</p>
</blockquote>
<h3 id="3-反范式化"><a href="#3-反范式化" class="headerlink" title="3.反范式化"></a>3.反范式化</h3><h4 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h4><p>有时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循业务优先的原则，首先满足业务需求，再尽量减少冗余。</p>
<p>有时候数据量特别大，如果安全按照MySQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式优化也是一种优化思路。此时可以通过在数据表中<strong>增加冗余字段</strong>来提高数据库的读性能。</p>
<p><strong>规范化 VS 性能</strong></p>
<blockquote>
<ul>
<li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p>
</li>
<li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p>
</li>
<li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p>
</li>
<li><p>通过在给定的表中插入计算列，以方便查询</p>
</li>
</ul>
</blockquote>
<h4 id="3-2-反范式的新问题"><a href="#3-2-反范式的新问题" class="headerlink" title="3.2 反范式的新问题"></a><strong>3.2 反范式的新问题</strong></h4><ul>
<li>存储 空间变大 了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致</li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源。</li>
<li>在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加 复杂</li>
</ul>
<h4 id="3-3-反范式的使用场景"><a href="#3-3-反范式的使用场景" class="headerlink" title="3.3 反范式的使用场景"></a><strong>3.3 反范式的使用场景</strong></h4><p>当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式的优化</p>
<p><strong>1.增加冗余字段的建议</strong></p>
<p>增加冗余字段一定要符合如下这两个条件。只有满足这两个条件，才可以考虑考虑增加冗余字段</p>
<p>1）这个冗余字段不需要经常进行修改</p>
<p>2）这个冗余字段查询的时候不可或缺</p>
<p><strong>2.历史快照，历史数据的需要</strong></p>
<p>反范式优化也常用在 数据仓库 的设计中，因为数据仓库通常 存储历史数据 ，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。  </p>
<h3 id="4-BCNF-巴斯范式"><a href="#4-BCNF-巴斯范式" class="headerlink" title="4.BCNF(巴斯范式)"></a><strong>4.BCNF(巴斯范式)</strong></h3><ul>
<li>在第三范式的基础上进行了改进，被称为修正的第三范式，并没有新的设计规范加进来，只是对第三范式中设计规范要求更强，使得数据冗余度更小。</li>
<li>定义：若一个关系达到了第三范式，并且**&#x3D;&#x3D;它只有一个候选键&#x3D;&#x3D;**，或者&#x3D;&#x3D;它的每个候选键都是单属性&#x3D;&#x3D;，则该关系自然达到BCNF.</li>
<li>一般说来，一个数据库设计符合3NF或BCNF就可以了</li>
</ul>
<h3 id="5-实战实例"><a href="#5-实战实例" class="headerlink" title="5.实战实例"></a>5.实战实例</h3><p>这个表中的字段很多，表里的数据量也很惊人。大量重复导致表变得庞大。</p>
<h3 id="6-ER模型"><a href="#6-ER模型" class="headerlink" title="6.ER模型"></a>6.ER模型</h3><ul>
<li><p>数据库设计是牵一发而动全身的，那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表，数据表中应该有哪些字段，数据表与数据表之间有什么关系，通过什么字段进行连接，  ，等等。这样我们才能进行整体的梳理和设计</p>
</li>
<li><p>其实ER模型就是一个这样的工具，ER模型也叫做实体关系模型，用来描述现实生活中客观存在的事物，事物的属性，以及事物之间关系的一种数据模型。在开发基于数据库的信息系统的设计阶段，通常使用ER模型来&#x3D;&#x3D;描述信息需求和信息特性，帮助我们清理业务逻辑，从而设计出优秀的数据库&#x3D;&#x3D;</p>
</li>
</ul>
<h4 id="6-1-ER模型包括哪些要素"><a href="#6-1-ER模型包括哪些要素" class="headerlink" title="6.1 ER模型包括哪些要素"></a>6.1 ER模型包括哪些要素</h4><p>ER 模型中有三个要素，分别是实体、属性和关系。  </p>
<ul>
<li>实体 ，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 矩形 来表示。实体分为两类，分别是 强实体 和 弱实体 。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</li>
<li>属性 ，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形 来表示。</li>
<li>关系 ，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用 菱形 来表示。</li>
<li>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，可以独立存在<br>的是实体，不可再分的是属性。也就是说，属性不能包含其他属性。</li>
</ul>
<h4 id="6-2-关系的类型"><a href="#6-2-关系的类型" class="headerlink" title="6.2 关系的类型"></a>6.2 关系的类型</h4><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p>
<ul>
<li>一对一 ：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</li>
<li>一对多 ：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学生则对应一个班级，班级对学生就是一对多的关系。</li>
<li>多对多 ：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这就是多对多的关系。</li>
</ul>
<h3 id="7-数据表的设计原则"><a href="#7-数据表的设计原则" class="headerlink" title="7.数据表的设计原则"></a>7.数据表的设计原则</h3><p>综合以上内容，总结出数据表设计的一般原则：”三少一多”</p>
<ul>
<li>数据表的个数越少越好<ul>
<li>RDBMS的核心在于对实体和联系的定义，也就是E-R图（Entity  Relationship  Diagram）,数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作</li>
</ul>
</li>
<li>数据表中的字段个数越少越好<ul>
<li>字段个数越多，数据冗余得可能性越大。设置字段个数少的前提是各个字段相互独立，这也是相对的，通常会在数据冗余和检索效率中进行平衡</li>
</ul>
</li>
<li>数据表中联合主键的字段个数越少越好<ul>
<li>设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是多个字段来定义一个主键）。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</li>
</ul>
</li>
<li>使用主键和外键越多越好  <ul>
<li>主外键越多说明关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。</li>
</ul>
</li>
<li>三少一多原则的核心就是简单可复用。简单指的是更少的表，更少的字段，更少的联合主键字段来完成数据表的设计。</li>
</ul>
<h3 id="8-数据库对象编写建议"><a href="#8-数据库对象编写建议" class="headerlink" title="8.数据库对象编写建议"></a>8.数据库对象编写建议</h3><h4 id="8-1-关于库"><a href="#8-1-关于库" class="headerlink" title="8.1 关于库"></a>8.1 关于库</h4><ul>
<li>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字<br>母开头。</li>
<li>【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。</li>
<li>【强制】库的名称格式：业务系统名称_子系统名。_</li>
<li>【强制】库名禁止使用关键字（如type,order等）。</li>
<li>【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。<ul>
<li>创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ;</li>
</ul>
</li>
<li>【建议】对于程序连接数据库账号，遵循 权限最小原则</li>
<li>使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限 。</li>
<li>【建议】临时库以 tmp_ 为前缀，并以日期为后缀；</li>
<li>备份库以 bak_ 为前缀，并以日期为后缀。</li>
</ul>
<h4 id="8-2-关于行、列"><a href="#8-2-关于行、列" class="headerlink" title="8.2 关于行、列"></a>8.2 关于行、列</h4><ul>
<li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议<br>以 英文字母开头 。</p>
</li>
<li><p>【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item</p>
</li>
<li><p>【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。</p>
</li>
<li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。</p>
</li>
<li><p>【强制】建表必须有comment。</p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用corporation_id, 而用corp_id 即可。  </p>
</li>
<li><p>布尔值以 is_描述</p>
</li>
<li><p>字段名称尽可能使用表达实际含义的英文单词或缩写</p>
</li>
<li><p>建表时关于主键，必须要有主键</p>
<ul>
<li>强调要求主键为id，类型为int或bigint，且为auto_increment建议使用unsigned无符号型</li>
<li>标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id,order_id等，并建立unique key索引。因为如果设为主键自主简直为随机插入，则会导致innodb内部页分裂和大量随机IO，性能下降</li>
</ul>
</li>
<li><p>表中所有字段尽量都是NOT NULL属性，业务可以根据需要定义DEFAULT值</p>
<ul>
<li>因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错，聚合函数计算结果偏差等问题</li>
</ul>
</li>
<li><p>建议所有存储相同数据的列名和列类型必须一致（一般作为查询列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</p>
</li>
<li><p>中间表（或临时表）用于保留中间结果集，名称以tmp_开头。备份表用于备份或抓紧原表快照，名称以bak_开头。中间表和备份表定期清理</p>
</li>
</ul>
<blockquote>
<p>一个规范的建表语句</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_info (</span><br><span class="line">`id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">`user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">`username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;,</span><br><span class="line">`email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;,</span><br><span class="line">`nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">`birthday` date NOT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;,</span><br><span class="line">`user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;,</span><br><span class="line">`user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;,</span><br><span class="line">`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE</span><br><span class="line">CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">`user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未</span><br><span class="line">通过，4为还未提交审核&#x27;,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `uniq_user_id` (`user_id`),</span><br><span class="line">KEY `idx_username`(`username`),</span><br><span class="line">KEY `idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。</li>
<li>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构<br>的导出和导入。</li>
</ul>
<h4 id="8-3-关于索引"><a href="#8-3-关于索引" class="headerlink" title="8.3 关于索引"></a>8.3 关于索引</h4><ul>
<li>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值 禁止被更新 。</li>
<li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。</li>
<li>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</li>
<li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如:sample 表 member_id 上的索引：idx_sample_mid。</li>
<li>【建议】单个表上的索引个数 不能超过6个 。</li>
<li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。</li>
<li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</li>
<li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除。</li>
</ul>
<h4 id="8-4-SQL编写"><a href="#8-4-SQL编写" class="headerlink" title="8.4 SQL编写"></a>8.4 SQL编写</h4><ul>
<li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</p>
</li>
<li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</p>
</li>
<li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p>
</li>
<li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p>
</li>
<li><p>【建议】SELECT<strong>语句不要使用UNION，推荐使用UNION ALL</strong>【这样就可以不用去重了】，并且UNION子句个数限制在5个以内。</p>
</li>
<li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p>
</li>
<li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p>
</li>
<li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p>
</li>
<li><p>【建议】对单表的多次alter操作必须合并为一次对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生 &#x3D;&#x3D;表锁&#x3D;&#x3D; ，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p>
</li>
<li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</p>
</li>
<li><p>【建议】事务里包含SQL不超过5个。 因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p>
</li>
<li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX;否则会产生&#x3D;&#x3D;间隙锁&#x3D;&#x3D;，内部扩大锁定范围，导致系统性能下降</p>
</li>
</ul>
<h3 id="9-PowerDesigner的使用"><a href="#9-PowerDesigner的使用" class="headerlink" title="9.PowerDesigner的使用"></a>9.PowerDesigner的使用</h3><p>PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作 &#x3D;&#x3D;数据流程图 、概念数据模型 、 物理数据模型&#x3D;&#x3D; ，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设计提供的一套完整的集成化企业级建模解决方案。  </p>
<p><a target="_blank" rel="noopener" href="https://pacslink.novalys.net/leadprocess/api/17/63dff71c-ebe7-ec11-80fb-005056080920">https://pacslink.novalys.net/leadprocess/api/17/63dff71c-ebe7-ec11-80fb-005056080920</a> 软件下载地址</p>
<h2 id="10-事务基础知识"><a href="#10-事务基础知识" class="headerlink" title="10.事务基础知识"></a>10.事务基础知识</h2><h3 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1.数据库事务概述"></a>1.数据库事务概述</h3><ul>
<li>事务是区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复来到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失</li>
</ul>
<h4 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h4><p>可以通过show engines;命令来查看哪些引擎支持事务。发现在MySQL中&#x3D;&#x3D;只有innodb支持事务&#x3D;&#x3D;</p>
<h4 id="1-2-基础概念"><a href="#1-2-基础概念" class="headerlink" title="1.2 基础概念"></a>1.2 基础概念</h4><ul>
<li><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</li>
<li><strong>事务处理的原则</strong>：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 案例:AA用户给用户转账100</span><br><span class="line">update account set money = money - 100 where name = &#x27;AA&#x27;;</span><br><span class="line"># 服务器宕机</span><br><span class="line">update account set money = money + 100 where name = &#x27;BB&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-事务的ACID特性"><a href="#1-3-事务的ACID特性" class="headerlink" title="1.3 事务的ACID特性"></a>1.3 事务的ACID特性</h4><ul>
<li><p><strong>原子性（atomicity）</strong></p>
<ul>
<li>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</li>
</ul>
</li>
<li><p><strong>一致性（consistency）</strong></p>
<ul>
<li>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述）根据定义，一致性是指事务执行前后，数据从一个 &#x3D;&#x3D;合法性状态&#x3D;&#x3D; 变换到另外一个 &#x3D;&#x3D;合法性状态&#x3D;&#x3D; 。这种状态是 语义上 的而不是语法上的，跟具体的业务有关。</li>
<li>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。  </li>
<li>举例（能量守恒）：<ul>
<li>A账户有200元，转账300元出去，此时就不是合法的，因为你定义了一个规则余额 &gt;&#x3D; 0</li>
<li>A账户200元，转账50元给B账户，A账户钱扣了，但是B账户因为各种意外钱没有增加，此时也不是合法状态，因为你定义了一个规则，要求A+B的总金额不变</li>
<li>在数据表中我们将姓名字段设置为唯一性约束，这时当食物进行提交或者事务发生回滚的时候，如果数据表中的姓名不唯一，就破坏了事务的一致性要求。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>隔离性（isolation）</strong></p>
<ul>
<li><p>事务的隔离性是指一个事务的执行 &#x3D;&#x3D;不能被其他事务干扰&#x3D;&#x3D; ，即一个事务内部的操作及使用的数据对 并发 的<br>其他事务是隔离的，并发执行的各个事务之间不能互相干扰。【一个事务其实可以看作是一个线程】</p>
</li>
<li><p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：  </p>
</li>
<li><p>举例</p>
</li>
<li><pre><code class="mysql">UPDATE accounts SET money = money - 50 WHERE NAME = &#39;AA&#39;;
UPDATE accounts SET money = money + 50 WHERE NAME = &#39;BB&#39;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 隔离性举例：并发执行的事务2与事务1相互干扰</span><br><span class="line"></span><br><span class="line">    ![image-20220609203306769](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220609203306769.png)</span><br><span class="line"></span><br><span class="line">- **持久性（Duration）**</span><br><span class="line"></span><br><span class="line">  - 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 ==永久性==的 ，==接下来的其他操作和数据库故障不应该对其有任何影响。==</span><br><span class="line">  - 持久性是通过 ==事务日志== 来保证的。日志包括了 ==重做日志（redo log） 和 回滚日志(undo log)== 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。  【先进行日志操作，再操作数据】</span><br><span class="line"></span><br><span class="line">&gt; 总结：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ACID是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 数据库事务，其实就是数据库设计者为了方便起见，把需要==保证原子性、隔离性、一致性和持久性的一个或多个数据库操作==称为一个事务。</span><br><span class="line"></span><br><span class="line">#### 1.4 事务的状态</span><br><span class="line"></span><br><span class="line">我们现在知道 ==事务== 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 事务 大致划分成几个状态：  </span><br><span class="line"></span><br><span class="line">- ==活动的（active）==</span><br><span class="line">  事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。</span><br><span class="line"></span><br><span class="line">- ==部分提交的==（partially committed）</span><br><span class="line"></span><br><span class="line">  当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响==并 没有刷新到磁盘==时，我们就说该事务处在 部分提交的 状态。</span><br><span class="line"></span><br><span class="line">- ==失败的==（failed）</span><br><span class="line"></span><br><span class="line">  当事务处在 ==活动的== 或者 ==部分提交的== 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失败的 状态  </span><br><span class="line"></span><br><span class="line">- ==中止的==（aborted）</span><br><span class="line"></span><br><span class="line">  如果==事务执行了一部分而变为 失败的 状态==，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要**撤销失败事务对当前数据库造成的影响**。我们把这个撤销的过程称之为 **回滚** 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态  </span><br><span class="line"></span><br><span class="line">- ==提交的==（committed）</span><br><span class="line"></span><br><span class="line">  当一个处在 部分提交的 状态的事务将修改过的数据都 ==同步到磁盘 上之后==，我们就可以说该事务处在了 提交的 状态。  </span><br><span class="line"></span><br><span class="line">- 事务的基本转换图如下</span><br><span class="line">  - ![image-20220609204844222](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220609204844222.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.如何使用事务</span><br><span class="line"></span><br><span class="line">使用事务有两种方式，分别为**显示事务和隐式事务**</span><br><span class="line"></span><br><span class="line">#### 2.1 显式事务</span><br><span class="line"></span><br><span class="line">步骤1：START TRANSACTION 或BEGIN，作用是显式开启一个事务</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql &gt; BEGIN;</span><br><span class="line"># 或者</span><br><span class="line">mysql &gt; START TRANSACTION;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个 修饰符 ：  </p>
<ul>
<li><p>&#x3D;&#x3D;READ ONLY&#x3D;&#x3D; ：标识当前事务是一个 只读事务 ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>
<blockquote>
<p>补充：只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用CREATE TEMPORARY TABLE创建的表），由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增删改操作的</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;READ WRITE&#x3D;&#x3D; ：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p>
</li>
<li><p>&#x3D;&#x3D;WITH CONSISTENT SNAPSHOT&#x3D;&#x3D; ：启动一致性读。</p>
</li>
</ul>
<p>步骤2：一系列事务中的操作（主要是DML，不含DDL）</p>
<p>步骤3：提交事务 或 中止事务（即回滚事务）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line"># 将事务回滚到某个保存点。</span><br><span class="line">mysql&gt; ROLLBACK TO [SAVEPOINT]</span><br></pre></td></tr></table></figure>

<p>其中关于SAVEPOINT相关操作有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在事务中创建保存点，方便后续针对保存点进行回滚，一个事务中可以存在多个保存点</span><br><span class="line">SAVEPOINT 保存点名称</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除某个保存点</span><br><span class="line">RELEASE SAVEPOINT 保存点名称</span><br></pre></td></tr></table></figure>

<h4 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h4><p>MySQL中有一个系统变量 autocommit【针对DML语句有效，对DDL操作是无效的】 ：  </p>
<ul>
<li>默认是开启的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit | ON |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 如果开启了事务的autocommit,则</span><br><span class="line">update account set balance = balance - 10 where id = 1;  -- 此时这条DML操作是一个独立的事务</span><br><span class="line">update account set balance = balance + 10 where id = 2;  -- 此时这条DML操作是一个独立的事务</span><br></pre></td></tr></table></figure>

<p>如何关闭自动提交？</p>
<ul>
<li>方式1：set  autocommit  &#x3D;  false;</li>
<li>方式2：我们在autocommit为true的情况下，使用start transaction 或 begin开启事务，那么DML操作就不会自动提交数据</li>
</ul>
<blockquote>
<p>Oracle默认不自动提交，需要手写commit命令，而MySQL是默认提交</p>
</blockquote>
<h4 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h4><ul>
<li><p>数据定义语言（Data Definition language，缩写为DDL）</p>
<ul>
<li>数据库对象，指的就是数据库、表、视图、存储过程等结构。当我们使用CREATE、ALTER、DROP等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事务。即：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT ...; -- 事务中的一条语句</span><br><span class="line">UPDATE ...; -- 事务中的一条语句</span><br><span class="line">... # 事务中的其他语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE ... -- 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式使用或修改MySQL数据库中的表</p>
<ul>
<li>当我们使用ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD等语句时也会隐式的提交前边语句所属于的事务</li>
</ul>
</li>
<li><p>事务控制或关于锁定的语句</p>
<ul>
<li>当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会 隐式的提交 上一个事务。即：</li>
<li>当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交 前边语句所属的事务。  </li>
<li>使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。</li>
</ul>
</li>
<li><p>加载数据的语句</p>
<ul>
<li>使用LOAD DATA语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务</li>
</ul>
</li>
<li><p>关于MySQL复制的一些语句</p>
<ul>
<li>使用START SLAVE，STOP SLAVE，RESET SLAVE、CHANGE MASTER TO等语句时会隐式的提交铅笔那语句所属的事务</li>
</ul>
</li>
<li><p>其它的一些语句  </p>
<ul>
<li>使用ANALYSE TABLE。CACHE INDEX，CHECK TABLE，FLUSH，LOAD INDEX INTO 　CACHE，OPTIMIZE　TABLE，REPAIR　TABLE，RESET等语句也会隐式的提交前边语句所属的事务。</li>
</ul>
</li>
</ul>
<h4 id="2-4-使用举例1：提交与回滚"><a href="#2-4-使用举例1：提交与回滚" class="headerlink" title="2.4 使用举例1：提交与回滚"></a>2.4 使用举例1：提交与回滚</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user3(</span><br><span class="line">NAME VARCHAR(15) PRIMARY KEY</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SELECT * FROM user3;</span><br><span class="line"></span><br><span class="line">BEGIN;  -- 因为使用了begin,所以就不会自动提交</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;张三&#x27;); # 此时不会自动提交数据</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;李四&#x27;);  # 此时执行完该条语句之后，不受autocommit影响</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;李四&#x27;);  # 受主键的影响，此时不能添加成功</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#情况2</span><br><span class="line">TRUNCATE TABLE user3; #DDL操作会自动提交数据，不受autocommit变量的影响</span><br><span class="line"></span><br><span class="line">BEGIN;  -- 因为使用了begin,所以就不会自动提交</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;张三&#x27;); # 此时不会自动提交数据</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO user3 VALUES(&#x27;李四&#x27;);  # 此时执行完该条语句之后，会自动提交</span><br><span class="line">INSERT INTO user3 VALUES(&#x27;李四&#x27;);  # 事务的失败状态</span><br><span class="line">ROLLBACK;  # 结束的是最近一条事务，只回滚最近一条插入的语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @@completion_type;  # NO_CHAIN</span><br><span class="line">SET @@completion_type=1;  # CHAIN</span><br></pre></td></tr></table></figure>

<p>我们发现相同的代码，只是在事务开始设置之前设置了 SET @@completion_type&#x3D;1;，结果就和我们之前处理的一样，只有一个张三。这是为什么呢？</p>
<ul>
<li>completion_type参数的作用，实际上这个参数有3种可能：<ul>
<li>completion_type &#x3D; 0，这是默认情况。当我们执行commit的时候会提交事务，在执行下一个事务的时候，还需要使用START TRANSACTION或者BEGIN来开启</li>
<li>completion_type&#x3D;1,这种情况下，当我们提交事务后，相当于执行了COMMIT AND CHAIN，也就是开启一个链式事务，即当我们提交事务之后，会开启一个相同隔离级别的事务。</li>
<li>completion_type&#x3D;2.这种情况下 commit&#x3D;commit with release，也就是当我们提交后，会自动与服务器断开连接</li>
</ul>
</li>
</ul>
<blockquote>
<p>当我们设置 autocommit&#x3D;0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p>
<p>当我们设置 autocommit&#x3D;1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。  </p>
</blockquote>
<h4 id="2-5-使用举例2：测试InnoDB与myisam的支持情况"><a href="#2-5-使用举例2：测试InnoDB与myisam的支持情况" class="headerlink" title="2.5 使用举例2：测试InnoDB与myisam的支持情况"></a>2.5 使用举例2：测试InnoDB与myisam的支持情况</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#举例2</span><br><span class="line">CREATE TABLE test1(</span><br><span class="line">i INT PRIMARY KEY</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE test2(</span><br><span class="line">i INT PRIMARY KEY</span><br><span class="line">) ENGINE=MyISAM;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test1;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test2;</span><br><span class="line">#针对于innodb表</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test1 VALUES(1);</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test2 VALUES(1);</span><br><span class="line">ROLLBACK;  # 对于Myisam由于不支持事务，所以回滚操作无效，上面插入的数据仍然存在</span><br></pre></td></tr></table></figure>

<h4 id="2-6-使用举例3：测试savepoint"><a href="#2-6-使用举例3：测试savepoint" class="headerlink" title="2.6 使用举例3：测试savepoint"></a>2.6 使用举例3：测试savepoint</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#举例3</span><br><span class="line">CREATE TABLE user4(</span><br><span class="line">NAME VARCHAR(15),</span><br><span class="line">balance DECIMAL(10,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user4(NAME,balance) VALUES(&#x27;张三&#x27;,1000);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user4;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE user4 SET balance = balance - 100 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">UPDATE user4 SET balance = balance - 100 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SAVEPOINT s1;  # 设置保存点</span><br><span class="line">UPDATE user4 SET balance = balance + 1 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">ROLLBACK TO s1; # 回滚到保存点 注意此时并没有将事务提交</span><br><span class="line">ROLLBACK;  -- | COMMIT 这两条语句才是事务真正的  结束</span><br></pre></td></tr></table></figure>

<h3 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h3><p>MySQL是一个 <strong>客户端／服务器</strong> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每<br>个客户端与服务器连接上之后，就可以称为一个会话<strong>（ Session ）</strong>。每个客户端都可以在自己的会话中<br>向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理<br>多个事务。事务有 <strong>隔离性</strong> 的特性，理论上在<strong>某个事务</strong> 对<strong>某个数据</strong>进行访问 时，其他事务应该进行 <strong><strong>排</strong><br>队</strong> ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <strong>性能影响太大</strong> ，我们既想保持<br>事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 <strong>性能尽量高些</strong> ，那就看二者如何<strong>权衡取</strong><br><strong>舍</strong>了  。</p>
<h4 id="3-1数据准备"><a href="#3-1数据准备" class="headerlink" title="3.1数据准备"></a>3.1数据准备</h4><p>我们需要创建一个表：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">studentno INT,</span><br><span class="line">name VARCHAR(20),</span><br><span class="line">class varchar(20),</span><br><span class="line">PRIMARY KEY (studentno)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>然后向这个表里插入一条数据：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student VALUES(1, &#x27;小谷&#x27;, &#x27;1班&#x27;);</span><br></pre></td></tr></table></figure>

<p>现在表里的数据是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">| studentno | name | class |</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">| 1 | 小谷 | 1班 |</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h4><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 不保证串行执行 （也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：  </p>
<h5 id="1-脏写（dirty-write）"><a href="#1-脏写（dirty-write）" class="headerlink" title="1.脏写（dirty write）"></a><strong>1.脏写</strong>（dirty write）</h5><p>对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数<br>据，那就意味着发生了 脏写  </p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>SessionA</th>
<th>SessionB</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE STUDENT set name &#x3D; ‘李四’  where studentno &#x3D; 1;</td>
</tr>
<tr>
<td>4</td>
<td>UPDATE STUDENT set name &#x3D; ‘张三’  where studentno &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>rollback;</td>
</tr>
</tbody></table>
<h5 id="2-脏读（dirty-read）"><a href="#2-脏读（dirty-read）" class="headerlink" title="2.脏读（dirty read）"></a><strong>2.脏读</strong>（dirty read）</h5><p>对于两个事务 Session A、Session B，Session A 读取 了已经被 Session B 更新 但还 <strong>没有被提交</strong> 的字段。之后若 Session B 回滚 ，Session A 读取 的内容就是 <strong>临时且无效</strong> 的。  </p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>SessionA</th>
<th>SessionB</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE STUDENT set name &#x3D; ‘张三’  where studentno &#x3D; 1;</td>
</tr>
<tr>
<td>4</td>
<td>select * from student where studentno &#x3D; 1;（如果读到列name的值为‘张三’，则意味着发生了脏读）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>rollback;</td>
</tr>
</tbody></table>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新<br>为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而<br>Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象<br>就称之为 脏读 。  </p>
<h5 id="3-不可重复读（Non-Repeatable-Read）"><a href="#3-不可重复读（Non-Repeatable-Read）" class="headerlink" title="3.不可重复读（Non-Repeatable Read）"></a><strong>3.不可重复读（Non-Repeatable Read）</strong></h5><p>对于两个事务Session A、Session B，Session A <strong>读取</strong> 了一个字段，然后 Session B 更新 了该字段。 之后Session A <strong>再次读取</strong> 同一个字段， <strong>值就不同</strong> 了。那就意味着发生了不可重复读。</p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>SessionA</th>
<th>SessionB</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from student where studentno &#x3D; 1;（此时读到列name的值为‘王五’）</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE STUDENT set name &#x3D; ‘张三’  where studentno &#x3D; 1;</td>
</tr>
<tr>
<td>4</td>
<td>select * from student where studentno &#x3D; 1;（如果读到列name的值为‘张三’，则意味着发生了不可重复读）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>UPDATE STUDENT set name &#x3D; ‘李四’  where studentno &#x3D; 1;</td>
</tr>
<tr>
<td>6</td>
<td>select * from student where studentno &#x3D; 1;（如果读到列name的值为‘李四’，则意味着发生了不可重复读）</td>
<td></td>
</tr>
</tbody></table>
<p>我们在Session B中提交了几个 隐式事务 （注意是隐式事务，意味着语句结束事务就提交了），这些事务<br>都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看<br>到最新的值，这种现象也被称之为 不可重复读 。  </p>
<h5 id="4-幻读（phantom）"><a href="#4-幻读（phantom）" class="headerlink" title="4.幻读（phantom）"></a>4.幻读（phantom）</h5><p>对于两个事务Session A、Session B, Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。那就意味着发生了幻读。</p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>SessionA</th>
<th>SessionB</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from student where studentno &gt; 0;（此时读到列name的值为‘张三’）</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>insert into student values(2,’赵六’，‘2班’);</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>5</td>
<td>select * from student where studentno &gt;0;（如果读到列name的值为‘张三’和‘赵六’，则意味着发生了幻读）</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录；之后Session B中提交了一个 隐式事务 ，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为 幻读 。我们把<strong>新插入的那些记录</strong>称之为 <strong>幻影记录</strong> 。  </p>
<p><strong>注意1：</strong></p>
<p>那如果Session B中删除了一些符合studentno &gt; 0 的记录而不是插入新纪录，那Session A之后再根据studentno &gt; 0的条件读取的记录变少了，这种现象算不算幻读呢？这种现象不属于幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>
<p><strong>注意2：</strong></p>
<p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？这相当于是对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前没有获取到的记录。</p>
<h4 id="3-3-SQL中的四种隔离级别"><a href="#3-3-SQL中的四种隔离级别" class="headerlink" title="3.3 SQL中的四种隔离级别"></a>3.3 SQL中的四种隔离级别</h4><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</span><br></pre></td></tr></table></figure>

<p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 SQL标准 中设立了4个 隔离级别 ：  </p>
<ul>
<li>&#x3D;&#x3D;READ UNCOMMITTED&#x3D;&#x3D; ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li>
<li>&#x3D;&#x3D;READ COMMITTED ：&#x3D;&#x3D;读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li>
<li>&#x3D;&#x3D;REPEATABLE READ ：&#x3D;&#x3D;可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li>
<li>&#x3D;&#x3D;SERIALIZABLE ：&#x3D;&#x3D;可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li>
</ul>
<p>SQL标准 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：  </p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED</td>
<td>YES</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>NO</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>&#x3D;&#x3D;REPEATABLE READ&#x3D;&#x3D;</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody></table>
<p>脏写 怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。  </p>
<p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下：  </p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610115204937.png" alt="image-20220610115204937"></p>
<h4 id="3-4-MySQL支持的四种隔离级别"><a href="#3-4-MySQL支持的四种隔离级别" class="headerlink" title="3.4 MySQL支持的四种隔离级别"></a>3.4 MySQL支持的四种隔离级别</h4><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL 5.7.20的版本之前：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;tx_isolation&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"># MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation</span><br><span class="line"># 查看隔离级别，MySQL 5.7.20的版本及之后：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;transaction_isolation&#x27;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line">SELECT @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h4><p>通过下面的语句修改事务的隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ UNCOMMITTED</span><br><span class="line">&gt; READ COMMITTED</span><br><span class="line">&gt; REPEATABLE READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 推荐下面这种</span><br><span class="line">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ-UNCOMMITTED</span><br><span class="line">&gt; READ-COMMITTED</span><br><span class="line">&gt; REPEATABLE-READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>关于设置时使用GLOBAL或SESSION的影响：</p>
<ul>
<li>使用 GLOBAL 关键字（在全局范围影响）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET GLOBAL TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>则：</p>
<ul>
<li><p>当前已经存在的会话无效</p>
</li>
<li><p>只对执行完该语句之后产生的会话起作用</p>
</li>
</ul>
</li>
<li><p>使用SESSION关键字（在会话范围影响）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET SESSION TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>则：<ul>
<li>对当前会话的所有后续的事务有效</li>
<li>如果在事务之间执行，则对后续的事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 会话1中</span><br><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global transaction_isolation = &#x27;read-committed&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 当前已经存在的会话无效</span><br><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>重新开启一个新会话2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 会话2</span><br><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| READ-COMMITTED          |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>针对session</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">mysql&gt; set session transaction_isolation = &#x27;read-uncommitted&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 修改后在当前会话中就适用</span><br><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| READ-UNCOMMITTED        |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>不论是SESSION还是GLOBAL，如果重启mysql服务，则又会恢复到默认值</li>
</ul>
<h3 id="4-事务的常见分类"><a href="#4-事务的常见分类" class="headerlink" title="4.事务的常见分类"></a>4.事务的常见分类</h3><p>从事务理论的角度来看，可以把事务分为以下几种类型：</p>
<ul>
<li>扁平事务（Flat Transactions）</li>
<li>带有保存点的扁平事务（Flat Transactions with Savepoints）</li>
<li>链事务（Chained Transactions）</li>
<li>嵌套事务（Nested Transactions）</li>
<li>分布式事务（Distributed Transactions）</li>
</ul>
<h2 id="11-MySQL事务日志"><a href="#11-MySQL事务日志" class="headerlink" title="11.MySQL事务日志"></a>11.MySQL事务日志</h2><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li><p>事务的隔离性由 <strong>锁机制</strong> 实现。</p>
</li>
<li><p>而事务的原子性、一致性和持久性由事务的 <strong>redo 日志</strong>和<strong>undo 日志</strong>来保证。</p>
<ul>
<li>REDO LOG 称为 <strong>重做日志</strong> ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</li>
<li>UNDO LOG 称为 <strong>回滚日志</strong> ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性、一致性</strong>。</li>
</ul>
</li>
<li><p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。 REDO和UNDO都可以被视为是一种<strong>恢复操作</strong>，但是：</p>
<ul>
<li><p>redo log：是&#x3D;&#x3D;存储引擎层（innodb）&#x3D;&#x3D;生成的日志，记录的是“&#x3D;&#x3D;物理级别”&#x3D;&#x3D;上页的修改操作，比如页号xxx，偏移量yyy,写入了’zzz’数据。主要为了&#x3D;&#x3D;保证数据的可靠性&#x3D;&#x3D;。</p>
</li>
<li><p>undo log：是存储引擎层（innodb）生成的日志，记录的是&#x3D;&#x3D;逻辑操作&#x3D;&#x3D;日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于&#x3D;&#x3D;事务的回滚&#x3D;&#x3D;（undo log记录的是每个修改操作的逆操作）和&#x3D;&#x3D;一致性非锁定读&#x3D;&#x3D;（undo log 回滚行记录到某种特定的版本–MVCC，即多版本并发控制）</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-redo-日志"><a href="#1-redo-日志" class="headerlink" title="1.redo 日志"></a>1.redo 日志</h3><p>Innodb存储引擎是以&#x3D;&#x3D;页为单位&#x3D;&#x3D;来管理存储空间的。在真正访问页面之前，需要把在&#x3D;&#x3D;磁盘上&#x3D;&#x3D;的页缓存到&#x3D;&#x3D;内存中的Buffer  Pool&#x3D;&#x3D;之后才可以访问。所有的变量都必须&#x3D;&#x3D;先更新缓冲池中的数据&#x3D;&#x3D;，然后缓冲池中的&#x3D;&#x3D;脏页&#x3D;&#x3D;会以一定的频率被刷入磁盘（&#x3D;&#x3D;checkpoint机制&#x3D;&#x3D;），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h4 id="1-1为什么需要REDO日志"><a href="#1-1为什么需要REDO日志" class="headerlink" title="1.1为什么需要REDO日志"></a>1.1为什么需要REDO日志</h4><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，&#x3D;&#x3D;checkpoint机制可以保证数据的最终落盘&#x3D;&#x3D;，然而由于&#x3D;&#x3D;checkpoint 并不是每次变更的时候就触发 的&#x3D;&#x3D;，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>另一方面，事务包含 &#x3D;&#x3D;持久性&#x3D;&#x3D; 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p>
<p>那么如何保证这个持久性呢？ 一个简单的做法 ：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p>
<ul>
<li>修改量与刷新磁盘工作量严重不成比例<ul>
<li>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在innodb中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘中，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是大题小做了。</li>
</ul>
</li>
<li>随机IO刷新较慢<ul>
<li>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的buffer pool中的页面&#x3D;&#x3D;刷新到磁盘&#x3D;&#x3D;时，需要进行很多的&#x3D;&#x3D;随机IO&#x3D;&#x3D;，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;另一个解决的思路&#x3D;&#x3D; ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。  </p>
<p>innodb引擎的事务采用了WAL技术（&#x3D;&#x3D;Write-Ahead Logging&#x3D;&#x3D;），这种技术的思想就是&#x3D;&#x3D;先写日志，再写磁盘，只有日志写入成功，才算事务提交成功&#x3D;&#x3D;，这里的日志就是redo log，当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610163635853.png" alt="image-20220610163635853"></p>
<h4 id="1-2-redo日志的好处、特点"><a href="#1-2-redo日志的好处、特点" class="headerlink" title="1.2 redo日志的好处、特点"></a>1.2 redo日志的好处、特点</h4><p><strong>1.好处</strong></p>
<ul>
<li>redo日志降低了刷盘频率</li>
<li>redo日志占用的空间非常小</li>
</ul>
<p>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快</p>
<p><strong>2.特点</strong></p>
<ul>
<li>&#x3D;&#x3D;redo日志是顺序写入磁盘的&#x3D;&#x3D;<ul>
<li>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO，效率比随机IO快</li>
</ul>
</li>
<li>&#x3D;&#x3D;事务执行过程中，redo log不断记录&#x3D;&#x3D;<ul>
<li>redo log跟bin log的区别，redo log是&#x3D;&#x3D;存储引擎层&#x3D;&#x3D;产生的，而bin log是&#x3D;&#x3D;数据库层&#x3D;&#x3D;产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中</li>
</ul>
</li>
</ul>
<h4 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a>1.3 redo的组成</h4><p>Redo log可以简单分为以下两个部分：  </p>
<ul>
<li><p>&#x3D;&#x3D;重做日志的缓冲&#x3D;&#x3D; (redo log buffer) ，保存在内存中，是易失的  </p>
<ul>
<li><p>在服务器启动时，就向操作系统申请了一大片称之为redo log buffer的&#x3D;&#x3D;连续内存&#x3D;&#x3D;空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分成若干个连续的redo log block，一个redo log block占用512字节大小。</p>
</li>
<li><p>参数大小设置</p>
<ul>
<li>redo log buffer 大小，默认 16M ，最大值是4096M，最小值为1M。</li>
</ul>
</li>
<li><pre><code class="mysql">mysql&gt; show variables like &#39;%innodb_log_buffer_size%&#39;;
+------------------------+----------+
| Variable_name          | Value    |
+------------------------+----------+
| innodb_log_buffer_size | 16777216 |
+------------------------+----------+
1 row in set (0.08 sec)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ==重做日志文件== (redo log file) ，保存在硬盘中，是持久的。  </span><br><span class="line"></span><br><span class="line">  - redo日志文件如图所示，其中的ib_logfile0和ib_logfile1即为REDO日志。</span><br><span class="line"></span><br><span class="line">#### 1.4 redo的整体流程</span><br><span class="line"></span><br><span class="line">以一个更新事务为例，redo log流转过程如下，如下图所示</span><br><span class="line"></span><br><span class="line">![image-20220610165855451](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610165855451.png)</span><br><span class="line"></span><br><span class="line">&gt; 只要上面的第三步不出事，那么就能够确保事务的持久性</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝<br>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值<br>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加<br>写的方式<br>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 体会：</span><br><span class="line">&gt;</span><br><span class="line">&gt; write-ahead log（预先日志持久化）：在持久化一个数据页之前，先将内存中相应的日志页持久化。</span><br><span class="line"></span><br><span class="line">#### 1.5 redo log的刷盘策略</span><br><span class="line"></span><br><span class="line">redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 ==一定的频率== 刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。  </span><br><span class="line"></span><br><span class="line">![image-20220610181115732](C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610181115732.png)</span><br><span class="line"></span><br><span class="line">注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 ==文件系统缓存（page cache）==中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。  </span><br><span class="line"></span><br><span class="line">针对这种情况，InnoDB给出 ==innodb_flush_log_at_trx_commit== 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：  </span><br><span class="line"></span><br><span class="line">- ==设置为0== ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）  </span><br><span class="line">- ==设置为1== ：表示每次事务提交时都将进行同步，刷盘操作（ ==默认值== ）</span><br><span class="line">- ==设置为2== ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。  </span><br><span class="line"></span><br><span class="line">&gt; 查看innodb_flush_log_at_trx_commit 或者设置该参数</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql&gt; show variables like &quot;innodb_flush_log_at_trx_commit&quot;;</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| Variable_name                  | Value |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| innodb_flush_log_at_trx_commit | 1     |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>另外，innodb存储引擎有一个&#x3D;&#x3D;后台线程&#x3D;&#x3D;，每隔一秒，就会把redo log buffer中的内容写到文件系统缓存（page cache）,然后调用刷盘操作。</p>
<p>一个没有提交事务的redo log记录，也可能会会刷盘。因为在事务执行过程中redo log是会写入redo log buffer中，这些redo log 记录会被&#x3D;&#x3D;后台线程&#x3D;&#x3D;刷盘。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610182724180.png" alt="image-20220610182724180"></p>
<h4 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h4><ul>
<li>innodb_flush_log_at_trx_commit &#x3D; 1时</li>
</ul>
<blockquote>
<p>小结：</p>
<p>为1时，只要事务提交成功，redo log记录就一定在硬盘里，不会又任何数据丢失。</p>
<p>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失，可以保证ACID的D，数据绝对不会丢失，但是&#x3D;&#x3D;效率最差&#x3D;&#x3D;的</p>
<p>建议使用默认值1，虽然操作系统宕机的概率小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全性相对来说更重要些。</p>
</blockquote>
<ul>
<li>innodb_flush_log_at_trx_commit&#x3D;2时</li>
</ul>
<blockquote>
<p>小结：</p>
<p>为2时，只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page  cache）.</p>
<p>如果仅仅只是&#x3D;&#x3D;MySQL挂了&#x3D;&#x3D;不会有任何数据丢失，但是操作系统宕机可能会有1秒数据的丢失，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p>
</blockquote>
<ul>
<li>innodb_flush_log_at_trx_commit&#x3D;0时</li>
</ul>
<blockquote>
<p>小结：</p>
<p>为0时，master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟的事务（master  thread是负责将缓冲池钟的数据异步刷新到磁盘，保证数据的一致性）</p>
<p>数值0的话，是一种折中的做法，它的IO效率理论是高于1和高于2的，但这种策略有丢失数据的风险，也无法保证ACID钟的D</p>
</blockquote>
<p>总结下来就是：0：延迟写，延迟刷  1：实时写，实时刷   2：实时写，延迟刷</p>
<blockquote>
<p>虽然用户可以通过设置参数innodb_flush_log_at_trx_commit为0或2来提高事务提交的性能，但需清楚，这种设置方法丧失了事务的ACID特性。</p>
</blockquote>
<h4 id="1-7-写入redo-log-buffer过程"><a href="#1-7-写入redo-log-buffer过程" class="headerlink" title="1.7 写入redo log  buffer过程"></a>1.7 写入redo log  buffer过程</h4><h5 id="1-补充概念：Mini-Transaction"><a href="#1-补充概念：Mini-Transaction" class="headerlink" title="1.补充概念：Mini-Transaction"></a>1.补充概念：Mini-Transaction</h5><ul>
<li>MySQL把底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr，比如，向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</li>
<li>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，</li>
<li><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220610191845121.png" alt="image-20220610191845121"></li>
</ul>
<h5 id="2-redo日志写入log-buffer"><a href="#2-redo日志写入log-buffer" class="headerlink" title="2.redo日志写入log buffer"></a>2.redo日志写入log buffer</h5><p>&#x3D;&#x3D;向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写&#x3D;&#x3D;。当我们想往log  buffer中写入redo日志时，第一个遇到的问题就是已更改写哪个block的哪个偏移量处，所以innodb的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续写入的redo日志应该写入到log  buffer中的哪个位置，如图所示：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611084844985.png" alt="image-20220611084844985"></p>
<p>一个mtr执行过程中可能产生若干条redo日志，&#x3D;&#x3D;这些redo日志是一个不可分割的组&#x3D;&#x3D;，所以其实不是每生成一条redo日志，就将其插入到log  buffer中，而是每个mtr运行过程中产生的日志先暂存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log  buffer中。我们现在假设有两个名为T1，T2的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下：</p>
<ul>
<li>事务T1的两个mtr分别称为mtr_T1_1和mtr_T1_2</li>
<li>事务T2的两个mtr分别称为mtr_T2_1和mtr_T2_2</li>
</ul>
<p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611085543880.png" alt="image-20220611085543880"></p>
<p>不同的事务可能是 并发 执行的，所以 T1 、 T2 之间的 mtr 可能是 交替执行 的。  每当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log  buffer中，也就是说不同事务的mtr可能是交替写入log  buffer的，我们画个示意图（为了美观，我们把一个mtr中产生的所有redo日志当作一个整体来画）：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611085924719.png" alt="image-20220611085924719"></p>
<p>有的mtr产生的redo日志量特别大，比如 mtr_t1_2产生的redo日志占用空间比较大，占用了3个block来存储。</p>
<h5 id="3-redo-log-block的结构图"><a href="#3-redo-log-block的结构图" class="headerlink" title="3.redo  log  block的结构图"></a>3.redo  log  block的结构图</h5><p>一个redo log block的结构图是由&#x3D;&#x3D;日志头、日志体、日志尾&#x3D;&#x3D;组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据就是512-12-8&#x3D;492字节</p>
<blockquote>
<p>为什么一个block设计成512字节？</p>
<p>这个和磁盘的扇区有关，机器磁盘默认的扇区大小就是512字节，如果你要写入的数据大于512字节，那么要写入的扇区肯定不止一个，这是就要涉及到盘片的转动，找到下一个扇区，假设现在需要写入两个扇区A和B，如果扇区A写入成功，而扇区B写入失败，那么就会出现非原子性的写入，而如果每次只写入和扇区的大小一样的512字节，那么每次的写入都是原子性的。</p>
</blockquote>
<h4 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h4><h5 id="1-相关参数设置"><a href="#1-相关参数设置" class="headerlink" title="1.相关参数设置"></a>1.相关参数设置</h5><ul>
<li>innodb_log_group_home_dir ：指定 redo log 文件组所在的路径，默认值为 .&#x2F; ，表示在数据库的数据目录下。MySQL的默认数据目录（ var&#x2F;lib&#x2F;mysql ）下默认有两个名为 ib_logfile0 和ib_logfile1 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</li>
<li>innodb_log_files_in_group：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1…<br>iblogfilen。默认2个，最大100个。 </li>
<li>innodb_flush_log_at_trx_commit：控制 redo log 刷新到磁盘的策略，默认为1。</li>
<li>innodb_log_file_size：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大512G。</li>
</ul>
<h5 id="2-日志文件组"><a href="#2-日志文件组" class="headerlink" title="2.日志文件组"></a>2.日志文件组</h5><p>从上面的描述中可以看到，磁盘上的redo日志文件不止一个，而是以一个日志文件组的形式出现。这些文件以ib_logfile[数字]（数字可以是0，1，2….）的形式进行命名，每个的redo日志文件大小是一样的。</p>
<p>在将redo日志写入日志文件组时，是从ib_logfile0开始写，如果ib_logfile0写满了，就接着ib_logfile1写。同理，依此类推，如果写到最后一个文件该咋办？那就重新转到ib_logfile0继续写，所以整个过程如下图所示：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611095543560.png" alt="image-20220611095543560"></p>
<p>总共的redo日志文件大小其实就是：innodb_log_file_size *  innodb_log_files_in_group</p>
<p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然，所以innodb的设计者提出了&#x3D;&#x3D;checkpoint&#x3D;&#x3D;的概念。</p>
<h5 id="3-checkpoint"><a href="#3-checkpoint" class="headerlink" title="3.checkpoint"></a>3.checkpoint</h5><p>在整个日志文件组中还有两个重要的属性，分别是write pos、checkpoint</p>
<ul>
<li>write pos是当前记录的位置，一边写一边移</li>
<li>checkpoint是当前要擦除的位置，也是往后移</li>
</ul>
<p>每次刷盘redo log记录到日志文件组中，write pos位置就会后移更新。每次MySQL加载日志文件组恢复数据时，会清空加载过的redo log记录，并把checkpoint后移更新。write pos和checkpoint之间的还空着的部分可以用来写入新的redo log记录</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611101710456.png" alt="image-20220611101710456"></p>
<p>如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log记录，MySQL 得<br>停下来，清空一些记录，把 checkpoint 推进一下。  </p>
<h4 id="1-9-redo-log小结"><a href="#1-9-redo-log小结" class="headerlink" title="1.9 redo log小结"></a>1.9 redo log小结</h4><p>innodb的更新操作采用的是write ahead log (预先日志持久化)策略，即先写日志，再写入磁盘。</p>
<h3 id="2-undo-日志"><a href="#2-undo-日志" class="headerlink" title="2.undo 日志"></a>2.undo 日志</h3><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个undo log.</p>
<h4 id="2-1-如何理解undo日志"><a href="#2-1-如何理解undo日志" class="headerlink" title="2.1 如何理解undo日志"></a>2.1 如何理解undo日志</h4><p>事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做，但有时候事务执行到一半会出现一些情况，比如：</p>
<ul>
<li>情况一：事务执行过程中可能遇到各种错误，比如 服务器本身的错误 ， 操作系统错误 ，甚至是突然 断电 导致的错误。</li>
<li>情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前事务的执行</li>
</ul>
<p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为回滚，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。</p>
<p>每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要留一手——把回滚时所需要的东西记下来。</p>
<p>MySQL把这些为了回滚而记录的这些内容称之为撤销日志或混滚日志（即undo log）。注意，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</p>
<p>此外，undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p>
<h4 id="2-2-undo日志的作用"><a href="#2-2-undo日志的作用" class="headerlink" title="2.2 undo日志的作用"></a>2.2 undo日志的作用</h4><ul>
<li>作用1：回滚数据<ul>
<li>用户对undo日志可能有误解：undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此，undo是&#x3D;&#x3D;逻辑日志&#x3D;&#x3D;，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</li>
<li>这是因为在多用户并发系统中，可能会有数十数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到十五开始的样子，因为这样会影响其他事务正在进行的工作。</li>
</ul>
</li>
<li>作用2：MVCC<ul>
<li>undo的另一个作用是MVCC,，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，一次实现&#x3D;&#x3D;非锁定读取&#x3D;&#x3D;。</li>
</ul>
</li>
</ul>
<h4 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a>2.3 undo的存储结构</h4><h5 id="1-回滚段与事务"><a href="#1-回滚段与事务" class="headerlink" title="1.回滚段与事务"></a>1.回滚段与事务</h5><p>InnoDB对undo log的管理采用段的方式，也就是 &#x3D;&#x3D;回滚段（rollback segment）&#x3D;&#x3D; 。每个回滚段记录了1024 个 &#x3D;&#x3D;undo log segment&#x3D;&#x3D; ，而在每个undo log segment段中进行 &#x3D;&#x3D;undo页&#x3D;&#x3D; 的申请。</p>
<ul>
<li><p>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。</p>
</li>
<li><p>从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到了 128*1024 </p>
</li>
<li><p>innodb_undo_directory：设置rollback segment文件所在的路径。</p>
</li>
<li><p>innodb_undo_logs：设置rollback segment的个数，默认值为128</p>
</li>
<li><p>innodb_undo_cablespace：设置构成rollback  segment文件的数量，这样rollback segment可以较为平均地分布在多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件</p>
</li>
</ul>
<p><strong>undo页的重用</strong></p>
<ul>
<li>当我们开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页。在这个申请到的undo页中进行undo log的写入，我们知道mysql默认一页的大小是16K。</li>
<li>为每一个事务分配一个页，是非常浪费的，除非MySQL清理的非常勤快，斗则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的</li>
<li>于是undo页就设计的可以重用了，当事务提交时，并不会立即删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo  log在commit后，会被放到一个链表中，然后判断undo页的使用空间是否小于3&#x2F;4，如果小于3&#x2F;4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是离散的，所以清理对应的磁盘空间时，效率不高</li>
</ul>
<h5 id="2-回滚段与事务"><a href="#2-回滚段与事务" class="headerlink" title="2.回滚段与事务"></a>2.回滚段与事务</h5><ul>
<li>&#x3D;&#x3D;每个事务只会使用一个回滚段&#x3D;&#x3D;，一个回滚段在同一时刻可能会服务于多个事务。</li>
<li>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</li>
<li>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</li>
<li>&#x3D;&#x3D;回滚段存在于undo表空间&#x3D;&#x3D;中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</li>
<li>当事务提交时，InnoDB存储引擎会做以下两件事情：<ul>
<li>将undo log放入列表中，以供之后的purge操作</li>
<li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li>
</ul>
</li>
</ul>
<h5 id="3-回滚段中的数据分类"><a href="#3-回滚段中的数据分类" class="headerlink" title="3.回滚段中的数据分类"></a>3.回滚段中的数据分类</h5><ul>
<li>未提交的回滚数据(uncommitted undo information)：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖</li>
<li>已经提交但未过期的回滚数据(committed undo information)：该数据关联的事务已经提交，但是仍受到undo  retention参数的保持时间的影响</li>
<li>事务已经提交并过期的数据(expired undo information)  ：事务已经提交，而且超过保持时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖事务已经提交并过期的数据</li>
</ul>
<p>事务提交后并不能马上删除undo log及undo log所在的页，这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo  log放入一个链表中，是否可以最终删除undo log以及undo  log所在页purge线程来判断。</p>
<h4 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a>2.4 undo的类型</h4><p>在InnoDB存储引擎中，undo log分为：</p>
<ul>
<li>insert undo log：是在insert操作中产生的，因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除，不需要进行purge操作</li>
<li>update undo log  ：是在update和delete操作中产生的，该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo  log链表，等待purge线程进行最后的删除</li>
</ul>
<h4 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a>2.5 undo log的生命周期</h4><h5 id="1-简明生成过程"><a href="#1-简明生成过程" class="headerlink" title="1.简明生成过程"></a>1.简明生成过程</h5><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611121120360.png" alt="image-20220611121120360"></p>
<p>有了Redo Log和Undo Log之后：  </p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611121147251.png" alt="image-20220611121147251"></p>
<h5 id="2-详细生成过程"><a href="#2-详细生成过程" class="headerlink" title="2. 详细生成过程"></a>2. 详细生成过程</h5><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611121725487.png" alt="image-20220611121725487"></p>
<ul>
<li>DB_ROW_ID：如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键</li>
<li>DB_TRX_ID：每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中。</li>
<li>DB_ROLL_PTR：回滚指针，本质上就是指向undo log的指针</li>
</ul>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611122131663.png" alt="image-20220611122131663"></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611122318517.png" alt="image-20220611122318517"></p>
<h5 id="3-undo-log是如何回滚的"><a href="#3-undo-log是如何回滚的" class="headerlink" title="3.undo log是如何回滚的"></a>3.undo log是如何回滚的</h5><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p>
<ul>
<li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</li>
<li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0</li>
<li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom</li>
<li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li>
</ul>
<h5 id="4-undo-log的删除"><a href="#4-undo-log的删除" class="headerlink" title="4.undo log的删除"></a>4.undo log的删除</h5><ul>
<li>针对于insert undo log</li>
</ul>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>
<ul>
<li>针对于update undo log</li>
</ul>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。  </p>
<blockquote>
<p>补充：</p>
<p>purge线程的两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delate Mark操作，在记录上标识Delete_Bit，而不删除记录，是一种假删除，只是做了个标记，真正的删除工作需要后台purge线程去完成。</p>
</blockquote>
<h4 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h4><p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611123010714.png" alt="image-20220611123010714"></p>
<p>undo log是&#x3D;&#x3D;逻辑日志&#x3D;&#x3D;，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。<br>redo log是&#x3D;&#x3D;物理日志&#x3D;&#x3D;，记录的是数据页的物理变化，undo log不是redo log的逆过程。  </p>
<h2 id="12-锁"><a href="#12-锁" class="headerlink" title="12.锁"></a>12.锁</h2><p>事务的隔离性由这章讲述的锁来实现的</p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 &#x3D;&#x3D;锁机制&#x3D;&#x3D; 也为实现MySQL的各个隔离级别提供了保证。 &#x3D;&#x3D;锁冲突&#x3D;&#x3D; 也是影响数据库 &#x3D;&#x3D;并发访问性能&#x3D;&#x3D; 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。  </p>
<h3 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2.MySQL并发事务访问相同记录"></a>2.MySQL并发事务访问相同记录</h3><p>并发事务访问相同记录的情况大致可以划分为3种：  </p>
<h4 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h4><p>读-读 情况，即并发事务相继 读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生    </p>
<h4 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h4><p>写-写 情况，即&#x3D;&#x3D;并发事务相继对相同的记录做出改动&#x3D;&#x3D;。  </p>
<p>在这种情况下会发生 &#x3D;&#x3D;脏写&#x3D;&#x3D; 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 &#x3D;&#x3D;排队执行&#x3D;&#x3D; ，这个排队的过程其实是通过 <strong>锁</strong> 来实现的。这个所谓的锁其实是一个 <strong>内存中的结构</strong> ，在事务执行前本来是没有锁的，也就是说一开始是没有 <strong>锁结构</strong> 和记录进行关联的，如图所示： </p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611144829782.png" alt="image-20220611144829782"> </p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与<strong>这条记录关联的 锁结构</strong> ，当没有的时候就会在内存中生成一个 <strong>锁结构</strong> 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构与之关联：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611144952050.png" alt="image-20220611144952050">  </p>
<p>在锁结构里有很多的记录，为了简化理解，只把两个比较重要的属性拿了出来：</p>
<ul>
<li>trx信息：代表这个锁结构是哪个事务生成的</li>
<li>is_waiting：代表当前事务是否在等待</li>
</ul>
<p>当事务T1改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting属性就是false，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了，</p>
<p>当事务T1提交之前，另一个事务T2也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性值为true，表示当前事务需要提前等待，我们把这个场景就称之为获取锁失败，或者加锁失败，图示：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611145810881.png" alt="image-20220611145810881"></p>
<p><strong>在&#x3D;&#x3D;事务T1提交&#x3D;&#x3D;之后，就会把该事务生成的锁结构释放掉</strong>，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的is_waiting属性设置为false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样：</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220611150115501.png" alt="image-20220611150115501"></p>
<p>小结几种说法：</p>
<ul>
<li>不加锁<ul>
<li>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。</li>
</ul>
</li>
<li>获取锁成功，或者加锁成功<ul>
<li>意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务可以继续执行操作。</li>
</ul>
</li>
<li>获取锁失败，或者加锁失败，或者没有获取到锁  <ul>
<li>意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务需要等待，不可以继续执行操作。</li>
</ul>
</li>
</ul>
<h4 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h4><p><strong>读-写</strong> 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 &#x3D;&#x3D;脏读 、 不可重复读 、 幻读&#x3D;&#x3D; 的问题。</p>
<p>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 &#x3D;&#x3D;REPEATABLE READ 隔离级别上就已经解决了 幻读&#x3D;&#x3D; 问题。  </p>
<h4 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h4><p>怎么解决 &#x3D;&#x3D;脏读 、 不可重复读 、 幻读&#x3D;&#x3D; 这些问题呢？其实有两种可选的解决方案：</p>
<ul>
<li><p>方案一：&#x3D;&#x3D;读操作&#x3D;&#x3D;利用多版本并发控制（ <strong>MVCC</strong> ，下章讲解），&#x3D;&#x3D;写操作&#x3D;&#x3D;进行 &#x3D;&#x3D;加锁&#x3D;&#x3D; 。</p>
<ul>
<li>所谓的<strong>MVCC</strong>，就是生成一个<strong>ReadView</strong>，通过ReadView找到符合条件的记录版本（历史版本由&#x3D;&#x3D;undo日志&#x3D;&#x3D;构建）。&#x3D;&#x3D;查询语句只能读&#x3D;&#x3D;到在生成ReadView之前已提交事务所作的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所作的更改是看不到的。而写操作肯定针对的是&#x3D;&#x3D;最新版本&#x3D;&#x3D;的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<strong>读-写</strong>操作并不冲突。</li>
</ul>
<blockquote>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在 READ COMMITTED 隔离级别下，一个事务在执行过程中&#x3D;&#x3D;每次&#x3D;&#x3D;执行SELECT操作时都会&#x3D;&#x3D;生成一个ReadView&#x3D;&#x3D;，<strong>ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改</strong> ，也就是避免了脏读现象；</li>
<li>在 REPEATABLE READ 隔离级别下，一个事务在执行过程中&#x3D;&#x3D;只有 第一次执行SELECT操作&#x3D;&#x3D; 才会生成一个ReadView，之后的SELECT操作都 &#x3D;&#x3D;复用 这个ReadView&#x3D;&#x3D;，这样也就避免了不可重复读和幻读的问题。</li>
</ul>
</blockquote>
</li>
<li><p>方案二：&#x3D;&#x3D;读、写操作都采用加锁&#x3D;&#x3D;的方式</p>
<ul>
<li>如果我们的一些&#x3D;&#x3D;业务场景不允许读取记录的旧版本&#x3D;&#x3D;，而是每次都必须去&#x3D;&#x3D;读取记录的最新版本&#x3D;&#x3D;。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存储事务执行完成，其他事务才可以访问账户的余额，这样在<strong>读取记录的时候</strong>就需要对其进行<strong>加锁</strong>操作，这样也就意味着<strong>读操作</strong>和<strong>写操作</strong>也像写-写操作那样排队执行。</li>
<li>脏读的产生是因为当前事务读取到了另一个未提交事务写的一条记录，如果另一事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</li>
<li>不可重复读的产生是因为当前事务读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时，会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会产生不可重复读了。</li>
<li>幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围插入了新纪录，当前事务再次读取该范围的记录时发现了新插入的记录。采用加锁的方式解决幻读的问题就有一些麻烦，&#x3D;&#x3D;因为当前事务在第一次读取记录时幻影记录并不存在&#x3D;&#x3D;，所以读取的时候加锁就有点尴尬（因为你不知道给谁加锁）。</li>
</ul>
</li>
<li><p>小结对比发现：</p>
<ul>
<li>采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 。</li>
<li>采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能。</li>
</ul>
</li>
</ul>
<p>一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 &#x3D;&#x3D;加锁&#x3D;&#x3D; 的方式执行。下面就讲解下MySQL中不同类别的锁  </p>
<h3 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h3><p>锁的分类图，如下：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206131649527.png" alt="image-20220611154335308"></p>
<h4 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h4><p>对于数据库中并发事务的读—读情况并不会引起什么问题。对于写—写、读—写或写—读这些情况可能会引起一些问题，需要使用&#x3D;&#x3D;MVCC或者加锁的方式来解决它们&#x3D;&#x3D;。在使用加锁的方式解决问题时，由于既要允许读—读情况不受影响，又要使写写，读写，写读情况中的操作相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为共享锁（Shared  Lock,S Lock）和排他锁（Exclusive Lock，X Lock）,也叫读锁和写锁。</p>
<ul>
<li>&#x3D;&#x3D;读锁 ：&#x3D;&#x3D;也称为 共享锁 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li>
<li>&#x3D;&#x3D;写锁 ：&#x3D;&#x3D;也称为 排他锁 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源</li>
</ul>
<p>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。  </p>
<p>举例（行级读写锁）：如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据；但是某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行</p>
<p>总结：这里的兼容是指对同一张表或记录的锁的兼容性情况</p>
<p>S-锁与S-锁兼容，其他的都不兼容。</p>
<h5 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1.锁定读"></a>1.锁定读</h5><p>在采用加锁方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取该记录的S锁，其实不严谨的，有时候需要在读取记录的时候就获取记录的X锁，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的SELECT语句格式：</p>
<p>&#x3D;&#x3D;对于InnoDB引擎中，下面两条语句的读和写指的都是行级锁&#x3D;&#x3D;</p>
<ul>
<li>&#x3D;&#x3D;对读取的记录加S锁：&#x3D;&#x3D;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line">#或</span><br><span class="line">SELECT ... FOR SHARE;  #(8.0新增语法)</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;对读取的记录加X锁&#x3D;&#x3D;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h5 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2.写操作"></a>2.写操作</h5><p>平常用到的写操作无非是delete、update、Insert这三种。</p>
<ul>
<li>INSERT:<ul>
<li>一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</li>
</ul>
</li>
</ul>
<p>在innodb中会默认给这这几种操作语句加上X行级锁</p>
<h4 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h4><p>为了尽可能提高数据库的并发度，每次锁定的数据越小越好，理论上每次之锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（设计检查、检查、释放锁等操作）。因此数据库系统需要在高并发相应和系统性能上方面进行平衡，这样就产生了锁粒度的概念。</p>
<p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；锁的粒度主要分为表级锁、页级锁和行锁。</p>
<h5 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1.表锁（Table Lock）"></a>1.表锁（Table Lock）</h5><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并不依赖于存储引擎（不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的），并且表锁是开销最小的策略（因为粒度比较大）。由于表级锁一次会将整个表锁定，所以很好的避免死锁问题。当然，锁的粒度大所带来的负面影响就是出现所资源争用的概率也会增高，导致并发率大打折扣。</p>
<p><strong>① 表级别的S锁、X锁</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 加上表级锁</span><br><span class="line">mysql&gt; lock tables account read;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line"># 加上表级锁后，自身事务可以进行读的操作</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | NAME   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 张三   |   40.00 |</span><br><span class="line">|  2 | 李四   |    0.00 |</span><br><span class="line">|  3 | 王五   |  100.00 |</span><br><span class="line">|  4 | 赵六   |  100.00 |</span><br><span class="line">|  5 | huhu   |   90.00 |</span><br><span class="line">|  6 | hehe   |  100.00 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 当该表被表级锁锁住时，自身事务也不可以进行写的操作</span><br><span class="line">mysql&gt; insert into account values(7,&#x27;刘起&#x27;,90);</span><br><span class="line">ERROR 1099 (HY000): Table &#x27;account&#x27; was locked with a READ lock and can&#x27;t be updated</span><br><span class="line"></span><br><span class="line">-- 查看锁的使用情况</span><br><span class="line">mysql&gt; show open tables where in_use &gt; 0;</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">| Database   | Table   | In_use | Name_locked |</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">| atguigudb3 | account |      1 |           0 |</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">1 row in set (0.26 sec)</span><br><span class="line"></span><br><span class="line">-- 释放读锁</span><br><span class="line">mysql&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 这是加表级锁的写锁</span><br><span class="line">mysql&gt; lock tables account write;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show open tables where in_use &gt;0;</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">| Database   | Table   | In_use | Name_locked |</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">| atguigudb3 | account |      1 |           0 |</span><br><span class="line">+------------+---------+--------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 可以对自身进行读</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | NAME   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 张三   |   40.00 |</span><br><span class="line">|  2 | 李四   |    0.00 |</span><br><span class="line">|  3 | 王五   |  100.00 |</span><br><span class="line">|  4 | 赵六   |  100.00 |</span><br><span class="line">|  5 | huhu   |   90.00 |</span><br><span class="line">|  6 | wajig  |  100.00 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 也可以对自身进行写</span><br><span class="line">mysql&gt; update account set name = &#x27;zhaoliu&#x27; where id =4;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>MyISAM在执行查询语句（select）前，会给设计的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁</li>
<li>&#x3D;&#x3D;InnoDB存储引擎是不会为这个表添加表级别的读锁或者写锁的&#x3D;&#x3D;</li>
</ul>
<p>MySQL的表级锁有两种模式</p>
<ul>
<li>表共享读锁（Table Read Lock）</li>
<li>表独享写锁（Table Write Lock）</li>
</ul>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>自己可读</th>
<th>自己可写</th>
<th>自己可操作其他表</th>
<th>他人可读</th>
<th>他人可写</th>
</tr>
</thead>
<tbody><tr>
<td>读锁（S）</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否，等</td>
</tr>
<tr>
<td>写锁 ( X )</td>
<td>是</td>
<td>&#x3D;&#x3D;是&#x3D;&#x3D;</td>
<td>否</td>
<td>&#x3D;&#x3D;否&#x3D;&#x3D;</td>
<td>否，等</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;② 意向锁 （intention lock&#x3D;&#x3D;  </p>
<p>InnoDB 支持 &#x3D;&#x3D;多粒度锁&#x3D;&#x3D;（multiple granularity locking） ，它允许 &#x3D;&#x3D;行级锁 与 表级锁 共存&#x3D;&#x3D;，而意向<br>锁就是其中的一种 &#x3D;&#x3D;表锁&#x3D;&#x3D; 。  </p>
<p>1.意向锁的存在是为了协调行级锁和表级锁的关系，支持多粒度（表锁与行锁）的锁并存。</p>
<p>2.意向锁是一种&#x3D;&#x3D;不与行级锁冲突的表级锁&#x3D;&#x3D;，这一点非常重要</p>
<p>3.表明“某个事务正在某些行持有了锁或该事务准备去持有”锁</p>
<p>意向锁分为两类：</p>
<ul>
<li>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加&#x3D;&#x3D;共享锁&#x3D;&#x3D;（S锁）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<ul>
<li>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加&#x3D;&#x3D;排他锁&#x3D;&#x3D;（X锁）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>即：意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁 。  </p>
<p>1.意向锁要解决的问题.</p>
<ul>
<li>在数据表的场景中，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了。这样当其他人想要获取数据表排他锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</li>
<li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁</li>
<li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排它锁。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>意向共享锁（IS）</th>
<th>意向排他锁(IS)</th>
</tr>
</thead>
<tbody><tr>
<td>意向共享锁(IS)</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>意向排它锁</td>
<td>兼容</td>
<td>&#x3D;&#x3D;兼容&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>意向共享锁</th>
<th>意向排他锁</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁( S  )</td>
<td>&#x3D;&#x3D;兼容&#x3D;&#x3D;</td>
<td>互斥</td>
</tr>
<tr>
<td>排他锁( X )</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody></table>
<p>从上面的案例可以得到如下结论：</p>
<ul>
<li>InnoDB 支持 &#x3D;&#x3D;多粒度锁&#x3D;&#x3D; ，特定场景下，&#x3D;&#x3D;行级锁可以与表级锁共存&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;意向锁之间互不排斥&#x3D;&#x3D;，但除了 IS 与 S 兼容外， 意向锁会与 &#x3D;&#x3D;共享锁 &#x2F; 排他锁【这两个锁是表级锁】&#x3D;&#x3D; 互斥 。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li>
<li>意向锁在保证并发性的前提下，实现了 行锁和表锁共存 且 满足事务隔离性 的要求。</li>
</ul>
<p><strong>③ 自增锁（AUTO-INC锁）</strong>  </p>
<p>在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性。举例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">`id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` varchar(255) NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure>

<p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改<br>如下所示。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `teacher` (name) VALUES (&#x27;zhangsan&#x27;), (&#x27;lisi&#x27;);</span><br></pre></td></tr></table></figure>

<p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1 | zhangsan |</span><br><span class="line">| 2 | lisi |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是“ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”。  </p>
<ol>
<li>“Simple inserts” （简单插入）<br>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</li>
<li>“Bulk inserts” （批量插入）<br>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE… SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</li>
<li>“Mixed-mode inserts” （混合模式插入）<br>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name)VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。</li>
</ol>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：  </p>
<p>（1）innodb_autoinc_lock_mode &#x3D; 0(“传统”锁定模式)</p>
<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会 限制并发 能力。<br>（2）innodb_autoinc_lock_mode &#x3D; 1(“连续”锁定模式)</p>
<p>在 MySQL 8.0 之前，连续锁定模式是 默认 的。在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT …SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。<br>（3）innodb_autoinc_lock_mode &#x3D; 2(“交错”锁定模式)</p>
<p>&#x3D;&#x3D;从 MySQL 8.0 开始，交错锁模式是 默认 设置。&#x3D;&#x3D;</p>
<p>在此锁定模式下，&#x3D;&#x3D;自动递增值&#x3D;&#x3D; 保证 在所有并发执行的所有类型的insert语句中是 &#x3D;&#x3D;唯一 且 单调递增 的&#x3D;&#x3D;。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能不是连续的。  </p>
<p><strong>④ 元数据锁（MDL锁）</strong>  </p>
<p>不需要显式使用，当在访问一个表的时候就会默认添加</p>
<h5 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2.InnoDB中的行锁"></a>2.InnoDB中的行锁</h5><h6 id="①-记录锁（Record-Locks）"><a href="#①-记录锁（Record-Locks）" class="headerlink" title="① 记录锁（Record Locks）"></a>① 记录锁（Record Locks）</h6><p>行锁（Row Lock）也称为记录锁，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行级锁，行级锁只&#x3D;&#x3D;在存储引擎层实现&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;优点&#x3D;&#x3D;：锁定粒度小，发生冲突概率低，可以实现的并发度高</p>
<p>&#x3D;&#x3D;缺点：&#x3D;&#x3D;对于锁的开销比较大，加锁会比较慢，容易出现死锁情况</p>
<p>&#x3D;&#x3D;InnoDB与MyISAM的最大不同有有两点：一是支持事务（Transaction）;二是采用了行级锁&#x3D;&#x3D;</p>
<p>记录锁是由S锁和X锁之分的，称之为S型记录锁和X型记录锁。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录所后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获得X型记录锁</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续X型记录锁。</li>
</ul>
<h6 id="②-间隙锁（Gap-Locks）"><a href="#②-间隙锁（Gap-Locks）" class="headerlink" title="② 间隙锁（Gap Locks）"></a>② 间隙锁（Gap Locks）</h6><p>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条记录加一个gap锁的示意图如下。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206131645606.png" alt="image-20220612212207773"></p>
<p>图中id值为8的记录加了gap锁，意味着 不允许别的事务在id值为8的记录前边的间隙插入新记录 ，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。  </p>
<p>&#x3D;&#x3D;gap锁的提出仅仅是为了防止插入幻影记录而提出的。&#x3D;&#x3D;，虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁  </p>
<p>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实影响了并发度的。</p>
<h6 id="③-临键锁（Next-Key-Locks）"><a href="#③-临键锁（Next-Key-Locks）" class="headerlink" title="③ 临键锁（Next-Key Locks）"></a><strong>③ 临键锁（Next-Key Locks）</strong></h6><p>有时候我们既想 锁住某条记录 ，又想 阻止 其他事务在该记录前边的 间隙插入新记录 ，所以InnoDB就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁，innodb默认的锁就是&#x3D;&#x3D;Next-Key locks&#x3D;&#x3D;。</p>
<p>next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能组织别的事务将新纪录插入被保护记录前边的间隙。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from student where id &lt;=8 and id &gt; 3 for update;</span><br></pre></td></tr></table></figure>

<h6 id="④-插入意向锁（Insert-Intention-Locks）"><a href="#④-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="④ 插入意向锁（Insert Intention Locks）"></a><strong>④ 插入意向锁（Insert Intention Locks）</strong></h6><p>我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁 （ next-key锁也包含 gap锁 ），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是&#x3D;&#x3D;InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个 间隙 中 插入 新记录，但是现在在等待&#x3D;&#x3D;。InnoDB就把这种类型的锁命名为 &#x3D;&#x3D;Insert Intention Locks&#x3D;&#x3D; ，官方的类型名称为：LOCK_INSERT_INTENTION ，我们称为 插入意向锁 。插入意向锁是一种 &#x3D;&#x3D;Gap锁&#x3D;&#x3D; ，不是&#x3D;&#x3D;意向锁&#x3D;&#x3D;，在insert操作时产生。</p>
<p>插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁 。&#x3D;&#x3D;事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。&#x3D;&#x3D;  </p>
<h5 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3.页锁"></a>3.页锁</h5><p>页锁就是在 &#x3D;&#x3D;页的粒度&#x3D;&#x3D; 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。&#x3D;&#x3D;页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。&#x3D;&#x3D;</p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间， &#x3D;&#x3D;锁空间的大小是有限的&#x3D;&#x3D; 。当某个层级的锁数量超过了这个层级的阈值时，就会进行 &#x3D;&#x3D;锁升级&#x3D;&#x3D; 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。  </p>
<h4 id="3-3-从对待锁的态度划分：乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分：乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分：乐观锁、悲观锁"></a>3.3 从对待锁的态度划分：乐观锁、悲观锁</h4><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<strong>数据并发的思维方式</strong> 。需要注意的是，&#x3D;&#x3D;乐观锁和悲观锁并不是锁，而是锁的 设计思想&#x3D;&#x3D; 。  </p>
<h5 id="1-悲观锁（Pessimistic-Locking）"><a href="#1-悲观锁（Pessimistic-Locking）" class="headerlink" title="1.悲观锁（Pessimistic Locking）"></a>1.悲观锁（Pessimistic Locking）</h5><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 &#x3D;&#x3D;阻塞&#x3D;&#x3D; 直到它拿到锁（&#x3D;&#x3D;共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程&#x3D;&#x3D;）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 &#x3D;&#x3D;synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现&#x3D;&#x3D;。 </p>
<p> 悲观锁不适用的场景较多，它存在一些不足，因为悲观锁大多数情况下依靠数据库的锁机制来实现，以保证程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是长事务而言，这样的开销往往无法承受，这时就需要乐观锁。</p>
<h5 id="2-乐观锁（Optimistic-Locking）"><a href="#2-乐观锁（Optimistic-Locking）" class="headerlink" title="2.乐观锁（Optimistic Locking）"></a>2.乐观锁（Optimistic Locking）</h5><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是&#x3D;&#x3D;不采用数据库自身的锁机制，而是通过程序来实现&#x3D;&#x3D;。在程序上，我们可以采用 &#x3D;&#x3D;版本号机制&#x3D;&#x3D; 或者 &#x3D;&#x3D;CAS机制&#x3D;&#x3D; 实现。&#x3D;&#x3D;乐观锁适用于多读的应用类型，这样可以提高吞吐量&#x3D;&#x3D;。在Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁  的一种实现方式：CAS实现的  </p>
<p><strong>1.乐观锁的版本号机制</strong>  </p>
<p>在表中&#x3D;&#x3D;设计一个 版本字段 version&#x3D;&#x3D; ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 UPDATE … SET version&#x3D;version+1 WHERE version&#x3D;version 。此时如果已经有事务对这条数据进行了更改，修改就不会成功。  </p>
<p><strong>2.乐观锁的时间戳机制</strong>  </p>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p>
<p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。  </p>
<p><strong>3.两种锁的适用场景</strong></p>
<p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>
<ul>
<li>乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 &#x3D;&#x3D;程序实现&#x3D;&#x3D; ， 不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li>悲观锁 适合 写操作多 的场景，因为写的操作具有 &#x3D;&#x3D;排它性&#x3D;&#x3D; 。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 &#x3D;&#x3D;读 - 写 和 写 - 写&#x3D;&#x3D; 的冲突。</li>
</ul>
<h4 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a>3.4 按加锁的方式划分：显式锁、隐式锁</h4><h5 id="1-隐式锁"><a href="#1-隐式锁" class="headerlink" title="1.隐式锁"></a>1.隐式锁</h5><p>一个事务在执行INSERT操作时，如果即将插入的间隙已经被其他事务加了gap锁，那么本次INSERT操作会阻塞，并且当前事务会在该间隙上加一个插入意向锁，否则一般情况下INSERT操作是不加锁的。</p>
<p>那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构），然后另一个事务：</p>
<ul>
<li>立即使用SELECT  …  LOCK IN  SHARE  MODE语句读取这条记录，也就是要获取这条记录的S锁，或者使用SELECT  …  FOR  UPDATE语句读取这条记录，也就是要获取这条记录的X锁，怎么办？<ul>
<li>如果允许这种情况发生，那么可能发生脏读问题。【即一个事务读取到了另一个事务尚未提交过的数据】</li>
</ul>
</li>
<li>立即修改这条记录，也就是要获取这条记录的X锁，怎么办？<ul>
<li>如果允许这种情况的发生，那么可能产生脏写问题。</li>
</ul>
</li>
</ul>
<p>这时候我们前边提过的事务ID又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下“</p>
<ul>
<li>情景一：对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是当前事务的 &#x3D;&#x3D;事务id&#x3D;&#x3D; ，如果&#x3D;&#x3D;其他事务此时想对该记录添加 S锁 或者 X锁 时&#x3D;&#x3D;，首先会看一下该记录的trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态（也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</li>
<li>情景二：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 &#x3D;&#x3D;Page&#x3D;&#x3D;<br>&#x3D;&#x3D;Header 部分有一个 PAGE_MAX_TRX_ID 属性&#x3D;&#x3D;，该属性代表对该页面做改动的最大的 事务id ，如<br>果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已<br>经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记<br>录，然后再重复 情景一 的做法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># session 1</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; insert INTO student VALUES(34,&quot;周八&quot;,&quot;二班&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># session 2</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from student lock in share mode; #执行完，当前事务被阻塞</span><br><span class="line"></span><br><span class="line"># 会话窗口session 3 查看当前的显式锁</span><br><span class="line">mysql&gt; SELECT * FROM performance_schema.data_lock_waits\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">REQUESTING_ENGINE_LOCK_ID: 140562531358232:7:4:9:140562535668584</span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: 422037508068888</span><br><span class="line">REQUESTING_THREAD_ID: 64</span><br><span class="line">REQUESTING_EVENT_ID: 6</span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: 140562535668584</span><br><span class="line">BLOCKING_ENGINE_LOCK_ID: 140562531351768:7:4:9:140562535619104</span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID: 15902</span><br><span class="line">BLOCKING_THREAD_ID: 64</span><br><span class="line">BLOCKING_EVENT_ID: 6</span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN: 140562535619104</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>隐式锁的逻辑过程如下：</p>
<p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。</p>
<p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 隐式锁 转换为 显式锁 (就是为该事务添加一个锁)。</p>
<p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。</p>
<p>D. 等待加锁成功，被唤醒，或者超时。</p>
<p>E. 写数据，并将自己的trx_id写入trx_id字段。   </p>
<h5 id="2-显式锁"><a href="#2-显式锁" class="headerlink" title="2.显式锁"></a>2.显式锁</h5><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：<br>显示加共享锁：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... lock in share mode</span><br></pre></td></tr></table></figure>

<p>显示加排它锁：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... for update;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-其他锁之：全局锁"><a href="#3-5-其他锁之：全局锁" class="headerlink" title="3.5 其他锁之：全局锁"></a>3.5 其他锁之：全局锁</h4><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份 。</p>
<p>全局锁的命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure>

<h4 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a>3.6 其它锁之：死锁</h4><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死<br>锁示例：  </p>
<table>
<thead>
<tr>
<th></th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction;  update account set money&#x3D;10 where id&#x3D;1;</td>
<td>start transaction;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>update account set money&#x3D;10 where id&#x3D;2;</td>
</tr>
<tr>
<td>3</td>
<td>update account set money&#x3D;20 where id&#x3D;2;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>update account set money&#x3D;20 where id&#x3D;1;</td>
</tr>
</tbody></table>
<p>这时候，事务1在等待事务2释放id&#x3D;2的行锁，而事务2在等待事务1释放id&#x3D;1的行锁。 事务1和事务2在互相等待对方的资源释放，就是进入了死锁状态。</p>
<ul>
<li>产生死锁的条件<ul>
<li>两个或者两个以上事务</li>
<li>每个事务都已经持有锁并且申请新的锁</li>
<li>锁资源同时只能被同一个事务持有或者不兼容</li>
<li>事务之间因为持有锁和申请锁彼此循环等待</li>
</ul>
</li>
</ul>
<blockquote>
<p>死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。</p>
</blockquote>
<ul>
<li>如何处理死锁：<ul>
<li>方式1：等待，直到超时（innodb_lock_wait_timeout&#x3D;50s）<ul>
<li>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其回滚，另外事务继续进行。这种方法简单有效，在innodb中，参数innodb_lock_wait_timeout用来设置超时时间</li>
<li>缺点：对于在线服务来说，这个等待时间往往是无法接受的</li>
<li>如果将时间简单的设置小一点，不可取，因为会误伤到普通的等待。</li>
</ul>
</li>
<li>方式2：使用死锁检测进行死锁处理<ul>
<li>方式1检测死锁太过被动，innodb还提供了wait-for graph算法来进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</li>
<li>这是一种较为主动的死锁检测机制，要求数据库保存锁的信息链表和事务等待链表两部分信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>死锁检测的原理是构建一个事务为顶点，锁为边的有向图，判断有向图是否存在环，存在既有死锁</p>
</blockquote>
<ul>
<li>一旦检测到回路，有死锁，这时候Innodb存储引擎会选择回滚undo量最小的事务，让其他事务继续执行（‘innodb_deaflock_detect&#x3D;on’表示开启这个逻辑）</li>
<li>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100&#x3D;1万次，一万个线程就会有1千万次检测</li>
</ul>
<p><strong>如何解决：</strong></p>
<ul>
<li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li>
<li>方式2：控制并发访问的数量，比如在中间件中实现对于想同行的更新，在进入引擎之前排队，这样在Innodb内部就不会有大量的死锁检测工作。</li>
</ul>
<p><strong>进一步的思路：</strong></p>
<p>可以通过将一行改成逻辑上的多行来减少锁冲突。比如，连锁超时总额的记录，可以考虑放到多条记录上，账户总额等于这多条记录的值的总和。</p>
<ul>
<li>如何避免死锁<ul>
<li>合理设计索引，使业务SQL尽可能通过索引定位更少的行，减少锁竞争</li>
<li>调整业务逻辑SQL执行顺序，避免update、delete长时间持有锁的SQL在事务前面</li>
<li>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。</li>
<li>在并发比较高的系统中，不要显式加锁，特别是在事务里显式加锁。如select … for  update语句，如果是在事务里执行了start transaction 或设置了autocommit等于0，那么就会锁定所有查找到的记录</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择。</li>
</ul>
</li>
</ul>
<h3 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4.锁的内存结构"></a>4.锁的内存结构</h3><p>我们前边说过对一条记录加锁的本质就是在内存中创建一个锁结构与之关联，那么是不是一个事务对多条记录加锁，就要创建多个锁结构呢？比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 事务T1</span><br><span class="line">select * from user lock in share mode;</span><br></pre></td></tr></table></figure>

<p>理论上创建多个锁结构没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了，所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个锁结构中。</p>
<ul>
<li>在同一个事务中进行加锁的操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型是一样的</li>
<li>等待状态是一样的</li>
</ul>
<p>InnoDB存储引擎中的键结构如下：</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132033904.png" alt="image-20220613203316672"></p>
<p>结构解析：</p>
<p>&#x3D;&#x3D;1.锁所在的事务信息：&#x3D;&#x3D;</p>
<p>不论是表锁还是行锁，都是在事务执行过程中生成的，哪个事务生成了这个锁结构，这里就记录这个事务的信息。</p>
<p>此锁所在的事务信息在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
<p>&#x3D;&#x3D;2.索引信息&#x3D;&#x3D;</p>
<p>对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针</p>
<p>&#x3D;&#x3D;3.表锁&#x2F;行锁信息&#x3D;&#x3D;<br>表锁结构 和 行锁结构 在这个位置的内容是不同的：</p>
<ul>
<li><p>表锁：</p>
<p>记载着是对哪个表加的锁，还有其他的一些信息</p>
</li>
<li><p>行锁：</p>
<p>记载了三个重要的信息：</p>
<ul>
<li><p>Space ID ：记录所在表空间。</p>
</li>
<li><p>Page Number ：记录所在页号。</p>
</li>
<li><p>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。  </p>
<blockquote>
<p>n_bits的值一般都比页面中记录条数多一些，主要是为了之后在页面中插入了新纪录后也不至于重新分配锁结构。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;4.type_mode&#x3D;&#x3D;</p>
<p>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：  </p>
<p>&#x3D;&#x3D;5.其他信息 ：&#x3D;&#x3D;<br>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。<br>&#x3D;&#x3D;6.一堆比特位 ：&#x3D;&#x3D;<br>如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 n_bits 属性<br>表示的。InnoDB数据页中的每条记录在 记录头信息 中都包含一个 heap_no 属性，伪记录 Infimum 的<br>heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录， heap_no 值就增1。 锁结<br>构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 heap_no ，即一个比特位映射<br>到页内的一条记录。  </p>
<h3 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5.锁监控"></a>5.锁监控</h3><p>关于MySQL锁的监控，我们一般可以通过检查InnoDB_row_lock等状态变量来分析系统上的行锁的争夺情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Innodb_row_lock_current_waits | 0 |</span><br><span class="line">| Innodb_row_lock_time | 0 |</span><br><span class="line">| Innodb_row_lock_time_avg | 0 |</span><br><span class="line">| Innodb_row_lock_time_max | 0 |</span><br><span class="line">| Innodb_row_lock_waits | 0 |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>对各个状态量的说明如下：</p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li>
<li>Innodb_row_lock_time ：从系统启动到现在锁定总时间长度；（等待总时长）</li>
<li>Innodb_row_lock_time_avg ：每次等待所花平均时间；（等待平均时长）</li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li>
<li>Innodb_row_lock_waits ：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<p>对于这5个状态变量，比较重要的3个见上面（橙色）。  </p>
<p>&#x3D;&#x3D;其他监控方法：&#x3D;&#x3D;</p>
<p>MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是INNODB_TRX 、 INNODB_LOCKS 和 INNODB_LOCK_WAITS 。</p>
<p>MySQL5.7及之前 ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p>
<p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了 performance_schema.data_locks ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，</p>
<p>performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。同时，information_schema.INNODB_LOCK_WAITS也被 &#x3D;&#x3D;performance_schema.data_lock_waits&#x3D;&#x3D; 所代替。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 会话1</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account for update;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 会话2</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account for update;  # 开始阻塞</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"># 会话3开始查看锁结构</span><br><span class="line">mysql&gt; select * from information_schema.INNODB_LOCK_WAITS\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">requesting_trx_id: 4190</span><br><span class="line">requested_lock_id: 4190:80:3:11</span><br><span class="line">  blocking_trx_id: 4189</span><br><span class="line"> blocking_lock_id: 4189:80:3:11</span><br><span class="line">1 row in set, 1 warning (0.06 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_TRX \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                    trx_id: 4190</span><br><span class="line">                 trx_state: LOCK WAIT</span><br><span class="line">               trx_started: 2022-06-13 21:00:46</span><br><span class="line">     trx_requested_lock_id: 4190:80:3:11</span><br><span class="line">          trx_wait_started: 2022-06-13 21:01:49</span><br><span class="line">                trx_weight: 2</span><br><span class="line">       trx_mysql_thread_id: 31</span><br><span class="line">                 trx_query: select * from account for update</span><br><span class="line">       trx_operation_state: starting index read</span><br><span class="line">         trx_tables_in_use: 1</span><br><span class="line">         trx_tables_locked: 1</span><br><span class="line">          trx_lock_structs: 2</span><br><span class="line">     trx_lock_memory_bytes: 1136</span><br><span class="line">           trx_rows_locked: 2</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line"> trx_adaptive_hash_latched: 0</span><br><span class="line"> trx_adaptive_hash_timeout: 0</span><br><span class="line">          trx_is_read_only: 0</span><br><span class="line">trx_autocommit_non_locking: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">                    trx_id: 4189</span><br><span class="line">                 trx_state: RUNNING</span><br><span class="line">               trx_started: 2022-06-13 21:00:21</span><br><span class="line">     trx_requested_lock_id: NULL</span><br><span class="line">          trx_wait_started: NULL</span><br><span class="line">                trx_weight: 2</span><br><span class="line">       trx_mysql_thread_id: 30</span><br><span class="line">                 trx_query: NULL</span><br><span class="line">       trx_operation_state: NULL</span><br><span class="line">         trx_tables_in_use: 0</span><br><span class="line">         trx_tables_locked: 1</span><br><span class="line">          trx_lock_structs: 2</span><br><span class="line">     trx_lock_memory_bytes: 1136</span><br><span class="line">           trx_rows_locked: 12</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line"> trx_adaptive_hash_latched: 0</span><br><span class="line"> trx_adaptive_hash_timeout: 0</span><br><span class="line">          trx_is_read_only: 0</span><br><span class="line">trx_autocommit_non_locking: 0</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_LOCKS\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    lock_id: 4190:80:3:11</span><br><span class="line">lock_trx_id: 4190</span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `atguigudb3`.`account`</span><br><span class="line"> lock_index: PRIMARY</span><br><span class="line"> lock_space: 80</span><br><span class="line">  lock_page: 3</span><br><span class="line">   lock_rec: 11</span><br><span class="line">  lock_data: 1</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    lock_id: 4189:80:3:11</span><br><span class="line">lock_trx_id: 4189</span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `atguigudb3`.`account`</span><br><span class="line"> lock_index: PRIMARY</span><br><span class="line"> lock_space: 80</span><br><span class="line">  lock_page: 3</span><br><span class="line">   lock_rec: 11</span><br><span class="line">  lock_data: 1</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h2 id="13-多版本并发控制"><a href="#13-多版本并发控制" class="headerlink" title="13 多版本并发控制"></a>13 多版本并发控制</h2><h3 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1.什么是MVCC"></a>1.什么是MVCC</h3><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 &#x3D;&#x3D;并发控制&#x3D;&#x3D; 。这项技术使得在InnoDB的事务隔离级别下执行 &#x3D;&#x3D;一致性读 操作&#x3D;&#x3D;有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。  </p>
<p>MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的（大家可以参考相关的DBMS文档）。这里讲解InnoDB中MVCC的实现机制（MySQL其他的存储引擎并不支持它）。</p>
<h3 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2.快照读与当前读"></a>2.快照读与当前读</h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 读-写冲突 ，做到即使有读写冲突时，也能做到 不加锁 ， 非阻塞并发读 ，而这个读指的就是 快照读 , 而非 当前读 。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。  </p>
<h4 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h4><p>快照读又叫一致性读，读取的是快照数据。&#x3D;&#x3D;不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读&#x3D;&#x3D;；比如这样：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM player WHERE ...</span><br></pre></td></tr></table></figure>

<p>之所以出现快照读的情况，是基于提高并发性能的考虑，&#x3D;&#x3D;快照读的实现是基于MVCC&#x3D;&#x3D;，它在很多情况下，避免了加锁操作，降低了开销。</p>
<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>
<p>快照读的前提是 隔离级别&#x3D;&#x3D;不是串行级别&#x3D;&#x3D;，串行级别下的快照读会退化成当前读。  </p>
<h4 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h4><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。&#x3D;&#x3D;加锁的 SELECT&#x3D;&#x3D;，或者&#x3D;&#x3D;对数据进行增删改都会进行当前读&#x3D;&#x3D;。比如：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁</span><br><span class="line"></span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line"></span><br><span class="line">INSERT INTO student values ... # 排他锁</span><br><span class="line"></span><br><span class="line">DELETE FROM student WHERE ... # 排他锁</span><br><span class="line"></span><br><span class="line">DELETE FROM student WHERE ... # 排他锁</span><br></pre></td></tr></table></figure>

<h3 id="3-复习"><a href="#3-复习" class="headerlink" title="3.复习"></a>3.复习</h3><h4 id="3-1再谈隔离级别"><a href="#3-1再谈隔离级别" class="headerlink" title="3.1再谈隔离级别"></a>3.1再谈隔离级别</h4><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132140291.png" alt="image-20220613214022086">  </p>
<p>在MySQL中，默认的隔离级别是不可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的并发能力。</p>
<p>MVCC可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题！它可以在大多数情况下替代行级锁，降低系统的开销。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132149820.png" alt="image-20220613214959640"></p>
<h4 id="3-2隐藏字段、Undo-Log版本链"><a href="#3-2隐藏字段、Undo-Log版本链" class="headerlink" title="3.2隐藏字段、Undo Log版本链"></a>3.2隐藏字段、Undo Log版本链</h4><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的&#x3D;&#x3D;隐藏列 【隐藏字段】&#x3D;&#x3D;。  </p>
<ul>
<li>&#x3D;&#x3D;trx_id&#x3D;&#x3D; ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给trx_id 隐藏列。</li>
<li>&#x3D;&#x3D;roll_pointer&#x3D;&#x3D; ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然<br>后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p>举例：</p>
<ul>
<li>这是插入前数据的结构情况：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132155442.png" alt="image-20220613215525260"></p>
<blockquote>
<p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。  </p>
</blockquote>
<p>假设之后两个事务id分别为 10 、 20 的事务对这条记录进行 UPDATE 操作，操作流程如下：  </p>
<table>
<thead>
<tr>
<th>发生时间 顺序</th>
<th>事务10</th>
<th>事务20</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE student SET name&#x3D;”李四” WHERE id&#x3D;1;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>UPDATE student SET name&#x3D;”王五” WHERE id&#x3D;1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>UPDATE student SET name&#x3D;”钱七” WHERE id&#x3D;1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>UPDATE student SET name&#x3D;”宋八” WHERE id&#x3D;1;</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 roll_pointer 属性（ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 undo日志都连起来，串成一个链表：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206132201223.png" alt="image-20220613220130037"></p>
<p>对该记录每次更新后，都会将旧值放到一条 &#x3D;&#x3D;undo日志&#x3D;&#x3D; 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 &#x3D;&#x3D;roll_pointer&#x3D;&#x3D; 属性连接成一个链表，我们把这个链表称之为 &#x3D;&#x3D;版本链&#x3D;&#x3D; ，版本链的头节点就是当前记录最新的值。</p>
<p>每个版本中还包含生成该版本时对应的 &#x3D;&#x3D;事务id&#x3D;&#x3D; 。  </p>
<h3 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4.MVCC实现原理之ReadView"></a>4.MVCC实现原理之ReadView</h3><p>MVCC的实现依赖于：&#x3D;&#x3D;隐藏字段、Undo  Log、Read View&#x3D;&#x3D;</p>
<h4 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h4><p>在MVCC机制中，多个事务对听一个行记录进行更新会产生多个历史版本，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p>
<p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护当前系统目前&#x3D;&#x3D;活跃事务&#x3D;&#x3D;的ID（活跃指的就是，启动了但还没提交）。</p>
<h4 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h4><p>使用&#x3D;&#x3D;READ UNCOMMITTED&#x3D;&#x3D;隔离级别的事务，用于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p>
<p>使用 &#x3D;&#x3D;SERIALIZABLE&#x3D;&#x3D; 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p>
<p>使用 &#x3D;&#x3D;READ COMMITTED 和 REPEATABLE READ&#x3D;&#x3D; 隔离级别的事务，都必须保证读到 &#x3D;&#x3D;已经提交了的 事务修改过的记录&#x3D;&#x3D;。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，&#x3D;&#x3D;核心问题&#x3D;&#x3D;就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p>这个ReadView中主要包含4个比较重要的内容，分别如下：  </p>
<ol>
<li><p>&#x3D;&#x3D;creator_trx_id&#x3D;&#x3D; ，创建这个 Read View 的事务 ID。</p>
<blockquote>
<p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;trx_ids&#x3D;&#x3D; ，表示在生成ReadView时当前系统中&#x3D;&#x3D;活跃的读写事务的 事务id&#x3D;&#x3D;列表 。</p>
</li>
<li><p>&#x3D;&#x3D;up_limit_id&#x3D;&#x3D; ，&#x3D;&#x3D;活跃的&#x3D;&#x3D;事务中最小的事务 ID。</p>
</li>
<li><p>&#x3D;&#x3D;low_limit_id&#x3D;&#x3D; ，表示生成ReadView时系统中应该分配给下一个事务的 &#x3D;&#x3D;id&#x3D;&#x3D; 值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p>
<blockquote>
<p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p>
</blockquote>
</li>
</ol>
<h4 id="4-3-ReadView的规则【重要】"><a href="#4-3-ReadView的规则【重要】" class="headerlink" title="4.3 ReadView的规则【重要】"></a>4.3 ReadView的规则【重要】</h4><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本 【这里的内容是存放在Undo Log中的】是否可见。</p>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
<h4 id="4-4-MVCC整体操作流程【重要】"><a href="#4-4-MVCC整体操作流程【重要】" class="headerlink" title="4.4 MVCC整体操作流程【重要】"></a>4.4 MVCC整体操作流程【重要】</h4><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID；</li>
<li>获取 ReadView；</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li>
<li>最后返回符合规则的数据。</li>
</ol>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性。依次类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
<blockquote>
<p>InnoDB中，MVCC是通过Undo Log+Read View进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见</p>
</blockquote>
<p>&#x3D;&#x3D;在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。&#x3D;&#x3D;  </p>
<p>如表所示  ：</p>
<table>
<thead>
<tr>
<th>事务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select * from student where id &gt;2;</td>
<td>获取一次Read View</td>
</tr>
<tr>
<td>………</td>
<td></td>
</tr>
<tr>
<td>select * from student where id &gt;2;</td>
<td>获取一次Read View</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。  </p>
</blockquote>
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141036007.png" alt="image-20220614103628819"></p>
<h3 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5.举例说明"></a>5.举例说明</h3><h4 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a>5.1 READ COMMITTED隔离级别下</h4><p>READ COMMITTED ：每次读取数据前都生成一个ReadView。  </p>
<p>现在有两个 事务id 分别为 10 、 20 的事务在执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141105775.png" alt="image-20220614110527599"></p>
<p>假设现在有一个使用 READ COMMITTED 隔离级别的事务开始执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下：</p>
<p>步骤1：在执行SELECT语句时会先生成一个Read VIew，ReadView的trx_ids列表的内容就是 [10，20]，up_limit_id为10，low_limit_id为21，creator_trx_id为0。</p>
<p>步骤2：从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是‘王五’，该版本的trx_id值为10，10在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p>
<p>步骤3：下一个版本的列name的内容是‘李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤4：下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView记录中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三‘的记录</p>
<p>之后，我们把 事务id 为 10 的事务提交一下 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>然后再到 事务id 为 20 的事务中更新一下表 student 中 id 为 1 的记录：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>此刻，表student中 id 为 1 的记录的版本链就长这样：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141149469.png" alt="image-20220614114942257"></p>
<p>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20均未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br><span class="line"></span><br><span class="line">#这一次的查询</span><br><span class="line"># SELECT2：Transaction 10提交，Transaction 20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;王五&#x27;</span><br></pre></td></tr></table></figure>

<p>这个SELECT2的执行过程如下：</p>
<p>步骤1：在执行SELECT语句时会先生成一个Read VIew，ReadView的trx_ids列表的内容就是 [20]，up_limit_id为20，low_limit_id为21，creator_trx_id为0。</p>
<p>步骤2：从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是‘宋八’，该版本的trx_id值为20，20在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p>
<p>步骤3：下一个版本的列name的内容是‘钱七’，该版本的trx_id值也为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤4：下一个版本的列name的内容是‘王五’，该版本的trx_id值为10，小于ReadView记录中的up_limit_id值20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘王五‘的记录</p>
<blockquote>
<p>强调：使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p>
</blockquote>
<h4 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a>5.2 REPEATABLE READ隔离级别下</h4><p>使用 REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。</p>
<p>比如，系统里有两个 事务id 分别为 10 、 20 的事务在执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"></span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141203759.png" alt="image-20220614120352573"></p>
<p>假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure>

<p>SELECT1的执行过程如下：</p>
<p>步骤1：在执行SELECT语句时会先生成一个Read VIew，ReadView的trx_ids列表的内容就是 [10，20]，up_limit_id为10，low_limit_id为21，creator_trx_id为0。</p>
<p>步骤2：从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是‘王五’，该版本的trx_id值为10，10在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p>
<p>步骤3：下一个版本的列name的内容是‘李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤4：下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView记录中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三‘的记录</p>
<p>之后，我们把 事务id 为 10 的事务提交一下，就像这样：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>然后再到 事务id 为 20 的事务中更新一下表 student 中 id 为 1 的记录：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中 id 为 1 的记录的版本链长这样：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141205028.png" alt="image-20220614120549822"></p>
<p>然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20均未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br><span class="line"></span><br><span class="line">#这一次的查询</span><br><span class="line"># SELECT2：Transaction 10提交，Transaction 20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值仍为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure>

<p>因为在REPEATABLE READ 隔离级别，所以这一次查询仍然是上面开始的第一个查询生成的ReadView。</p>
<p>这个SELECT2的执行过程如下：</p>
<p>步骤1：在执行SELECT语句时会用第一个查询生成的Read VIew，ReadView的trx_ids列表的内容就是 [10，20]，up_limit_id为10，low_limit_id为21，creator_trx_id为0。</p>
<p>步骤2：从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是‘宋八’，该版本的trx_id值为20，20在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p>
<p>步骤3：下一个版本的列name的内容是‘钱七’，该版本的trx_id值也为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤4：下一个版本的列name的内容是‘王五’，该版本的trx_id值为10，10在trx_ids列表内，所以不符合可见性要求，继续跳到下一个版本</p>
<p>步骤5：下一个版本的列name的内容是‘李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p>
<p>步骤6：下一个版本的列name的内容是‘张三’，该版本的trx_id值为8，小于ReadView记录中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三‘的记录</p>
<h4 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a>5.3 如何解决幻读</h4><p>接下来说明InnoDB 是如何解决幻读的。</p>
<p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141305674.png" alt="image-20220614130541421"></p>
<p>假设现在有事务 A 和事务 B 并发执行， 事务 A 的事务 id 为 20 ， 事务 B 的事务 id 为 30 。 </p>
<p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id &gt;= 1;</span><br></pre></td></tr></table></figure>

<p> 在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： trx_ids&#x3D;[20,30] ， up_limit_id&#x3D;20 ， low_limit_id&#x3D;31 ， creator_trx_id&#x3D;20 。</p>
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p>
<p>步骤2：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id,name) values(2,&#x27;李四&#x27;);</span><br><span class="line">insert into student(id,name) values(3,&#x27;王五&#x27;);</span><br></pre></td></tr></table></figure>

<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141313717.png" alt="image-20220614131330510"></p>
<p> 步骤3：接着事务 A 开启第二次查询，根据&#x3D;&#x3D;可重复读隔离级别&#x3D;&#x3D;的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<p>1）首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</p>
<p>2）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p>
<p>3）同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。 </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141316983.png" alt="image-20220614131603776"> </p>
<p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。  </p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>这里介绍了 MVCC 在 &#x3D;&#x3D;READ COMMITTD 、 REPEATABLE READ&#x3D;&#x3D; 这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p>
<p>核心点在于 ReadView 的原理， READ COMMITTD 、 REPEATABLE READ 这两个隔离级别的一个&#x3D;&#x3D;很大不同就是生成ReadView的时机不同：&#x3D;&#x3D;</p>
<ul>
<li><p>READ COMMITTD 在每一次进行普通SELECT操作前都会生成一个ReadView</p>
</li>
<li><p>REPEATABLE READ 只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p>
</li>
</ul>
<blockquote>
<p>说明：我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。</p>
</blockquote>
<p>通过MVCC我们可以解决：</p>
<p>1.&#x3D;&#x3D;读写之间阻塞的问题。&#x3D;&#x3D;通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力</p>
<p>2.&#x3D;&#x3D;降低了死锁的概率。&#x3D;&#x3D;这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</p>
<p>3&#x3D;&#x3D;.解决快照读的问题&#x3D;&#x3D;。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</p>
<h2 id="14-其他数据库日志"><a href="#14-其他数据库日志" class="headerlink" title="14.其他数据库日志"></a>14.其他数据库日志</h2><p>我们在讲解数据库事务时，讲过两种日志：重做日志、回滚日志。</p>
<p>对于线上数据库应用系统来说，突然遭遇数据库宕机怎么办？在这种情况下，定位宕机的原因就非常关键，我们可以查看数据库的错误日志。除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。</p>
<p>千万不要小看日志。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数据库应用开发能力至关重要。  </p>
<h3 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1.MySQL支持的日志"></a>1.MySQL支持的日志</h3><h4 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a>1.1 日志类型</h4><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二进制日志 、 错误日志 、 通用查询日志和 慢查询日志 ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使用这些日志文件，可以查看MySQL内部发生的事情。  </p>
<p>这6类日志分别为：</p>
<ul>
<li><p>慢查询日志：记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p>
</li>
<li><p>通用查询日志：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p>
</li>
<li><p>错误日志：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</p>
</li>
<li><p><strong>二进制日志【bin log】</strong>：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p>
</li>
<li><p>中继日志【Relay log】：用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p>
</li>
<li><p>数据定义语句日志：记录数据定义语句执行的元数据操作。</p>
</li>
</ul>
<p>除二进制日志外，其他日志都是 &#x3D;&#x3D;文本文件&#x3D;&#x3D; 。默认情况下，所有日志创建于 MySQL数据目录 中。  </p>
<h4 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a>1.2 日志的弊端</h4><ul>
<li>日志功能会 降低MySQL数据库的性能 。<ul>
<li>例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志</li>
</ul>
</li>
<li>日志会 占用大量的磁盘空间 。<ul>
<li>日志会占用大量的磁盘空间。对于用户量非常大，操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还大。</li>
</ul>
</li>
</ul>
<h3 id="2-慢查询日志（slow-query-log）"><a href="#2-慢查询日志（slow-query-log）" class="headerlink" title="2.慢查询日志（slow query log）"></a>2.慢查询日志（slow query log）</h3><p>在第九章性能分析工具中讲过</p>
<h3 id="3-通用查询日志（general-query-log）"><a href="#3-通用查询日志（general-query-log）" class="headerlink" title="3.通用查询日志（general query log）"></a>3.通用查询日志（general query log）</h3><p>通用查询日志用来 记录用户的所有操作 ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，可以帮助我们准确定位问题。  </p>
<h4 id="3-2-查看当前状态"><a href="#3-2-查看当前状态" class="headerlink" title="3.2 查看当前状态"></a>3.2 查看当前状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%general%&#x27;;</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| general_log | OFF | #通用查询日志处于关闭状态</span><br><span class="line">| general_log_file | /var/lib/mysql/dmtsai.log | #通用查询日志文件的名称是dmtsai.log</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">2 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-启动日志"><a href="#3-3-启动日志" class="headerlink" title="3.3 启动日志"></a>3.3 启动日志</h4><p><strong>方式1：永久性方式</strong><br>修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log=ON</span><br><span class="line">general_log_file=[path[filename]] #日志文件所在目录路径，filename为日志文件名</span><br></pre></td></tr></table></figure>

<p>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名。  </p>
<p><strong>方式2：临时性方式</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=on; # 开启通用查询日志</span><br><span class="line"></span><br><span class="line">SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置</span><br></pre></td></tr></table></figure>

<p>对应的，关闭操作SQL命令如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL general_log=off; # 关闭通用查询日志</span><br></pre></td></tr></table></figure>

<p>查看设置后情况：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-查看日志"><a href="#3-4-查看日志" class="headerlink" title="3.4 查看日志"></a>3.4 查看日志</h4><p>通用查询日志是以 文本文件 的形式存储在文件系统中的，可以使用 文本编辑器 直接打开日志文件。每台MySQL服务器的通用查询日志内容是不同的。</p>
<ul>
<li>在Windows操作系统中，使用文本文件查看器；</li>
<li>在Linux系统中，可以使用vi工具或者gedit工具查看；</li>
<li>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。</li>
</ul>
<p>从 SHOW VARIABLES LIKE ‘general_log%’; 结果中可以看到通用查询日志的位置。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/mysqld, Version: 8.0.26 (MySQL Community Server - GPL). started with:</span><br><span class="line">Tcp port: 3306 Unix socket: /var/lib/mysql/mysql.sock</span><br><span class="line">Time Id Command Argument</span><br><span class="line">2022-01-04T07:44:58.052890Z 10 Query SHOW VARIABLES LIKE &#x27;%general%&#x27;</span><br><span class="line">2022-01-04T07:45:15.666672Z 10 Query SHOW VARIABLES LIKE &#x27;general_log%&#x27;</span><br><span class="line">2022-01-04T07:45:28.970765Z 10 Query select * from student</span><br><span class="line">2022-01-04T07:47:38.706804Z 11 Connect root@localhost on using Socket</span><br><span class="line">2022-01-04T07:47:38.707435Z 11 Query select @@version_comment limit 1</span><br><span class="line">2022-01-04T07:48:21.384886Z 12 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:21.385253Z 12 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:21.385640Z 12 Query USE `atguigu12`</span><br><span class="line">2022-01-04T07:48:21.386179Z 12 Query SHOW FULL TABLES WHERE Table_Type !=</span><br><span class="line">&#x27;VIEW&#x27;</span><br><span class="line">2022-01-04T07:48:23.901778Z 13 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:23.902128Z 13 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:23.905179Z 13 Query USE `atguigu`</span><br><span class="line">2022-01-04T07:48:23.905825Z 13 Query SHOW FULL TABLES WHERE Table_Type !=</span><br><span class="line">&#x27;VIEW&#x27;</span><br><span class="line">2022-01-04T07:48:32.163833Z 14 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:32.164451Z 14 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:32.164840Z 14 Query USE `atguigu`</span><br><span class="line">2022-01-04T07:48:40.006687Z 14 Query select * from account</span><br></pre></td></tr></table></figure>

<p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。  </p>
<h4 id="3-5-停止日志"><a href="#3-5-停止日志" class="headerlink" title="3.5 停止日志"></a>3.5 停止日志</h4><p><strong>方式1：永久性方式</strong><br>修改 my.cnf 或者 my.ini 文件，把[mysqld]组下的 general_log 值设置为 OFF 或者把general_log一项注释掉。修改保存后，再 重启MySQL服务 ，即可生效。 举例1：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log=OFF</span><br></pre></td></tr></table></figure>

<p>举例2：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">#general_log=ON</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong>  </p>
<h4 id="3-6-删除-刷新日志"><a href="#3-6-删除-刷新日志" class="headerlink" title="3.6 删除\刷新日志"></a>3.6 删除\刷新日志</h4><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。  </p>
<p>使用如下命令重新生成查询日志文件，具体命令如下。刷新MySQL数据目录，发现创建了新的日志文件。前提一定要开启通用日志。  【在刷新后，需要开启通用查询日志】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>

<h3 id="4-错误日志-error-log"><a href="#4-错误日志-error-log" class="headerlink" title="4.错误日志(error log)"></a>4.错误日志(error log)</h3><p>通过错误日志可以查看系统的运行状态，便于即时发现故障、修复故障。如果MySQL服务出现异常，错误日志是发现问题、解决问题的首选。</p>
<h4 id="4-1-启动日志"><a href="#4-1-启动日志" class="headerlink" title="4.1 启动日志"></a>4.1 启动日志</h4><p>在MySQL数据库中，错误日志功能是 &#x3D;&#x3D;默认开启&#x3D;&#x3D; 的。而且，错误&#x3D;&#x3D;日志 无法被禁止&#x3D;&#x3D; 。默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 mysqld.log （Linux系统）或hostname.err （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-error=[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名</span><br></pre></td></tr></table></figure>

<p>修改配置项后，需要重启MySQL服务以生效。  </p>
<h4 id="4-2-查看日志"><a href="#4-2-查看日志" class="headerlink" title="4.2 查看日志"></a>4.2 查看日志</h4><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。</p>
<p>查询错误日志的存储路径：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;log_err%&#x27;;</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| log_error | /var/log/mysqld.log |</span><br><span class="line">| log_error_services | log_filter_internal; log_sink_internal |</span><br><span class="line">| log_error_suppression_list | |</span><br><span class="line">| log_error_verbosity | 2 |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下。  </p>
<h4 id="4-3-删除-刷新日志"><a href="#4-3-删除-刷新日志" class="headerlink" title="4.3 删除\刷新日志"></a>4.3 删除\刷新日志</h4><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除，以保证MySQL服务器上的 硬盘空间 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以直接删除 。 </p>
<p>删除原有错误日志文件后 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@atguigu01 log]# mysqladmin -uroot -p flush-logs</span><br><span class="line">Enter password:</span><br><span class="line">mysqladmin: refresh failed; error: &#x27;Could not open file &#x27;/var/log/mysqld.log&#x27; for</span><br><span class="line">error logging.&#x27;</span><br></pre></td></tr></table></figure>

<p>补充操作【先做下面的操作，再做上面的刷新操作】：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p>flush-logs指令操作：</p>
<ul>
<li>MySQL5.5.7以前的版本，flush-logs将错误日志文件重命名为filename.err_old，并创建新的日志文件</li>
<li>从MySQL5.5.7开始，flush-logs只是重新打开日志文件，并不做日志备份和创建的操作</li>
<li>如果日志文件不存在，MySQL启动或者执行flush-logs时会自动创建新的日志文件。重新创建错误日志，大小为0字节。</li>
</ul>
<h3 id="5-二进制日志-bin-log"><a href="#5-二进制日志-bin-log" class="headerlink" title="5.二进制日志(bin log)"></a>5.二进制日志(bin log)</h3><p>binlog可以说是MySQL中比较 &#x3D;&#x3D;重要&#x3D;&#x3D; 的日志了，在日常开发及运维过程中，经常会遇到。</p>
<p>binlog即binary log，二进制日志文件，也叫作&#x3D;&#x3D;变更日志&#x3D;&#x3D;（update log）。它记录了数据库所有执行的&#x3D;&#x3D;DDL 和 DML&#x3D;&#x3D; 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</p>
<p>它以事件形式记录并保存在二进制文件中。通过这些信息，我们可以在线数据更新操作的全过程。</p>
<blockquote>
<p>如果想要记录所有语句（例如，为了识别有问题的查询），需要使用通用查询日志</p>
</blockquote>
<p>binlog主要应用场景：</p>
<ul>
<li>一是用于 &#x3D;&#x3D;数据恢复&#x3D;&#x3D;，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器</li>
<li>二是用于 &#x3D;&#x3D;数据复制&#x3D;&#x3D;  ，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</li>
</ul>
<p>可以说MySQL数据库的数据备份、主备、主主、主从都离不开bin log，需要依靠bin log来同步数据，保证数据一致性。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141643969.png" alt="image-20220614164349706"></p>
<h4 id="5-1-查看默认情况"><a href="#5-1-查看默认情况" class="headerlink" title="5.1 查看默认情况"></a>5.1 查看默认情况</h4><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| log_bin | ON |</span><br><span class="line">| log_bin_basename | /var/lib/mysql/binlog |</span><br><span class="line">| log_bin_index | /var/lib/mysql/binlog.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF |</span><br><span class="line">| log_bin_use_v1_row_events | OFF |</span><br><span class="line">| sql_log_bin | ON |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>如果是在MySQL5.7上面，打开log_bin的方法，就是修改 &#x2F;etc&#x2F;my.cnf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure>

<p>然后重启mysqld服务。</p>
<h4 id="5-2-日志参数设置"><a href="#5-2-日志参数设置" class="headerlink" title="5.2 日志参数设置"></a>5.2 日志参数设置</h4><p><strong>方式1：永久性方式</strong></p>
<p>修改MySQL的my.cnf或my.ini文件可以设置二进制日志的相关参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#启用二进制日志</span><br><span class="line">log-bin=atguigu-bin</span><br><span class="line">binlog_expire_logs_seconds=600</span><br><span class="line">max_binlog_size=100M</span><br></pre></td></tr></table></figure>

<p>重新启动MySQL服务，查询二进制日志的信息，执行结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| log_bin | ON |</span><br><span class="line">| log_bin_basename | /var/lib/mysql/atguigu-bin |</span><br><span class="line">| log_bin_index | /var/lib/mysql/atguigu-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF |</span><br><span class="line">| log_bin_use_v1_row_events | OFF |</span><br><span class="line">| sql_log_bin | ON |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>设置带文件夹的bin-log日志存放目录</strong>  </p>
<p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span><br></pre></td></tr></table></figure>

<p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R -v mysql:mysql binlog</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<p>数据库文件最好不要与日志文件放在同一个磁盘上，这样，当数据库文件所在的磁盘发生故障时，可以使用日志文件恢复数据</p>
</blockquote>
<p><strong>方式2：临时性方式</strong>  </p>
<p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是在mysql8中只有 会话级别 的设置，没有了global级别的设置。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># global 级别</span><br><span class="line">mysql&gt; set global sql_log_bin=0;</span><br><span class="line">ERROR 1228 (HY000): Variable &#x27;sql_log_bin&#x27; is a SESSION variable and can`t be used</span><br><span class="line">with SET GLOBAL</span><br><span class="line"># session级别</span><br><span class="line">mysql&gt; SET sql_log_bin=0;  #关闭sql_log_bin</span><br><span class="line">Query OK, 0 rows affected (0.01 秒)</span><br></pre></td></tr></table></figure>

<h4 id="5-3-查看日志"><a href="#5-3-查看日志" class="headerlink" title="5.3 查看日志"></a>5.3 查看日志</h4><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。   </p>
<p>MySQL服务 重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了 max_binlog_size 的上限（默认是1GB），就会创建一个新的日志文件。  </p>
<p>查看当前的二进制日志文件列表及大小。指令如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW BINARY LOGS;</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">| Log_name | File_size | Encrypted |</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">| atguigu-bin.000001 | 156 | No |</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">1 行于数据集 (0.02 秒)</span><br></pre></td></tr></table></figure>

<p>所有对数据库的修改都会记录在binlog中，但binlog是二进制文件，无法直接查看，想要直接查看，可以借助mysqlbinlog命令工具了。指令如下：下面命令将行事件以 伪SQL的形式 表现出来  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai ~]<span class="comment"># mysqlbinlog -v &quot;/var/lib/mysql/mysql-bin.000001&quot;;</span></span><br></pre></td></tr></table></figure>

<p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events [IN &#x27;log_name&#x27;] [FROM pos] [LIMIT [offset,] row_count];</span><br></pre></td></tr></table></figure>

<ul>
<li>IN ‘log_name’ ：指定要查询的binlog文件名（不指定就是第一个binlog文件）　</li>
<li>FROM pos ：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li>
<li>LIMIT [offset] ：偏移量(不指定就是0)</li>
<li>row_count :查询总条数（不指定就是所有行）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events in &#x27;mysql-bin.000001&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141817245.png" alt="image-20220614181703951"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events in &#x27;mysql-bin.000001&#x27; from 442;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141817947.png" alt="image-20220614181729711"></p>
<p>上面我们讲了这么多都是基于binlog的默认格式，binlog格式查看  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;binlog_format&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 行于数据集 (0.02 秒)</span><br></pre></td></tr></table></figure>

<p>除此之外，binlog还有两种格式，分别是Statement和Mixed</p>
<ul>
<li>Statement</li>
</ul>
<p>每一条会修改数据的sql都会记录在binlog中。</p>
<p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p>
<ul>
<li>Row</li>
</ul>
<p>5.1.5版本的MySQL才开始支持row level 的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>
<p>优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</p>
<ul>
<li>Mixed</li>
</ul>
<p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p>
<p>详细情况，下章讲解。  </p>
<h4 id="5-4-使用日志恢复数据"><a href="#5-4-使用日志恢复数据" class="headerlink" title="5.4 使用日志恢复数据"></a>5.4 使用日志恢复数据</h4><p>如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间的日志中恢复数据。</p>
<p>mysqlbinlog恢复数据的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename|mysql –uuser -ppass;</span><br></pre></td></tr></table></figure>

<p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复数据库中。  </p>
<ul>
<li>filename ：是日志文件名。</li>
<li>option ：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、<ul>
<li>–stop-position。</li>
<li>–start-date 和 –stop-date ：可以指定恢复数据库的起始时间点和结束时间点。</li>
<li>–start-position和–stop-position ：可以指定恢复数据的开始位置和结束位置。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141839419.png" alt="image-20220614183956153"></p>
<ul>
<li>通过binlog进行恢复数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141847056.png" alt="image-20220614184711787"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/mysqlbinlog --start-position=1696 --stop-position=1917 --database=atguigudb3 /var/lib/mysql/mysql-bin.000001 | /usr/bin/mysql -uroot -proot -v atguigudb3</span><br></pre></td></tr></table></figure>

<h4 id="5-5-删除二进制日志"><a href="#5-5-删除二进制日志" class="headerlink" title="5.5 删除二进制日志"></a>5.5 删除二进制日志</h4><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。&#x3D;&#x3D;PURGE MASTER LOGS&#x3D;&#x3D; 只删除指定部分的二进制日志文件， &#x3D;&#x3D;RESET MASTER&#x3D;&#x3D; 删除所有的二进制日志文件。具体如下：  </p>
<ol>
<li>PURGE MASTER LOGS：删除指定日志文件</li>
</ol>
<p>PURGE MASTER LOGS语法如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘指定日志文件名’</span><br><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE ‘指定日期’</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush logs;  # 重新生成一个二进制文件，后面的更新就将写到这个新生成的二进制文件中</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |      2844 |</span><br><span class="line">| mysql-bin.000002 |       487 |</span><br><span class="line">| mysql-bin.000003 |       201 |</span><br><span class="line">| mysql-bin.000004 |       201 |</span><br><span class="line">| mysql-bin.000005 |       201 |</span><br><span class="line">| mysql-bin.000006 |       201 |</span><br><span class="line">| mysql-bin.000007 |       154 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 删除 000003之前的二进制日志文件</span><br><span class="line">mysql&gt; purge master logs to &#x27;mysql-bin.000003&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000003 |       201 |</span><br><span class="line">| mysql-bin.000004 |       201 |</span><br><span class="line">| mysql-bin.000005 |       201 |</span><br><span class="line">| mysql-bin.000006 |       201 |</span><br><span class="line">| mysql-bin.000007 |       154 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这是删除该日期之前的所有二进制文件</span><br><span class="line">purge master logs before &#x27;20220614&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这是删除所有的二进制文件</span><br><span class="line">reset master</span><br><span class="line"></span><br><span class="line"># 执行完该语句后，原来的所有二进制文件都会被删除  谨慎使用</span><br></pre></td></tr></table></figure>

<h4 id="5-6-其它场景"><a href="#5-6-其它场景" class="headerlink" title="5.6 其它场景"></a>5.6 其它场景</h4><p>二进制日志可以通过数据库的 &#x3D;&#x3D;全量备份&#x3D;&#x3D; 和二进制日志中保存的 &#x3D;&#x3D;增量信息&#x3D;&#x3D; ，完成数据库的 &#x3D;&#x3D;无损失恢复&#x3D;&#x3D; 。但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p>
<p>在这种情况下，一个有效的解决办法是 &#x3D;&#x3D;配置主从数据库服务器&#x3D;&#x3D; ，甚至是 &#x3D;&#x3D;一主多从&#x3D;&#x3D; 的架构，把二进制日志文件的内容通过&#x3D;&#x3D;中继日志&#x3D;&#x3D;，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。  </p>
<h3 id="6-再谈二进制日志（binlog）"><a href="#6-再谈二进制日志（binlog）" class="headerlink" title="6.再谈二进制日志（binlog）"></a>6.再谈二进制日志（binlog）</h3><h4 id="6-1-写入机制"><a href="#6-1-写入机制" class="headerlink" title="6.1 写入机制"></a>6.1 写入机制</h4><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到 &#x3D;&#x3D;binlog cache&#x3D;&#x3D; ，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。 </p>
<p>我们可以通过binlog_cache_size参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）.binlog日志刷盘流程如下：</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141908276.png" alt="image-20220614190821974"> </p>
<blockquote>
<ul>
<li>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度快</li>
<li>上图的fsync，才是将数据持久化到磁盘的操作</li>
</ul>
</blockquote>
<p>write和fsync的时机，可以由参数 &#x3D;&#x3D;sync_binlog&#x3D;&#x3D; 控制，默认是 0 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141912788.png" alt="image-20220614191207437"></p>
<p>为了安全起见，可以设置为 1 ，表示每次提交事务都会执行fsync，就如同&#x3D;&#x3D;redo log 刷盘&#x3D;&#x3D;流程一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141913528.png" alt="image-20220614191347240"></p>
<p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。  </p>
<h4 id="6-2-binlog与redolog对比"><a href="#6-2-binlog与redolog对比" class="headerlink" title="6.2 binlog与redolog对比"></a>6.2 binlog与redolog对比</h4><ul>
<li><p>redo log 它是 &#x3D;&#x3D;物理日志&#x3D;&#x3D; ，记录内容是“在某个数据页上做了什么修改”，属于 &#x3D;&#x3D;InnoDB 存储引擎层&#x3D;&#x3D;产生的。</p>
</li>
<li><p>而 binlog 是 &#x3D;&#x3D;逻辑日志&#x3D;&#x3D; ，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，&#x3D;&#x3D;属于MySQL Server 层。&#x3D;&#x3D;  【注意：undo log也是逻辑日志】</p>
</li>
<li><p>虽然它们都属于持久化的保证，但是侧重点不同：</p>
<ul>
<li>redo log让InnoDB存储引擎拥有了崩溃恢复能力</li>
<li>bin log保证了MySQL集群架构的数据一致性</li>
</ul>
</li>
</ul>
<h4 id="6-3-两阶段提交"><a href="#6-3-两阶段提交" class="headerlink" title="6.3 两阶段提交"></a>6.3 两阶段提交</h4><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在&#x3D;&#x3D;事务执行过程中&#x3D;&#x3D;可以不断写入，而&#x3D;&#x3D;binlog只有在提交事务时&#x3D;&#x3D;才写入，所以redo log与binlog的 &#x3D;&#x3D;写入时机&#x3D;&#x3D; 不一样。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141923804.png" alt="image-20220614192304476"></p>
<p>&#x3D;&#x3D;redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？&#x3D;&#x3D;  </p>
<p>以update语句为例，假设id&#x3D;2的记录，字段c值是0，把字段c值更新成1，SQL语句为update T set c &#x3D; 1 where id &#x3D; 2;</p>
<p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141929571.png" alt="image-20220614192912269"></p>
<p>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。  因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为redo  log日志恢复，这一行c值是1，最终数据不一致。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141937104.png" alt="image-20220614193755746"></p>
<p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用&#x3D;&#x3D;两阶段提交方案&#x3D;&#x3D;。原理很简单，将redo log的写入拆分成了两个步骤prepare和commit，这就是两阶段提交。  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141942787.png" alt="image-20220614194259456"></p>
<p>使用两阶段提交后，写入binlog时发生异常也不会有影响  ，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应的binlog日志，就会回滚该事务。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141945537.png" alt="image-20220614194520183"></p>
<p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢  ？</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206141947396.png" alt="image-20220614194705755"></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。  </p>
<h3 id="7-中继日志"><a href="#7-中继日志" class="headerlink" title="7.中继日志"></a>7.中继日志</h3><h4 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h4><p>&#x3D;&#x3D;中继日志只在主从服务器架构的从服务器上存在。&#x3D;&#x3D;从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入 &#x3D;&#x3D;本地的日志文件&#x3D;&#x3D; 中，这个从服务器本地的日志文件就叫&#x3D;&#x3D;中继日志&#x3D;&#x3D; 。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的 &#x3D;&#x3D;数据同步&#x3D;&#x3D; 。</p>
<p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p>
<p>文件名的格式是： &#x3D;&#x3D;从服务器名 -relay-bin.序号&#x3D;&#x3D; 。中继日志还有一个索引文件： 从服务器名 -relaybin.index ，用来定位当前正在使用的中继日志。  </p>
<h4 id="7-2-查看中继日志"><a href="#7-2-查看中继日志" class="headerlink" title="7.2 查看中继日志"></a>7.2 查看中继日志</h4><p>中继日志与二进制日志的格式相同，可以用 mysqlbinlog 工具进行查看。下面是中继日志的一个片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SET TIMESTAMP=1618558728/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 950</span><br><span class="line">#210416 15:38:48 server id 1 end_log_pos 832 CRC32 0xcc16d651 Table_map:</span><br><span class="line">`atguigu`.`test` mapped to number 91</span><br><span class="line"># at 1000</span><br><span class="line">#210416 15:38:48 server id 1 end_log_pos 872 CRC32 0x07e4047c Delete_rows: table id</span><br><span class="line">91 flags: STMT_END_F -- server id 1 是主服务器，意思是主服务器删了一行数据</span><br><span class="line">BINLOG &#x27;</span><br><span class="line">CD95YBMBAAAAMgAAAEADAAAAAFsAAAAAAAEABGRlbW8ABHRlc3QAAQMAAQEBAFHWFsw=</span><br><span class="line">CD95YCABAAAAKAAAAGgDAAAAAFsAAAAAAAEAAgAB/wABAAAAfATkBw==</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 1040</span><br></pre></td></tr></table></figure>

<p>  这一段的意思是，主服务器（“server id 1”）对表 atguigu.test 进行了 2 步操作：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定位到表 atguigu.test 编号是 91 的记录，日志位置是 832；</span><br><span class="line">删除编号是 91 的记录，日志位置是 872。</span><br></pre></td></tr></table></figure>

<h4 id="7-3-恢复的典型错误"><a href="#7-3-恢复的典型错误" class="headerlink" title="7.3 恢复的典型错误"></a>7.3 恢复的典型错误</h4><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的 服务器名称 与之前 不同 。而中继日志里是 包含从服务器名 的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。解决的方法也很简单，把从服务器的名称改回之前的名称。  </p>
<h2 id="第15章-主从复制"><a href="#第15章-主从复制" class="headerlink" title="第15章_主从复制"></a>第15章_主从复制</h2><h3 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1.主从复制概述"></a>1.主从复制概述</h3><h4 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a>1.1 如何提升数据库并发能力</h4><p>在实际工作中，我们常常将Redis作为缓存与MySQL配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在在访问数据库，这样就提升了读取的效率，也减少了对后端数据库的访问压力。Redis的缓存架构是高并发架构中非常重要的一环。</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220614195652323.png" alt="image-20220614195652323">  </p>
<p>此外，一般应用对数据库而言都是<strong>“ 读多写少 ”，</strong>也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做 <strong>主从架构</strong> 、<strong>进行 读写分离</strong> ，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p>
<p>如果我们的目的在于提升数据库高并发访问的效率，那么<strong>首先考虑</strong>的是如何 <strong>优化SQL和索引</strong> ，这种方式简单有效；<strong>其次才是采用 缓存的策略</strong> ，比如使用 <strong>Redis将热点数据保存在内存数据库</strong>中，提升读取的效率；最后才是对数据库采用 <strong>主从架构</strong> ，进行读写分离。  </p>
<p>按照上面的方式进行优化，使用和维护的成本是由低到高的。</p>
<h4 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a>1.2 主从复制的作用</h4><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。  </p>
<p><strong>第1个作用：读写分离。</strong>  我们可以通过主从复制的方式来同步数据，然后通过读写分离提高数据库并发处理能力。</p>
<ul>
<li>面对读多写少的需求，采用读写分离的方式，可以实现更高的并发访问。同时，我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到从服务器上，让读取更加顺畅。读取顺畅的另一个原因就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行select的读取。</li>
</ul>
<p><strong>第2个作用就是数据备份。</strong>我们通过主从复制将主库上的数据复制到了从库上，相当于是一种&#x3D;&#x3D;热备份机制&#x3D;&#x3D;，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p>
<p><strong>第3个作用是具有高可用性。</strong>  数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。</p>
<p>实际上，更高的高可用性，意味着需要付出更高的成本代价。在现实中我们需要结合业务需求和成本来进行选择。</p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206142002272.png" alt="image-20220614200238894"></p>
<h3 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2.主从复制的原理"></a>2.主从复制的原理</h3><p>&#x3D;&#x3D;Slave&#x3D;&#x3D; 会从 &#x3D;&#x3D;Master&#x3D;&#x3D; 读取 &#x3D;&#x3D;binlog&#x3D;&#x3D; 来进行数据同步。  </p>
<h4 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a>2.1 原理剖析</h4><p>三个线程</p>
<p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 &#x3D;&#x3D;3 个线程&#x3D;&#x3D; 来操作，一个主库线程，两个从库线程。 </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206142014457.png" alt="image-20220614201442112"> </p>
<ul>
<li><strong>二进制日志转储线程</strong> （Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 &#x3D;&#x3D;加锁&#x3D;&#x3D; ，读取完成之后，再将锁释放掉。</li>
<li><strong>从库 I&#x2F;O 线程</strong> 会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</li>
<li><strong>从库 SQL 线程</strong> 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志</p>
<p>除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p>
</blockquote>
<p>&#x3D;&#x3D;复制三步骤：&#x3D;&#x3D;</p>
<p>步骤1： Master 将写操作记录到二进制日志（ binlog ）。</p>
<p>步骤2： Slave 将 Master 的binary log events拷贝到它的中继日志（ relay log ）；</p>
<p>步骤3： Slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从 接入点 开始复制。  </p>
<p>&#x3D;&#x3D;复制的最大的问题：延时&#x3D;&#x3D;</p>
<h4 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a>2.2 复制的基本原则</h4><ul>
<li>每个 Slave 只有一个 Master</li>
<li>每个 Slave 只能有一个唯一的服务器ID</li>
<li>每个 Master 可以有多个 Slave</li>
</ul>
<h3 id="3-一主一从架构搭建"><a href="#3-一主一从架构搭建" class="headerlink" title="3.一主一从架构搭建"></a>3.一主一从架构搭建</h3><p>一台 主机 用于处理所有 写请求 ，一台 从机 负责所有 读请求 ，架构图如下：  </p>
<p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206142023193.png" alt="image-20220614202339902"></p>
<h4 id="3-1准备工作"><a href="#3-1准备工作" class="headerlink" title="3.1准备工作"></a>3.1准备工作</h4><p><img src="https://raw.githubusercontent.com/kdhelloa/MyPicGo/main/image/202206151500784.png" alt="image-20220615150019515"></p>
<h3 id="4-同步数据库一致性问题"><a href="#4-同步数据库一致性问题" class="headerlink" title="4.同步数据库一致性问题"></a>4.同步数据库一致性问题</h3><p>主从同步的要求：</p>
<ul>
<li>读库和写库的数据一致(最终一致)；</li>
<li>写数据必须写到写库；</li>
<li>读数据必须到读库(不一定)；</li>
</ul>
<h4 id="4-1-理解主从延迟问题"><a href="#4-1-理解主从延迟问题" class="headerlink" title="4.1 理解主从延迟问题"></a>4.1 理解主从延迟问题</h4><p>进行主从同步的内容是二进制日志，它是一个文件，在进行 网络传输 的过程中就一定会 存在主从延迟（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的 数据不一致性 问题。  </p>
<h4 id="4-2-主从延迟问题原因"><a href="#4-2-主从延迟问题原因" class="headerlink" title="4.2 主从延迟问题原因"></a>4.2 主从延迟问题原因</h4><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。  </p>
<p>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。造成原因：</p>
<p>1、从库的机器性能比主库要差</p>
<p>2、从库的压力大</p>
<p>3、大事务的执行  </p>
<h4 id="4-3-如何减少主从延迟"><a href="#4-3-如何减少主从延迟" class="headerlink" title="4.3 如何减少主从延迟"></a>4.3 如何减少主从延迟</h4><p>若想要减少主从延迟的时间，可以采取下面的办法：</p>
<p>降低多线程大事务并发的概率，优化业务逻辑</p>
<p>优化SQL，避免慢SQL， 减少批量操作 ，建议写脚本以update-sleep这样的形式完成。</p>
<p>提高从库机器的配置 ，减少主库写binlog和从库读binlog的效率差。</p>
<p> 尽量采用 短的链路 ，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p>
<p>实时性要求的业务读强制走主库，从库只做灾备，备份。  </p>
<h4 id="4-4-如何解决一致性问题"><a href="#4-4-如何解决一致性问题" class="headerlink" title="4.4 如何解决一致性问题"></a>4.4 如何解决一致性问题</h4><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是 备份 ，并没有起到 读写分离 ，分担主库读压力 的作用。  </p>
<ul>
<li>方法1：异步复制</li>
<li>方法2：半同步复制</li>
<li>方法3：组复制</li>
</ul>
<h2 id="16-数据库备份与恢复"><a href="#16-数据库备份与恢复" class="headerlink" title="16.数据库备份与恢复"></a>16.数据库备份与恢复</h2><h3 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1.物理备份与逻辑备份"></a>1.物理备份与逻辑备份</h3><p>物理备份：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用 xtrabackup 工具来进行物理备份。</p>
<p>逻辑备份：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为 <strong>mysqldump</strong> 。逻辑备份就是 备份sql语句 ，在恢复的时候执行备份的sql语句实现数据库数据的重现。  </p>
<h2 id="X-MySQL索引："><a href="#X-MySQL索引：" class="headerlink" title="X: MySQL索引："></a>X: MySQL索引：</h2><blockquote>
<ul>
<li>说起提高数据库性能，索引是最物美价廉的东西了，不用加索引，不用加内存，不用改程序，不用调SQL，查询速度就可能提升百倍千倍了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- empno_index：索引名称</span><br><span class="line">-- emp (empno)：表示在 emp表的 empno列创建索引</span><br><span class="line">create index empno_index on emp (empno)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建的索引也会占用空间。</li>
<li>创建索引后只对创建了索引的列有作用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 如对ename字段就不会起作用</span><br><span class="line">select * from emp where ename = &quot;jidj&quot;   -- 没有在ename创建索引，所以速度依然不变</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>索引的原理：</p>
<ul>
<li>当没有索引的时候，select * from emp where id &#x3D; 1 ，会进行全表扫描，因此查询速度慢。</li>
<li>创建索引后，会创建一个索引的数据结构，比如二叉树，b+树</li>
<li>索引的代价：<ul>
<li>磁盘占用</li>
<li>对dml(update  delete  insert)语句有效率影响，因为需要重新维护索引结构。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>索引的类型：</p>
<ul>
<li><p>主键索引：逐渐自动的为主索引（类型为Primary key）</p>
<ul>
<li><pre><code class="mysql">create table t1 (
    id int primary key,   -- primary key 主键，同时也是索引，称为主键索引
    name varchar(32)
);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 唯一索引：unique</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    create table t1 (</span><br><span class="line">    	id int primary key unique,   -- unique，id是唯一的，同时也是索引，称unique索引。</span><br><span class="line">    	name varchar(32)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>普通索引：index</p>
</li>
<li><p>全文索引：FULLTEXT（适用于MylSAM存储引擎）。开发中考虑使用全文搜索（Solr）和ElasticSearch(ES)</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>索引的使用：</p>
<ul>
<li>添加索引</li>
<li>删除索引</li>
<li>查找索引</li>
<li>修改索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t25 (</span><br><span class="line">	id INT,</span><br><span class="line">	`name` VARCHAR(32)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 查询该表是否有索引</span><br><span class="line"></span><br><span class="line">show index from t25;</span><br><span class="line"></span><br><span class="line">-- 添加索引</span><br><span class="line">--  添加唯一索引</span><br><span class="line">CREATE unique index id_index on t25 (id);</span><br><span class="line"></span><br><span class="line">-- 添加普通索引方式1</span><br><span class="line">CREATE index ids_index on t25 (id);</span><br><span class="line"></span><br><span class="line">-- 如何选择：</span><br><span class="line">-- 1. 如果某列的值，是不会重复的，则优先考虑使用unique索引，否则使用普通索引</span><br><span class="line"></span><br><span class="line">-- 添加普通索引方式2</span><br><span class="line">ALTER TABLE t25 add index id_index (id) </span><br><span class="line"></span><br><span class="line">-- 添加主键索引</span><br><span class="line">ALTER TABLE t25 add primary KEY (id) </span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">DROP INDEX id_index on t25</span><br><span class="line"></span><br><span class="line">-- 删除主键索引</span><br><span class="line">ALTER TABLE t25 drop PRIMARY KEY</span><br><span class="line"></span><br><span class="line">-- 修改索引  ==  先删除，再添加新的索引</span><br><span class="line"></span><br><span class="line">-- 查询索引</span><br><span class="line">-- 1. </span><br><span class="line">show index from t25;</span><br><span class="line">-- 2.</span><br><span class="line">show indexes from t25;</span><br><span class="line">-- 3.</span><br><span class="line">show KEYS from t25;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>小结：哪些列上适合使用索引：</p>
<ul>
<li>较频繁的作为查询条件字段应该创建索引</li>
<li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li>
<li>更新非常频繁的字段不适合创建索引</li>
<li>不会出现在where子句中的字段不该创建索引</li>
</ul>
</blockquote>
<h2 id="XI-MySQL存储引擎"><a href="#XI-MySQL存储引擎" class="headerlink" title="XI:MySQL存储引擎"></a>XI:MySQL存储引擎</h2><blockquote>
<ul>
<li>MySQL的表类型由存储引擎（Storage Engine）决定，主要包括MylSAM、innoDB,Memory等。</li>
<li>MySQL数据表主要支持六种类型，分别是：CSV、Memory、ARCHIVE、MRG_MYISAM、MYISAM、InnoBDB.</li>
<li>这六种又分为两类：一类是“事务安全性”，比如InnoDB，其余都属于第二类，称为非事务安全性（myisam和memory）</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查看所有的存储引擎</span><br><span class="line">show ENGINES;</span><br></pre></td></tr></table></figure>

<img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20220513150552613.png" alt="image-20220513150552613"  />

<table>
<thead>
<tr>
<th>特点</th>
<th>myisam</th>
<th>Innodb</th>
<th>memory</th>
<th>archive</th>
</tr>
</thead>
<tbody><tr>
<td>批量插入的速度</td>
<td>高</td>
<td>低</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>事务安全</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>表锁</td>
<td>行锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>存储限制</td>
<td>没有</td>
<td>64TB</td>
<td>有</td>
<td>没有</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>集群索引</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据缓存</td>
<td></td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>数据可压缩</td>
<td>支持</td>
<td></td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>空间使用</td>
<td>低</td>
<td>高</td>
<td>N&#x2F;A</td>
<td>非常低</td>
</tr>
<tr>
<td>内存使用</td>
<td>低</td>
<td>高</td>
<td>中等</td>
<td>低</td>
</tr>
<tr>
<td>支持外键</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>小结：</p>
<ul>
<li>myisam不支持事务，也不支持外键，但其访问速度快，对事务完整性没有要求</li>
<li>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是比起MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</li>
<li>MEMORY存储引擎使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用hash索引。但是一旦服务关闭，表中的数据就会丢失掉，表的结构还在。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以管理员身份运行</span></span><br><span class="line"><span class="comment"># 关闭mysql服务</span></span><br><span class="line">C:\Windows\system32&gt;net stop mysql   </span><br><span class="line">MySQL 服务正在停止..</span><br><span class="line">MySQL 服务已成功停止。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启mysql服务</span></span><br><span class="line">C:\Windows\system32&gt;net start mysql</span><br><span class="line">MySQL 服务正在启动 .</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 查看所有的存储引擎</span><br><span class="line">show ENGINES;</span><br><span class="line"></span><br><span class="line">-- INNODB 存储引擎</span><br><span class="line">-- 1. 支持事务 2. 支持外键 3. 支持行级锁</span><br><span class="line"></span><br><span class="line">-- myisam 存储引擎</span><br><span class="line">-- 1. 添加速度快  2.不支持外键和事务  3. 支持表级锁</span><br><span class="line">CREATE TABLE t26 (</span><br><span class="line">	id int,</span><br><span class="line">	`name` VARCHAR(32)</span><br><span class="line">) ENGINE myisam;</span><br><span class="line"></span><br><span class="line">start TRANSACTION;	-- 开启事务</span><br><span class="line">SAVEPOINT t1;			-- 建立安全点</span><br><span class="line">INSERT INTO t26 VALUES(1,&quot;jack&quot;);</span><br><span class="line">select * from t26;		</span><br><span class="line">ROLLBACK to t1;   -- 回滚失效，因为myisam不支持事务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- memory 存储引擎</span><br><span class="line">-- 1. 数据存储在内存中 (一旦mysql服务关闭或重启，表结构还在，但是数据就消失了)</span><br><span class="line">-- 2. 执行速度很快（因为没有IO读写）  3. 默认支持索引（hash表）</span><br><span class="line">CREATE TABLE t27 (</span><br><span class="line">	id int,</span><br><span class="line">	`name` VARCHAR(32)</span><br><span class="line">) ENGINE memory;</span><br><span class="line"></span><br><span class="line">insert into t27 VALUES(1,&quot;tom&quot;),(2,&quot;jack&quot;),(3,&quot;hap&quot;);</span><br><span class="line">select * from t27;</span><br><span class="line"></span><br><span class="line">-- 修改存储引擎</span><br><span class="line">ALTER TABLE `t27`	ENGINE = INNODB;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何选择表的存储引擎：</p>
<ul>
<li>如果你的应用不需要事务，处理的只是基本的CRUD操作，那么MyISAM是不二选择，速度快</li>
<li>如果需要支持事务，选择InnoDB</li>
<li>Memory存储引擎就是将数据存储在内存中，由于没有磁盘I&#x2F;O的等待，速度极快，但由于是内存存储引擎，所作的任何修改在服务器重启后都将消失（经典用法：用户的在线状态）</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/27/MySQL%E5%AD%A6%E4%B9%A0/" data-id="clrv2tqxp000n4hku5edqhzmn" data-title="MySQL学习" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java秒杀系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/15/Java%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2022-06-15T01:23:38.000Z" itemprop="datePublished">2022-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java秒杀系统:</p>
<ul>
<li><p>项目框架搭建：</p>
<ul>
<li>SpringBoot环境搭建</li>
<li>集成Thymeleaf，RespBean</li>
<li>mybatis</li>
</ul>
</li>
<li><p>分布式会话：</p>
<ul>
<li><p>用户登录</p>
<ul>
<li><p>设计数据库</p>
<ul>
<li>主要有以下这些表。用户表、商品表、订单表、秒杀商品表、秒杀订单表</li>
</ul>
</li>
<li><p>明文密码二次MD5加密</p>
<ul>
<li><p>为什么要进行二次MD5加密？</p>
</li>
<li><pre><code class="shell"># 第一次 （在前端加密，客户端）：密码加密是（明文密码+固定盐值）生成md5用于传输，目的，由于http是明文传输，当输入密码若直接发送服务端验证，此时被截取将直接获取到明文密码，获取用户信息。

# 第二次（服务端）：当获取到前端发送来的密码后。通过MD5（密码+随机盐值）再次生成密码后存入数据库。
防止数据库被盗的情况下，通过md5反查，查获用户密码。方法是盐值会在用户登陆的时候随机生成，并存在数据库中，这个时候就会获取到。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 参数校验+全局异常处理</span><br><span class="line"></span><br><span class="line">      - 利用枚举+公共返回对象来实现全局异常处理</span><br><span class="line"></span><br><span class="line">  - 共享Session</span><br><span class="line"></span><br><span class="line">    - Cookie存储在客户端，Session存储在服务端 【通过response的set-cookie来进行设置cookie并返回给客户端，客户端在发送请求时，就会携带存储在cookie中的session信息，服务端就可以根据客户端传来的session信息与自己存储的session信息进行比对】</span><br><span class="line">    - 解决分布式共享问题。</span><br><span class="line">      - 分布式共享问题：session是通过Servlet创建的，tomcat服务器都是将其存储在内存中，所以在分布式环境下，进行负载均衡时，就会出现同一用户的请求就会被分发到两个web站点上。</span><br><span class="line">    - SpringSession</span><br><span class="line">    - Redis</span><br><span class="line">      - 使用Redis来进行存储，将用户cookie信息与用户进行映射。</span><br><span class="line"></span><br><span class="line">- 功能开发</span><br><span class="line"></span><br><span class="line">  - 商品列表</span><br><span class="line">  - 商品详情</span><br><span class="line">  - 秒杀</span><br><span class="line">  - 订单详情</span><br><span class="line"></span><br><span class="line">- 系统压测</span><br><span class="line"></span><br><span class="line">  - JMeter</span><br><span class="line"></span><br><span class="line">  - 自定义变量模拟多用户</span><br><span class="line"></span><br><span class="line">  - 正式压测</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。 </span><br><span class="line">      TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。 它是软件测试结果的测量单位。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>商品列表</p>
</li>
<li><pre><code>* windows优化前QPS: 256  
* linux优化前QPS: 164
*
* windows优化页面缓存和对象缓存后QPS: 871
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 秒杀</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">   * 秒杀</span><br><span class="line">   * windows优化前QPS： 270</span><br><span class="line">   * linux优化前：122</span><br><span class="line">   *</span><br><span class="line">   * windows优化缓存和页面静态化后QPS: 348</span><br><span class="line">   *</span><br><span class="line">   * rabbitmq优化缓存后qps: 539</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>页面优化 （见文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Wangdiankun/article/details/106663103">https://blog.csdn.net/Wangdiankun/article/details/106663103</a> ）</p>
<ul>
<li>页面缓存+URL缓存+对象缓存<ul>
<li>页面缓存：对于通用页面，一般使用页面缓存，直接将需要返回给用户的页面存储到redis中，然后当有人再次访问时直接出redis中取出直接返回给用户，不在进行其他操作，节省系统资源。（设置过期时间）</li>
<li>url缓存：url缓存是一种特殊的页面缓存，原因在于他有特殊的参数信息，对应不同的页面，比如一个商品的详情页，就需要url缓存，因为不同的商品有不同的信息，使用页面缓存并不能实现这一功能。 （设置过期时间）</li>
<li>对象缓存在所有缓存中是一个比较小的缓存单位，最常用的是对用户常用信息的缓存，加快系统对常用用户信息的读取速度从而加快系统的反应速度。</li>
</ul>
</li>
<li>页面静态化，前后端分离<ul>
<li>页面静态化也是前后端分离的一大优势所在，就是利用浏览器缓存数据从而减少与服务器的交互。</li>
</ul>
</li>
<li>静态资源优化<ul>
<li>（1）JS&#x2F;CSS压缩，减少流量<br>（2）多个JS&#x2F;CSS组合，减少连接数<br>（3）CDN就近访问</li>
</ul>
</li>
</ul>
</li>
<li><p>接口优化</p>
<ul>
<li><p>Redis预减库存减少数据库的访问</p>
<ul>
<li><pre><code>// 例如在进行下单的时候。还有在判断是否重复抢购的时候
这里是将向mysql数据库中查询的过程转化为向redis内存数据库中进行查询
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 内存标记减少Redis的访问</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    //通过内存标记减少redis的访问，可以通过设置一个全局变量map来存储每个商品剩余的数量，从而可以减少对redis数据库的查询</span><br><span class="line">    if (emptyStockMap.get(goodsId)) &#123;</span><br><span class="line">    	return RespBean.error(RespBeanEnum.EMPTY_STOCK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>Rabbitmq异步下单</p>
<ul>
<li><pre><code>下单   通过RabbitMQ可以快速返回，从而达到一个流量削峰的功能，将向MYSQL查询的过程放在queue中进行完成

//在前端页面js中，使用rabbitmq后，需要进行判断是否已经下单成功，还是在排队中
</code></pre>
</li>
<li><p>Springboot整合rabbitmq</p>
</li>
<li><p>交换机</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>安全优化</p>
<ul>
<li>秒杀接口地址隐藏</li>
<li>算术验证码</li>
<li>接口防刷</li>
</ul>
</li>
<li><p>主流的秒杀方案</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/06/15/Java%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" data-id="clrv2tqx500004hku7swfcem6" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-git学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/27/git%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-05-26T16:00:00.000Z" itemprop="datePublished">2022-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/27/git%E5%AD%A6%E4%B9%A0/">git学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="01-git版本控制"><a href="#01-git版本控制" class="headerlink" title="01.git版本控制"></a>01.git版本控制</h1><h2 id="1-1-版本控制"><a href="#1-1-版本控制" class="headerlink" title="1.1 版本控制"></a>1.1 版本控制</h2><ul>
<li>本地版本控制：RCS。本地代码的版本控制。</li>
<li>集中式版本控制：svn。提供一个远端服务器来维护代码版本，本地不保存代码版本，解决多人协作的问题</li>
<li>分布式版本控制：Git。每个仓库都能记录版本历史，解决只有一个服务器保存版本的问题。</li>
</ul>
<h3 id="1-1-1-本地版本控制"><a href="#1-1-1-本地版本控制" class="headerlink" title="1.1.1 本地版本控制"></a>1.1.1 本地版本控制</h3><ul>
<li>最初的方式<ul>
<li>通过本地复制文件夹，来完成版本控制，一般可以通过不同的文件名来区分版本</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-集中版本控制"><a href="#1-1-2-集中版本控制" class="headerlink" title="1.1.2 集中版本控制"></a>1.1.2 集中版本控制</h3><ul>
<li>基本原理：<ul>
<li>提供一个远端服务来保存文件，所有用户的提交都提交到该服务器中</li>
<li>增量保存每次提交的Diff,如果提交的增量中和远端现存的文件存在冲突，则需要本地提前解决冲突</li>
</ul>
</li>
<li>优点：<ul>
<li>学习简单，更容易操作</li>
<li>支持二进制文件，对大文件支持更友好</li>
</ul>
</li>
<li>缺点<ul>
<li>本地不存储版本管理的概念，所有提交都只能联上服务器后才可以提交</li>
<li>分支上的支持不够好，对于大型项目团队合作比较困难</li>
<li>用户本地不保存所有版本的代码，如果服务端故障容易导致历史版本的丢失</li>
</ul>
</li>
</ul>
<h3 id="1-1-3-分布式版本控制"><a href="#1-1-3-分布式版本控制" class="headerlink" title="1.1.3 分布式版本控制"></a>1.1.3 分布式版本控制</h3><ul>
<li>基本原理<ul>
<li>每个库都存有完整的提交历史，可以直接在本地进行代码提交</li>
<li>每次提交记录的都是完整的文件快照，而不是记录增量</li>
<li>通过Push等操作来完成和远端代码的同步</li>
</ul>
</li>
<li>优点<ul>
<li>分布式开发，每个库都是完整的提交历史，支持本地提交，强调个体</li>
<li>分支管理功能强大，方便团队合作，多人协同开发</li>
<li>校验和机制保证完整性，一般只添加数据，很少执行删除操作，不容易导致代码丢失。</li>
</ul>
</li>
<li>缺点<ul>
<li>相对SVN更复杂，学习成本高</li>
<li>对于大文件的支持不是特别好（git-lfs工具可以弥补这个功能）</li>
</ul>
</li>
</ul>
<h2 id="1-2-Git发展历史"><a href="#1-2-Git发展历史" class="headerlink" title="1.2 Git发展历史"></a>1.2 Git发展历史</h2><ul>
<li>github</li>
<li>gitlab</li>
<li>gitee</li>
</ul>
<h1 id="02-git的基本使用方式"><a href="#02-git的基本使用方式" class="headerlink" title="02 git的基本使用方式"></a>02 git的基本使用方式</h1><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li>为什么我明明配置了Git配置，但是依然没有办法拉取代码？<ul>
<li>没有配置密钥，没有权限</li>
<li>免密认证没有配</li>
<li>instead of配置没有配，配的SSH免密配置，但是使用的还是HTTP协议访问</li>
</ul>
</li>
<li>为什么我Fetch了远端分支，但是我看本地当前的分支历史还是没有变化？<ul>
<li>只会更新origin的分支</li>
<li>fetch会把代码拉取到本地的远端分支，但是并不会合并到当前分支，所以当前分支历史没有变化</li>
</ul>
</li>
</ul>
<h2 id="2-1-Git目录介绍"><a href="#2-1-Git目录介绍" class="headerlink" title="2.1 Git目录介绍"></a>2.1 Git目录介绍</h2><ul>
<li>项目初始化<ul>
<li>mkdir demo</li>
<li>cd demo</li>
<li>git init</li>
</ul>
</li>
<li>其他参数  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--initial-branch 初始化的分支</span><br><span class="line">--bare 创建一个裸仓库</span><br><span class="line">--template 可以通过模板来创建预先构建好的自定义git目录</span><br></pre></td></tr></table></figure></li>
<li>git仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># tree .git</span></span><br><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 3b</span><br><span class="line">│   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">10 directories, 15 files</span><br></pre></td></tr></table></figure>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20009a18333b4f1ebb56805f0fd10595~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></li>
</ul>
<h3 id="2-1-2-常见git配置"><a href="#2-1-2-常见git配置" class="headerlink" title="2.1.2 常见git配置"></a>2.1.2 常见git配置</h3><ul>
<li>用户名配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai <span class="built_in">test</span>]<span class="comment"># git config --global user.name &quot;kdhelloa&quot;</span></span><br><span class="line">[root@dmtsai <span class="built_in">test</span>]<span class="comment"># git config --global user.email 1026789105@qq.com</span></span><br></pre></td></tr></table></figure></li>
<li>Git命令别名配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.cin <span class="string">&quot;commit --amend --no-edit&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-Git-Remote"><a href="#2-2-Git-Remote" class="headerlink" title="2.2 Git Remote"></a>2.2 Git Remote</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看remote</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git remote -v</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Remote</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git remote add origin_ssh git@github.com:git/git.git</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git remote add origin_http https://github.com:git/git.git</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git remote -v</span></span><br><span class="line">origin_http	https://github.com:git/git.git (fetch)</span><br><span class="line">origin_http	https://github.com:git/git.git (push)</span><br><span class="line">origin_ssh	git@github.com:git/git.git (fetch)</span><br><span class="line">origin_ssh	git@github.com:git/git.git (push)</span><br></pre></td></tr></table></figure>
<ul>
<li>同一个Origin设置不同的Push和Fetch URL<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># git remote add origin git@github.com:git/git.git</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git remote set-url --add --push origin git@github.com:my_repo/git.git</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git remote -v</span></span><br><span class="line">origin	git@github.com:git/git.git (fetch)</span><br><span class="line">origin	git@github.com:my_repo/git.git (push)</span><br><span class="line">origin_http	https://github.com:git/git.git (fetch)</span><br><span class="line">origin_http	https://github.com:git/git.git (push)</span><br><span class="line">origin_ssh	git@github.com:git/git.git (fetch)</span><br><span class="line">origin_ssh	git@github.com:git/git.git (push)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-1-HTTP-Remote"><a href="#2-2-1-HTTP-Remote" class="headerlink" title="2.2.1 HTTP Remote"></a>2.2.1 HTTP Remote</h3><h3 id="2-2-1-SSH-Remote"><a href="#2-2-1-SSH-Remote" class="headerlink" title="2.2.1 SSH Remote"></a>2.2.1 SSH Remote</h3><h3 id="2-2-2-配置github的公私钥验证。"><a href="#2-2-2-配置github的公私钥验证。" class="headerlink" title="2.2.2 配置github的公私钥验证。"></a>2.2.2 配置github的公私钥验证。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># ssh-keygen -t ed25519 -C &quot;1026789105@qq.com&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-Git-Add"><a href="#2-3-Git-Add" class="headerlink" title="2.3 Git Add"></a>2.3 Git Add</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># touch readme.md</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># vim readme.md</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git status</span></span><br><span class="line"><span class="comment"># 位于分支 master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 初始提交</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 未跟踪的文件:</span></span><br><span class="line"><span class="comment">#   （使用 &quot;git add &lt;file&gt;...&quot; 以包含要提交的内容）</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#	readme.md</span></span><br><span class="line">提交为空，但是存在尚未跟踪的文件（使用 <span class="string">&quot;git add&quot;</span> 建立跟踪）</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git add .</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git status</span></span><br><span class="line"><span class="comment"># 位于分支 master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 初始提交</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 要提交的变更：</span></span><br><span class="line"><span class="comment">#   （使用 &quot;git rm --cached &lt;file&gt;...&quot; 撤出暂存区）</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#	新文件：    readme.md</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># tree .git</span></span><br><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 3b</span><br><span class="line">│   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">10 directories, 15 files</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="2-4-git-commit"><a href="#2-4-git-commit" class="headerlink" title="2.4 git commit"></a>2.4 git commit</h2><ul>
<li>将修改过的文件进行提交<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># git commit -m &quot;add readme&quot;</span></span><br><span class="line">[master（根提交） 0eecbc6] add readme</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.md</span><br><span class="line">[root@dmtsai demo]<span class="comment"># tree .git</span></span><br><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 0e</span><br><span class="line">│   │   └── ecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">│   ├── 3b</span><br><span class="line">│   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad</span><br><span class="line">│   ├── 73</span><br><span class="line">│   │   └── 94b8cc9ca916312a79ce8078c34b49b1617718</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">15 directories, 21 files</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p 7394b8cc9ca916312a79ce8078c34b49b1617718</span></span><br><span class="line">100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad	readme.md</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p 0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span></span><br><span class="line">tree 7394b8cc9ca916312a79ce8078c34b49b1617718</span><br><span class="line">author kdhelloa &lt;1026789105@qq.com&gt; 1653386601 +0800</span><br><span class="line">committer kdhelloa &lt;1026789105@qq.com&gt; 1653386601 +0800</span><br><span class="line"></span><br><span class="line">add readme</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git log</span></span><br><span class="line">commit 0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">Author: kdhelloa &lt;1026789105@qq.com&gt;</span><br><span class="line">Date:   Tue May 24 18:03:21 2022 +0800</span><br><span class="line"></span><br><span class="line">    add readme</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-5-Objects"><a href="#2-5-Objects" class="headerlink" title="2.5 Objects"></a>2.5 Objects</h2><ul>
<li>commit | tree | blod 在git里面都统一称为Object,除此之外还有个tag的object</li>
<li>Blob：存储文件的内容</li>
<li>tree：存储文件的目录信息</li>
<li>commit：存储提交信息，一个commit可以对应唯一版本的代码</li>
<li>如何把这三个信息串联在一起呢？<ol>
<li>通过commit寻找到tree信息，每个commit都会存储对应的Tree ID</li>
<li>通过tree存储的信息，获取到对应的目录树信息</li>
<li>从tree中获得blob的ID,通过blob ID获取对应的文件内容</li>
</ol>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba048867983e4119b3bbc66901ada01e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="2-6-Refs"><a href="#2-6-Refs" class="headerlink" title="2.6 Refs"></a>2.6 Refs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到新分支</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git checkout -b test</span></span><br><span class="line">切换到一个新分支 <span class="string">&#x27;test&#x27;</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># tree .git</span></span><br><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           ├── master</span><br><span class="line">│           └── <span class="built_in">test</span></span><br><span class="line">├── objects</span><br><span class="line">│   ├── 0e</span><br><span class="line">│   │   └── ecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">│   ├── 3b</span><br><span class="line">│   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad</span><br><span class="line">│   ├── 73</span><br><span class="line">│   │   └── 94b8cc9ca916312a79ce8078c34b49b1617718</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   ├── master</span><br><span class="line">    │   └── <span class="built_in">test</span></span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">15 directories, 23 files</span><br></pre></td></tr></table></figure>
<ul>
<li>refs文件存储的内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># cat .git/refs/heads/master </span></span><br><span class="line">0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">[root@dmtsai demo]<span class="comment"># cat .git/refs/heads/test</span></span><br><span class="line">0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br></pre></td></tr></table></figure></li>
<li>refs的内容就是对应的commit ID</li>
<li>因此把ref当作指针，指向对应的commit来表示当前ref对应的版本</li>
<li>不同种类的ref<ul>
<li>refs&#x2F;heads 前缀表示的是分支</li>
<li>除此之外还有其他种类的ref。 refs&#x2F;tags 前缀表示的是标签</li>
</ul>
</li>
<li><strong>branch 分支</strong><ul>
<li>分支一般用于开发阶段，是可以不断添加commit进行迭代的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># git checkout -b test</span></span><br><span class="line">切换到一个新分支 <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>tag 标签<ul>
<li>标签一般表示的是一个稳定版本，指向的commit一般不会变更<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过git tag 命令生成tag.</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git tag v0.0.1</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># tree .git</span></span><br><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           ├── master</span><br><span class="line">│           └── <span class="built_in">test</span></span><br><span class="line">├── objects</span><br><span class="line">│   ├── 0e</span><br><span class="line">│   │   └── ecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">│   ├── 3b</span><br><span class="line">│   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad</span><br><span class="line">│   ├── 73</span><br><span class="line">│   │   └── 94b8cc9ca916312a79ce8078c34b49b1617718</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   ├── master</span><br><span class="line">    │   └── <span class="built_in">test</span></span><br><span class="line">    └── tags</span><br><span class="line">        └── v0.0.1</span><br><span class="line"></span><br><span class="line">15 directories, 24 files</span><br><span class="line">[root@dmtsai demo]<span class="comment"># cat .git/refs/tags/v0.0.1 </span></span><br><span class="line">0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-7-Annotation-Tag"><a href="#2-7-Annotation-Tag" class="headerlink" title="2.7 Annotation Tag"></a>2.7 Annotation Tag</h2><ul>
<li>什么是附注标签<ul>
<li>一种特殊的标签，可以给Tag提供一些额外的信息</li>
</ul>
</li>
<li>如何创建附注标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过git tag -a 命令来完成附注标签的创建</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git tag -a v0.0.2 -m &quot;add feature 1&quot;</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># tree .git</span></span><br><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           ├── master</span><br><span class="line">│           └── <span class="built_in">test</span></span><br><span class="line">├── objects</span><br><span class="line">│   ├── 0e</span><br><span class="line">│   │   └── ecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">│   ├── 3b</span><br><span class="line">│   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad</span><br><span class="line">│   ├── 4c</span><br><span class="line">│   │   └── 4341fe5161c9951eaff90b07a5f923e2d3026b</span><br><span class="line">│   ├── 73</span><br><span class="line">│   │   └── 94b8cc9ca916312a79ce8078c34b49b1617718</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   ├── master</span><br><span class="line">    │   └── <span class="built_in">test</span></span><br><span class="line">    └── tags</span><br><span class="line">        ├── v0.0.1</span><br><span class="line">        └── v0.0.2</span><br><span class="line"></span><br><span class="line">16 directories, 26 files</span><br><span class="line">[root@dmtsai demo]<span class="comment"># cat .git/refs/tags/v0.0.2</span></span><br><span class="line">4c4341fe5161c9951eaff90b07a5f923e2d3026b</span><br><span class="line"><span class="comment"># 这是第四种object信息</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p 4c4341fe5161c9951eaff90b07a5f923e2d3026b</span></span><br><span class="line">object 0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line"><span class="built_in">type</span> commit</span><br><span class="line">tag v0.0.2</span><br><span class="line">tagger kdhelloa &lt;1026789105@qq.com&gt; 1653388503 +0800</span><br><span class="line"></span><br><span class="line">add feature 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-8-追溯历史版本"><a href="#2-8-追溯历史版本" class="headerlink" title="2.8 追溯历史版本"></a>2.8 追溯历史版本</h2><ul>
<li>获取当前版本代码<ul>
<li>通过ref指向的commit可以获取唯一的代码版本</li>
</ul>
</li>
<li>获取历史版本代码<ul>
<li>commit里面会存有parent commit字段，通过commit的串联获取历史版本代码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># git branch</span></span><br><span class="line">  master</span><br><span class="line">* <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 修改更新 readme.md文件</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># vim readme.md </span></span><br><span class="line"><span class="comment"># add修改文件</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git add .</span></span><br><span class="line"><span class="comment"># 提交修改的文件</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git commit -m &quot;update readme&quot;</span></span><br><span class="line">[<span class="built_in">test</span> ba9ab4e] update readme</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"><span class="comment"># 查看更新后文件目录结构。新增了 一个tree object,一个 blob object,一个commit object</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># tree .git</span></span><br><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           ├── master</span><br><span class="line">│           └── <span class="built_in">test</span></span><br><span class="line">├── objects</span><br><span class="line">│   ├── 0e</span><br><span class="line">│   │   └── ecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">│   ├── 2b</span><br><span class="line">│   │   └── e7c65ae93b54b988416f280298b0b8b5f20385</span><br><span class="line">│   ├── 38</span><br><span class="line">│   │   └── 6eb799bbfd0826f510b6587c5afaae2a962279</span><br><span class="line">│   ├── 3b</span><br><span class="line">│   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad</span><br><span class="line">│   ├── 4c</span><br><span class="line">│   │   └── 4341fe5161c9951eaff90b07a5f923e2d3026b</span><br><span class="line">│   ├── 73</span><br><span class="line">│   │   └── 94b8cc9ca916312a79ce8078c34b49b1617718</span><br><span class="line">│   ├── ba</span><br><span class="line">│   │   └── 9ab4eee8a009eeeb52028069192963ecc30657</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   ├── master</span><br><span class="line">    │   └── <span class="built_in">test</span></span><br><span class="line">    └── tags</span><br><span class="line">        ├── v0.0.1</span><br><span class="line">        └── v0.0.2</span><br><span class="line"></span><br><span class="line">19 directories, 29 files</span><br><span class="line"><span class="comment"># 查看git commit的操作日志</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git log</span></span><br><span class="line">commit ba9ab4eee8a009eeeb52028069192963ecc30657</span><br><span class="line">Author: kdhelloa &lt;1026789105@qq.com&gt;</span><br><span class="line">Date:   Tue May 24 18:45:17 2022 +0800</span><br><span class="line"></span><br><span class="line">    update readme</span><br><span class="line"></span><br><span class="line">commit 0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">Author: kdhelloa &lt;1026789105@qq.com&gt;</span><br><span class="line">Date:   Tue May 24 18:03:21 2022 +0800</span><br><span class="line"></span><br><span class="line">    add readme</span><br><span class="line"><span class="comment"># 通过查看update readme操作中这个新增的commit object来获取新增的tree object</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p ba9ab4eee8a009eeeb52028069192963ecc30657</span></span><br><span class="line">tree 386eb799bbfd0826f510b6587c5afaae2a962279</span><br><span class="line">parent 0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">author kdhelloa &lt;1026789105@qq.com&gt; 1653389117 +0800</span><br><span class="line">committer kdhelloa &lt;1026789105@qq.com&gt; 1653389117 +0800</span><br><span class="line"></span><br><span class="line">update readme</span><br><span class="line"><span class="comment"># 通过新增的tree object来查看新增的blob这个object</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p 386eb799bbfd0826f510b6587c5afaae2a962279</span></span><br><span class="line">100644 blob 2be7c65ae93b54b988416f280298b0b8b5f20385	readme.md</span><br><span class="line"><span class="comment"># 通过新增的blob object 来查看存储的文件内容</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p 2be7c65ae93b54b988416f280298b0b8b5f20385</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># update redame中commit object里面有一个parent commit字段，通过commit的串联获取历史版本代码</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p 0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span></span><br><span class="line">tree 7394b8cc9ca916312a79ce8078c34b49b1617718</span><br><span class="line">author kdhelloa &lt;1026789105@qq.com&gt; 1653386601 +0800</span><br><span class="line">committer kdhelloa &lt;1026789105@qq.com&gt; 1653386601 +0800</span><br><span class="line"></span><br><span class="line">add readme</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p 7394b8cc9ca916312a79ce8078c34b49b1617718</span></span><br><span class="line">100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad	readme.md</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad</span></span><br><span class="line">hello world</span><br><span class="line"><span class="comment"># test ref指向新的commit</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># cat .git/refs/heads/test </span></span><br><span class="line">ba9ab4eee8a009eeeb52028069192963ecc30657</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-9-修改历史版本"><a href="#2-9-修改历史版本" class="headerlink" title="2.9 修改历史版本"></a>2.9 修改历史版本</h2><ul>
<li>commit –amend<ul>
<li>通过这个命令可以修改最近一次的commit信息，修改之后commit id会变。但是commit object里面的tree字段与parent字段不会发生改变<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># git commit --amend</span></span><br><span class="line">[<span class="built_in">test</span> 9a6b509] update readme!!!</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git log</span></span><br><span class="line">commit 9a6b5096f1f7e889cf871db03fd1c6c22d9f5c48</span><br><span class="line">Author: kdhelloa &lt;1026789105@qq.com&gt;</span><br><span class="line">Date:   Tue May 24 18:45:17 2022 +0800</span><br><span class="line"></span><br><span class="line">    update readme!!!</span><br><span class="line"></span><br><span class="line">commit 0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br><span class="line">Author: kdhelloa &lt;1026789105@qq.com&gt;</span><br><span class="line">Date:   Tue May 24 18:03:21 2022 +0800</span><br><span class="line"></span><br><span class="line">    add readme</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>rebase<ul>
<li>通过 git rebase -i HEAD~3 可以实现对最近三个commit的修改<ol>
<li>合并commit</li>
<li>修改具体的commit message</li>
<li>删除某个commit</li>
</ol>
</li>
</ul>
</li>
<li>filter –branch<ul>
<li>该命令可以指定删除所有提交中的某个文件或者全局修改邮箱地址等操作</li>
</ul>
</li>
</ul>
<h2 id="2-10-Objects"><a href="#2-10-Objects" class="headerlink" title="2.10 Objects"></a>2.10 Objects</h2><ul>
<li>新增的Object<ul>
<li>修改commit后，我们可以发现git object又出现了变化。新增了修改后的commit object，但是之前的commit object并没有被删除。</li>
</ul>
</li>
<li>悬空的Object<ul>
<li>例如上面那个Object，顾名思义就是没有ref指向的object<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过下面这条命令来查找悬空的Object</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git fsck --lost-found</span></span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">dangling commit ba9ab4eee8a009eeeb52028069192963ecc30657</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-11-git-gc"><a href="#2-11-git-gc" class="headerlink" title="2.11 git gc"></a>2.11 git gc</h2><ul>
<li>GC<ul>
<li>通过git gc命令，可以删除一些不需要的Object(例如悬空的object),以及会对object进行一些打包压缩来减少仓库的体积</li>
</ul>
</li>
<li>reflog<ul>
<li>reflog是用于记录操作日志，防止误操作后数据丢失。通过reflog来找到丢失的数据，手动将日志设置为过期</li>
</ul>
</li>
<li>指定时间<ul>
<li>git gc prune&#x3D;now 指定的是修剪多久之前的对象，默认是两周前<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># git reflog expire --expire=now --all</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git gc --prune=now</span></span><br><span class="line">Counting objects: 7, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (7/7), <span class="keyword">done</span>.</span><br><span class="line">Total 7 (delta 0), reused 0 (delta 0)</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git fsck --lost-found</span></span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (7/7), <span class="keyword">done</span>.</span><br><span class="line">[root@dmtsai demo]<span class="comment"># tree .git</span></span><br><span class="line">.git</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   ├── exclude</span><br><span class="line">│   └── refs</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           ├── master</span><br><span class="line">│           └── <span class="built_in">test</span></span><br><span class="line">├── lost-found</span><br><span class="line">│   └── commit</span><br><span class="line">│       └── ba9ab4eee8a009eeeb52028069192963ecc30657</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   │   └── packs</span><br><span class="line">│   └── pack</span><br><span class="line">│       ├── pack-891f2b138ece528aa7a2733f2d6e98c0e7bc5f34.idx</span><br><span class="line">│       └── pack-891f2b138ece528aa7a2733f2d6e98c0e7bc5f34.pack</span><br><span class="line">├── packed-refs</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">14 directories, 24 files</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git cat-file -p ba9ab4eee8a009eeeb52028069192963ecc30657</span></span><br><span class="line">error: unable to find ba9ab4eee8a009eeeb52028069192963ecc30657</span><br><span class="line">fatal: Not a valid object name ba9ab4eee8a009eeeb52028069192963ecc30657</span><br><span class="line"><span class="comment"># 可以查看压缩后的内容</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># cat .git/packed-refs </span></span><br><span class="line"><span class="comment"># pack-refs with: peeled fully-peeled </span></span><br><span class="line">0eecbc6b9742fc3eba018b9f34b5a4f5c391b988 refs/heads/master</span><br><span class="line">9a6b5096f1f7e889cf871db03fd1c6c22d9f5c48 refs/heads/test</span><br><span class="line">0eecbc6b9742fc3eba018b9f34b5a4f5c391b988 refs/tags/v0.0.1</span><br><span class="line">4c4341fe5161c9951eaff90b07a5f923e2d3026b refs/tags/v0.0.2</span><br><span class="line">^0eecbc6b9742fc3eba018b9f34b5a4f5c391b988</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-12git的完整视图"><a href="#2-12git的完整视图" class="headerlink" title="2.12git的完整视图"></a>2.12git的完整视图</h2><p>就是通过一个commit object可以查看到一个完整的版本代码。一个commit object会有tree字段和parent字段，tree字段又可以找到blob字段，继而找到代码。通过parent字段可以可以历史版本代码。</p>
<h2 id="2-13-git-clone-pull-fetch"><a href="#2-13-git-clone-pull-fetch" class="headerlink" title="2.13 git clone &amp; pull &amp; fetch"></a>2.13 git clone &amp; pull &amp; fetch</h2><ul>
<li>clone<ul>
<li>拉取完整的仓库到本地目录，可以指定分支，深度</li>
</ul>
</li>
<li>fetch<ul>
<li>将远端某些分支代码最新代码拉取到本地，不会执行merge操作，会修改refs&#x2F;remote内的分支信息，如果需要和本地代码合并需要执行手动操作。</li>
</ul>
</li>
<li>pull<ul>
<li>拉取远端某分支，并和本地代码进行合并，操作等同于git fetch + git merge,也可以通过 git pull –rebase 完成git fetch + git rebase操作</li>
<li>可能存在冲突，需要解决冲突</li>
</ul>
</li>
</ul>
<h2 id="2-14-git-push"><a href="#2-14-git-push" class="headerlink" title="2.14 git push"></a>2.14 git push</h2><ul>
<li>push<ul>
<li>git push是将本地代码同步至远端的方式</li>
</ul>
</li>
<li>常用命令<ul>
<li>一般使用 git push origin master命令即可完成</li>
</ul>
</li>
<li>冲突问题<ol>
<li>如果本地的commit记录和远端的commit历史不一致，则会产生冲突，比如 git commit –amend or git rebase 都有可能导致这个问题</li>
<li>如果该分支就自己一个人使用，或者团队确认过可以修改历史则可以通过git push origin master -f来完成强制推送，一般不推荐主干（master）分支进行该操作，正常都应该解决冲突后再进行push(推送)。</li>
</ol>
</li>
<li>推送规则限制<ul>
<li>可以通过保护分支，来配置一些保护规则，防止误操作，或者一些不合规的操作出现，导致代码丢失。</li>
</ul>
</li>
</ul>
<h1 id="3-git研发流程"><a href="#3-git研发流程" class="headerlink" title="3.git研发流程"></a>3.git研发流程</h1><h2 id="3-0常见问题"><a href="#3-0常见问题" class="headerlink" title="3.0常见问题"></a>3.0常见问题</h2><ul>
<li>在gerrit平台上使用merge的方式合入代码<ul>
<li>不推荐，因为gerrit是集中式平台</li>
</ul>
</li>
<li>不了解保护分支，Code Review CI等概念，研发流程不规范<ul>
<li>保护分支：防止用户直接向主干分支提交代码，必须经过PR(pull request)来进行合入。</li>
<li>code review,CI:都是在合入前检查策略，Code Review是人工进行检查，CI则是通过一些定制化的脚本来进行一些校验</li>
</ul>
</li>
<li>代码历史混乱，代码合并方式不清晰<ul>
<li>不理解Fase forward和three way merge的区别，本地代码更新频繁的使用three way的方式，导致生成过多的Merge节点，是提交历史变得复杂不清晰</li>
</ul>
</li>
</ul>
<h2 id="3-1-不同的工作流"><a href="#3-1-不同的工作流" class="headerlink" title="3.1 不同的工作流"></a>3.1 不同的工作流</h2><ul>
<li>类型<ul>
<li>集中式工作流。代表平台：Gerrit&#x2F;SVN。特点：只依托于主干分支进行开发，不存在其他分支。合入方式：Fast-forward.</li>
<li>分支管理工作流。代表平台：Github&#x2F;gitlab。特点：可以定义不同特性的开发分支，上线分支，在开发分支完成开发后再通过MR&#x2F;PR合入主干分支。合入方式：自定义，Fast-Forward or Three-Way Merge都可以</li>
</ul>
</li>
</ul>
<h2 id="3-2-集中式工作流"><a href="#3-2-集中式工作流" class="headerlink" title="3.2 集中式工作流"></a>3.2 集中式工作流</h2><ul>
<li>只依托于master分支进行研发活动</li>
<li>工作方式<ol>
<li>获取远端master代码</li>
<li>直接在master分支完成修改</li>
<li>提交前拉去最新的master代码和本地代码进行合并（使用rebase）,如果有冲突需要解决冲突。</li>
<li>提交本地代码到master.</li>
</ol>
</li>
</ul>
<h2 id="3-3-分支管理工作流"><a href="#3-3-分支管理工作流" class="headerlink" title="3.3 分支管理工作流"></a>3.3 分支管理工作流</h2><ul>
<li>git flow ：分支类型丰富</li>
<li>GitHub flow：只有主干分支和开发分支，规则简单</li>
<li>gitlab flow：在主干分支和开发分支之构建环境分支，版本分支，满足不同发布 or 环境的需要</li>
</ul>
<h3 id="3-3-2-github-flow"><a href="#3-3-2-github-flow" class="headerlink" title="3.3.2 github flow"></a>3.3.2 github flow</h3><ul>
<li>github 的工作流，只有一个主干分支，基于pull request往主干分支中提交代码</li>
<li>选择团队合作的方式<ol>
<li>owner创建好仓库后，其他用户通过fork的方式来创建自己的仓库，并在fork的仓库上进行开发</li>
<li>owner创建好仓库后，统一给团队内成员 分配权限，直接在同一个仓库内进行开发</li>
</ol>
</li>
<li>github上操作流程<ol>
<li><p>在github上新建一个repository。并clone到本地</p>
</li>
<li><p>创建一个pull request</p>
<ol>
<li>创建一个main主分支</li>
<li>创建一个feature分支</li>
<li>可以通过进行一些保护分支设置，来限制合入的策略，以及限制直接的push操作</li>
</ol>
</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai ~]<span class="comment"># git clone git@github.com:kdhelloa/demo.git</span></span><br><span class="line">正克隆到 <span class="string">&#x27;demo&#x27;</span>...</span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;/root/.ssh/id_rsa&#x27;</span>: </span><br><span class="line">warning: 您似乎克隆了一个空版本库。</span><br><span class="line">[root@dmtsai demo]<span class="comment"># vim readme.md</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git add .</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git commit -m &quot;add readme&quot;</span></span><br><span class="line">[master（根提交） 99fd23f] add readme</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.md</span><br><span class="line"> [root@dmtsai demo]<span class="comment"># git branch -m master main</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git push origin main</span></span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;/root/.ssh/id_rsa&#x27;</span>: </span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 218 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:kdhelloa/demo.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 创建一个新分支feature,并进入到feature分支</span></span><br><span class="line"> [root@dmtsai demo]<span class="comment"># git checkout -b feature</span></span><br><span class="line">切换到一个新分支 <span class="string">&#x27;feature&#x27;</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># vim readme.md</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git add .</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git commit -m &quot;update readme&quot;</span></span><br><span class="line">[feature ab09033] update readme</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git push origin feature</span></span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;/root/.ssh/id_rsa&#x27;</span>: </span><br><span class="line">Counting objects: 5, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 270 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: </span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">&#x27;feature&#x27;</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/kdhelloa/demo/pull/new/feature</span><br><span class="line">remote: </span><br><span class="line">To git@github.com:kdhelloa/demo.git</span><br><span class="line"> * [new branch]      feature -&gt; feature</span><br><span class="line"> <span class="comment"># 在浏览器打开上面那个remote地址 https://github.com/kdhelloa/demo/pull/new/feature，然后进行一个创建</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在push时出现问题的解决办法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># git push origin main</span></span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;/root/.ssh/id_rsa&#x27;</span>: </span><br><span class="line">error: src refspec main does not match any.</span><br><span class="line">error: 无法推送一些引用到 <span class="string">&#x27;git@github.com:kdhelloa/demo.git&#x27;</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git branch</span></span><br><span class="line">* master</span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git branch -m master main</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git push origin main</span></span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;/root/.ssh/id_rsa&#x27;</span>: </span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 218 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:kdhelloa/demo.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-2-gitlab-flow"><a href="#3-3-2-gitlab-flow" class="headerlink" title="3.3.2 gitlab flow"></a>3.3.2 gitlab flow</h3><ul>
<li>推荐的工作六是在gitflow和github flow上做出优化，即保持了单一主分支的间接，又可以适应不同的开发环境</li>
<li>原则：upstream first 上游优先<ul>
<li>只有在上游分支采纳的代码才可以进入到下游分支，一般上游分支就是master</li>
</ul>
</li>
</ul>
<h2 id="3-4-代码合并"><a href="#3-4-代码合并" class="headerlink" title="3.4 代码合并"></a>3.4 代码合并</h2><ul>
<li>fast-forward[[root@dmtsai demo]# git merge test –ff-only]<ul>
<li>不会产生一个merge节点，合并后保持一个线性历史，如果target分支有了更新，则需要通过rebase操作更新source branch后才可以合入。</li>
</ul>
</li>
<li>three-way merge<ul>
<li>三方合并，会产生新的merge节点[[root@dmtsai demo]# git merge test –no-ff]<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@dmtsai demo]<span class="comment"># git checkout -b test</span></span><br><span class="line">切换到一个新分支 <span class="string">&#x27;test&#x27;</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># ls</span></span><br><span class="line">readme.md</span><br><span class="line">[root@dmtsai demo]<span class="comment"># vim readme.md </span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git add .</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git commit -m &quot;test&quot;</span></span><br><span class="line">[<span class="built_in">test</span> dafd462] <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">[root@dmtsai demo]<span class="comment"># git checkout main</span></span><br><span class="line">切换到分支 <span class="string">&#x27;main&#x27;</span></span><br><span class="line">[root@dmtsai demo]<span class="comment"># git merge test --ff-only</span></span><br><span class="line">更新 ba4f142..dafd462</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-5-如何选择合适的工作流"><a href="#3-5-如何选择合适的工作流" class="headerlink" title="3.5 如何选择合适的工作流"></a>3.5 如何选择合适的工作流</h2><ul>
<li>针对小型团队，推荐使用github工作流即可<ol>
<li>尽量保证少量多次，最好不要一次性提交上千行代码</li>
<li>提交pull request后最少需要保证有cr（check request）后再合入</li>
<li>主干分支尽量保持整洁，使用fast-forward合入方式，合入前进行rebase</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/05/27/git%E5%AD%A6%E4%B9%A0/" data-id="clrv16wj70004z5kua3b4d26j" data-title="git学习" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-05-26T16:00:00.000Z" itemprop="datePublished">2022-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Go语言学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Go语言学习"><a href="#Go语言学习" class="headerlink" title="Go语言学习"></a>Go语言学习</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><h3 id="Go-Land使用快捷键"><a href="#Go-Land使用快捷键" class="headerlink" title="Go Land使用快捷键"></a>Go Land使用快捷键</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件相关快捷键：</span></span><br><span class="line">    代码格式化：</span><br><span class="line">    #CTRL+ALT+T，可以把代码包在一个块内，例如if&#123;…&#125;else&#123;…&#125;。</span><br><span class="line">    #CTRL+ALT+L，格式化代码。</span><br><span class="line">    CTRL+空格，代码提示。</span><br><span class="line">    CTRL+/，单行注释。CTRL+SHIFT+/，进行多行注释。</span><br><span class="line">    CTRL+B，快速打开光标处的结构体或方法（跳转到定义处）。</span><br><span class="line">    CTRL+“+/-”，可以将当前方法进行展开或折叠。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查找和定位：</span></span><br><span class="line">    CTRL+R，替换文本。</span><br><span class="line">    CTRL+F，查找文本。</span><br><span class="line">    CTRL+SHIFT+F，进行全局查找。</span><br><span class="line">    CTRL+G，快速定位到某行。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码编辑：</span></span><br><span class="line">    #CTRL+O，实现接口的所有方法</span><br><span class="line">    ALT+Q，可以看到当前方法的声明。</span><br><span class="line">    #SHIFT+ENTER，可以向下插入新行，即使光标在当前行的中间。</span><br><span class="line">    #CTRL+X，删除当前光标所在行。</span><br><span class="line">    #CTRL+D，复制当前光标所在行。</span><br><span class="line">    #ALT+SHIFT+UP/DOWN，可以将光标所在行的代码上下移动。</span><br><span class="line">    CTRL+SHIFT+U，可以将选中内容进行大小写转化。</span><br><span class="line">    CTRL+Backspace，按单词进行删除。</span><br><span class="line">    SHIFT+ENTER，可以向下插入新行，即使光标在当前行的中间。</span><br><span class="line">    ALT+UP可以实现方法的跳转</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其它快捷键：</span></span><br><span class="line">    ctrl + n 导航到类名</span><br><span class="line">    ctrl + shift + n 导航到文件</span><br><span class="line">    ctrl + e/ctrl + shift + e 打开到最近的文件/打开最近修改的文件</span><br><span class="line">    ctrl + shift + i 简短地查看源定义</span><br><span class="line">    ctrl + alt + m 重构表达式为函数 光标在表达式的末尾</span><br><span class="line">    ctrl + space 快速返回实现 return 字段后使用</span><br><span class="line">    ctrl+ shift+ a 工具调用 如 go tools，restful 等</span><br><span class="line">    ctrl + shift + space 智能类型推断式返回 return 字段后使用</span><br><span class="line">    ctrl + i 实现某接口</span><br><span class="line">    ctrl + p 查看 method 参数信息</span><br><span class="line">    ctrl + shift + p 查看表达式类型</span><br><span class="line">    ctrl + alt + v 自动生成表达式返回值</span><br><span class="line">    alt + j 相同单词多选 类似 sublime Ctrl + D</span><br><span class="line">    ctrl+alt+enter 在上一行重启一行</span><br><span class="line">    ctrl + i 实现某接口（在 type struct 上使用）</span><br><span class="line">    ctrl + p 查看方法参数信息（在方法括号中使用）</span><br><span class="line">    ctrl + shift + p 查看表达式类型（在表达式上或者表达式末尾使用）</span><br><span class="line">    alt + enter 会出现一些 intention的操作（比如在第三方包名上使用，可以添加 import 包别名）</span><br><span class="line">    ctrl + alt + v 生成表达式返回值（表达式末尾使用。先不要写 “resp, err :=”，按下快捷键后会自动生成。）</span><br><span class="line">    Alt + J 类似 sublime 上的 Ctrl + D 多选 （此外还有 Shift + Ctrl + Alt + J， Alt + Shift + Mouse Click，可以实现多选 ）</span><br></pre></td></tr></table></figure>



<h2 id="第一章：Go语言的环境安装与快速入门"><a href="#第一章：Go语言的环境安装与快速入门" class="headerlink" title="第一章：Go语言的环境安装与快速入门"></a>第一章：Go语言的环境安装与快速入门</h2><h3 id="1-安装SDK-软件开发工具包"><a href="#1-安装SDK-软件开发工具包" class="headerlink" title="1.安装SDK(软件开发工具包)"></a>1.安装SDK(软件开发工具包)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">包下载地址</span></span><br><span class="line">https://golang.org/doc/install</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压安装在 D:\program\Go 目录</span></span><br></pre></td></tr></table></figure>

<h3 id="2-windows环境下配置go环境变量（在任意路径下执行go程序）"><a href="#2-windows环境下配置go环境变量（在任意路径下执行go程序）" class="headerlink" title="2.windows环境下配置go环境变量（在任意路径下执行go程序）"></a>2.windows环境下配置go环境变量（在任意路径下执行go程序）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2.配置全局Path	   添加SDK的/bin目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.配置GOROOT  	指定SDK的安装路径D:\program\Go</p>
<p>2.配置全局Path	   添加SDK的&#x2F;bin目录</p>
<p>3.配置GOPATH		 工作目录，将来我们go项目的工作路径(就是以后go项目存放的路径，即工作目录)</p>
<h3 id="3-GO语言快速开发入门"><a href="#3-GO语言快速开发入门" class="headerlink" title="3.GO语言快速开发入门"></a>3.GO语言快速开发入门</h3><p>​	1.项目开发时的目录环境</p>
<p>2.go程序开发（在GoLand中开发），将go代码写到hello.go文件中来</p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211011151546260.png" alt="image-20211011151546260"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意事项</span></span><br><span class="line"><span class="keyword">package</span> main 	<span class="comment">//表示该hello.go文件所在的包是main,在go中，每个文件必须归属于一个包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> 	<span class="comment">//表示引入一个包，包名 fmt,引入该包后，就可以使用fmt包的函数,比如fmt.Println()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func是一个关键字，表示一个函数</span></span><br><span class="line"><span class="comment">//main是函数名，是一个主函数，即我们程序的入口</span></span><br></pre></td></tr></table></figure>

<p>3.使用go build命令对该go文件(hello.go)进行编译，生成可执行文件(hello.exe文件)</p>
<p>4.也可以通过go run直接对hello.go文件编译运行（但不推荐，类似一个脚本文件的执行）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">两种执行流程的区别与注意事项</span></span><br><span class="line">1.hello.exe可执行文件能在没有go开发环境上运行</span><br><span class="line">2.hello.go源代码的运行需要go开发环境</span><br><span class="line">3.在编译生成可执行文件时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以可执行文件变大了很多</span><br></pre></td></tr></table></figure>

<p>5.可以指定生成的二进制文件名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定源码hello.go生成的可执行文件名为myhello.exe</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;go build -o myhello.exe hello.go</span><br><span class="line"></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;dir</span><br><span class="line"> 驱动器 D 中的卷是 软件</span><br><span class="line"> 卷的序列号是 32FB-4470</span><br><span class="line"></span><br><span class="line"> D:\program\goPath\src\go_code\project01\main 的目录</span><br><span class="line"></span><br><span class="line">2021/10/11  15:38    &lt;DIR&gt;          .</span><br><span class="line">2021/10/11  15:38    &lt;DIR&gt;          ..</span><br><span class="line">2021/10/11  15:24         2,094,592 hello.exe</span><br><span class="line">2021/10/11  15:15               151 hello.go</span><br><span class="line">2021/10/11  15:38         2,094,592 myhello.exe</span><br><span class="line">               3 个文件      4,189,335 字节</span><br><span class="line">               2 个目录 175,641,739,264 可用字节</span><br></pre></td></tr></table></figure>

<h3 id="4-go语言开发的注意事项"><a href="#4-go语言开发的注意事项" class="headerlink" title="4.go语言开发的注意事项"></a>4.go语言开发的注意事项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Go源文件以’go‘为扩展名</span><br><span class="line">2.Go应用程序的执行入口是main函数</span><br><span class="line">3.严格区分大小写</span><br><span class="line">4.Go方法由一条语句构成，每个语句后不需要加分号（会默认加分号）</span><br><span class="line">5.Go编辑器是一行行进行编译的，因此我们一行就写一行语句，如果写多行就加分号</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6.go语言定义的变量或者import的包如果没有使用到，代码不能编译通过</span></span><br><span class="line">7.大括号成对出现，缺一不可</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当要引入多个包时使用这样的方式</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="5-转义字符与java一样"><a href="#5-转义字符与java一样" class="headerlink" title="5.转义字符与java一样"></a>5.转义字符与java一样</h3><h3 id="6-go语言编程规范"><a href="#6-go语言编程规范" class="headerlink" title="6.go语言编程规范"></a>6.go语言编程规范</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.gofmt hello.go		是将hello.go源码格式化后控制台输出，而源文件本身不会有变化</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;gofmt hello.go</span><br><span class="line">//要求开发一个hello.go程序，可以输出hello,world</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">//导入一个包</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        //在go语言里面默认加分号，如果要写多行需要在一行语句后写分号</span><br><span class="line">        fmt.Println(&quot;hello,world&quot;)</span><br><span class="line">        fmt.Println(&quot;hello,world&quot;)</span><br><span class="line">        var na = 12</span><br><span class="line">        fmt.Println(na)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.gofmt -w hello.go		是将hello.go文件本身格式化 就是源文件本身会被格式化，有点类似于java格式化的快捷键的功能。</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;gofmt -w hello.go</span><br></pre></td></tr></table></figure>

<h3 id="7-go语言文档"><a href="#7-go语言文档" class="headerlink" title="7.go语言文档"></a>7.go语言文档</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">golang中文网	https://studygolang.com/pkgdoc</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">golang官方文档	https://golang.org/</span></span><br></pre></td></tr></table></figure>

<h2 id="第二章：Go语言数据类型、运算符、键盘输入语句、三种码，三种结构"><a href="#第二章：Go语言数据类型、运算符、键盘输入语句、三种码，三种结构" class="headerlink" title="第二章：Go语言数据类型、运算符、键盘输入语句、三种码，三种结构"></a>第二章：Go语言数据类型、运算符、键盘输入语句、三种码，三种结构</h2><h3 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a>1.整数类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.分为有符号和无符号之分  int和uint,大小和系统有关</span><br><span class="line">2.整数类型默认声明为int型</span><br><span class="line">3.如何在程序中查看某个变量的字节大小和数据类型（使用较多）</span><br><span class="line">4.整型变量在使用时，遵守保小不保大的原则，即在保证程序正常运行时，尽量使用空间小的数据类型。【如，年龄】</span><br><span class="line">5.bit:计算机中最小的存储单位；byte:计算机中的最小存储单元</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.整数类型默认声明为int型</span></span><br><span class="line"><span class="keyword">var</span> n1=<span class="number">100</span></span><br><span class="line"><span class="comment">//fmt.Printf() 可以用于格式化输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;na的类型 %T&quot;</span>,n1)  <span class="comment">//这里返回的是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.如何在程序中查看某个变量的字节大小和数据类型（使用较多）</span></span><br><span class="line"><span class="comment">//如何在程序中查看某个变量导的占用字节大小和数据类型（使用较多）</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int64</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">//unsafe.Sizeof(n1)  是unsafe包的一个函数，可以返回n1变量占用的字节数  答案返回的是8个字节</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n2 的类型 %T  n2的占用字节数是 %d&quot;</span>,n2,unsafe.Sizeof(n2))</span><br></pre></td></tr></table></figure>

<h3 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//float32单精度，float64是双精度</span></span><br><span class="line"><span class="keyword">var</span> salary <span class="type">float32</span>=<span class="number">1.2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;salary:&quot;</span>,salary)</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型初始化</span></span><br><span class="line">num6 := <span class="number">5.12</span></span><br><span class="line">num7 := <span class="number">.123</span>  <span class="comment">//小数中前面的0可以省略</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num6：&quot;</span>,num6)</span><br><span class="line">fmt.Println(<span class="string">&quot;num7：&quot;</span>,num7)</span><br><span class="line"></span><br><span class="line">num8 := <span class="number">5.123e2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num8：&quot;</span>,num8)</span><br><span class="line">num9 := <span class="number">5.123E2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num9：&quot;</span>,num9)</span><br><span class="line">num10 := <span class="number">5.123e-2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num10：&quot;</span>,num10)</span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">num6： <span class="number">5.12</span></span><br><span class="line">num7： <span class="number">0.123</span></span><br><span class="line">num8： <span class="number">512.34</span></span><br><span class="line">num9： <span class="number">512.34</span></span><br><span class="line">num10： <span class="number">0.051234</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.go的浮点型有固定的范围和字段长度，不受操作系统影响</span><br><span class="line">2.go的浮点型默认是float64类型</span><br><span class="line">3.通常情况下使用float64类型定义，这个比float32精确</span><br><span class="line">4.浮点型数据表示形式：</span><br><span class="line">	num6 := 5.12 	 十进制数形式	</span><br><span class="line">	num8 := 5.123e2  科学计数法形式</span><br></pre></td></tr></table></figure>

<h3 id="3-字符类型"><a href="#3-字符类型" class="headerlink" title="3.字符类型"></a>3.字符类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字符类型使用字节</span></span><br><span class="line">1.go语言中没有专门的字符类型，如果要存储单个字符（字母），一般用byte来保存</span><br><span class="line">2.官方将字符串类型归到基本数据类型中来</span><br><span class="line">3.字符串就是一串字符组成的。go的字符串是由单个字节连接起来的。而go的字符串不同，它是由字节组成的</span><br><span class="line">4.go语言中的字符使用Unicode编码，再也没有编程乱码的困扰了</span><br><span class="line">5.go中的字符可以作为整数进行运算</span><br><span class="line">6.当我们直接输出byte类型的字符时，使出的是字符对应的码值</span><br><span class="line">7.如果需要原样输出字符时，需要格式化输出（Printf）。反过来也是可以的（即根据码值求字符）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本使用</span></span><br><span class="line"><span class="keyword">var</span> c1 <span class="type">byte</span>=<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">byte</span>=<span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment">//当我们直接输出byte的字符时，使出的是字符对应的码值</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br><span class="line"><span class="comment">//如果需要原样输出字符时，需要格式化输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;c1的值 %c\n&quot;</span>,c1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;c2的值 %c&quot;</span>,c2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们保存的字符在ASCII表中，可以直接保存在byte中，当超出时，可以保存在int中，同时还可以进行格式化输出</span></span><br><span class="line"><span class="keyword">var</span> c3 <span class="type">int</span> =<span class="string">&#x27;北&#x27;</span></span><br><span class="line">fmt.Println(c3)</span><br><span class="line"><span class="comment">//可以用字符进行整数运算，因为他对应有Unicode码</span></span><br><span class="line">fmt.Println(c3+<span class="number">10</span>) </span><br><span class="line">fmt.Printf(<span class="string">&quot;c3的值 %c %d&quot;</span>,c3,c3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">49</span></span><br><span class="line">c1的值 a</span><br><span class="line">c2的值 <span class="number">1</span></span><br><span class="line"><span class="number">21271</span></span><br><span class="line"><span class="number">21281</span></span><br><span class="line">c3的值 北 <span class="number">21271</span></span><br></pre></td></tr></table></figure>

<h3 id="4-bool类型"><a href="#4-bool类型" class="headerlink" title="4.bool类型"></a>4.bool类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.bool类型只占用一个字节</span><br><span class="line">2.适合用于逻辑运算</span><br><span class="line">3.bool类型只能取true或者false,不可以用0或者非0来替用</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意flag等同于true的常量</span></span><br><span class="line"><span class="keyword">var</span> ff=<span class="literal">true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;bool的占用空间&quot;</span>,unsafe.sizeof(ff))</span><br><span class="line">fmt.Println(flag)</span><br><span class="line">fmt.Println(ff)</span><br></pre></td></tr></table></figure>

<h3 id="5-字符串类型"><a href="#5-字符串类型" class="headerlink" title="5.字符串类型"></a>5.字符串类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.go的字符串不同，它是由字节组成的</span><br><span class="line">2.字符串一旦赋值，字符串中的字符就不可修改了（通过字符数组进行修改），但是可以将字符串当作字符数组来进行输出</span><br><span class="line">3.字符串表示形式</span><br><span class="line">	1.双引号，会识别转义字符</span><br><span class="line">	2.反引号，以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击，输出源代码等效果。</span><br><span class="line">4.拼接字符串时，如果操作太长要换行写时，需要将连接符+放在上面</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例演示</span></span><br><span class="line"><span class="keyword">var</span> address <span class="type">string</span>=<span class="string">&quot;北&quot;</span></span><br><span class="line">fmt.Println(address)</span><br><span class="line">fmt.Printf(<span class="string">&quot;address 的占用空间 %d&quot;</span>,unsafe.Sizeof(address))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">&quot;abc\nabc&quot;</span></span><br><span class="line"><span class="comment">//声明加赋值</span></span><br><span class="line">str3:=<span class="string">&quot;bc\nbc&quot;</span></span><br><span class="line">fmt.Println(str2)</span><br><span class="line">fmt.Println(str2[<span class="number">1</span>])  <span class="comment">//输出内容为98，可以直接将字符串用作字符数组用，但是不能修改</span></span><br><span class="line">fmt.Println(str3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反引号的使用演示</span></span><br><span class="line">str4:=<span class="string">`var address string=&quot;北&quot;</span></span><br><span class="line"><span class="string">			fmt.Println(address)</span></span><br><span class="line"><span class="string">			fmt.Printf(&quot;address 的占用空间 %d\n&quot;,unsafe.Sizeof(address))</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string">			var str2=&quot;abc\nabc&quot;</span></span><br><span class="line"><span class="string">			//声明加赋值</span></span><br><span class="line"><span class="string">			str3:=&quot;bc\nbc&quot;</span></span><br><span class="line"><span class="string">			fmt.Println(str2)</span></span><br><span class="line"><span class="string">			fmt.Println(str3)`</span></span><br><span class="line"></span><br><span class="line">fmt.Println(str4)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当拼接有多行时，+要放在上面</span></span><br><span class="line">str5 := <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>+</span><br><span class="line">		<span class="string">&quot;hello&quot;</span></span><br><span class="line">str5+=<span class="string">&quot;你好&quot;</span></span><br><span class="line">fmt.Println(str5)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">北</span><br><span class="line">address 的占用空间 <span class="number">16</span></span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="number">98</span></span><br></pre></td></tr></table></figure>

<h3 id="6-基本数据类型默认值"><a href="#6-基本数据类型默认值" class="headerlink" title="6.基本数据类型默认值"></a>6.基本数据类型默认值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.在go中，数据类型都有一个默认值，默认值又叫零值。  注意float64的默认值或者说零值也是0</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本演示</span></span><br><span class="line"><span class="keyword">var</span> aa <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> bb <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> cc <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> dd <span class="type">string</span></span><br><span class="line">fmt.Println(<span class="string">&quot;aa的默认值：&quot;</span>,aa)</span><br><span class="line">fmt.Println(<span class="string">&quot;bb的默认值：&quot;</span>,bb)</span><br><span class="line">fmt.Println(<span class="string">&quot;cc的默认值：&quot;</span>,cc)</span><br><span class="line">fmt.Println(<span class="string">&quot;dd的默认值：&quot;</span>,dd)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">aa的默认值： <span class="number">0</span></span><br><span class="line">bb的默认值： <span class="number">0</span></span><br><span class="line">cc的默认值： <span class="literal">false</span></span><br><span class="line">dd的默认值： </span><br></pre></td></tr></table></figure>

<h3 id="7-基本数据类型的相互转换"><a href="#7-基本数据类型的相互转换" class="headerlink" title="7.基本数据类型的相互转换"></a>7.基本数据类型的相互转换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意字节</span></span><br><span class="line">1.这与java不同，go在不同数据类型之间的转换需要显示转换，不能自动转换。</span><br><span class="line">2.数据类型可以从 表示范围小-&gt;表示范围大 ，也可以表示范围大-&gt;表示范围小</span><br><span class="line">3.被转换的是变量存储的数据（即值），变量本身的数据类型并没有变化</span><br><span class="line">4.在将大数转换到表示范围小的数据时，如果超出，编译不会出错，会按照溢出处理，和我们希望的结果不一样</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">表达式T(v) 将v转换成T类型   这与java的类型转换有点不一样，java是  int a=10; long b=(long)a;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本演示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int32</span>=<span class="number">12</span></span><br><span class="line"><span class="comment">//希望将i =》 float64类型</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span>= <span class="type">float64</span>(i)</span><br><span class="line">f=<span class="number">12.3</span></span><br><span class="line"><span class="comment">//希望将f =》 int8 类型</span></span><br><span class="line"><span class="keyword">var</span> i2 <span class="type">int8</span>=<span class="type">int8</span>(f)</span><br><span class="line"><span class="comment">//希望将i =》 int64</span></span><br><span class="line"><span class="keyword">var</span> i3 <span class="type">int64</span>=<span class="type">int64</span>(i)  <span class="comment">//低精度转换到高精度也需要进行显示转换</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">fmt.Println(f)</span><br><span class="line">fmt.Println(i2)</span><br><span class="line">fmt.Println(i3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12.3</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211012095126995.png" alt="image-20211012095126995"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这个转换细节</span></span><br><span class="line"><span class="keyword">var</span> nn1 <span class="type">int32</span>=<span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> ii1 <span class="type">int8</span>=<span class="number">12</span>+<span class="number">128</span>          <span class="comment">//编译可以通过，但是运行会出错，溢出</span></span><br><span class="line"><span class="keyword">var</span> ii2 <span class="type">int8</span>=<span class="type">int8</span>(nn1)+<span class="number">127</span>	<span class="comment">//编译可以通过，运行成功，但是结果会溢出，与实际运算结果不一致</span></span><br><span class="line"><span class="keyword">var</span> ii3 <span class="type">int8</span> =<span class="type">int8</span>(nn1)+<span class="number">128</span>  <span class="comment">//编译不通过,不能将已知的数据常量（超出了要转换的数据类型）转换到要转换到的类型</span></span><br><span class="line">fmt.Println(ii2)</span><br><span class="line">fmt.Println(ii1)</span><br></pre></td></tr></table></figure>

<h3 id="8-基本数据类型与string的相互转换"><a href="#8-基本数据类型与string的相互转换" class="headerlink" title="8.基本数据类型与string的相互转换"></a>8.基本数据类型与string的相互转换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本数据类型转string</span></span><br><span class="line">1.方式1：fmt.Sprintf(&quot;%参数&quot;,表达式)  ，会返回字符串【推荐使用这个】</span><br><span class="line">    func Sprintf</span><br><span class="line">    func Sprintf(format string, a ...interface&#123;&#125;) string</span><br><span class="line">    Sprintf根据format参数生成格式化的字符串并返回该字符串。</span><br><span class="line">2.方式2：使用strconv包的函数</span><br><span class="line">	func Itoa(i int) string</span><br><span class="line">	func FormatInt(i int64, base int) string</span><br><span class="line">	func FormatBool(b bool) string</span><br><span class="line">	func FormatFloat(f float64, fmt byte, prec, bitSize int) string</span><br><span class="line">	func FormatUint(i uint64, base int) string</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">string类型转基本数据类型</span></span><br><span class="line">1.方式：使用strconv包中的函数</span><br><span class="line">	func ParseBool(str string) (value bool, err error)</span><br><span class="line">	func ParseInt(s string, base int, bitSize int) (i int64, err error)</span><br><span class="line">	func ParseUint(s string, base int, bitSize int) (n uint64, err error)</span><br><span class="line">	func ParseFloat(s string, bitSize int) (f float64, err error)</span><br><span class="line">2.注意事项：在将一个不是有效数据的字符串转换成基本数据类型时，go会直接将其转换为基本数据类型的默认值，即0或者false</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型转string，第一种方法演示</span></span><br><span class="line"><span class="keyword">var</span> num1 <span class="type">int</span>=<span class="number">99</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">float64</span>=<span class="number">12.234</span></span><br><span class="line"><span class="keyword">var</span> bool1 <span class="type">bool</span>=<span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> mychar <span class="type">byte</span>=<span class="string">&#x27;h&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span> <span class="comment">//空的str</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用第一种方式转换 fmt.Sprintf()方法</span></span><br><span class="line">str=fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,num1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">str=fmt.Sprintf(<span class="string">&quot;%f&quot;</span>,num2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">str=fmt.Sprintf(<span class="string">&quot;%t&quot;</span>,bool1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">str=fmt.Sprintf(<span class="string">&quot;%c&quot;</span>,mychar)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="number">99</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="number">12.234000</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="literal">true</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=h</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型转string,第二种方法演示</span></span><br><span class="line"><span class="keyword">var</span> num1 <span class="type">int</span>=<span class="number">99</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">float64</span>=<span class="number">12.234</span></span><br><span class="line"><span class="keyword">var</span> bool1 <span class="type">bool</span>=<span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> mychar <span class="type">byte</span>=<span class="string">&#x27;h&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span> <span class="comment">//空的str</span></span><br><span class="line"></span><br><span class="line">str=strconv.FormatInt(<span class="type">int64</span>(num1),<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//strconv.FormatFloat(num2,&#x27;f&#x27;,10,64)</span></span><br><span class="line"><span class="comment">//说明：’f‘指格式，10：表示小数点后的位数，64：表示这个小数是float64</span></span><br><span class="line">str=strconv.FormatFloat(num2,<span class="string">&#x27;f&#x27;</span>,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">str=strconv.FormatBool(bool1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str的类型是%T，str=%v\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="number">99</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="number">12.2340000000</span></span><br><span class="line">str的类型是<span class="type">string</span>，str=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string类型转基本数据类型，实例演示</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span>=<span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="keyword">var</span> bool2 <span class="type">bool</span></span><br><span class="line"><span class="comment">//func ParseBool(str string) (value bool, err error)</span></span><br><span class="line"><span class="comment">//bool2, _ =strconv.ParseBool(str1)</span></span><br><span class="line"><span class="comment">//说明：</span></span><br><span class="line"><span class="comment">//1.函数返回两个值，(value bool, err error)</span></span><br><span class="line"><span class="comment">//2.因为我只关心第一个值value bool，所以用下划线忽略第二个值err error</span></span><br><span class="line">bool2, _ =strconv.ParseBool(str1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;bool2的类型%T,bool2=%v\n&quot;</span>,bool2,bool2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 <span class="type">string</span>=<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">var</span> num4 <span class="type">int64</span></span><br><span class="line">num4,_=strconv.ParseInt(str2,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;bool2的类型%T,bool2=%v\n&quot;</span>,num4,num4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str3 <span class="type">string</span>=<span class="string">&quot;123.456&quot;</span></span><br><span class="line"><span class="keyword">var</span> num5 <span class="type">float64</span></span><br><span class="line">num5,_=strconv.ParseFloat(str3,<span class="number">64</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;bool2的类型%T,bool2=%v\n&quot;</span>,num5,num5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">bool2的类型<span class="type">bool</span>,bool2=<span class="literal">true</span></span><br><span class="line">bool2的类型<span class="type">int64</span>,bool2=<span class="number">123</span></span><br><span class="line">bool2的类型<span class="type">float64</span>,bool2=<span class="number">123.456</span></span><br></pre></td></tr></table></figure>

<h3 id="9-指针"><a href="#9-指针" class="headerlink" title="9.指针"></a>9.指针</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.基本数据类型，变量存的是值，也叫值类型</span><br><span class="line">2.获取变量的地址，用&amp;，比如var num int,获取num的地址：&amp;num</span><br><span class="line">3.指针类型：指针变量存的是一个地址，这个地址指向的空间寸的才是值，比如var ptr *int=&amp;num</span><br><span class="line">4.获取指针类型所指向的值，使用：*，比如：var ptr *int,使用*ptr获取ptr指向的值</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意事项</span></span><br><span class="line">1.值类型都有对应的指针类型，形式为*数据类型，如*int,依次类推。</span><br><span class="line">2.值类型包括：基本数据类型int系列，，float系列，bool，string，数组和结构体struct（基本数据类型+数组+结构体）</span><br><span class="line">3.引用类型：指针，slice切片，map,管道chan,interface等都是引用类型</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>&#x3D;&#x3D;值类型和引用类型的区别&#x3D;&#x3D;<ol>
<li>值类型，变量直接存储值，内存通常在栈中分配</li>
<li>引用类型，变量存储的是一个地址，这个地址对应的空间才真正的存储数据值，内存通常在堆中分配空间，当没有变量引用这个地址时，该改地址对应的数据空间就成为一个垃圾，由GC来回收。</li>
</ol>
</li>
</ul>
</blockquote>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211012112204780.png" alt="image-20211012112204780"></p>
<h3 id="10-标识符"><a href="#10-标识符" class="headerlink" title="10.标识符"></a>10.标识符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本概念</span></span><br><span class="line">1.go中对各种变量、方法、函数等命名时使用的字符序列</span><br><span class="line">2.凡是可以自己取名字的都叫标识符</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">标识符的命名规则</span></span><br><span class="line">1.由26个英文字母大小写，0-9，_组成</span><br><span class="line">2.数字不可以开头</span><br><span class="line">3.严格区分大小写</span><br><span class="line">4.标识符不能包含空格</span><br><span class="line">5.不能用系统关键字（一共有25个），如break,if等</span><br><span class="line">6.下划线 _ 在go中是一个特殊的标识符，成为空标识符，可以代表任何其他的标识符，但是他它对应的值会被忽略（比如：忽略某个返回值），所以仅能作为占位符来使用，不能作为标识符来使用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">标识符命名的注意事项</span></span><br><span class="line">1.包名：保持package的名字和目录保持一致，尽量采取有意义的包名，简短有意义，不要和标准库冲突。(如标准库fmt)</span><br><span class="line">2.变量名，函数名，常量名：采用驼峰法</span><br><span class="line">3.如果变量名、函数名、常量名首字母大写，则可以被其他包访问，如果首字母小写，则只能在本包中使用（首字母大写是公有的 ，首字母小写是私有的，首字母大写类似于java中的public，可以在全局访问，在不同包中可以访问）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意根据标识符的大小写来决定一个成员是公有还是私有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.go文件中的内容</span></span><br><span class="line"><span class="comment">//我们使用utils.go的heroName  包名.标识符</span></span><br><span class="line">fmt.Println(model.HeroName)</span><br><span class="line"><span class="comment">//fmt.Println(model.heroName)//不可以访问utils.go中的私有成员，私有体现在标识符的开头首字母是否大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//utils.go文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"><span class="comment">//定义了一个变量</span></span><br><span class="line"><span class="keyword">var</span> HeroName <span class="type">string</span>=<span class="string">&quot;宋江&quot;</span></span><br><span class="line"><span class="keyword">var</span> heroName <span class="type">string</span>=<span class="string">&quot;songjiang&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>引入包的方式</strong></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211012132200454.png" alt="image-20211012132200454"></p>
<h3 id="11-运算符"><a href="#11-运算符" class="headerlink" title="11.运算符"></a>11.运算符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运算符介绍</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">算术运算符注意细节</span></span><br><span class="line">1.go语言中的++，--运算符只能独立使用。如var i int=3; var j int=i++ 会编译出错。</span><br><span class="line">2.go语言中的++，--只能放在变量后面， 即i++可以，++i就不可以</span><br></pre></td></tr></table></figure>

<h3 id="12-键盘输入语句"><a href="#12-键盘输入语句" class="headerlink" title="12.键盘输入语句"></a>12.键盘输入语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取用户键盘输入的数据，你就可以使用键盘输入语句来获取，InputDemo.go</span></span><br><span class="line"> </span><br><span class="line">1.步骤:</span><br><span class="line">	1.导入fmt包</span><br><span class="line">	2.调用fmt包的fmt.Scanln()或者fmt.Scanf()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例演示</span></span><br><span class="line"><span class="comment">//要求：可以从控制台接收用户信息，【姓名，年龄，薪水，是否通过考试】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1：fmt.Scanln</span></span><br><span class="line"><span class="comment">//1.先声明需要的变量</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> salary <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> test <span class="type">bool</span></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入姓名&quot;</span>)</span><br><span class="line"><span class="comment">//当程序执行到fmt.Scanln(&amp;name),程序会停在这里，等待用户输入，并回车</span></span><br><span class="line">fmt.Scanln(&amp;name)</span><br><span class="line">fmt.Println(<span class="string">&quot;请输入年龄&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;age)</span><br><span class="line">fmt.Println(<span class="string">&quot;请输入薪水&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;salary)</span><br><span class="line">fmt.Println(<span class="string">&quot;请输入是否考试&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;test)</span><br><span class="line">fmt.Println(name)</span><br><span class="line">fmt.Println(age)</span><br><span class="line">fmt.Println(salary)</span><br><span class="line">fmt.Println(test)</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">请输入姓名</span><br><span class="line">哈哈</span><br><span class="line">请输入年龄</span><br><span class="line"><span class="number">12</span></span><br><span class="line">请输入薪水</span><br><span class="line"><span class="number">123.45</span></span><br><span class="line">请输入是否考试</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">哈哈</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">123.45</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：fmt.Scanf</span></span><br><span class="line"><span class="comment">//1.先声明需要的变量</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> salary <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> test <span class="type">bool</span></span><br><span class="line">fmt.Println(<span class="string">&quot;请输出姓名，年龄，薪水，是否通过考试，用空格隔开&quot;</span>)</span><br><span class="line"><span class="comment">//注意这里面要输入多个时，用空格分割</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%s %d %f %t&quot;</span>,&amp;name,&amp;age,&amp;salary,&amp;test)</span><br><span class="line"></span><br><span class="line">fmt.Println(name)</span><br><span class="line">fmt.Println(age)</span><br><span class="line">fmt.Println(salary)</span><br><span class="line">fmt.Println(test)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">请输出姓名，年龄，薪水，是否通过考试，用空格隔开</span><br><span class="line">哈哈 <span class="number">12</span> <span class="number">123.45</span> <span class="literal">false</span></span><br><span class="line">哈哈</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">123.45</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="13-原码，反码，补码"><a href="#13-原码，反码，补码" class="headerlink" title="13.原码，反码，补码"></a>13.原码，反码，补码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意字节</span></span><br><span class="line">1.对于有符号数而言，二进制的最高位是符号位，正数为0，负数为1</span><br><span class="line">2.正数的原码，反码，补码都一样</span><br><span class="line">3.负数的反码=它的原码符号位不变，其他位取反</span><br><span class="line">4.负数的补码=它的反码+1</span><br><span class="line">5.0的反码，补码都是0</span><br><span class="line">6.在计算机运算的时候，都是以补码的方式来运算的</span><br></pre></td></tr></table></figure>

<h3 id="14-控制流程"><a href="#14-控制流程" class="headerlink" title="14.控制流程"></a>14.控制流程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">主要有3大流程控制语句</span></span><br><span class="line">1.顺序控制</span><br><span class="line">	程序从上至下顺序执行，中间没有任何判断和跳转</span><br><span class="line">2.分支控制 if-else  switch-case</span><br><span class="line">	让程序有选择执行</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="keyword">if</span>语句基本语法  注意事项：这里面的&#123;&#125;必须写，并且<span class="keyword">else</span>不能换行</span></span><br><span class="line">		双分支</span><br><span class="line">		if 条件表达式 &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		多分支</span><br><span class="line">		if 条件表达式 &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;else if 条件表达式&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">switch基本语法</span>  </span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">注意事项：</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">1.每一个<span class="keyword">case</span>分支都是唯一的，从上到下逐一测试，直到匹配为止。</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">2.<span class="keyword">case</span>里面可以写多个表达式(即常量，变量，一个有返回值的函数都可以)，如果是常量或者字面量，不能有重复。</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">3.匹配项后面也不需要加<span class="built_in">break</span>,因为go中他是匹配执行完后，直接默认<span class="built_in">break</span>了。</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">4.不论default放置的位置是在匹配项之前还是之后，都默认先进行匹配，匹配不上之后才执行default里面的语句</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">5.default语句不是必须的</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">6.switch后也可以不带表达式，类似if-else分支来使用</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">7.switch后也可以直接声明/定义一个变量，分号结束，不推荐，如switch age:=32; &#123;...&#125;</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">8.switch穿透 fallthrough,如果在<span class="keyword">case</span>语句块后增加fallthrough,则会在该<span class="keyword">case</span>执行完后继续执行后面的<span class="keyword">case</span>语句</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">9.Type Switch:switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型</span></span><br><span class="line">		switch 表达式&#123;</span><br><span class="line">			case 表达式1,表达式2：</span><br><span class="line">				语句</span><br><span class="line">			case 表达式3：</span><br><span class="line">				语句</span><br><span class="line">			default：</span><br><span class="line">				语句</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		switch当作if-else使用语法</span><br><span class="line">		var age int=32</span><br><span class="line">		switch &#123;  #switch后也可以直接声明/定义一个变量，分号结束，不推荐，如switch age:=32; &#123;...&#125;</span><br><span class="line">			case age==30:</span><br><span class="line">				语句1</span><br><span class="line">			case age&lt;=10:</span><br><span class="line">				语句2</span><br><span class="line">			case age&gt;=40</span><br><span class="line">				语句3</span><br><span class="line">			default:</span><br><span class="line">				语句4</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">3.循环控制 for  while</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="keyword">for</span>循环基本语法</span></span><br><span class="line">        for 循环变量初始化;循环条件；循环变量迭代&#123;</span><br><span class="line">            循环操作（语句）</span><br><span class="line">        &#125;</span><br><span class="line">    #for循环注意事项</span><br><span class="line">    	1.for循环的第二种使用方式</span><br><span class="line">    		for 循环判断条件&#123;</span><br><span class="line">    			//循环执行语句</span><br><span class="line">    		&#125;</span><br><span class="line">    		这里面是将变量初始化和变量迭代放在其他位置</span><br><span class="line">    	2.for循环的第三种使用方式</span><br><span class="line">    		for &#123;</span><br><span class="line">    			//循环执行语句</span><br><span class="line">    		&#125;</span><br><span class="line">    		上面的写法等同于 for ; ;&#123;&#125;是一个无限循环，通常需要借助break语句使用</span><br><span class="line">    	3.go语言也提供for-range的方式，可以方便遍历字符串和数组，同java中的for-each方式</span><br><span class="line">  			基本语法见下面的演示</span><br><span class="line">  			for index, val := range str &#123;</span><br><span class="line">                fmt.Printf(&quot;索引%d的值是%c&quot;,index,val)</span><br><span class="line">                fmt.Println()</span><br><span class="line">            &#125;</span><br><span class="line">            如果不需要使用index时，可以用_忽略  for _, val := range str</span><br><span class="line">       	4.如果我们的字符串含有中文，那么传统的遍历字符串方式，就是错误的，会出现乱码，原因是传统的对字符串的			 遍历是按照字节来遍历，而一个汉字在utf8编码中是对应3个字节。</span><br><span class="line">       		解决的方式是：需要将str转成[]rune 切片</span><br><span class="line">       		str:=&quot;你好生活&quot;</span><br><span class="line">            str2 := []rune(str)</span><br><span class="line">            for i:=0;i&lt;len(str2);i++&#123;</span><br><span class="line">                fmt.Printf(&quot;%c&quot;,str2[i])</span><br><span class="line">                fmt.Println()</span><br><span class="line">            &#125;</span><br><span class="line">       		</span><br><span class="line">       		上面的问题也可以直接使用for-range方式，就不用处理可以正确输出。</span><br><span class="line">       		str:=&quot;你好生活&quot;</span><br><span class="line">       		for _, val := range str &#123;</span><br><span class="line">                fmt.Printf(&quot;值是%c&quot;,val)</span><br><span class="line">                fmt.Println()</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">go语言中没有<span class="keyword">while</span>循环，但是可以使用<span class="keyword">for</span>循环来实现<span class="keyword">while</span>和do...while</span></span><br><span class="line">		1.while循环实现</span><br><span class="line">			循环变量初始化</span><br><span class="line">			for&#123;</span><br><span class="line">				if 循环条件表达式&#123;</span><br><span class="line">					break;  //跳出for循环</span><br><span class="line">				&#125;</span><br><span class="line">				循环操作语句</span><br><span class="line">				循环变量迭代</span><br><span class="line">			&#125;</span><br><span class="line">		2.do-while实现</span><br><span class="line">			循环变量初始化</span><br><span class="line">			for&#123;</span><br><span class="line">				循环操作语句</span><br><span class="line">				循环变量迭代</span><br><span class="line">				if 循环条件表达式&#123;</span><br><span class="line">					break; //跳出for循环</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">4.跳转控制语句 break，continue，goto，return</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">需求：随机生成1-100的一个数，直到生成了99这个数，看看你一共用了几次？</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">分析：编写一个无限循环的控制，然后不停的随机生成数，当生成了99时，就退出这个无线循环</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">提示使用：</span></span><br><span class="line">		//time.Now().Unix():返回一个从1979 1-1 0：0：0到现在的一个秒数</span><br><span class="line">		rand.Seed(time.Now().Unix())</span><br><span class="line">		fmt.Println(&quot;n=&quot;,rand.Intn(100)+1)</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">注意事项：</span></span><br><span class="line">		1.break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块，默认终止的是最近一个</span><br><span class="line">			基本语法</span><br><span class="line">				标签名1:for ... &#123;</span><br><span class="line">					标签名2:for ...&#123;</span><br><span class="line">						if ...&#123;</span><br><span class="line">						 	break 标签名1</span><br><span class="line">						&#125;</span><br><span class="line">						if ...&#123;</span><br><span class="line">							break 标签名2</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			演示</span><br><span class="line">				hello:for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">                    hai:for j := 0; j &lt; 10; j++ &#123;</span><br><span class="line">                        fmt.Println(j)</span><br><span class="line">                        if j==5 &amp;&amp; i==2&#123;</span><br><span class="line">                            break hello</span><br><span class="line">                        &#125;</span><br><span class="line">                        if j==3 &amp;&amp; i==1&#123;</span><br><span class="line">                            break hai</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">      	</span><br><span class="line">      	2.continue语句出现在多层嵌套时，可以通过标签指明要跳过的是哪一层语句块中的此次语句，默认跳过最近一			次循环</span><br><span class="line">      	</span><br><span class="line">      	3.goto语句可以无条件的转移到程序中指定的行</span><br><span class="line">      	4.goto语句通常与条件语句配合使用，可用来实现条件转移，跳出循环体等功能</span><br><span class="line">      	5.在go程序设计中一般不主张使用goto语句，以免造成混乱</span><br><span class="line">      		基本语法：</span><br><span class="line">      			goto label</span><br><span class="line">      			...</span><br><span class="line">      			label:statement</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if结构演示</span></span><br><span class="line"><span class="comment">//输出a,b中的最大值</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出a,b中的最大值</span></span><br><span class="line"><span class="comment">//golang在if中，支持定义一个变量,效果和上面等同</span></span><br><span class="line"><span class="keyword">if</span> a,b :=<span class="number">1</span>,<span class="number">2</span>;a&gt;b &#123;   <span class="comment">//但是不能这样if var a,b int=1,2;a&gt;b &#123;  </span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//switch结构演示</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span>=<span class="number">124</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span>=<span class="number">124</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="comment">//default的位置可以写在任意位置</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;我是终章&quot;</span>)</span><br><span class="line">    <span class="comment">//case表达式后可以接多个表达式，用逗号隔开，case语句块执行完后面不用加break，默认直接跳出</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">120</span>,<span class="number">124</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;我是case1&quot;</span>)</span><br><span class="line">    	<span class="keyword">fallthrough</span>  <span class="comment">//默认只能穿透一层，即在执行的时候不用判断后面那个表达式是否匹配直接执行里面的语句</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">121</span>,<span class="number">125</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;我是case2&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">122</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;我是case3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台语句</span></span><br><span class="line">我是case1</span><br><span class="line">我是case2</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环基本演示</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span> ; i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">5</span>&#123;</span><br><span class="line">    	<span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str:=<span class="string">&quot;12345&quot;</span></span><br><span class="line"><span class="comment">//遍历str字符串</span></span><br><span class="line"><span class="comment">//for循环演示</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(str);i++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c&quot;</span>,str[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for-range方式演示</span></span><br><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> str &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;索引%d的值是%c&quot;</span>,index,val)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">索引<span class="number">0</span>的值是<span class="number">1</span></span><br><span class="line">索引<span class="number">1</span>的值是<span class="number">2</span></span><br><span class="line">索引<span class="number">2</span>的值是<span class="number">3</span></span><br><span class="line">索引<span class="number">3</span>的值是<span class="number">4</span></span><br><span class="line">索引<span class="number">4</span>的值是<span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//break演示</span></span><br><span class="line">count :=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">    <span class="comment">//提供随机化种子</span></span><br><span class="line">    <span class="comment">//time.Now().Unix()，返回一个从1970 1-1 0：0：0到现在的一个纳秒数</span></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="comment">//rand.Intn(100)，生成一个[0,n)的值</span></span><br><span class="line">    n:=rand.Intn(<span class="number">100</span>)+<span class="number">1</span></span><br><span class="line">    count++</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">99</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(count)</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="comment">//break在多层嵌套中，使用标签的演示</span></span><br><span class="line">hello:<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    hai:<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">        fmt.Println(j)</span><br><span class="line">        <span class="keyword">if</span> j==<span class="number">3</span> &amp;&amp; i==<span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">break</span> hello</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j==<span class="number">2</span> &amp;&amp; i==<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">break</span> hai</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="15-常量"><a href="#15-常量" class="headerlink" title="15.常量"></a>15.常量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">1.常量使用const修饰的</span><br><span class="line">2.常量在定义的时候必须初始化</span><br><span class="line">3.常量不能修改</span><br><span class="line">4.常量只能修饰bool,数值类型（int,float系列），string类型</span><br><span class="line">5.语法：const 常量名 类型=value  //类型可写可不写</span><br><span class="line">	举例：</span><br><span class="line">		const name string=&quot;tom&quot;</span><br><span class="line">		const a int=12</span><br><span class="line">		const b=9/3</span><br><span class="line">		const c=getVal()  //这时会报错的</span><br><span class="line">6.常量在程序中声明定义初始化了，没有使用也不报错</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意事项：</span></span><br><span class="line">1.比较简介的写法：</span><br><span class="line">	const (</span><br><span class="line">		a =1</span><br><span class="line">		b =2</span><br><span class="line">	)</span><br><span class="line">2.还有一种专业的写法</span><br><span class="line">	const (</span><br><span class="line">		a=iota  //当将iota赋给一个常量时，此时这个值就等于从0开始属于第几行的数，如a,b,f,j</span><br><span class="line">		b=iota</span><br><span class="line">		c=1</span><br><span class="line">		d  	//当没有值赋给常量时，就根据它最上面的一个数是iota还是常量值，如果是常量值，它就也等于常量值</span><br><span class="line">		e</span><br><span class="line">		f=iota  </span><br><span class="line">		g	  //如果上面是iota，则就依次递增1</span><br><span class="line">		h=1</span><br><span class="line">		i</span><br><span class="line">		j=iota</span><br><span class="line">	)</span><br><span class="line">	fmt.Println(&quot;a=&quot;,a)   //a=0</span><br><span class="line">	fmt.Println(&quot;b=&quot;,b)   //b=1</span><br><span class="line">	fmt.Println(&quot;c=&quot;,c)	  //c=1	</span><br><span class="line">	fmt.Println(&quot;d=&quot;,d)   //d=1</span><br><span class="line">	fmt.Println(&quot;e=&quot;,e)   //e=1</span><br><span class="line">	fmt.Println(&quot;f=&quot;,f)   //f=5</span><br><span class="line">	fmt.Println(&quot;g=&quot;,g)   //g=6</span><br><span class="line">	fmt.Println(&quot;h=&quot;,h)   //h=1</span><br><span class="line">	fmt.Println(&quot;i=&quot;,i)   //i=1</span><br><span class="line">	fmt.Println(&quot;j=&quot;,j)   //j=9</span><br><span class="line">3.golang中没有要常量名必须大写的规范</span><br><span class="line">4.仍然通过首字母的大小写来控制常量的访问范围</span><br></pre></td></tr></table></figure>



<h2 id="第三章：函数"><a href="#第三章：函数" class="headerlink" title="第三章：函数"></a>第三章：函数</h2><h3 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.函数分为自定义函数，系统函数（API中的那些函数）</span><br><span class="line">2.基本语法</span><br><span class="line">	func 函数名 (形参列表) (返回值类型列表) &#123;</span><br><span class="line">		执行语句</span><br><span class="line">		return 返回值列表</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的使用演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//函数的快速入门问题</span></span><br><span class="line">	a:=<span class="number">1.2</span></span><br><span class="line">	b:=<span class="number">2.3</span></span><br><span class="line">	<span class="keyword">var</span> operate <span class="type">byte</span>=<span class="string">&#x27;+&#x27;</span></span><br><span class="line">	res:=cal(a,b,operate)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的计算函数cal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a <span class="type">float64</span>,b <span class="type">float64</span>,operate <span class="type">byte</span>)</span></span> <span class="type">float64</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> res <span class="type">float64</span></span><br><span class="line">	<span class="keyword">switch</span> operate &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">		res=a+b</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">		res=a-b</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">		res=a*b</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">		res=a/b</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;操作符输入失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-包的引出和使用原理"><a href="#2-包的引出和使用原理" class="headerlink" title="2.包的引出和使用原理"></a>2.包的引出和使用原理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">    1.包的本质实际上就是创建不同的文件夹，来存放程序文件</span><br><span class="line">    2.go的每一个文件都是属于一个包的,也就是说go是以包的形式来管理文件和项目目录结构的</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">包的三大作用</span></span><br><span class="line">    1.区分相同名字的函数、变量等标识符</span><br><span class="line">    2.当程序文件很多时，可以很好的管理项目</span><br><span class="line">    3.控制函数，变量等访问范围，即作用域</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">包的相关说明</span></span><br><span class="line">    打包基本语法</span><br><span class="line">        package util</span><br><span class="line">    引入包的基本语法</span><br><span class="line">        import &quot;包的路径&quot;   //import &quot;go_code/project01/utils&quot;  是从src的下一层目录开始写</span><br><span class="line">    使用包的函数语法</span><br><span class="line">        包名.函数名( )  //注意包中的函数名要大写才能被调用，否则就不能被调用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">包的使用细节和注意事项</span></span><br><span class="line">	1.在给一个文件打包时，该包对应的一个文件夹，比如utils文件夹对应的包名就是utils,文件的包名通常和文件所在		的文件夹名保持一致。</span><br><span class="line">	2.package指令要放在文件第一行，然后是import指令</span><br><span class="line">	3.在import包时，路径从$GOPATH的src下开始，不用带src,编译器自动从src下开始引入</span><br><span class="line">	4.可以给包取别名，此时就必须用别名进行使用。原来的包名就不能使用了</span><br><span class="line">		如import &quot;go_code/project01/utils&quot; 这里使用utils来进行访问，如utils.Cal</span><br><span class="line">        别名方式：</span><br><span class="line">        	import util &quot;go_code/project01/utils&quot;  此时就是用别名进行访问 如util.Cal</span><br><span class="line">       	特殊的别名有下划线_，此时表示忽略这个包名 </span><br><span class="line">  	5.在同一包下，不能有相同的函数名，否则报重复定义</span><br><span class="line">  	6.如果你要编译一个可执行程序文件，就需要把这个包声明为main,即package main,这个就是一个语法规范，如果	  你写一个库，包名可以自定义（程序文件只有main包中，才能够进行一个编译和运行）</span><br><span class="line">  		编译的指令，在项目目录下，编译路径不需要带src,编译器会自动带</span><br><span class="line">  			如 go build go_code/project01/main</span><br><span class="line">  		编译后生成一个有默认名的可执行文件，在$GOPATH目录下，可以指定名字和目录</span><br><span class="line">  			如放在bin目录下 go build -o bin/my.exe go_code/project01/main</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="3-函数调用机制"><a href="#3-函数调用机制" class="headerlink" title="3.函数调用机制"></a>3.函数调用机制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.<span class="built_in">return</span>语句</span></span><br><span class="line">基本语法：</span><br><span class="line">	go函数支持返回多个值，这一点是其他编程语言没有的</span><br><span class="line">	fun 函数名 （形参列表） （返回值类型列表）&#123;</span><br><span class="line">		语句...</span><br><span class="line">		return 返回值列表</span><br><span class="line">	&#125;</span><br><span class="line">	1.如果返回多个值时，在接收时，希望忽略某个值时，则使用_符号表示占位忽略</span><br><span class="line">	2.如果返回值只有一个，（返回值类型列表列表），可以不用（）</span><br></pre></td></tr></table></figure>

<h3 id="4-函数注意事项和细节讨论"><a href="#4-函数注意事项和细节讨论" class="headerlink" title="4.函数注意事项和细节讨论"></a>4.函数注意事项和细节讨论</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.函数改变函数外的变量</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">		change(&amp;n)</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(n *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		*n=*n+<span class="number">13</span></span><br><span class="line">        fmt.Println(*n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.go语言不支持函数重载，会报函数重复定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*3.在go中，函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了，通过该变量可以对函数调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.函数既然是一种数据类型，因此在go中，函数可以作为形参，并且调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.为了简化数据类型定义，go支持数据类型自定义</span></span><br><span class="line">	基本语法：<span class="keyword">type</span> 自定义数据类型名 数据类型  <span class="comment">//相当于一个别名,注意这一般需要放到main函数的外面</span></span><br><span class="line">	例如：</span><br><span class="line">		<span class="keyword">type</span> myint <span class="type">int</span>  <span class="comment">//这时myint就等价int来使用了  但是注意在将myint类型的值赋给int类型的变量时，						//依然需要显示转换</span></span><br><span class="line">		<span class="keyword">type</span> mySum <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span>  <span class="comment">//这时mySum就等价一个函数类型func(int,int) int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.支持对函数返回值命名，此时必须将返回值用括号括起来，即便是一个也需要括号</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> (sum <span class="type">int</span>,sub <span class="type">int</span>)&#123;</span><br><span class="line">        sum =n1+n2   <span class="comment">//注意这里面的sum和sub在返回值中已经定义了，所以不需要使用 := 进行定义调用</span></span><br><span class="line">        sub =n1-n2</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.使用_标识符，忽略返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8.go支持可变参数</span></span><br><span class="line">	<span class="comment">//支持0到多个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args... <span class="type">int</span>)</span></span> sum <span class="type">int</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//支持1到多个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>,args... <span class="type">int</span>)</span></span> sum <span class="type">int</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//注意</span></span><br><span class="line">		<span class="number">1.</span>args是slice(切片)，通过args[index] 可以访问到各个值</span><br><span class="line">		<span class="number">2.</span>案例演示，编写一个sum，可以求出<span class="number">1</span>到多个<span class="type">int</span>的和</span><br><span class="line">		<span class="number">3.</span>如果一个函数的形参列表中有可变参数，则可变参数需要放在形参列表最后</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.函数的形参还可以这样输入,例如下面的例子，a和b就都是int类型的</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示 3,4,5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数也可以是一种数据类型，同时还可以作为值传递给变量</span></span><br><span class="line">	a:=fib</span><br><span class="line">	fmt.Printf(<span class="string">&quot;a的类型是%T,fib的类型是%T\n&quot;</span>,a,fib)</span><br><span class="line"></span><br><span class="line">	res:=a(<span class="number">5</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line"></span><br><span class="line">	myFunc(a,<span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int32</span>)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n==<span class="number">1</span>||n==<span class="number">2</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数也可以作为形参进行传递，并调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(funVar <span class="keyword">func</span>(<span class="type">int32</span>)</span></span> <span class="type">int32</span>,n <span class="type">int32</span>)  &#123;</span><br><span class="line">		res:=funVar(n)</span><br><span class="line">		fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">a的类型是<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int32</span>)</span></span> <span class="type">int32</span>,fib的类型是<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int32</span>)</span></span> <span class="type">int32</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//演示8，支持可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	res:=sumTest(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例演示，编写一个函数，求解1到多个int的和</span></span><br><span class="line"><span class="comment">//arr是一个切片类型，类似于数组的使用，len(arr)求切片的长度，arr[i]求第i+1个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumTest</span><span class="params">(n1 <span class="type">int</span>,arr... <span class="type">int</span>)</span></span> (count <span class="type">int</span>)&#123;  </span><br><span class="line">	count=n1</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		count+=val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-init函数使用"><a href="#5-init函数使用" class="headerlink" title="5.init函数使用"></a>5.init函数使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍：</span></span><br><span class="line">	每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被go运行框架调用，也就是说init函数会在main函数前被调用</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意事项和使用细节</span></span><br><span class="line">1.如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程是变量定义-&gt;init函数-&gt;main函数</span><br><span class="line">2.最主要作用完成初始化工作</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> age =test()   <span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">	<span class="keyword">return</span> <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init函数使用演示，在main函数执行前被调用</span></span><br><span class="line"><span class="comment">//作用：通常在init函数中完成初始化工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;init&quot;</span>) <span class="comment">//2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;main&quot;</span>) <span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">test</span><br><span class="line">init</span><br><span class="line">main</span><br></pre></td></tr></table></figure>

<h3 id="6-匿名函数"><a href="#6-匿名函数" class="headerlink" title="6.匿名函数"></a>6.匿名函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">go支持匿名函数，如果我们某个函数只希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匿名函数使用方式：</span></span><br><span class="line">	1.在定义匿名函数时直接使用，这种方式匿名函数只能使用一次</span><br><span class="line">	2.将匿名函数赋值给一个变量（函数变量），再通过变量来使用匿名函数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局匿名函数</span></span><br><span class="line">	1.如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示匿名函数的使用方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">//fun1就是一个全局匿名函数</span></span><br><span class="line">	fun1= <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1*n2</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//调用全局匿名函数</span></span><br><span class="line">	fmt.Println(fun1(<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在定义匿名函数直接调用,这种方式匿名函数只能使用一次，更多的时候是使用这一种</span></span><br><span class="line">	res:= <span class="function"><span class="keyword">func</span><span class="params">(n1,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1+n2</span><br><span class="line">	&#125;(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">//直接赋值</span></span><br><span class="line">	fmt.Println(res)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将匿名函数传给一个变量（函数变量），则res2的数据类型就是函数类型，此时我们可以通过res2完成调用</span></span><br><span class="line">	<span class="comment">//可以执行多次</span></span><br><span class="line">	res2:= <span class="function"><span class="keyword">func</span><span class="params">(n1,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1+n2</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(res2(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">	fmt.Println(res2(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.闭包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">闭包就是一个函数与其相关的引用环境组合的一个整体（实体）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		n=n+x</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	f:=AddUpper()</span><br><span class="line">	fmt.Println(f(<span class="number">1</span>))  <span class="comment">//11</span></span><br><span class="line">	fmt.Println(f(<span class="number">2</span>))  <span class="comment">//13</span></span><br><span class="line">	fmt.Println(f(<span class="number">3</span>))  <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对上面代码的说明</span></span><br><span class="line"><span class="number">1.</span>AddUppper是一个函数，返回的数据类型是fun(<span class="type">int</span>) <span class="type">int</span></span><br><span class="line"><span class="number">2.</span>闭包的说明：返回的是一个匿名函数，但这个匿名函数引用到函数外的n,因此这个匿名函数就和n形成一个整体，就叫闭包</span><br><span class="line"><span class="number">3.</span>可以这样理解，闭包是类，函数是操作，n是字段</span><br><span class="line"><span class="number">4.</span>当我们反复的调用f函数时，因为n时初始化一次，因此每调用一次就进行累加</span><br><span class="line"><span class="number">5.</span>闭包的关键，就是要分析出返回的函数它使用（引用）到哪些变量，因为函数和它引用到的变量共同构成闭包</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包代码练习</span></span><br><span class="line"><span class="comment">//闭包使用练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffix</span><span class="params">(suffix <span class="type">string</span>)</span></span>  <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">		<span class="comment">//strings.HasSuffix(str,suffix) bool 该函数判断字符串str的后缀是否是suffix</span></span><br><span class="line">		<span class="keyword">if</span> strings.HasSuffix(str,suffix)&#123;</span><br><span class="line">			<span class="keyword">return</span> str</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> str+suffix</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffix2</span><span class="params">(str <span class="type">string</span>,suffix <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> strings.HasSuffix(str,suffix)&#123;</span><br><span class="line">		<span class="keyword">return</span> str</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> str+suffix</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mySuffix:=makeSuffix(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">	fmt.Println(mySuffix(<span class="string">&quot;aaa&quot;</span>))</span><br><span class="line">	fmt.Println(mySuffix(<span class="string">&quot;bbb.jpg&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">aaa.jpg</span><br><span class="line">bbb.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码说明</span></span><br><span class="line"><span class="number">1.</span>返回的函数和makeSuffix(suffix <span class="type">string</span>)的suffix变量组合成为一个闭包，因为返回的函数引用到了suffix这个变量</span><br><span class="line"><span class="number">2.</span>体会一下闭包的好处，如果使用传统的方法也能实现这个功能，但是传统的方法需要每次都传入后缀名，比如.jpg.而闭包因为可以保留上次引用的某个值，所以我们传入一次就可以反复使用。</span><br></pre></td></tr></table></figure>

<h3 id="8-函数中的defer"><a href="#8-函数中的defer" class="headerlink" title="8.函数中的defer"></a>8.函数中的defer</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍 为什么需要defer</span></span><br><span class="line">在函数中，程序员经常需要创建资源（比如数据库连接，文件句柄，锁等），为了在函数执行完毕后，及时的释放资源，go语言的设计者提供defer机制（延时机制）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">defer注意事项和使用细节</span></span><br><span class="line">1.当go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入到一个栈中，然后继续执行函数下一条语句</span><br><span class="line">2.当函数执行完毕后，再执行defer栈中的语句，按照先入后出的顺序</span><br><span class="line">3.**在defer将语句放入到栈时，也会将相关的值拷贝同时入栈</span><br><span class="line">4.当函数执行完毕后，可以及时的释放函数创建的资源，有点类似于finally里面释放资源（如数据库连接，字节流）</span><br><span class="line">	func test()&#123;</span><br><span class="line">		connect =openDatabase() </span><br><span class="line">		defer connect.close()  //可以让程序员不用关心何时关闭资源而烦心，在derfer之后可以继续创建资源</span><br><span class="line">	&#125;</span><br><span class="line">5.不要在defer语句后面执行赋值或者初始化等操作。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	res:=sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">	<span class="comment">//当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈（defer栈）</span></span><br><span class="line">	<span class="comment">//当函数执行完毕后，再从defer栈中，按照先入后出的方式出栈，执行</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n1的值：&quot;</span>,n1)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n2的值:&quot;</span>,n2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//演示注意细节第三点，即便后面修改了n1为20，但是defer栈中的n1依然为当时进栈时存入的那个值10，因此后面defer中输出的还是10</span></span><br><span class="line">    n1=<span class="number">20</span></span><br><span class="line">	</span><br><span class="line">    res:=n1+n2</span><br><span class="line">	fmt.Println(<span class="string">&quot;res的值：&quot;</span>,res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">res的值： <span class="number">30</span></span><br><span class="line">n2的值: <span class="number">20</span></span><br><span class="line">n1的值： <span class="number">10</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="9-变量作用域"><a href="#9-变量作用域" class="headerlink" title="9.变量作用域"></a>9.变量作用域</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本规则</span></span><br><span class="line">1.函数内部声明/定义的变量叫局部变量，作用域仅在函数内部</span><br><span class="line">2.函数外部声明/定义的变量叫全局变量，作用域在整个包有效，如果其首字母为大写，则在整个程序有效</span><br><span class="line">3.如果变量是在一个代码块中，比如if/for中，那么这个变量的作用域就在该代码块中</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意</span></span><br><span class="line">var name string=&quot;hello&quot;</span><br><span class="line">//nameErr:=&quot;error&quot;  //等价于 var nameErr string; nameErr=&quot;error ,此处会报错，</span><br><span class="line">				 //因为nameErr=&quot;err&quot;是执行语句，不能在函数外执行</span><br><span class="line">func main()&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		n1:=100</span><br><span class="line">		fmt.Println(n1)</span><br><span class="line">	&#125;</span><br><span class="line">	n1:=10</span><br><span class="line">	n2:=20</span><br><span class="line">	res:=sum(&amp;n1,&amp;n2)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-字符串中常用的系统函数"><a href="#10-字符串中常用的系统函数" class="headerlink" title="10.字符串中常用的系统函数"></a>10.字符串中常用的系统函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字符串中常用系统函数  strings包 strconv包</span></span><br><span class="line">1.统计字符串的长度，按字节 len(str) //这是内置的函数 </span><br><span class="line">2.字符串遍历，同时处理有中文的问题， arr:=[]rune(str)</span><br><span class="line">3.字符串转整数 n,err=strconv.Atoi(&quot;12&quot;)</span><br><span class="line">4.整数转字符串 str=strconv.Itoa(12345)</span><br><span class="line">5.字符串转byte[] var bytes=[]byte(&quot;hello go&quot;)</span><br><span class="line">6.byte[]转字符串 str=string([]byte&#123;97,98,99&#125;)</span><br><span class="line">7.10进制转2，8，16进制： str=strconv.FormatInt(123,2)  //2指转换为2进制</span><br><span class="line">8.查找子串是否在指定的字符串中：strings.Contains(&quot;seafood&quot;,&quot;foo&quot;)  //结果为true</span><br><span class="line">9.统计一个字符串中有几个指定的字串：strings.Count(&quot;seafoodfootjjFoou&quot;,&quot;foo&quot;) //3</span><br><span class="line">10.不区分大小写的字符串比较（==是区分大小写的）：fmt.Println(strings.EqualFold(&quot;abc&quot;,&quot;Abc&quot;))//true</span><br><span class="line">11.返回子串在字符串中第一次出现的index值，如果没有返回-1，strings.Index(&quot;NLP_abc&quot;,&quot;abc&quot;)  //4</span><br><span class="line">12.返回子串在字符串最后一次出现的index,如没有就返回-1，strings.LastIndex(&quot;go golang&quot;,&quot;go&quot;)</span><br><span class="line">13.将指定的字符串替换成另外一个子串：strings.Replace(&quot;go go hello&quot;,&quot;go&quot;,&quot;go语言&quot;,n) n可以指定你希望替换几个，如果n=-1表示全部替换</span><br><span class="line">14.按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组，strings.Split(&quot;hello,world,ok&quot;,&quot;,&quot;) </span><br><span class="line">15.将字符串的字母进行大小写的转换：strings.ToLower(&quot;Go&quot;) //strings.ToUpeer(&quot;Go&quot;)</span><br><span class="line">16.将字符串左右两边的空格去掉，strings.TrimSpace(&quot; tn a lo her ntm   &quot;) //tn a lo her ntm</span><br><span class="line">17.将字符串左右两边指定的字符去掉，strings,Trim(&quot;!!!!Hell!!!ooo!!!&quot;,&quot;!&quot;) //hell!!!ooo</span><br><span class="line">18.将字符串左边的指定字符去掉，strings.TrimLeft(&quot;!hello!!&quot;,&quot;!&quot;)  //hello!!</span><br><span class="line">19.将字符串右边的指定字符去掉，strings.TrimRight(&quot;!hello!!&quot;,&quot;!&quot;) //！hello</span><br><span class="line">20.判断字符串是否以指定的字符串开头：strings.HasPrefix(&quot;ftp://192.168.10.1&quot;,&quot;ftp&quot;) //true</span><br><span class="line">21.判断字符串是否以指定的字符串结束：strings.HasSuffix(&quot;NLP_abc.jpg&quot;,&quot;.jpg&quot;) //true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//字符串中常用系统函数</span></span><br><span class="line">	<span class="comment">//1.统计字符串的长度，按字节 len(str) //这是内置的函数 在builtin包中</span></span><br><span class="line">	str:=<span class="string">&quot;hello&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;str的长度为&quot;</span>,<span class="built_in">len</span>(str))</span><br><span class="line">	<span class="comment">//golang的编码统一为utf-8 （ascii的字符（字母和数字）占一个字节，汉字占用3个字节）</span></span><br><span class="line">	str1:=<span class="string">&quot;hello中&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;str1长度为：&quot;</span>,<span class="built_in">len</span>(str1))</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.字符串遍历，同时处理有中文的问题， arr:=[]rune(str)</span></span><br><span class="line">	str2:=<span class="string">&quot;hello北京&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str2); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;字符%c\n&quot;</span>,str2[i])  <span class="comment">//此时中文部分会乱码</span></span><br><span class="line">	&#125;</span><br><span class="line">	str3:=[]<span class="type">rune</span>(str2)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str3); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;字符%c\n&quot;</span>,str3[i])  <span class="comment">//此时中文乱码就得到了解决</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//3.字符串转整数 n,err=strconv.Atoi(&quot;12&quot;)</span></span><br><span class="line">	n,err:=strconv.Atoi(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;  <span class="comment">//转换成功，则err接收到的就是nil</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;转换错误&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;转换而成的结果是：&quot;</span>,n)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//4.整数转字符串 str=strconv.Itoa(12345)</span></span><br><span class="line">	str4:=strconv.Itoa(<span class="number">12345</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str的类型是%T,str的值是%v\n&quot;</span>,str4,str4)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//5.字符串转byte[] var bytes=[]byte(&quot;hello go&quot;)</span></span><br><span class="line">	<span class="keyword">var</span> bytes=[]<span class="type">byte</span>(<span class="string">&quot;hello go&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;bytes=%v\n&quot;</span>,bytes)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(bytes); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;字符%c&quot;</span>,bytes[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//6.byte[]转字符串 str=string([]byte&#123;97,98,99&#125;)</span></span><br><span class="line">	str6:=<span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str6类型%T,str6值是%v\n&quot;</span>,str6,str6)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//7.10进制转2，8，16进制： str=strconv.FormatInt(123,2)  //2指转换为2进制</span></span><br><span class="line">	str7:=strconv.FormatInt(<span class="number">123</span>,<span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str7类型%T,123对应的二进制是%v\n&quot;</span>,str7,str7)</span><br><span class="line">	str8:=strconv.FormatInt(<span class="number">123</span>,<span class="number">8</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str8类型%T,123对应的八进制是%v\n&quot;</span>,str8,str8)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//8.查找子串是否存在指定的字符串中：strings.Contains(&quot;seafood&quot;,&quot;foo&quot;)  //结果为true</span></span><br><span class="line">	b:=strings.Contains(<span class="string">&quot;seafood&quot;</span>,<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//9.统计一个字符串中有几个指定的字串：strings.Count(&quot;seafoodfootjjfoou&quot;,&quot;foo&quot;) //3</span></span><br><span class="line">	count:=strings.Count(<span class="string">&quot;seafoodfootjuFooldd&quot;</span>,<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;出现foo字串的次数是:&quot;</span>,count)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//10.不区分大小写的字符串比较（==是区分大小写的）：fmt.Println(strings.EqualFold(&quot;abc&quot;,&quot;Abc&quot;))//true</span></span><br><span class="line">	fmt.Println(strings.EqualFold(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;Abc&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;abc&quot;</span>==<span class="string">&quot;Abc&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//11.返回子串在字符串中第一次出现的index值，如果没有返回-1，strings.Index(&quot;NLP_abc&quot;,&quot;abc&quot;)  //4</span></span><br><span class="line">	in:=strings.Index(<span class="string">&quot;NLP_abc&quot;</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;abc的位置在下标：&quot;</span>,in)</span><br><span class="line">	in2:=strings.Index(<span class="string">&quot;NLP中_abc&quot;</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;abc的位置在下标：&quot;</span>,in2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//12.返回子串在字符串最后一次出现的index,如没有就返回-1，strings.LastIndex(&quot;go golang&quot;,&quot;go&quot;)</span></span><br><span class="line">	in12:=strings.LastIndex(<span class="string">&quot;go golang&quot;</span>,<span class="string">&quot;go&quot;</span>)</span><br><span class="line">	fmt.Println(in12)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//13.将指定的字符串替换成另外一个子串：strings.Replace(&quot;go go hello&quot;,&quot;go&quot;,&quot;go语言&quot;,n)</span></span><br><span class="line">	<span class="comment">//,n可以指定你希望替换几个，如果n=-1表示全部替换</span></span><br><span class="line">	str13:=strings.Replace(<span class="string">&quot;go go hello&quot;</span>,<span class="string">&quot;go&quot;</span>,<span class="string">&quot;go语言&quot;</span>,<span class="number">2</span>)</span><br><span class="line">	fmt.Println(str13)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//14.按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组，strings.Split(&quot;hello,world,ok&quot;,&quot;,&quot;)</span></span><br><span class="line">	strArr:=strings.Split(<span class="string">&quot;hello,world,ok&quot;</span>,<span class="string">&quot;,&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(strArr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//15.将字符串的字母进行大小写的转换：strings.ToLower(&quot;Go&quot;) //strings.ToUpeer(&quot;Go&quot;)</span></span><br><span class="line">	str15:=strings.ToLower(<span class="string">&quot;Go&quot;</span>)</span><br><span class="line">	fmt.Println(str15)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//16.将字符串左右两边的空格去掉，strings.TrimSpace(&quot; tn a lo her ntm   &quot;) //tn a lo her ntm</span></span><br><span class="line">	str16:=strings.TrimSpace(<span class="string">&quot; tn a lo her ntm   &quot;</span>)</span><br><span class="line">	fmt.Println(str16)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//17.将字符串左右两边指定的字符去掉，strings.Trim(&quot;!!!!Hell!!!ooo!!!&quot;,&quot;!&quot;) //hell!!!ooo</span></span><br><span class="line">	str17:=strings.Trim(<span class="string">&quot;!!!!Hell!!!ooo!!!&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">	fmt.Println(str17)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//18.将字符串左边的指定字符去掉，strings.TrimLeft(&quot;!hello!!&quot;,&quot;!&quot;)  //hello!!</span></span><br><span class="line">	str18:=strings.TrimLeft(<span class="string">&quot;!hello!!&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">	fmt.Println(str18)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//19.将字符串右边的指定字符去掉，strings.TrimRight(&quot;!hello!!&quot;,&quot;!&quot;) //！hello</span></span><br><span class="line">	str19:=strings.TrimRight(<span class="string">&quot;!hello!!&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">	fmt.Println(str19)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//20.判断字符串是否以指定的字符串开头：strings.HasPrefix(&quot;ftp://192.168.10.1&quot;,&quot;ftp&quot;) //true</span></span><br><span class="line">	b20:=strings.HasPrefix(<span class="string">&quot;ftp://192.168.10.1&quot;</span>,<span class="string">&quot;ftp&quot;</span>)</span><br><span class="line">	fmt.Println(b20)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//21.判断字符串是否以指定的字符串结束：strings.HasSuffix(&quot;NLP_abc.jpg&quot;,&quot;.jpg&quot;) //true</span></span><br><span class="line">	b21:=strings.HasSuffix(<span class="string">&quot;NLP_abc.jpg&quot;</span>,<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">	fmt.Println(b21)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-时间和日期相关函数"><a href="#11-时间和日期相关函数" class="headerlink" title="11.时间和日期相关函数"></a>11.时间和日期相关函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">在编程中，程序员经常用到日期函数，比如：统计某段代码执行花费的时间</span><br><span class="line">1.时间和日期相关函数，需要导入time包</span><br><span class="line">2.time.Time类型，用于表示时间</span><br><span class="line">3.获取到当前时间的方法</span><br><span class="line">	now:=time.Now() //now的类型就是time.Time</span><br><span class="line">4.如何获取到其他的日期信息</span><br><span class="line">5.格式化 日期时间</span><br><span class="line">	格式化的第一种方式</span><br><span class="line">		now:=time.Now()</span><br><span class="line">		fmt.Printf(&quot;当前年月日 %d-%d-%d %d:%d:%d\n&quot;,</span><br><span class="line">           now.Year(),now.Month(),now.Day(),</span><br><span class="line">           now.Hour(),now.Minute(),now.Second())</span><br><span class="line">  	格式化的第二种方式</span><br><span class="line">  		fmt.Println(now.Format(&quot;2006/01/02 15:04:05&quot;))</span><br><span class="line">        fmt.Println(now.Format(&quot;2006/01/02&quot;))</span><br><span class="line">        fmt.Println(now.Format(&quot;15:04:05&quot;))</span><br><span class="line">        fmt.Println(now.Format(&quot;02 15:05&quot;))</span><br><span class="line">6.时间的常量</span><br><span class="line">	const (</span><br><span class="line">        Nanosecond  Duration = 1  //纳秒</span><br><span class="line">        Microsecond          = 1000 * Nanosecond //微秒</span><br><span class="line">        Millisecond          = 1000 * Microsecond //毫秒</span><br><span class="line">        Second               = 1000 * Millisecond //秒</span><br><span class="line">        Minute               = 60 * Second</span><br><span class="line">        Hour                 = 60 * Minute</span><br><span class="line">    )</span><br><span class="line">    常量的作用：在程序中可用于获取指定时间单位的时间，比如想得到100毫秒</span><br><span class="line">    100*time.Millisecond  </span><br><span class="line">7.休眠（结合sleep）</span><br><span class="line">	func Sleep(d Duration)</span><br><span class="line">8.获取当前Unix时间戳和unixnano时间戳（作用是可以获取随机的数字）</span><br><span class="line">	unix时间戳</span><br><span class="line">	unixnano时间戳</span><br><span class="line">	用法：</span><br><span class="line">    func (t Time) Unix() int64</span><br><span class="line">    Unix将t表示为Unix时间，即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位秒）。</span><br><span class="line">    </span><br><span class="line">    func (t Time) UnixNano() int64</span><br><span class="line">    UnixNano将t表示为Unix时间，即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位纳秒）。如果纳	秒为单位的unix时间超出了int64能表示的范围，结果是未定义的。注意这就意味着Time零值调用UnixNano方法的	话，结果是未定义的。</span><br><span class="line">9.最佳实践案例：求解函数test03执行的时间</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="comment">//看看日期和时间相关的函数和方法使用</span></span><br><span class="line"><span class="comment">//1.获取当前时间</span></span><br><span class="line">now:=time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;now类型是%T,now的值是%v\n&quot;</span>,now,now)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过now可以获取到年月日，时分秒</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;年=%v\n&quot;</span>,now.Year())</span><br><span class="line">fmt.Printf(<span class="string">&quot;月=%v\n&quot;</span>,<span class="type">int</span>(now.Month()))</span><br><span class="line">fmt.Printf(<span class="string">&quot;日=%v\n&quot;</span>,now.Day())</span><br><span class="line">fmt.Printf(<span class="string">&quot;时=%v\n&quot;</span>,now.Hour())</span><br><span class="line">fmt.Printf(<span class="string">&quot;分=%v\n&quot;</span>,now.Minute())</span><br><span class="line">fmt.Printf(<span class="string">&quot;秒=%v\n&quot;</span>,now.Second())</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化日期输出</span></span><br><span class="line"><span class="comment">//第一种方式 其中-和：可以自己定义</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;当前年月日 %d-%d-%d %d:%d:%d\n&quot;</span>,</span><br><span class="line">           now.Year(),now.Month(),now.Day(),</span><br><span class="line">           now.Hour(),now.Minute(),now.Second())</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式格式化后赋值给一个变量</span></span><br><span class="line">dateStr:=fmt.Sprintf(<span class="string">&quot;当前年月日 %d-%d-%d %d:%d:%d\n&quot;</span>,</span><br><span class="line">                     now.Year(),now.Month(),now.Day(),</span><br><span class="line">                     now.Hour(),now.Minute(),now.Second())</span><br><span class="line">fmt.Println(dateStr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种格式化方式</span></span><br><span class="line"><span class="comment">//说明： &quot;2006/01/02 15:04:05&quot;这个字符串的各个数字是固定的</span></span><br><span class="line"><span class="comment">//必须是这样写，但是这个字符串各个数字可以自由组合</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;02 15:05&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求1：每隔1秒中打印一个数字，打印到100时就退出</span></span><br><span class="line"><span class="comment">//需求2：每隔0.1秒中打印一个数字，打印到100时就退出</span></span><br><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    <span class="comment">//休眠</span></span><br><span class="line">    <span class="comment">//需求1</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="comment">//需求2</span></span><br><span class="line">    time.Sleep(<span class="number">100</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">10</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳，unix和unixnano的使用</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;unix时间戳=%v unixnano时间戳=%v&quot;</span>,now.Unix(),now.UnixNano())</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="comment">//求解函数test03执行的时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//在执行test03前，先获取到当前的unix时间戳</span></span><br><span class="line">	start:=time.Now().Unix()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;start类型%T，start值是%v\n&quot;</span>,start,start)</span><br><span class="line">	test03()</span><br><span class="line">	end:=time.Now().Unix()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;end类型%T，end值是%v\n&quot;</span>,end,end)</span><br><span class="line">	fmt.Println(<span class="string">&quot;执行test03()消耗的时间&quot;</span>,end-start)</span><br><span class="line">	fmt.Println(<span class="number">1634482665</span><span class="number">-1634482650</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test03</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	str:=<span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">		str+=<span class="string">&quot;hello&quot;</span>+strconv.Itoa(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-内置函数"><a href="#12-内置函数" class="headerlink" title="12.内置函数"></a>12.内置函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明</span></span><br><span class="line">go设计者为了编程方便，提供了一些函数，可以直接使用，不用导包，我们称之为内置函数。  主要见builtin包</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">常用内置函数</span></span><br><span class="line">1.len：用来求长度，比如string，array，slice,map,channel</span><br><span class="line">2.new：用来分配内存，主要用来分配值类型，比如int,float32,struct...返回的是指针</span><br><span class="line">3.make:用来分配内存，主要用来分配引用类型，比如chan,map,slice</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line">num1:=<span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;num1的类型=%T，num1的值=%v,num1的地址=%v\n&quot;</span>,num1,num1,&amp;num1)</span><br><span class="line">num2:= <span class="built_in">new</span>(<span class="type">int</span>)  <span class="comment">// num2的类型是 *int</span></span><br><span class="line"><span class="comment">//num2的类型=*int</span></span><br><span class="line"><span class="comment">//num2的值= 地址？0xc00000a0c0  (这个地址不能更改，由系统分配)</span></span><br><span class="line"><span class="comment">//num2的地址=地址？0xc000006030 (这个地址不能更改，由系统分配)</span></span><br><span class="line"><span class="comment">//num2指向的值 默认初始是0，后面可以通过*num2进行更改</span></span><br><span class="line">*num2=<span class="number">100</span></span><br><span class="line">fmt.Println(*num2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;num2的类型=%T，num2的值=%v,num2的地址=%v,num2指针指向的值%v&quot;</span>,num2,num2,&amp;num2,*num2)</span><br></pre></td></tr></table></figure>

<h2 id="第四章：错误处理"><a href="#第四章：错误处理" class="headerlink" title="第四章：错误处理"></a>第四章：错误处理</h2><h3 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1.错误处理"></a>1.错误处理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍 为什么引入错误处理</span></span><br><span class="line">1.在默认情况下，当发生错误（panic）后,程序就会退出</span><br><span class="line">2.如果我们希望，当发生错误后，可以捕获到错误，并进行处理，保证程序可以继续执行，还可以在捕获到错误后，给管理员一个提示</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本说明</span></span><br><span class="line">1.go语言追求简介优雅，所以，go语言不支持try,catch,finally这种处理</span><br><span class="line">2.go中引入的处理方式是：defer,panic,recover</span><br><span class="line">3.这几个异常的使用场景可以这么简单描述：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用defer+recover结合来捕获并处理异常</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误处理的演示代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	test03()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test03</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//使用defer+recover来捕获异常</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := <span class="built_in">recover</span>() <span class="comment">//recover()内置函数，可以捕获到异常</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	n1:=<span class="number">10</span></span><br><span class="line">	n2:=<span class="number">0</span></span><br><span class="line">	n3:=n1/n2</span><br><span class="line">	fmt.Println(n3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义异常"><a href="#2-自定义异常" class="headerlink" title="2.自定义异常"></a>2.自定义异常</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本说明</span></span><br><span class="line">go程序中也支持自定义错误，使用errors.New和panic内置函数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line">1.errors.New(&quot;错误说明&quot;)，会返回一个error类型的值，表示一个错误</span><br><span class="line">2.panic内置函数，接收一个interface&#123;&#125;类型的值（也就是任何值）作为参数，可以接收error类型的变量，输出错误信息，并退出程序</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例演示</span></span><br><span class="line"><span class="comment">//函数去读取配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，我们就返回一个自定义的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;init.conf&quot;</span>&#123;</span><br><span class="line">		<span class="comment">//读取</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//返回一个自定义错误</span></span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	err:=readConf(<span class="string">&quot;init.conf2&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="comment">//如果读取文件发生错误，就输出这个错误，并终止程序</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;test02后面的代码&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//自定义代码的测试</span></span><br><span class="line">	test02()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第五章：数组和切片和map"><a href="#第五章：数组和切片和map" class="headerlink" title="第五章：数组和切片和map"></a>第五章：数组和切片和map</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.数组也是一种数据类型，在go中，数组是值类型</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组的定义</span></span><br><span class="line">	var 数组名 [数组大小]数据类型</span><br><span class="line">	var arr [5]int  //数组定义后都会有一个默认值</span><br><span class="line">	赋初值 arr[0]=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组的使用</span></span><br><span class="line">    1.访问数组元素</span><br><span class="line">        数组名[下标] 如arr[2]</span><br><span class="line">    2.四种默认初始化数组的方式</span><br><span class="line">        1.var arr [3]int=[3]int&#123;1,2,3&#125;</span><br><span class="line">        2.var arr=[3]int&#123;1,2,3&#125;</span><br><span class="line">        3.var arr=[...]int&#123;1,2,3&#125;</span><br><span class="line">        4.var arr=[3]string&#123;1:&quot;hehe&quot;,2:&quot;haha&quot;,0:&quot;xixi&quot;&#125;</span><br><span class="line">        5.arr:=[3]string&#123;1:&quot;hehe&quot;,2:&quot;haha&quot;,0:&quot;xixi&quot;&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组的遍历</span></span><br><span class="line">	1.for循环</span><br><span class="line">	2.for-range</span><br><span class="line">		基本语法：</span><br><span class="line">			for index,value := range arr&#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		说明：</span><br><span class="line">		1.第一个返回值是index,数组的下标</span><br><span class="line">		2.第二个value是在该下标位置的值</span><br><span class="line">		3.他们都是仅在for循环内部可见的局部变量</span><br><span class="line">		4.遍历数组时，如果不想使用下标index,可以直接使用_来取代index,进行省略</span><br><span class="line">		5.index和value的名称不是固定的，即程序员可以自行指定，一般命名为index,value</span><br><span class="line"><span class="meta prompt_">		</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数组的使用细节和注意事项</span></span><br><span class="line">1.数组中的元素是多个相同类型数据的组合，一个数组一旦声明定义了，长度就固定了，不能动态变化</span><br><span class="line">2.var arr []int  这时arr就是一个切片，后面再讲解</span><br><span class="line">3.数组中的元素可以是任何数据类型，包括值类型和引用类型，但是不能混用</span><br><span class="line">4.go语言中的数组是值类型，在默认情况下是值传递，因此会进行值拷贝，数组间不会相互影响</span><br><span class="line">5.#如果想在其他函数中，去修改原来的数组，可以使用引用传递（指针方式） //先体验下</span><br><span class="line">6.数组类型没有进行初始化，有默认值（零值）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速入门代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.定义一个数组</span></span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">6</span>]<span class="type">float64</span></span><br><span class="line">	<span class="comment">//2.给数组的每个元素进行赋值</span></span><br><span class="line">	arr[<span class="number">0</span>]=<span class="number">3.0</span></span><br><span class="line">	arr[<span class="number">1</span>]=<span class="number">5.7</span></span><br><span class="line">	arr[<span class="number">2</span>]=<span class="number">3.0</span></span><br><span class="line">	arr[<span class="number">3</span>]=<span class="number">8.4</span></span><br><span class="line">	arr[<span class="number">4</span>]=<span class="number">6.0</span></span><br><span class="line">	arr[<span class="number">5</span>]=<span class="number">5.0</span></span><br><span class="line">	<span class="comment">//3.计算总体重</span></span><br><span class="line">	sum:=<span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		sum+=arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;总体重为&quot;</span>,sum)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.求出平均体重  %.2f保留两位小数</span></span><br><span class="line">	avg:=fmt.Sprintf(<span class="string">&quot;%.2f&quot;</span>,sum/<span class="type">float64</span>(<span class="built_in">len</span>(arr)))</span><br><span class="line">	fmt.Println(<span class="string">&quot;平均体重为&quot;</span>,avg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//理解数组内存布局</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.定义一个数组</span></span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">int</span>  <span class="comment">//int32占4个字节  int占8个字节</span></span><br><span class="line"></span><br><span class="line">	arr[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">	arr[<span class="number">1</span>]=<span class="number">20</span></span><br><span class="line">	arr[<span class="number">2</span>]=<span class="number">30</span></span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	<span class="comment">//数组的地址可以通过数组名来获取 &amp;arr</span></span><br><span class="line">	<span class="comment">//数组的地址与数组第一个元素的地址相同，后面的元素地址都是根据第一个元素地址加上元素类型所占的字节数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;arr的地址=%p arr[0]的地址=%p arr[1]的地址=%p arr[2]的地址=%p&quot;</span>,&amp;arr,&amp;arr[<span class="number">0</span>],&amp;arr[<span class="number">1</span>],&amp;arr[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br><span class="line">arr的地址=<span class="number">0xc0000ae090</span> arr[<span class="number">0</span>]的地址=<span class="number">0xc0000ae090</span> arr[<span class="number">1</span>]的地址=<span class="number">0xc0000ae098</span> arr[<span class="number">2</span>]的地址=<span class="number">0xc0000ae0a0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组值传递以及通过指针传递改变数组值得演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(arr [3]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;arr1类型=%T\n&quot;</span>,arr)</span><br><span class="line">	arr[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">	arr[<span class="number">1</span>]=<span class="number">10</span></span><br><span class="line">	arr[<span class="number">2</span>]=<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;arr2类型=%T\n&quot;</span>,arr)</span><br><span class="line">    (*arr)[<span class="number">0</span>]=<span class="number">10</span>   <span class="comment">//arr[0]=10 这也是可以的</span></span><br><span class="line">    (*arr)[<span class="number">1</span>]=<span class="number">10</span></span><br><span class="line">    (*arr)[<span class="number">2</span>]=<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//数组是值传递</span></span><br><span class="line">	<span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="type">int</span>=[<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;arr1=&quot;</span>,arr1)</span><br><span class="line">	test1(arr1)</span><br><span class="line">	fmt.Println(<span class="string">&quot;arr1=&quot;</span>,arr1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过指针传递改变数组值</span></span><br><span class="line">	<span class="keyword">var</span> arr2 [<span class="number">3</span>]<span class="type">int</span>=[<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;arr2=&quot;</span>,arr2)</span><br><span class="line">	test2(&amp;arr2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;arr2=&quot;</span>,arr2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">arr1= [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">arr1类型=[<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">arr1= [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">arr2= [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">arr2类型=*[<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">arr2= [<span class="number">10</span> <span class="number">10</span> <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2-切片"><a href="#2-切片" class="headerlink" title="2.切片"></a>2.切片</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么需要切片</span></span><br><span class="line">需要一个长度不确定的相同类型数据的结构，因此数组就不可用了，因此引入切片</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.切片的英文是slice</span><br><span class="line">2.#切片是数组的引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制</span><br><span class="line">3.切片的使用和数组类似，遍历切片，访问切片的元素和求切片长度len(slice)都一样</span><br><span class="line">4.#切片的长度是可以变化的，因此切片是一个可以动态变化数组</span><br><span class="line">5.切片定义的基本语法</span><br><span class="line">	var 变量名 []数据类型  如var arr []int</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切片在内存中的形式</span></span><br><span class="line">var intArr [5]int=[...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">slice:=intArr[1:3]</span><br><span class="line"></span><br><span class="line">1.slice是一个引用类型</span><br><span class="line">2.slice从底层来说，其实就是一个数据结构（struct结构体）</span><br><span class="line">	type slice struct&#123;</span><br><span class="line">		ptr *[2]int</span><br><span class="line">		len int</span><br><span class="line">		cap int</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切片的使用</span></span><br><span class="line">    第一种方式：定义一个切片，然后让切片去引用一个已经创建好得数组，比如前面得案例就是这样的</span><br><span class="line">        var intArr [5]int=[...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">        slice:=intArr[1:3]</span><br><span class="line">    第二种方式：通过make来创建切片</span><br><span class="line">        基本语法：</span><br><span class="line">            var 切片名 []type=make([]type,len,[cap])  //make是内置函数</span><br><span class="line">            参数说明：type：就是数据类型  len:大小  cap:指定切片容量，是可选的 ，如果有，则必须cap&gt;=len</span><br><span class="line">        说明：</span><br><span class="line">            1.通过make方式创建切片可以指定切片的大小和容量</span><br><span class="line">            2.如果没有给切片的各个元素进行赋值，那么就会使用默认值（零值）</span><br><span class="line">            3.通过make方式创建的切片对应的数组只能通过切片来访问，对外不可见</span><br><span class="line">        例如：</span><br><span class="line">            var slice []int=make([]int,2,3)</span><br><span class="line">    第三种方式：定义一个切片，直接就指定具体数组，使用原理类似make方式</span><br><span class="line">        基本语法：</span><br><span class="line">            var slice []int=[]int&#123;1,2,3,4,5&#125;</span><br><span class="line">        说明：</span><br><span class="line">            这样声明的长度len和cap就是5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切片注意事项和使用细节</span></span><br><span class="line">1.切片初始化时，var intArr [5]int=[...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">        	  slice:=intArr[1:3]</span><br><span class="line">  说明：从intArr数组下标为startIndex（即上面的1）,取到下标为endIndex的元素（3），不含intArr[3]</span><br><span class="line">2.切片初始化时，在使用下标访问时，仍然不能越界，范围在[0,len(slice))之间，但是可以动态增长（通过内置的append函数）</span><br><span class="line">3.一些简写的形式</span><br><span class="line">	1.var slice=arr[0:end]  可以简写为var slice=arr[:end]</span><br><span class="line">	2.var slice=arr[start:len(arr)]  可以简写为var slice=arr[start:]</span><br><span class="line">	3.var slice=arr[0:len(arr)] 可以简写为var slice=arr[:]</span><br><span class="line">4.cap是一个内置函数，可用于统计切片的容量，即最大可以存放多少个元素</span><br><span class="line">5.切片定义完毕后，还不能使用，因为本身是一个空的，需要让其引用到一个数组，或者make一个空间供切片来使用，否则就只能进行append操作</span><br><span class="line">6.切片可以继续切片</span><br><span class="line">	案例演示：</span><br><span class="line">		var slice []int=[]int&#123;1,2,3,4,5&#125;</span><br><span class="line">		var slice2=slice[1:3]</span><br><span class="line">	说明：</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">当改变第二个切片中的元素值时，其关联的数据也都会改变</span></span><br><span class="line">7.#用append内置函数，可以对切片进行动态追加</span><br><span class="line">	基本语法：</span><br><span class="line">		func append(slice []Type, elems ...Type) []Type</span><br><span class="line">        内建函数append将元素追加到切片的末尾。若它有足够的容量，其目标就会重新切片以容纳新的元素。否则，就		会分配一个新的基本数组。append返回更新后的切片，因此必须存储追加后的结果。</span><br><span class="line">        slice = append(slice, elem1, elem2)</span><br><span class="line">        slice = append(slice, anotherSlice...)</span><br><span class="line">	案例演示：</span><br><span class="line">		//切片在末尾添加元素</span><br><span class="line">    	slice = append(slice, 2，3)  //末尾添加元素值2，4</span><br><span class="line">    	slice = append(slice,slice2...)  //在slice后面追加一个切片slice2,slice2也可以是自												己，...是固定写法</span><br><span class="line">    说明：</span><br><span class="line">    	1.切片append操作的本质就是对数组扩容</span><br><span class="line">    	2.go底层会创建一下新的数组newArr(安装后扩容大小)</span><br><span class="line">    	3.将slice原来包含的元素拷贝到新的数组newArr</span><br><span class="line">    	4.slice重新引用到newArr</span><br><span class="line">    	5.注意newArr是在底层来维护的，程序员不可见</span><br><span class="line">8.切片的拷贝操作copy </span><br><span class="line">	基本语法：</span><br><span class="line">		func copy(dst, src []Type) int</span><br><span class="line">        内建函数copy将元素从来源切片复制到目标切片中，也能将字节从字符串复制到字节切片中。copy返回被复制的		 元素数量，它会是 len(src) 和 len(dst) 中较小的那个。来源和目标的底层内存可以重叠。</span><br><span class="line">	切片使用copy内置函数完成拷贝，举例说明</span><br><span class="line">		var arr =[5]int&#123;1,2,3,4,5&#125;</span><br><span class="line">        var slice1=arr[:]</span><br><span class="line">        var slice2=make([]int,10,10)</span><br><span class="line">        copy(slice2,slice1)   //可以从长度大的切片往小的拷贝，反着来也可以</span><br><span class="line">        fmt.Println(&quot;slice1=&quot;,slice1)</span><br><span class="line">        fmt.Println(&quot;slice2=&quot;,slice2)</span><br><span class="line">    注意：</span><br><span class="line">    	copy(para1,para2) para1和para2都是切片类型，不能是数组，拷贝时他们的内存空间是独立的.所以改变其中的一个切片内容，并不会影响另外一个切片的内容</span><br><span class="line">9.切片是引用类型，所以在传递时，遵守引用传递机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切片的演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//切片的快速入门</span></span><br><span class="line">	<span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="type">int</span>=[...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">//声明定义一个切片</span></span><br><span class="line">	<span class="comment">//slice:=intArr[1:3]</span></span><br><span class="line">	<span class="comment">//1.slice就是切片名</span></span><br><span class="line">	<span class="comment">//2.intArr[1:3]  表示slice引用到intArr这个数组</span></span><br><span class="line">	<span class="comment">//3.引用intArr数组下标为1的元素到下标为3的元素，包括下标1，但是不包括下标3</span></span><br><span class="line">	slice:=intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    <span class="comment">//在切片里面修改值，同时会直接更改掉切片引用的数组中对应的值</span></span><br><span class="line">    slice[<span class="number">1</span>]=<span class="number">100</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;intArr=&quot;</span>,intArr)</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice=&quot;</span>,slice)</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice的元素个数是&quot;</span>,<span class="built_in">len</span>(slice))</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice的容量是&quot;</span>,<span class="built_in">cap</span>(slice))  <span class="comment">//切片的容量是可以动态变化的</span></span><br><span class="line">	<span class="comment">//切片在末尾添加元素</span></span><br><span class="line">    slice = <span class="built_in">append</span>(slice, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">//遍历切片</span></span><br><span class="line">    <span class="keyword">for</span> i, i2 := <span class="keyword">range</span> slice &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;i:&quot;</span>,i,<span class="string">&quot;i2:&quot;</span>,i2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">intArr= [<span class="number">1</span> <span class="number">2</span> <span class="number">100</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">slice= [<span class="number">2</span> <span class="number">100</span>]</span><br><span class="line">slice的元素个数是 <span class="number">2</span></span><br><span class="line">slice的容量是 <span class="number">4</span></span><br><span class="line">i: <span class="number">0</span> i2: <span class="number">2</span></span><br><span class="line">i: <span class="number">1</span> i2: <span class="number">100</span></span><br><span class="line">i: <span class="number">2</span> i2: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-string和slice"><a href="#3-string和slice" class="headerlink" title="3.string和slice"></a>3.string和slice</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.string底层是一个byte数组，因此string也可以进行切片处理</span><br><span class="line">	str:=&quot;hello@world&quot;</span><br><span class="line">	slice:=str[6:]  //slice=[world]</span><br><span class="line">2.string和切片在内存的形式，以abcd画出内存形式</span><br><span class="line">3.string是不可变的，也就是说不能通过str[0]=&#x27;z&#x27;方式来修改字符串</span><br><span class="line">4.如果需要修改字符串，可以先将string-&gt;[]byte/或者[]rune -&gt; 修改 -&gt;再重写转成string  </span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> slice =<span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">	fmt.Println(slice)</span><br><span class="line">	str:=<span class="string">&quot;hello你好中国world&quot;</span></span><br><span class="line">    <span class="comment">//str[0]=&#x27;z&#x27;  //编译会出错</span></span><br><span class="line">	<span class="comment">//将字符串显示转换为切片[]int32</span></span><br><span class="line">	<span class="keyword">var</span> arr=[]<span class="type">rune</span>(str)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>,arr)</span><br><span class="line">    <span class="comment">//rune是int32的别名，  []rune(str)相当于是将字符串显示转换为rune类型的切片</span></span><br><span class="line">	<span class="comment">//for i, r := range arr &#123;   </span></span><br><span class="line">	<span class="comment">//	fmt.Printf(&quot;i=%d r=%c\n&quot;,i,r)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	fmt.Println(str)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="comment">//fmt.Println(arr[i])</span></span><br><span class="line">		<span class="comment">//通过将字符串转换为切片之后，改变切片中的元素值，再将切片转换为字符串的方式来修改字符串</span></span><br><span class="line">        arr[i]+=<span class="number">5</span></span><br><span class="line">	&#125;</span><br><span class="line">	str=<span class="type">string</span>(arr)</span><br><span class="line">	fmt.Println(str)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//细节，我们转成[]byte数组时，可以处理英文和数字，但是不能处理中文</span></span><br><span class="line">    <span class="comment">//原因是[]byte 按字节来处理，而一个汉字，是3个字节，因此会出现乱码</span></span><br><span class="line">    <span class="comment">//解决办法是将string转成[]rune 即可，因为[]rune是按字符处理，兼容汉字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[]<span class="type">int32</span></span><br><span class="line">hello你好中国world</span><br><span class="line">mjqqt佥如串圂|twqi</span><br></pre></td></tr></table></figure>

<h3 id="4-排序和查找"><a href="#4-排序和查找" class="headerlink" title="4.排序和查找"></a>4.排序和查找</h3><h4 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">排序的分类：</span><br><span class="line">1.内部排序</span><br><span class="line">	指将需要处理的所有数据都加载到内部存储器中进行排序，包括（交换式排序法，选择式排序法和插入式排序法）</span><br><span class="line">2.外部排序</span><br><span class="line">	数据量过大，无法全部加载到内存中，需要借助外部存储进行排序，包括（合并排序法和直接合并排序法）</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">交换式排序法</span></span><br><span class="line">	介绍：是运用数据值比较后，依据判断规则对数据位置进行交换，以达到排序的目的</span><br><span class="line">	交换式排序分为：</span><br><span class="line">		1.冒泡排序法（Bubble sort） (从小到大顺序)</span><br><span class="line">		2.快速排序法（Quick sort）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(arr *[5]<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(arr); i &gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">		b:=<span class="literal">true</span></span><br><span class="line">		<span class="comment">//每一轮内循环，选出数组的最大的值，相当于依次选出数组中最大元素</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (*arr)[j]&lt;(*arr)[j<span class="number">-1</span>]&#123;</span><br><span class="line">				temp:=(*arr)[j]</span><br><span class="line">				(*arr)[j]=(*arr)[j<span class="number">-1</span>]</span><br><span class="line">				(*arr)[j<span class="number">-1</span>]=temp</span><br><span class="line">				b=<span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> b&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr =[<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">24</span>,<span class="number">69</span>,<span class="number">80</span>,<span class="number">57</span>,<span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;排序前：&quot;</span>,arr)</span><br><span class="line">    BubbleSort(&amp;arr)</span><br><span class="line">	fmt.Println(<span class="string">&quot;排序后：&quot;</span>,arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">常用的查找有两种</span><br><span class="line">1.顺序查找</span><br><span class="line">2.二分查找 (该数组必须有序)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearch</span><span class="params">(arr [6]<span class="type">int</span>,res <span class="type">int</span>)</span></span> (index <span class="type">int</span>) &#123;</span><br><span class="line">	index=<span class="number">-1</span></span><br><span class="line">	left:=<span class="number">0</span></span><br><span class="line">	right:=<span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		middle:=(left+right)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> left&lt;=right&#123;</span><br><span class="line">			<span class="keyword">if</span> arr[middle]==res&#123;</span><br><span class="line">				index=middle</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> arr[middle]&gt;res&#123;</span><br><span class="line">				right=middle<span class="number">-1</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				left=middle+<span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr =[<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">1000</span>,<span class="number">1234</span>&#125;</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	n:=<span class="number">123</span></span><br><span class="line">	res:=BinarySearch(arr,n)</span><br><span class="line">	<span class="keyword">if</span> res==<span class="number">-1</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;没有找到&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d在数组下标为%d&quot;</span>,n,res)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-二维数组"><a href="#5-二维数组" class="headerlink" title="5.二维数组"></a>5.二维数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">var matrix [4][5]int=[4][5]int&#123;&#123;0,0,0,0,0&#125;,&#123;0,0,0,0,0&#125;,&#123;0,0,0,0,0&#125;,&#123;0,0,0,0,0&#125;&#125;</span><br><span class="line">基本语法：</span><br><span class="line">	var 数组名 [大小][大小]类型   如var matrix [4][5]int</span><br><span class="line">	访问：</span><br><span class="line">		数组名[i][j]</span><br><span class="line">	</span><br><span class="line">	var 数组名 [大小][大小]类型=[大小][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line">	var 数组名 [大小][大小]类型=[...][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line">	var 数组名 =[大小][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line">	var 数组名 =[...][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line">	数组名 :=[大小][大小]类型&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">二维数组的遍历</span></span><br><span class="line">	1.for循环</span><br><span class="line">	2.for-range循环</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> matrix [<span class="number">4</span>][<span class="number">5</span>]<span class="type">int</span>=[<span class="number">4</span>][<span class="number">5</span>]<span class="type">int</span>&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">30</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;</span><br><span class="line">	fmt.Println(matrix[<span class="number">2</span>])</span><br><span class="line">	matrix[<span class="number">1</span>]=[<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">			fmt.Print(matrix[i][j],<span class="string">&quot; &quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组的内存分布演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> matrix [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;matrix地址=%p\n&quot;</span>,&amp;matrix)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;matrix[0]地址=%p\n&quot;</span>,&amp;matrix[<span class="number">0</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;matrix[1]地址=%p\n&quot;</span>,&amp;matrix[<span class="number">1</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;matrix[0][0]地址=%p\n&quot;</span>,&amp;matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="number">0xc00013e060</span></span><br><span class="line"><span class="number">0xc00013e060</span></span><br><span class="line"><span class="number">0xc00013e078</span></span><br><span class="line"><span class="number">0xc00013e060</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-map"><a href="#6-map" class="headerlink" title="6.map"></a>6.map</h3><h4 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">	map是key-value数据结构，又称为字段或者关联数组，类似其他编程语言的集合，在编程中是经常使用到</span><br><span class="line">	基本语法：</span><br><span class="line">		var 变量名 map[key类型]value类型  如var kv map[int]string</span><br><span class="line">    说明：</span><br><span class="line">    	key的类型可以是哪些？</span><br><span class="line">    		可以是bool,数字，string，指针，channel,还可以是只包含前面几个类型的接口，结构体，数组</span><br><span class="line">    		通常为int,string</span><br><span class="line">    		注意：slice,map还有function不可以，因为这几个无法使用==来判断</span><br><span class="line">    	value可以的类型和key差不多</span><br><span class="line">    		通常为数字，string,map,struct</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">map声明</span></span><br><span class="line">	举例：</span><br><span class="line">        var a map[string]string</span><br><span class="line">        var a map[string]int</span><br><span class="line">        var a map[int]string</span><br><span class="line">        var a map[string]map[string]string</span><br><span class="line">  	说明：</span><br><span class="line">  		声明是不会分配内存的，初始化需要make,分配内存后才能赋值和使用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">map的使用方式：</span></span><br><span class="line">func main()&#123;</span><br><span class="line">	//map使用方式</span><br><span class="line">	//第一种</span><br><span class="line">	var kv map[int]string</span><br><span class="line">	kv=make(map[int]string,10)</span><br><span class="line">	kv[1]=&quot;hello&quot;</span><br><span class="line">	kv[2]=&quot;hello111&quot;</span><br><span class="line">	fmt.Printf(&quot;kv的类型=%T,kv的值=%v\n&quot;,kv,kv)</span><br><span class="line">	fmt.Printf(&quot;kv[1]的类型=%T,kv[1]的值=%v\n&quot;,kv[1],kv[1])</span><br><span class="line"></span><br><span class="line">	//第二种</span><br><span class="line">	var kv2 map[int]string =make(map[int]string)</span><br><span class="line">	kv2[1]=&quot;hello&quot;</span><br><span class="line">	kv2[2]=&quot;hello111&quot;</span><br><span class="line">	kv2[3]=&quot;hello111&quot;</span><br><span class="line">	fmt.Println(kv2)</span><br><span class="line"></span><br><span class="line">	//第三种  声明的时候直接赋值</span><br><span class="line">	var kv3 map[int]string =map[int]string&#123;1:&quot;hello&quot;,2:&quot;am&quot;&#125;</span><br><span class="line">	kv4 :=map[int]string&#123;1:&quot;hello&quot;,2:&quot;am&quot;&#125;</span><br><span class="line">	kv3[2]=&quot;www&quot;</span><br><span class="line">	fmt.Println(kv3)</span><br><span class="line">	fmt.Println(kv4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//map的声明和注意事项</span></span><br><span class="line">	<span class="keyword">var</span> kv <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">	<span class="comment">//在使用map前选哟make，make的作用就是给map分配内存空间</span></span><br><span class="line">	kv=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>,<span class="number">10</span>)</span><br><span class="line">	kv[<span class="number">1</span>]=<span class="string">&quot;hello&quot;</span></span><br><span class="line">	kv[<span class="number">1</span>]=<span class="string">&quot;hello111&quot;</span></span><br><span class="line">	kv[<span class="number">2</span>]=<span class="string">&quot;xixi&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;kv的类型=%T,kv的值=%v\n&quot;</span>,kv,kv)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;kv[1]的类型=%T,kv[1]的值=%v&quot;</span>,kv[<span class="number">1</span>],kv[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码说明</span></span><br><span class="line">	<span class="number">1.</span><span class="keyword">map</span>使用前需要<span class="built_in">make</span></span><br><span class="line">	<span class="number">2.</span><span class="keyword">map</span>的key不能重复，value可以重复，并且值以最后的为准</span><br><span class="line">	<span class="number">3.</span><span class="keyword">map</span>的key-value是无序的</span><br></pre></td></tr></table></figure>

<h4 id="2-案例分析"><a href="#2-案例分析" class="headerlink" title="2.案例分析"></a>2.案例分析</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map案例应用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//案例：一个学生有学号，学号对应有姓名和性别和地址</span></span><br><span class="line">	stu:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	stu[<span class="string">&quot;stu001&quot;</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>,<span class="number">3</span>)  <span class="comment">//这句话不可少</span></span><br><span class="line">	stu[<span class="string">&quot;stu001&quot;</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;张三&quot;</span></span><br><span class="line">	stu[<span class="string">&quot;stu001&quot;</span>][<span class="string">&quot;age&quot;</span>]=<span class="string">&quot;15&quot;</span></span><br><span class="line">	stu[<span class="string">&quot;stu001&quot;</span>][<span class="string">&quot;address&quot;</span>]=<span class="string">&quot;北京&quot;</span></span><br><span class="line"></span><br><span class="line">	stu[<span class="string">&quot;stu002&quot;</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>,<span class="number">3</span>)</span><br><span class="line">	stu[<span class="string">&quot;stu002&quot;</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;李四&quot;</span></span><br><span class="line">	stu[<span class="string">&quot;stu002&quot;</span>][<span class="string">&quot;age&quot;</span>]=<span class="string">&quot;16&quot;</span></span><br><span class="line">	stu[<span class="string">&quot;stu002&quot;</span>][<span class="string">&quot;address&quot;</span>]=<span class="string">&quot;上海&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除map中的一个key-value</span></span><br><span class="line">    <span class="built_in">delete</span>(stu,<span class="string">&quot;stu001&quot;</span>)</span><br><span class="line">    <span class="built_in">delete</span>(stu,<span class="string">&quot;stu003&quot;</span>)</span><br><span class="line">    <span class="comment">//通过for-range遍历map</span></span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> stu &#123;</span><br><span class="line">		fmt.Println(key,<span class="string">&quot; &quot;</span>,value)</span><br><span class="line">        <span class="comment">//可以逐一删除</span></span><br><span class="line">        <span class="comment">//delete(stu,key)</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//演示map的查找,</span></span><br><span class="line">	value,ok:=stu[<span class="string">&quot;stu003&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> ok&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;有stu001值&quot;</span>,value)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;没有stu001这个值&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">	fmt.Println(stu[<span class="string">&quot;stu002&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-map的增删改查（crud操作）"><a href="#3-map的增删改查（crud操作）" class="headerlink" title="3.map的增删改查（crud操作）"></a>3.map的增删改查（crud操作）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加和更新</span></span><br><span class="line">map增加和更新</span><br><span class="line">	map[key]=value //#如果key还没有，就增加，如果key存在就是修改</span><br><span class="line">map删除：</span><br><span class="line">	说明：使用delete内置函数，delete(map,&quot;key&quot;),delete是一个内置函数，如果key存在，就删除key-value,</span><br><span class="line">		如果key不存在，不操作，但是也不会报错</span><br><span class="line">	基本语法：</span><br><span class="line">		func delete(m map[Type]Type1, key Type)</span><br><span class="line">		内建函数delete按照指定的键将元素从映射中删除。若m为nil或无此元素，delete不进行操作。</span><br><span class="line">	细节说明：</span><br><span class="line">		1.如果要删除map所有的key，没有一个专门的方法一次删除，可以遍历一下key然后逐个删除</span><br><span class="line">		2.或者map=make(...) ,make一个新的，让原来的成为垃圾，被gc回收</span><br><span class="line">map查询：</span><br><span class="line">	基本语法：</span><br><span class="line">		value,ok=stu[key]  </span><br><span class="line">	案例演示：</span><br><span class="line">        value,ok:=stu[&quot;stu001&quot;]</span><br><span class="line">        if ok&#123;</span><br><span class="line">            fmt.Println(&quot;有stu001值&quot;,value)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            fmt.Println(&quot;没有stu001这个值&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">	说明：</span><br><span class="line">		1.ok是bool类型的值，如果有stu001这个key，就为true,并且value为对应的值</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h4 id="4-map的遍历"><a href="#4-map的遍历" class="headerlink" title="4.map的遍历"></a>4.map的遍历</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">map遍历</span></span><br><span class="line">map的遍历使用for-range的方式进行遍历</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例演示</span></span><br><span class="line">for key, value := range stu &#123;</span><br><span class="line">    fmt.Println(key,&quot; &quot;,value)</span><br><span class="line">    for k, v := range value &#123;</span><br><span class="line">    	fmt.Println(k,&quot; &quot;,v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台结果</span><br><span class="line">stu001   map[address:北京 age:15 name:张三]</span><br><span class="line">name   张三</span><br><span class="line">age   15</span><br><span class="line">address   北京</span><br><span class="line">stu002   map[address:上海 age:16 name:李四]</span><br><span class="line">name   李四</span><br><span class="line">age   16</span><br><span class="line">address   上海</span><br></pre></td></tr></table></figure>

<h4 id="5-map的长度"><a href="#5-map的长度" class="headerlink" title="5.map的长度"></a>5.map的长度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.使用len内置函数，求解map中有多少对键值对</span><br><span class="line">len(stu)</span><br></pre></td></tr></table></figure>

<h4 id="6-map切片"><a href="#6-map切片" class="headerlink" title="6.map切片"></a>6.map切片</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">切片的数据类型如果是map,则我们称为map切片，这样使用map个数就可以动态变化了</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最大的作用就是map的个数可以动态增加</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示 </span></span><br><span class="line"><span class="comment">//声明一个map切片</span></span><br><span class="line"><span class="keyword">var</span> slice =<span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">slice[<span class="number">1</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">slice[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;haha&quot;</span></span><br><span class="line">slice[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>]=<span class="string">&quot;15&quot;</span></span><br><span class="line">slice[<span class="number">2</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">slice[<span class="number">2</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;hehe&quot;</span></span><br><span class="line">slice[<span class="number">2</span>][<span class="string">&quot;age&quot;</span>]=<span class="string">&quot;16&quot;</span></span><br><span class="line">stu:=<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;18&quot;</span>&#125;</span><br><span class="line"><span class="comment">//通过内置函数append动态增加</span></span><br><span class="line">slice=<span class="built_in">append</span>(slice,stu)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure>

<h4 id="7-map排序"><a href="#7-map排序" class="headerlink" title="7.map排序"></a>7.map排序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//现在新版本有按字典排序的功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//map的排序</span></span><br><span class="line">	map1:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	map1[<span class="number">10</span>]=<span class="number">3</span></span><br><span class="line">	map1[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">	map1[<span class="number">1</span>]=<span class="number">6</span></span><br><span class="line">	map1[<span class="number">5</span>]=<span class="number">2</span></span><br><span class="line">	fmt.Println(map1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果按照map的key的顺序进行排序输出</span></span><br><span class="line">	<span class="comment">//1.先将map的放入到切片</span></span><br><span class="line">	<span class="comment">//2.对切片进行排序</span></span><br><span class="line">	<span class="comment">//3.遍历切片，再根据key来输出map的值</span></span><br><span class="line">	<span class="keyword">var</span> keys []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	sort.Ints(keys)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map1[%v]=%v&quot;</span>,k,map1[k])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-使用和注意细节"><a href="#8-使用和注意细节" class="headerlink" title="8.使用和注意细节"></a>8.使用和注意细节</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.map是引用类型，遵守引用类型传递的机制，在一个函数接收map，修改后，会直接修改原来的map</span><br><span class="line">2.map的容量达到后，再想map增加元素，会自动扩容，并不会发生panic,也就是说map能动态的增长键值对</span><br><span class="line">3.map的value也经常使用struct,更适合管理复杂的数据（比前面value是一个map更好）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与结构体的使用演示</span></span><br><span class="line"><span class="comment">//定义一个结构体Stu</span></span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	map1:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Stu)</span><br><span class="line">	map1[<span class="string">&quot;stu001&quot;</span>]=Stu&#123;Name:<span class="string">&quot;haha&quot;</span>,Age:<span class="number">13</span>,Address:<span class="string">&quot;北京&quot;</span>&#125;   <span class="comment">//可以以键值对的方式给出</span></span><br><span class="line">	map1[<span class="string">&quot;stu002&quot;</span>]=Stu&#123;<span class="string">&quot;hehe&quot;</span>,<span class="number">13</span>,<span class="string">&quot;上海&quot;</span>&#125;  <span class="comment">//也可以直接给</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> s, stu := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;学号：%v 姓名：%v 年龄：%v 地址：%v\n&quot;</span>,s,stu.Name,stu.Age,stu.Address)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(map1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第六章：面向对象编程（上）"><a href="#第六章：面向对象编程（上）" class="headerlink" title="第六章：面向对象编程（上）"></a>第六章：面向对象编程（上）</h2><h3 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1.结构体"></a>1.结构体</h3><h4 id="1-快速入门-1"><a href="#1-快速入门-1" class="headerlink" title="1.快速入门"></a>1.快速入门</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.golang也支持面向对象编程，但是和传统的面向对象编程有很大的不同，并不是纯粹的面向对象编程，应该说golang是支持面向对象编程的特性。</span><br><span class="line">2.golang没有类（class），golang语言的结构体与java的类有同等的地位，可以理解golang是基于struct来支持oop特性的。</span><br><span class="line">3.golang面向对象非常简洁，去掉了oop语言的继承，方法重载，构造函数和析构函数，隐藏的this指针等等</span><br><span class="line">4.golang仍然有面向对象编程的继承，封装和多态，只是实现的方式和其他oop语言不太一样</span><br><span class="line">5.golang非常的优雅，golang中面向接口编程时非常重要的特性</span><br><span class="line">6.#结构体是一个值类型。</span><br><span class="line">7.基本语法</span><br><span class="line">	type 结构体名称 struct&#123;</span><br><span class="line">		field1 type</span><br><span class="line">		field2 type</span><br><span class="line">	&#125;</span><br><span class="line">	说明：</span><br><span class="line">		字段一般是基本类型，数组，也可是引用类型。</span><br><span class="line"><span class="meta prompt_">		</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字段的使用细节和注意事项</span></span><br><span class="line">1.字段声明语法同变量，实例：字段名 字段类型  #注意这里不用加var</span><br><span class="line">2.字段类型可以为：基本类型，数组或引用类型</span><br><span class="line">3.在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值（默认值），规则同前面讲的一样</span><br><span class="line">	bool类型为false,整形是0，字符串是&quot;&quot;</span><br><span class="line">	数组类型的默认值和它的元素类型有关，比如score [3]int ，则为[0,0,0]</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">指针，slice和map的零值都是nil,即还没有分配空间，如果要使用slice和map，需要先make。指针的值为&lt;nil&gt;,slice的nil输出的值为[],map为map[]</span></span><br><span class="line">4.不同结构体变量的字段是独立，互不影响，一个结构体变量字段的更改，不影响另外一个。结构体是值类型。要想通过另一个结构体进行改变，就需要借助指针/地址进行传递</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结构体的声明方式</span></span><br><span class="line">1.直接声明 var person Person  (其中Person是结构体名称，person是结构体变量名)</span><br><span class="line">2.声明并进行初始化 （推荐使用第二种）</span><br><span class="line">	var person Person=Person&#123;&#125;</span><br><span class="line">	var person=Person&#123;&#125;</span><br><span class="line">	person:=Person&#123;Name:&quot;hehe&quot;&#125;</span><br><span class="line">3.通过new</span><br><span class="line">	var person *Person=new(Person)</span><br><span class="line">	person:=new(Person)   //此时person是一个指向结构体的指针</span><br><span class="line">	访问的方式：(*person).Name=&quot;hehe&quot;  //左边这种方式也可以写为person.Name=&quot;hehe&quot;,这是为了程序员方便</span><br><span class="line">4.通过&amp;方式</span><br><span class="line">	//下面的语句也可以直接赋初值</span><br><span class="line">	var person *Person=&amp;Person&#123;&#125;</span><br><span class="line">	访问的方式：(*person).Name=&quot;hehe&quot;  go的设计者为了使用方便，在底层进行处理，也支持person.Name=&quot;hehe&quot;这种方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体入门字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Cat结构体，将Cat的各个/字段属性，放入到Cat结构体进行管理</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Color <span class="type">string</span></span><br><span class="line">    Ptr *<span class="type">int</span></span><br><span class="line">	Map1 <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">	Slice []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个Cat的变量,并且初始化所有字段的值</span></span><br><span class="line">	cat1:=Cat&#123;</span><br><span class="line">		Name:  <span class="string">&quot;小花&quot;</span>,</span><br><span class="line">		Age:   <span class="number">0</span>,</span><br><span class="line">		Color: <span class="string">&quot;yellow&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个Cat的变量,只初始化部分字段的值</span></span><br><span class="line">	<span class="keyword">var</span> cat2=Cat&#123;</span><br><span class="line">		Color: <span class="string">&quot;Black&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> cat3=Cat&#123;&#125;</span><br><span class="line">	<span class="comment">//给结构体里面的字段进行赋值</span></span><br><span class="line">	cat3.Age=<span class="number">14</span></span><br><span class="line">	cat3.Color=<span class="string">&quot;blue&quot;</span></span><br><span class="line">	cat3.Name=<span class="string">&quot;haha&quot;</span></span><br><span class="line">    cat3.Ptr=&amp;cat3.Age</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//map和slice类型的字段需要先make，才能使用</span></span><br><span class="line">	cat3.Map1=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	cat3.Map1[<span class="number">1</span>]=<span class="number">12</span></span><br><span class="line"></span><br><span class="line">	cat3.Slice=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">	cat3.Slice[<span class="number">1</span>]=<span class="number">14</span></span><br><span class="line">	cat3.Slice[<span class="number">2</span>]=<span class="number">15</span></span><br><span class="line">    cat4:=&amp;cat3</span><br><span class="line">	fmt.Println(*(cat3.Ptr))</span><br><span class="line">	fmt.Println(*(cat4.Ptr))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat3的类型=%T，cat3值=%v\n&quot;</span>,cat3,cat3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat4的类型=%T，cat4值=%v\n&quot;</span>,cat4,cat4)</span><br><span class="line">	<span class="comment">//修改cat4的指针字段值，cat3的指针字段值也会变，但指针字段指向的那个值却没有发生变化</span></span><br><span class="line">    <span class="comment">//注意这里要将*cat4用括号括起来，因为.的优先级比*号高，不括起来则取的是这个Ptr对应的值</span></span><br><span class="line">	(*cat4).Ptr=&amp;cat1.Age</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改cat4的值类型字段</span></span><br><span class="line">	(*cat4).Age=<span class="number">18</span></span><br><span class="line">	fmt.Println(*(cat3.Ptr))</span><br><span class="line">	fmt.Println(*(cat4.Ptr))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat3的类型=%T，cat3值=%v\n&quot;</span>,cat3,cat3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat4的类型=%T，cat4值=%v\n&quot;</span>,cat4,cat4)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat1的类型=%T，cat1值=%v\n&quot;</span>,cat1,cat1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat2的类型=%T，cat2值=%v\n&quot;</span>,cat2,cat2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat3的类型=%T，cat3值=%v\n&quot;</span>,cat3,cat3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat3的姓名=%v，cat3.年龄=%v,cat3.颜色=%v\n&quot;</span>,cat3.Name,cat3.Age,cat3.Color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.结构体的使用细节和注意事项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.结构体字段的内存存放地址是连续的</span><br><span class="line">2.结构体使用户单独定义的类型，和其他类型进行转换时需要有完全相同的字段（名字，个数和类型）</span><br><span class="line">	type A struct&#123;</span><br><span class="line">		Num int</span><br><span class="line">	&#125;</span><br><span class="line">	type B struct&#123;</span><br><span class="line">		Num int</span><br><span class="line">	&#125;</span><br><span class="line">	func main()&#123;</span><br><span class="line">		var a A</span><br><span class="line">		var b B</span><br><span class="line">		a=A(b) #将b强制转换为A结构体，这样做可行的原因是两个结构体有完全相同的字段（名字，个数和类型）</span><br><span class="line">	&#125;</span><br><span class="line">3.结构体可以使用type重新定义（相当于取别名），golang认为是新的数据类型，但是相互间可以强转</span><br><span class="line">	type Student struct&#123;</span><br><span class="line">		Name string</span><br><span class="line">		Age int</span><br><span class="line">	&#125;</span><br><span class="line">	type Stu Student</span><br><span class="line">	//上面其实同type integer int</span><br><span class="line">	func main()&#123;</span><br><span class="line">		var stu1 Student</span><br><span class="line">		var stu2 Stu</span><br><span class="line">		stu2=stu1  //这是会报错的，可以进行强转stu2=Stu(stu1)  </span><br><span class="line">	&#125;</span><br><span class="line">4.struct的每个字段上，可以写上一个tag,该tag可以通过反射机制进行获取，常见的使用场景就是序列化和反序列化</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面第四点的使用方式，即为什么需要这种方式</span></span><br><span class="line"><span class="comment">//为了输出json格式字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span>   <span class="comment">//  `json:&quot;name&quot;` 就是struct tag</span></span><br><span class="line">	Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Skill <span class="type">string</span> <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.创建一个Monster变量</span></span><br><span class="line">	monster := Monster&#123;<span class="string">&quot;牛魔王&quot;</span>,<span class="number">500</span>,<span class="string">&quot;芭蕉扇&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.将monster变量序列化为字符json格式的字符串</span></span><br><span class="line">	<span class="comment">//json.Marshal函数使用到了反射，将Name转化为name</span></span><br><span class="line">	jsonMonster,err := json.Marshal(monster)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;json 处理错误&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;json:&quot;</span>,<span class="type">string</span>(jsonMonster))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-方法的使用"><a href="#2-方法的使用" class="headerlink" title="2.方法的使用"></a>2.方法的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">在某些情况下，我们需要定义（声明）方法，比如在Person结构体中，除了有一些字段外（年龄、姓名），Person结构体还有一些行为，比如说话，吃饭等，这时就要用方法才能完成</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">golang中的方法是作用在指定的数据类型上（即：和指定的数据类型绑定），因此自定义类型，都可以有方法，而不仅仅是struct。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方法的声明和调用</span></span><br><span class="line">	type A struct&#123;</span><br><span class="line">		Num int</span><br><span class="line">	&#125;</span><br><span class="line">	func (a A) test()&#123;</span><br><span class="line">		fmp(a.Num)</span><br><span class="line">	&#125;</span><br><span class="line">	func main()&#123;</span><br><span class="line">		var a=A&#123;Num:12&#125;</span><br><span class="line">		a.test()</span><br><span class="line">	&#125;</span><br><span class="line">	说明：</span><br><span class="line">		1.func (a A) test()&#123;&#125;  表示A结构体有一方法，方法名为test</span><br><span class="line">		2.(a A)体现test方法是和A类型绑定的</span><br><span class="line">		3.定义的test方法只能通过A类型的变量进行调用</span><br><span class="line">		4.func (a A) test()其中</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法声明和使用的演示</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Person这个类型绑定一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> test() &#123;</span><br><span class="line">	p.Name=<span class="string">&quot;jack&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;test():&quot;</span>,p.Name)  <span class="comment">//输出jack</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> speak()  &#123;</span><br><span class="line">	fmt.Println(p.Name,<span class="string">&quot;是一个好人&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> jisaun()  &#123;</span><br><span class="line">	sum:=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		sum+=i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(p.Name,<span class="string">&quot;计算的结果是&quot;</span>,sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> jisaun2(n <span class="type">int</span>)  &#123;</span><br><span class="line">	sum:=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		sum+=i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(p.Name,<span class="string">&quot;计算的结果是&quot;</span>,sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> getSum(n1,n2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> p =Person&#123;Name:<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">	<span class="comment">//调用结构体中的方法</span></span><br><span class="line">	p.test()</span><br><span class="line">	p.speak()</span><br><span class="line">	p.jisaun()</span><br><span class="line">	p.jisaun2(<span class="number">10</span>)</span><br><span class="line">	res:=p.getSum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	fmt.Println(p.Name)   <span class="comment">//输出Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-方法的调用和传参机制（重要）"><a href="#3-方法的调用和传参机制（重要）" class="headerlink" title="3.方法的调用和传参机制（重要）"></a>3.方法的调用和传参机制（重要）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明</span></span><br><span class="line">1.方法的调用和传参机制与函数基本一样，不一样的地方是方法在调用时，会将调用方法的变量，当作实参传递给方法（如果变量是值类型，则进行值拷贝，如果变量是引用类型，则进行地址拷贝）</span><br></pre></td></tr></table></figure>

<h3 id="4-方法的使用细节和注意事项"><a href="#4-方法的使用细节和注意事项" class="headerlink" title="4.方法的使用细节和注意事项"></a>4.方法的使用细节和注意事项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.结构体是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式</span><br><span class="line">2.如果程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理</span><br><span class="line">3.golang中的方法作用在指定的数据类型上（即和指定的数据类型绑定），因此自定义类型，都可以有方法，而不仅仅是struct,比如int，float32等也可以有方法</span><br><span class="line">4.方法的访问范围控制的规则，和函数一样，方法名首字母小写，只能在本包访问，方法首字母大写，可以在本包和其他包中访问</span><br><span class="line">5.#如果一个类型实现了String()这个方法，那么fmt.Pringln(变量名)默认会调用这个变量的String()进行输出</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法调用的演示  通常使用指针进行调用</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span>&#123;</span><br><span class="line">	Radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">	c.Radius=<span class="number">5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span>*c.Radius*c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> area2() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="comment">//return 3.14*(*c).Radius*(*c).Radius</span></span><br><span class="line"></span><br><span class="line">	c.Radius=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//理应是上面这种写法，但是go语言底层进行了优化，就也支持下面这种方式</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span>*c.Radius*c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> c Circle</span><br><span class="line">	<span class="keyword">var</span> c2 Circle</span><br><span class="line">	c.Radius=<span class="number">10</span></span><br><span class="line">	c2.Radius=<span class="number">10</span></span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(c2)</span><br><span class="line">	<span class="comment">//(&amp;c).area()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//理应是上面这种写法，go语言底层也给进行了优化，支持下面这种写法</span></span><br><span class="line">	res:=c.area()</span><br><span class="line">	res2:=c2.area2()</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(c2)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	fmt.Println(res2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第3点演示——--给自定义类型绑定方法演示</span></span><br><span class="line"><span class="keyword">type</span> floatAlias <span class="type">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n floatAlias)</span></span> getArea() <span class="type">float64</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(<span class="number">3.14</span> * n * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *floatAlias)</span></span> getArea2() <span class="type">float64</span>&#123;</span><br><span class="line">	*n=<span class="number">5.0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(<span class="number">3.14</span> * (*n) * (*n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> f floatAlias</span><br><span class="line">	f=<span class="number">10.0</span></span><br><span class="line">	res:=f.getArea()</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第5点演示  如果一个类型实现了String()这个方法，那么fmt.Pringln(变量名)默认会调用这个变量的String()进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> String()  <span class="type">string</span>&#123;</span><br><span class="line">	str:=fmt.Sprintf(<span class="string">&quot;Name=[%v],Age=[%v]&quot;</span>,stu.Name,stu.Age)</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> stu =Student&#123;Name:<span class="string">&quot;haha&quot;</span>,Age:<span class="number">12</span>&#125;</span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">	fmt.Println(&amp;stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-方法和函数区别"><a href="#5-方法和函数区别" class="headerlink" title="5.方法和函数区别"></a>5.方法和函数区别</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.调用方式不一样</span><br><span class="line">	函数的调用方式：	函数名（实参列表）</span><br><span class="line">	方法的调用方式：	变量.方法名（实参列表）</span><br><span class="line">2.对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然</span><br><span class="line">3.对于方法（如struct的方法），接收者为值类型时，可以直接使用指针类型的变量调用方法，反过来同样也可以。</span><br><span class="line">	总结：方法不论调用形式如何，真正决定是值拷贝还是地址拷贝，看这个方法是和哪个类型绑定</span><br><span class="line">		（p Person）  值拷贝</span><br><span class="line">		（p *Person） 地址拷贝</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示3.对于方法（如struct的方法），接收者为值类型时，可以直接使用指针类型的变量调用方法，反过来同样也可以。</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> String()  <span class="type">string</span>&#123;</span><br><span class="line">	str:=fmt.Sprintf(<span class="string">&quot;Name=[%v],Age=[%v]&quot;</span>,stu.Name,stu.Age)</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span></span> String2()  <span class="type">string</span>&#123;</span><br><span class="line">	str:=fmt.Sprintf(<span class="string">&quot;Name=[%v],Age=[%v]&quot;</span>,stu.Name,stu.Age)</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> stu =Student&#123;Name:<span class="string">&quot;haha&quot;</span>,Age:<span class="number">12</span>&#125;</span><br><span class="line">    <span class="comment">//看方法能不能修改外面的内容，主要看方法里面绑定的是变量值类型还是地址类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//即便是值传入，但是仍然是地址拷贝，方法里面的修改会修改外面的内容</span></span><br><span class="line">	stu.String()</span><br><span class="line">	(&amp;stu).String()</span><br><span class="line">    stu.String2()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//即便是地址传入，但是仍然是值拷贝，方法里面的修改不会修改外面的内容</span></span><br><span class="line">    (&amp;stu).String2()</span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">	fmt.Println(&amp;stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-面向对象编程应用实例"><a href="#6-面向对象编程应用实例" class="headerlink" title="6.面向对象编程应用实例"></a>6.面向对象编程应用实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">步骤</span></span><br><span class="line">1.声明（定义）结构体，确定结构体名</span><br><span class="line">2.编写结构体的字段</span><br><span class="line">3.编写结构体的方法</span><br></pre></td></tr></table></figure>

<h3 id="7-创建结构体指定字段值"><a href="#7-创建结构体指定字段值" class="headerlink" title="7.创建结构体指定字段值"></a>7.创建结构体指定字段值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type Student struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line">方式1:</span><br><span class="line">	var stu =Student&#123;&quot;hehe&quot;,12&#125;</span><br><span class="line">		stu :=Student&#123;&quot;hehe&quot;,12&#125;</span><br><span class="line">方式2：</span><br><span class="line">	var stu =Student&#123;Name:&quot;hehe&quot;,Age:12&#125;</span><br><span class="line">		stu :=Student&#123;Name:&quot;hehe&quot;,Age:12&#125;</span><br><span class="line">方式3：</span><br><span class="line">	//顺序可以颠倒</span><br><span class="line">	var stu =Student&#123;Age:12,Name:&quot;hehe&quot;&#125;</span><br><span class="line">	//可以只赋部分字段的值</span><br><span class="line">	var stu =Student&#123;Name:&quot;hehe&quot;&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式4：</span></span><br><span class="line">	var stu3 =&amp;Student&#123;Name:&quot;haha&quot;,Age:12&#125;</span><br><span class="line">    fmt.Println(stu3)  //输出结果为： &amp;&#123;haha 12&#125;  ||stu3的类型：*main.Student</span><br><span class="line">    fmt.Println(*stu3) //输出结果为： &#123;haha 12&#125;	||*stu3的类型：main.Student</span><br><span class="line">    fmt.Println(stu3.Name)  //输出结果为haha</span><br><span class="line">	fmt.Println(stu3.Age)   //输出结果为12</span><br><span class="line">	fmt.Println((*stu3).Name) //输出结果为haha</span><br><span class="line">	fmt.Println((*stu3).Age) //输出结果为12</span><br></pre></td></tr></table></figure>

<h3 id="8-工厂模式"><a href="#8-工厂模式" class="headerlink" title="8.工厂模式"></a>8.工厂模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明</span></span><br><span class="line">golang中没有构造函数，通常可以使用工厂模式来解决这个问题</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么引入工厂模式</span></span><br><span class="line">	当一个包model中的结构体type student struct&#123;&#125;中的student首字母是小写的时候，在其他包如main中需要使用student这个结构体，这个时候就需要引入工厂模式来解决</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用工厂模式实现跨包创建结构体实例（变量）的案例</span></span><br><span class="line">	1.如果model包中的student首字母大写直接引入使用没有问题</span><br><span class="line">	2.如果model包中的结构体变量首字母小写，引入后，不能直接使用，可以工厂模式解决，其中结构体字段首字母时小写时，解决方法与上面是一样的</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211021175813731.png" alt="image-20211021175813731"></p>
<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211021175829967.png" alt="image-20211021175829967"></p>
<h2 id="第七章：面向对象编程（下）"><a href="#第七章：面向对象编程（下）" class="headerlink" title="第七章：面向对象编程（下）"></a>第七章：面向对象编程（下）</h2><h3 id="1-面向对象编程三大特性"><a href="#1-面向对象编程三大特性" class="headerlink" title="1.面向对象编程三大特性"></a>1.面向对象编程三大特性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">go语言中也有封装，继承，多态三大特性，只是实现方式与其他OOP语言不太一样。</span><br></pre></td></tr></table></figure>

<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">封装介绍</span></span><br><span class="line">1.封装就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">封装的好处</span></span><br><span class="line">1.隐藏实现细节</span><br><span class="line">2.还可以对数据进行验证，保证安全</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如何体现封装</span></span><br><span class="line">1.对结构体中的属性进行封装</span><br><span class="line">2.通过方法，包实现封装</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">封装的实现步骤</span></span><br><span class="line">    1.将结构体、字段（属性）的首字母小写（不能导出了，其他包不能直接使用，类似加上private）</span><br><span class="line">    2.将结构体所在包提供一个工厂模式的函数，首字母大写，类似一个构造函数</span><br><span class="line">    3.提供一个首字母大写的Set方法（类似其他语言的public），用于对属性判断并赋值</span><br><span class="line">        func (变量v 结构体类型名) SetXxxx(参数列表) &#123;</span><br><span class="line">            //加入数据验证的业务逻辑</span><br><span class="line">            变量v.字段名=参数</span><br><span class="line">        &#125;</span><br><span class="line">    4.提供一个首字母大写的Get方法（类似其他语言的pubic），用于获取属性的值</span><br><span class="line">        func (变量v 结构体类型名) GetXxxx() （返回值列表）&#123;</span><br><span class="line">            return 变量v.字段</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta prompt_">  	#</span><span class="language-bash">特别说明：在golang开发中并没有特别强调封装，这点不像java,golang本身对面向对象的特性做了简化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例：</span></span><br><span class="line">	看一个程序person.go,不能随便查看人的年龄，工资等隐私，并对输入的年龄进行合理的验证</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例演示</span></span><br><span class="line"><span class="comment">//model person.go</span></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">	age    <span class="type">int</span></span><br><span class="line">	salary <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们通过工厂模式来让其他包使用这个person结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Person</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;person&#123;Name: name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了让其他包能获取person结构体里面的age,salary字段,我们提供Set/Get方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetAge(age <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span> &#123;</span><br><span class="line">		p.age = age</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;超出年龄范围&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> GetAge() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetSalary(salary <span class="type">float64</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> salary &gt; <span class="number">3000</span> &amp;&amp; salary &lt; <span class="number">30000</span> &#123;</span><br><span class="line">		p.salary = salary</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;超出薪资范围&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> GetSalary() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.salary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;go_code/project01/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p=model.Person(<span class="string">&quot;王五&quot;</span>)</span><br><span class="line">	p.SetAge(<span class="number">45</span>)</span><br><span class="line">	p.SetSalary(<span class="number">13000</span>)</span><br><span class="line">	fmt.Println(p.Name)</span><br><span class="line">	fmt.Println(p.GetAge())</span><br><span class="line">	fmt.Println(p.GetSalary())</span><br><span class="line">	fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么需要继承</span></span><br><span class="line">因为代码冗余，维护比较复杂，所以我们引入继承，来增加代码复用，和功能的扩展</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">当多个结构体存在相同的属性（字段）和方法时，如小学生，高中生，大学生等结构体，可以从这些结构体中抽象出结构体如学生student,在该结构体中定义这些相同的属性和方法。</span><br><span class="line">此时，在其他的结构体中不需要重新定义这些属性和方法，只需嵌套一个Student匿名结构体即可</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">总结：在golang中，如果一个struct中嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性。</span></span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">	type Goods struct&#123;</span><br><span class="line">        Name string</span><br><span class="line">        Price int</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    type Book struct&#123;</span><br><span class="line">        Goods  //这里就是嵌套匿名结构体Goods</span><br><span class="line">        Writer string</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门-1"><a href="#2-快速入门-1" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示案例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Price <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(good *Goods)</span></span> Introduction()  &#123;</span><br><span class="line">	fmt.Println(good.Name,<span class="string">&quot;的价格:&quot;</span>,good.Price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span>&#123;</span><br><span class="line">	Goods  <span class="comment">//这里就是嵌套匿名结构体Goods</span></span><br><span class="line">	<span class="comment">//特有字段</span></span><br><span class="line">	Writer <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Book的特有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Book)</span></span> PrintWriter()  &#123;</span><br><span class="line">	fmt.Println(b.Name,<span class="string">&quot;的作者是&quot;</span>,b.Writer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Light <span class="keyword">struct</span>&#123;</span><br><span class="line">	Goods  <span class="comment">//这里就是嵌套匿名结构体Goods</span></span><br><span class="line">    good Goods<span class="comment">//有名结构体，在访问有名结构体的字段和方法时，就必须带上这个名字good，即 l.good.Price=12</span></span><br><span class="line">	<span class="comment">//特有字段</span></span><br><span class="line">	Owner <span class="type">string</span></span><br><span class="line">   	<span class="comment">//可以与匿名结构体有相同的字段和方法,访问时采用就近原则</span></span><br><span class="line">    <span class="comment">//Name string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Light的特有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Light)</span></span> PrintOwner()  &#123;</span><br><span class="line">	fmt.Println(l.Name,<span class="string">&quot;的发明者是&quot;</span>,l.Owner)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b Book</span><br><span class="line">	<span class="comment">//下面这两种方式都可以</span></span><br><span class="line">	b.Goods.Name=<span class="string">&quot;海底两万里&quot;</span></span><br><span class="line">	b.Name=<span class="string">&quot;海底两万里&quot;</span></span><br><span class="line">	b.Price=<span class="number">12</span></span><br><span class="line">	b.Writer=<span class="string">&quot;凡尔赛&quot;</span></span><br><span class="line">	b.Introduction()</span><br><span class="line">	b.Goods.Introduction()</span><br><span class="line">	b.PrintWriter()</span><br><span class="line">	fmt.Println(b)   <span class="comment">//&#123;&#123;海底两万里 12&#125; 凡尔赛&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> l Light</span><br><span class="line">	<span class="comment">//下面这两种方式都可以</span></span><br><span class="line">	l.Goods.Name=<span class="string">&quot;电灯泡&quot;</span></span><br><span class="line">	l.Name=<span class="string">&quot;电灯泡&quot;</span></span><br><span class="line">	l.Price=<span class="number">5</span></span><br><span class="line">	l.Owner=<span class="string">&quot;爱迪生&quot;</span></span><br><span class="line">	l.Introduction()</span><br><span class="line">	l.Goods.Introduction()</span><br><span class="line">	l.PrintOwner()</span><br><span class="line">	fmt.Println(l.Goods)  <span class="comment">//&#123;电灯泡 5&#125;</span></span><br><span class="line">	fmt.Println(l)    <span class="comment">//&#123;&#123;电灯泡 5&#125; 爱迪生&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-继承的深入讨论"><a href="#3-继承的深入讨论" class="headerlink" title="3.继承的深入讨论"></a>3.继承的深入讨论</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.结构体可以使用嵌套匿名结构体中所有的字段和方法。即：首字母大写或者小写的字段、方法，都可以使用(大小写只针对是否在同一个包中)</span><br><span class="line">2.匿名结构体字段和方法可以简化</span><br><span class="line">	如上面案例: b.Goods.Name=&quot;海底两万里&quot;可以简化为 b.Name=&quot;海底两万里&quot;</span><br><span class="line">			  b.Goods.Introdution()可以简化为b.Introduction()</span><br><span class="line">3.当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则，如希望访问匿名结构体的字段和方法时，可以通过匿名结构体名来区分</span><br><span class="line">4.结构体嵌入两个（或多个）匿名结构体，如果两个匿名结构体中有相同的字段和方法（同时结构体本身没有同名的字段和方法时），在访问时，就必须指定匿名结构体名字，否则编译出错</span><br><span class="line">5.如果一个struct嵌套了一个有名结构体，这种方式就是组合，如果是组合关系，那么在访问组合的结构体的字段和方法时，必须带上结构体的名字</span><br><span class="line">6.嵌套匿名结构体时后，也可以在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值</span><br><span class="line">	例如：下面这几种方式都可以</span><br><span class="line">	var b2 =Book&#123;Goods:Goods&#123;Name: &quot;平凡的世界&quot;,Price: 123,discount: 0.7&#125;,Writer: &quot;路遥&quot;&#125;</span><br><span class="line">	var b3 =Book&#123;Goods&#123;Name: &quot;平凡的世界&quot;,Price: 123,discount: 0.7&#125;, &quot;路遥&quot;&#125;</span><br><span class="line">	var b4 =Book&#123;Goods:Goods&#123;Name: &quot;平凡的世界&quot;,Price: 123,discount: 0.7&#125;&#125;</span><br><span class="line">	var b5 =Book&#123;Writer:&quot;路遥&quot;,Goods:Goods&#123;Name: &quot;平凡的世界&quot;,Price: 123,discount: 0.7&#125;&#125;</span><br><span class="line">7.也可以在结构体中使用匿名结构体的指针进行传入</span><br><span class="line">	如 </span><br><span class="line">	type Light struct&#123;</span><br><span class="line">		*Goods</span><br><span class="line">        Owner string</span><br><span class="line">	&#125;</span><br><span class="line">	var light =Light&#123;Goods:&amp;Goods&#123;Name: &quot;电灯泡&quot;,Price: 3,discount: 0.9&#125;,Owner: &quot;爱迪生&quot;&#125;</span><br><span class="line">	fmt.Println(*light.Goods,&quot; &quot;,light.Owner)  //&#123;电灯泡 3 0.9&#125;   爱迪生</span><br><span class="line">8.我们既可以将结构体类型作为匿名字段传给一个结构体，同时还可以将基本类型作为匿名字段传入</span><br><span class="line">	如：</span><br><span class="line">	type Light struct&#123;</span><br><span class="line">		*Goods</span><br><span class="line">		int  //匿名的基本类型</span><br><span class="line">		n int</span><br><span class="line">        Owner string</span><br><span class="line">	&#125;</span><br><span class="line">	var light Light</span><br><span class="line">	light.int=10</span><br><span class="line">	light.n=20</span><br><span class="line">	//说明一个结构体中有一个匿名的int字段时，就不能有第二个匿名int字段，如果要有，就用名字区分，如n int</span><br></pre></td></tr></table></figure>

<h4 id="4-多重继承"><a href="#4-多重继承" class="headerlink" title="4.多重继承"></a>4.多重继承</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.如果一个struct中嵌套了多个匿名结构体，那么该结构体可以直接访问所有嵌套的匿名结构体的字段和方法，从而实现了多重继承。java不支持多继承，但支持多实现</span><br><span class="line">	//如Graduate继承了Person,Student</span><br><span class="line">	type Graduate struct&#123;</span><br><span class="line">		Person</span><br><span class="line">		Student</span><br><span class="line">		Name string</span><br><span class="line">	&#125;</span><br><span class="line">2.为了代码的简洁性，建议大家尽量不使用多重继承</span><br></pre></td></tr></table></figure>

<h3 id="4-接口-interface"><a href="#4-接口-interface" class="headerlink" title="4.接口(interface)"></a>4.接口(interface)</h3><h4 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">1.在golang中，多态的特性主要是通过接口来体现的。</span><br><span class="line">2.interface类型可以定义一组方法，但是这些不需要实现，并且interface不能包含任何变量，到某个自定义类型（比如结构体Phone）要使用的时候，再根据实际情况把这些方法写出来</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本语法</span></span><br><span class="line">    type 接口名 interface&#123;</span><br><span class="line">        //声明了两个没有实现的方法</span><br><span class="line">        Method1(参数列表) 返回值列表</span><br><span class="line">        Method2(参数列表) 返回值列表</span><br><span class="line">    &#125;</span><br><span class="line">    实现接口的语法如</span><br><span class="line">    type 自定义类型 struct&#123;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //让Phone实现Usb接口的方法 注意必须是接口中的所有方法</span><br><span class="line">    func (p 自定义类型) Method1(参数列表) 返回值列表&#123;</span><br><span class="line">        //具体实现</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func (p 自定义类型) Method2(参数列表) 返回值列表&#123;</span><br><span class="line">        //具体实现</span><br><span class="line">    &#125;</span><br><span class="line">    说明：</span><br><span class="line">    	1.接口里的所有方法都没有方法体，即没有实现，体现了程序设计的多态和高内聚低耦合的思想</span><br><span class="line">    	2.#golang中的接口，不需要显示的实现，只要一个变量，含有接口类型中的所有方法，那么这个变量就实现了这个接口，因此，golang中没有implements关键字</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门-2"><a href="#2-快速入门-2" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="comment">//声明/定义一个接口</span></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span>&#123;</span><br><span class="line">	<span class="comment">//声明了两个没有实现的方法</span></span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让Phone实现Usb接口的方法 注意必须是接口中的所有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机开始工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机停止工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让Camera实现Usb接口的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机开始工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机停止工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不一定只有struct能实现接口，下面的这种类型也可以</span></span><br><span class="line"><span class="keyword">type</span> integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i integer)</span></span> Start()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;int工作了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i integer)</span></span> Stop()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;int停止了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算机</span></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个Working方法，接收一个Usb接口类型变量</span></span><br><span class="line"><span class="comment">//只要是实现了Usb接口，所谓实现Usb接口，就是指实现了接口中所有的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span></span> Working(usb Usb)&#123;</span><br><span class="line">	<span class="comment">//通过usb接口变量来调用Start和Stop方法</span></span><br><span class="line">	usb.Start()</span><br><span class="line">	usb.Stop()</span><br><span class="line">	fmt.Println(<span class="string">&quot;计算机开始工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">	<span class="comment">//先创建结构体变量</span></span><br><span class="line">	computer:=Computer&#123;&#125;</span><br><span class="line">	phone:=Phone&#123;&#125;</span><br><span class="line">	camera:=Camera&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关键点</span></span><br><span class="line">	computer.Working(phone)</span><br><span class="line">	computer.Working(camera)</span><br><span class="line">    computer.Working(integer(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-接口的注意事项和使用细节"><a href="#3-接口的注意事项和使用细节" class="headerlink" title="3.接口的注意事项和使用细节"></a>3.接口的注意事项和使用细节</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1.接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量（实例）</span><br><span class="line">	如：var u Usb=camera  </span><br><span class="line">	   computer.Working(u)</span><br><span class="line">2.接口中所有的方法都没有方法体，即都是没有实现的方法</span><br><span class="line">3.一个自定义类型需要将某个接口中的所有方法都实现，就说这个自定义类型实现了这个接口</span><br><span class="line">4.一个自定义类型只有实现了某个接口，才能将该自定义类型的实例（变量）赋给接口类型</span><br><span class="line">5.只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型。如type integer int&#123;&#125;类型也可以</span><br><span class="line">6.一个自定义类型可以实现多个接口，只要实现了这些接口中的方法就可以了</span><br><span class="line">7.golang接口中不能有任何变量</span><br><span class="line">8.#一个接口（比如A接口）可以继承多个别的接口（比如B,C接口）,这时如果要实现A接口，也必须将B,C接口的方法也全部实现。同时接口只能继承接口，不能继承类</span><br><span class="line">	如：</span><br><span class="line">		type Object interface&#123;</span><br><span class="line">            Equal()</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">//Usb接口继承了Object接口</span></span><br><span class="line">        type Usb interface&#123;</span><br><span class="line">        	//Usb类型继承Object接口</span><br><span class="line">            Object</span><br><span class="line">            //声明了两个没有实现的方法</span><br><span class="line">            Start()</span><br><span class="line">            Stop()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #这时Phone结构体类型要实现Usb接口，就必须要实现Usb接口中的方法，并且还有Object接口中的方法</span><br><span class="line">        type Phone struct&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //让Phone实现Usb接口的方法 注意必须是接口中的所有方法</span><br><span class="line">        func (p Phone) Start() &#123;</span><br><span class="line">            fmt.Println(&quot;手机开始工作&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        func (p Phone) Stop() &#123;</span><br><span class="line">            fmt.Println(&quot;手机停止工作&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        func (p Phone) Equal() &#123;</span><br><span class="line">            fmt.Println(&quot;手机比较工作&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">9.interface类型默认是一个指针（引用类型），如果没有对interface初始化就使用，那么会输出nil</span><br><span class="line">10.#空接口interface&#123;&#125; 没有任何方法，所以所有类型都实现了空接口，那么空接口的变量可以接收任何类型的变量。</span><br><span class="line">	如 </span><br><span class="line">	type Object interface&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	var phone Phone</span><br><span class="line">	var obj Object=phone</span><br><span class="line">	var t2 interface&#123;&#125;=stu</span><br><span class="line">	var num float64=1.23</span><br><span class="line">    t2=num</span><br><span class="line">    obj=num</span><br><span class="line">    fmt.Println(t2,&quot; &quot;,obj)</span><br></pre></td></tr></table></figure>

<h4 id="4-易错练习"><a href="#4-易错练习" class="headerlink" title="4.易错练习"></a>4.易错练习</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="keyword">type</span> AInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Test01()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DStruct <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里是 *DStruct类型实现了AInterface接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DStruct)</span></span> Test01()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Test01&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d DStruct</span><br><span class="line">	<span class="keyword">var</span> a AInterface</span><br><span class="line">    <span class="comment">//因此在赋值给接口变量时，也只能将DStruct的指针类型赋给接口类型变量，否则报错</span></span><br><span class="line">	a=&amp;d</span><br><span class="line">	a.Test01()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-接口最佳实践"><a href="#5-接口最佳实践" class="headerlink" title="5.接口最佳实践"></a>5.接口最佳实践</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：实现Hero结构体排序</span></span><br><span class="line"><span class="comment">//1.声明Hero结构体</span></span><br><span class="line"><span class="keyword">type</span> Hero <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明一个Hero结构体的切片类型</span></span><br><span class="line"><span class="keyword">type</span> HeroSlice []Hero</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.实现Interface,即要实现下面这三个方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//type Interface interface &#123;</span></span><br><span class="line"><span class="comment">//	// Len方法返回集合中的元素个数</span></span><br><span class="line"><span class="comment">//	Len() int</span></span><br><span class="line"><span class="comment">//	// Less方法报告索引i的元素是否比索引j的元素小</span></span><br><span class="line"><span class="comment">//	Less(i, j int) bool</span></span><br><span class="line"><span class="comment">//	// Swap方法交换索引i和j的两个元素</span></span><br><span class="line"><span class="comment">//	Swap(i, j int)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs HeroSlice)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(hs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法决定了是按什么标准进行排序的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs HeroSlice)</span></span> Less(i,j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">//按照年龄进行排序</span></span><br><span class="line">	<span class="comment">//return hs[i].Age&lt;hs[j].Age</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//按照名字进行排序</span></span><br><span class="line">	<span class="keyword">return</span> hs[i].Name&lt;hs[j].Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs HeroSlice)</span></span> Swap(i,j <span class="type">int</span>)  &#123;</span><br><span class="line">	<span class="comment">//交换</span></span><br><span class="line">	<span class="comment">//temp:=hs[i]</span></span><br><span class="line">	<span class="comment">//hs[i]=hs[j]</span></span><br><span class="line">	<span class="comment">//hs[j]=temp</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面一句话等同于上面三句话</span></span><br><span class="line">	hs[i],hs[j]=hs[j],hs[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hs:=<span class="built_in">make</span>([]Hero,<span class="number">6</span>,<span class="number">6</span>)</span><br><span class="line">	hs[<span class="number">0</span>]=Hero&#123;<span class="string">&quot;hehe&quot;</span>,<span class="number">12</span>&#125;</span><br><span class="line">	hs[<span class="number">1</span>]=Hero&#123;<span class="string">&quot;haha&quot;</span>,<span class="number">32</span>&#125;</span><br><span class="line">	hs[<span class="number">2</span>]=Hero&#123;<span class="string">&quot;xixi&quot;</span>,<span class="number">2</span>&#125;</span><br><span class="line">	hs[<span class="number">3</span>]=Hero&#123;<span class="string">&quot;hiahia&quot;</span>,<span class="number">42</span>&#125;</span><br><span class="line">	hs[<span class="number">4</span>]=Hero&#123;<span class="string">&quot;haihai&quot;</span>,<span class="number">22</span>&#125;</span><br><span class="line">	hs[<span class="number">5</span>]=Hero&#123;<span class="string">&quot;heihei&quot;</span>,<span class="number">2</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;排序前：&quot;</span>,hs)</span><br><span class="line">	sort.Sort(HeroSlice(hs))</span><br><span class="line">	fmt.Println(<span class="string">&quot;排序后：&quot;</span>,hs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-接口和继承"><a href="#6-接口和继承" class="headerlink" title="6.接口和继承"></a>6.接口和继承</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.实现接口可以看作是对继承的一种补充，并且不会对原有的继承关系产生影响</span><br><span class="line">2.接口和继承解决的问题是不一样的</span><br><span class="line">	继承的价值主要在于：解决代码的复用性和可维护性</span><br><span class="line">	接口的价值主要在于：设计，设计好各种规范（方法），让其他自定义类型去实现这些方法</span><br><span class="line">3.接口比继承更灵活</span><br><span class="line">	继承是满足is-a的关系，接口只需满足like-a的关系</span><br><span class="line">4.接口在一定程度上实现代码</span><br></pre></td></tr></table></figure>

<h3 id="7-多态"><a href="#7-多态" class="headerlink" title="7.多态"></a>7.多态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">变量（实例）具有多种形态，面向对象的第三大特征，在Go语言，多态特征是通过接口实现的，可以按照统一的接口来调用不同的实现。这时接口变量就呈现不同的形态。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">快速入门</span></span><br><span class="line">在前面的Usb接口案例，Usb usb,这既可以接收手机变量，也可以接收相机变量，这时就体现了Usb接口的多态特性</span><br><span class="line">func (c Computer) Working(usb Usb)&#123;&#125;  //这里面的usb变量会根据传入的形参，来判断底层是Phone还是相机</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">接口体现多态特征</span></span><br><span class="line">1.多态参数</span><br><span class="line">	在前面的Usb接口案例中，usb Usb,既可以接收手机变量，也可以接收相机变量，就体现了Usb接口多态</span><br><span class="line">2.多态数组</span><br><span class="line">	演示一个案例：给Usb数组中，存放Phone结构体，Camera结构体，Phone还有一个特有的方法Call(),请遍历Usb数	组，如果是Phone变量，除了调用Usb接口声明的方法外，还需要调用Phone特有方法call</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多态数组以及类型断言的代码演示</span></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	Test01()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Test01()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone Test01&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Call()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone Call&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Test01()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;camera Test01&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">3</span>]Usb</span><br><span class="line">	arr[<span class="number">0</span>]=Phone&#123;<span class="string">&quot;xiaomi&quot;</span>&#125;</span><br><span class="line">	arr[<span class="number">1</span>]=Phone&#123;<span class="string">&quot;vivo&quot;</span>&#125;</span><br><span class="line">	arr[<span class="number">2</span>]=Camera&#123;<span class="string">&quot;nikang&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="comment">//需求：如果是Phone变量，就还需要调用Phone变量中的Call方法</span></span><br><span class="line">		p,ok:=arr[i].(Phone)  <span class="comment">//使用带检测的类型断言进行判断</span></span><br><span class="line">		<span class="keyword">if</span> ok&#123;</span><br><span class="line">            <span class="comment">//类型转换成功，就调用Phone中的方法</span></span><br><span class="line">			p.Call()</span><br><span class="line">		&#125;</span><br><span class="line">		arr[i].Test01()</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-类型断言"><a href="#8-类型断言" class="headerlink" title="8.类型断言"></a>8.类型断言</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">引出类型断言</span></span><br><span class="line">	func main()&#123;</span><br><span class="line">		var a interface&#123;&#125;</span><br><span class="line">        var point Phone=Phone&#123;&quot;nihao&quot;&#125;</span><br><span class="line">        a=point</span><br><span class="line">        var b Phone</span><br><span class="line">        var c Camera</span><br><span class="line">        b= a.(Phone)   #类型断言</span><br><span class="line">        c,ok:=a.(Camera)  #带检测的类型断言</span><br><span class="line">        if ok&#123;</span><br><span class="line">            fmt.Println(&quot;转换成功&quot;)</span><br><span class="line">            fmt.Printf(&quot;c的类型是%T,c的值是%v&quot;,c,c)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            fmt.Println(&quot;转换失败&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(b)</span><br><span class="line">	&#125;</span><br><span class="line">	说明：</span><br><span class="line">		b=a.(Point)是类型断言，如果可以转换就成功，否则就运行出错，因此在类型断言时，要确保类型一致。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">类型断言</span></span><br><span class="line">由于接口是一般类型，不知道具体类型，如果要转换成具体类型，就需要使用类型断言，具体的如上演示。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如何在进行断言时，带上检查机制，如果成功就ok,否则也不要报Panic</span></span><br></pre></td></tr></table></figure>

<h4 id="1-类型断言的最佳实践"><a href="#1-类型断言的最佳实践" class="headerlink" title="1.类型断言的最佳实践"></a>1.类型断言的最佳实践</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个函数，可以判断输入的参数是什么类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeJudge</span><span class="params">(item ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心注意   switch x.(type)</span></span><br><span class="line">	<span class="keyword">for</span> index,x:=<span class="keyword">range</span> item&#123;</span><br><span class="line">		<span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 bool类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> <span class="type">float32</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 float32类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 float64类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> <span class="type">int</span>,<span class="type">int32</span>,<span class="type">int64</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 整数类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 string类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">            <span class="keyword">case</span> Student:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 Student类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">case</span> *Student:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 *Student类型，值是%v\n&quot;</span>,index,x)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数是 类型不匹配，值是%v\n&quot;</span>,index,x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n1 <span class="type">float32</span>=<span class="number">1.1</span></span><br><span class="line">	<span class="keyword">var</span> n2 <span class="type">float64</span>=<span class="number">1.1</span></span><br><span class="line">	<span class="keyword">var</span> n3 <span class="type">int</span>=<span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> n4 <span class="type">int32</span>=<span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> n5 <span class="type">int64</span>=<span class="number">111</span></span><br><span class="line">	<span class="keyword">var</span> n6 <span class="type">string</span>=<span class="string">&quot;1111&quot;</span></span><br><span class="line">	<span class="keyword">var</span> stu=Student&#123;&#125;</span><br><span class="line">	TypeJudge(n1,n2,n3,n4,n5,n6,stu,&amp;stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第八章：项目练手"><a href="#第八章：项目练手" class="headerlink" title="第八章：项目练手"></a>第八章：项目练手</h2><h3 id="1-项目1：家庭收支记账软件"><a href="#1-项目1：家庭收支记账软件" class="headerlink" title="1.项目1：家庭收支记账软件"></a>1.项目1：家庭收支记账软件</h3><h3 id="2-项目2：客户管理系统"><a href="#2-项目2：客户管理系统" class="headerlink" title="2.项目2：客户管理系统"></a>2.项目2：客户管理系统</h3><h2 id="第九章：文件、命令行参数、json数据处理"><a href="#第九章：文件、命令行参数、json数据处理" class="headerlink" title="第九章：文件、命令行参数、json数据处理"></a>第九章：文件、命令行参数、json数据处理</h2><h3 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">文件是数据源，保存数据的的地方。文件在程序中是以流的形式来操作的。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">流：数据在数据源（文件）和程序（内存）之间经历的路径</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入流（读文件）：数据从数据源（文件）到程序（内存）的路径</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出流（写文件）：数据从程序（内存）到数据源（文件）的路径</span></span><br><span class="line"></span><br><span class="line">1.os.File封装所有文件相关操作，File是一个结构体。这个在os包中。后面会经常使用</span><br></pre></td></tr></table></figure>

<h3 id="2-常见的文件操作函数和方法"><a href="#2-常见的文件操作函数和方法" class="headerlink" title="2.常见的文件操作函数和方法"></a>2.常见的文件操作函数和方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.打开一个文件进行读操作：</span><br><span class="line">	os.Open(name string) (*File,error)</span><br><span class="line">	func Open</span><br><span class="line">    func Open(name string) (file *File, err error)</span><br><span class="line">    Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有			O_RDONLY模式。如果出错，错误底层类型是*PathError。</span><br><span class="line">2.关闭一个文件：</span><br><span class="line">	File.Close()  </span><br><span class="line">	func (*File) Close</span><br><span class="line">    func (f *File) Close() error</span><br><span class="line">    Close关闭文件f，使文件不能用于读写。它返回可能出现的错误。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开文件  输入绝对路径</span></span><br><span class="line">	file,err:=os.Open(<span class="string">&quot;d:/123.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err &quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出下文件，看看文件是什么,看出文件就是一个指针 *File</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;file=%v&quot;</span>,file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-读文件操作应用实例"><a href="#3-读文件操作应用实例" class="headerlink" title="3.读文件操作应用实例"></a>3.读文件操作应用实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.读取文件的内容并显示在终端（带缓冲区的方式），使用os.Open,file.Close,bufio.NewReader(),reader.ReadString函数和方法</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.案例演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开文件</span></span><br><span class="line">	file,err:=os.Open(<span class="string">&quot;d:/123.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err &quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出下文件，看看文件是什么,看出文件就是一个指针 *File</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;file=%v\n&quot;</span>,file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当函数退出时，要及时的关闭file文件</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()  <span class="comment">//要及时关闭file句柄，否则会有内存泄漏</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个 *Reader ,是带缓冲的</span></span><br><span class="line">	<span class="comment">//func NewReader</span></span><br><span class="line">	<span class="comment">//func NewReader(rd io.Reader) *Reader</span></span><br><span class="line">	<span class="comment">//NewReader创建一个具有默认大小缓冲、从r读取的*Reader。</span></span><br><span class="line">	<span class="comment">//const(defaultBufSize=4096)  //默认的缓冲区大小为4096</span></span><br><span class="line">	reader:=bufio.NewReader(file)</span><br><span class="line">	<span class="comment">//循环的读取文件内容</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		str,err:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)  <span class="comment">//读到一个换行就结束</span></span><br><span class="line">		<span class="keyword">if</span> err==io.EOF&#123;  <span class="comment">// io.EOF表示文件的末尾</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出内容</span></span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.读取文件的内容并显示在终端（使用ioutil一次将整个文件读入到内存中），这种方式适用于文件不大的情况，相关函数和函数（ioutil.ReadFile）</span><br><span class="line">func ReadFile</span><br><span class="line">func ReadFile(filename string) ([]byte, error)</span><br><span class="line">ReadFile 从filename指定的文件中读取数据并返回文件的内容。成功的调用返回的err为nil而非EOF。因为本函数定义为读取整个文件，它不会将读取返回的EOF视为应报告的错误。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//func ReadFile(filename string) ([]byte, error)</span></span><br><span class="line">	fileName :=<span class="string">&quot;d:/123.txt&quot;</span></span><br><span class="line">	arr,err:=ioutil.ReadFile(fileName)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;red file error &quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把读取到的内容显示到终端上</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>,<span class="type">string</span>(arr))   <span class="comment">// 将[]byte转换为string进行输出</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为，我们没有显示的Open文件，因此也不需要显式的Close文件</span></span><br><span class="line">	<span class="comment">//因为文件的Open和Close被封装到ReadFile函数内部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-写文件操作应用实例"><a href="#4-写文件操作应用实例" class="headerlink" title="4.写文件操作应用实例"></a>4.写文件操作应用实例</h3><h4 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.基本介绍，os.OpenFile函数</span><br><span class="line">func OpenFile</span><br><span class="line">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</span><br><span class="line">OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。 其中FileMode主要用于Linux系统。，其中flag可取的值如下，当要使用多个时用|隔开</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\helloworld\AppData\Roaming\Typora\typora-user-images\image-20211022143543015.png" alt="image-20211022143543015"></p>
<h4 id="2-基本应用案例——方式一"><a href="#2-基本应用案例——方式一" class="headerlink" title="2.基本应用案例——方式一"></a>2.基本应用案例——方式一</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个新文件，写入内容 5句 &quot;hello,world&quot;</span><br><span class="line">2.打开一个存在的文件，将原来的内容覆盖成新的内容10句 &quot;你好，尚硅谷！&quot;</span><br><span class="line">3.打开一个存在的文件，在原来的内容中追加 &#x27;ABC!ENGLISH!&#x27;</span><br><span class="line">4.打开一个存在的文件，将原来的内容读出显示在中端，并且追加5句”hello 北京“</span><br><span class="line"></span><br><span class="line">使用os.OpenFile( ),bufio.NewWriter( )，*Writer的方法WriteString完成上面的任务</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个新文件，写入内容 5句 &quot;hello,world&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建一个新文件，写入内容 5句 &quot;hello,world&quot;</span></span><br><span class="line">	<span class="comment">//1.打开文件 d:/abc.txt</span></span><br><span class="line">	filePath:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file,err:=os.OpenFile(filePath,os.O_WRONLY | os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备写入5句 ”hello,world“</span></span><br><span class="line">	str:=<span class="string">&quot;heool,world\r\n&quot;</span></span><br><span class="line">	<span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为writer是带缓存的，因此在调用WriteString方法时，</span></span><br><span class="line">	<span class="comment">//其实内容是先写入到缓存的，因此要想写到文件，还需要调用Flush函数刷新,将缓存的数据真正写入到数据，否则文件中没有数据</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.打开一个存在的文件，将原来的内容覆盖成新的内容10句 &quot;你好，尚硅谷！&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个存在的文件，将原来的内容覆盖成新的内容10句 &quot;你好，尚硅谷！&quot;</span></span><br><span class="line">	<span class="comment">//1.打开文件 d:/abc.txt</span></span><br><span class="line">	filePath:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file,err:=os.OpenFile(filePath,os.O_WRONLY | os.O_TRUNC,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备写入10句 ”你好，尚硅谷！“</span></span><br><span class="line">	str:=<span class="string">&quot;你好，尚硅谷！\r\n&quot;</span></span><br><span class="line">	<span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为writer是带缓存的，因此在调用WriteString方法时，</span></span><br><span class="line">	<span class="comment">//其实内容是先写入到缓存的，因此要想写到文件，还需要调用Flush函数刷新,将缓存的数据真正写入到数据，否则文件中没有数据</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.打开一个存在的文件，在原来的内容中追加 &#x27;ABC!ENGLISH!&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个存在的文件，在原来的内容中追加 &#x27;ABC!ENGLISH!&#x27;</span></span><br><span class="line">	<span class="comment">//1.打开文件 d:/abc.txt</span></span><br><span class="line">	filePath:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file,err:=os.OpenFile(filePath,os.O_WRONLY | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备写入10句 ”你好，尚硅谷！“</span></span><br><span class="line">	str:=<span class="string">&quot;ABC!ENGLISH!\r\n&quot;</span></span><br><span class="line">	<span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为writer是带缓存的，因此在调用WriteString方法时，</span></span><br><span class="line">	<span class="comment">//其实内容是先写入到缓存的，因此要想写到文件，还需要调用Flush函数刷新,将缓存的数据真正写入到数据，否则文件中没有数据</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.打开一个存在的文件，将原来的内容读出显示在终端，并且追加5句”hello 北京“</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个存在的文件，将原来的内容读出显示在中端，并且追加5句”hello 北京“</span></span><br><span class="line">	<span class="comment">//1.打开文件 d:/abc.txt</span></span><br><span class="line">	filePath:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file,err:=os.OpenFile(filePath,os.O_RDWR | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先读取原来文件的内容，并显示到终端</span></span><br><span class="line">	reader:=bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str,err:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err==io.EOF&#123;  <span class="comment">//如果读取到文件的末尾</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//显示到终端</span></span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">//准备追加5句”hello 北京“</span></span><br><span class="line">	str:=<span class="string">&quot;hello 北京\r\n&quot;</span></span><br><span class="line">	<span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为writer是带缓存的，因此在调用WriteString方法时，</span></span><br><span class="line">	<span class="comment">//其实内容是先写入到缓存的，因此要想写到文件，还需要调用Flush函数刷新,将缓存的数据真正写入到数据，否则文件中没有数据</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-基本应用实例——方式二"><a href="#3-基本应用实例——方式二" class="headerlink" title="3.基本应用实例——方式二"></a>3.基本应用实例——方式二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.编写一个程序，将一个文件的内容，写入到另外一个文件，注：这两个文件已经存在了</span><br><span class="line"></span><br><span class="line">说明：使用ioutil.ReadFile / ioutil.WriteFile完成写文件的任务</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>代码演示</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//编写一个程序，将一个文件（d:/abc.txt）的内容，写入到另外一个文件d:/test/123.txt，注：这两个文件已经存在了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.首先将d:/abc.txt文件的内容读取到</span></span><br><span class="line">	<span class="comment">//2.将读取到的内容写入d:/test/123.txt</span></span><br><span class="line"></span><br><span class="line">	filePath1:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	arr,err:=ioutil.ReadFile(filePath1)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;read file err:&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filePath2:=<span class="string">&quot;d:/test/123.txt&quot;</span></span><br><span class="line">	err2:=ioutil.WriteFile(filePath2,arr, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err2!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;write file err:&quot;</span>,err2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-判断文件或者目录是否存在"><a href="#5-判断文件或者目录是否存在" class="headerlink" title="5.判断文件或者目录是否存在"></a>5.判断文件或者目录是否存在</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.golang判断文件或者文件夹是否存在的方法为使用os.Stat()函数返回的错误值进行判断</span><br><span class="line">	1）：如果返回的错误为nil,说明文件或者文件夹存在</span><br><span class="line">	2）：如果返回的错误类型使用os.IsNotExist()判断为true,说明文件或文件夹不存在</span><br><span class="line">	3）：如果返回的错误为其他类型，则不确定是否存在</span><br><span class="line">	</span><br><span class="line">//自定义一个函数来进行判断</span><br><span class="line">func PathExists(path string) (bool,error)&#123;</span><br><span class="line">	_,err:=os.Stat(path)</span><br><span class="line">	if err==nil&#123; //说明文件或者目录存在</span><br><span class="line">		return true,nil</span><br><span class="line">	&#125;</span><br><span class="line">	if os.IsNotExist(err)&#123;</span><br><span class="line">		return false,nil</span><br><span class="line">	&#125;</span><br><span class="line">	return false,err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-文件编程应用实例"><a href="#6-文件编程应用实例" class="headerlink" title="6.文件编程应用实例"></a>6.文件编程应用实例</h3><h4 id="1-拷贝文件"><a href="#1-拷贝文件" class="headerlink" title="1.拷贝文件"></a>1.拷贝文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.将一张图片/电影/mp3 拷贝到另外一个文件下 d:/test/abc.jpg  </span><br><span class="line">	</span><br><span class="line">说明：使用io包中func Copy(dst Writer,src Reader) (written int64,err error)</span><br><span class="line">	func Copy(dst Writer, src Reader) (written int64, err error)</span><br><span class="line">	将src的数据拷贝到dst，直到在src上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。</span><br><span class="line">    对成功的调用，返回值err为nil而非EOF，因为Copy定义为从src读取直到EOF，它不会将读取到EOF视为应报告的错	误。如果src实现了WriterTo接口，本函数会调用src.WriteTo(dst)进行拷贝；否则如果dst实现了ReaderFrom接口，本函数会调用dst.ReadFrom(src)进行拷贝。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.演示</span></span><br><span class="line"><span class="comment">//编写一个函数，接收两个文件路径 srcFileName  dstFileName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="type">string</span>,srcFileName <span class="type">string</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>)&#123;</span><br><span class="line">	srcFile,err:=os.Open(srcFileName)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> srcFile.Close()</span><br><span class="line">	<span class="comment">//通过srcFile这个句柄，获取到Reader</span></span><br><span class="line">	reader:=bufio.NewReader(srcFile)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开dstFileName</span></span><br><span class="line">	dstFile,err:=os.OpenFile(dstFileName, os.O_WRONLY | os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open dstfile err:&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dstFile.Close()</span><br><span class="line">	writer:=bufio.NewWriter(dstFile)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回</span></span><br><span class="line">	<span class="keyword">return</span> io.Copy(writer,reader)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//将一张图片/电影/mp3 拷贝到另外一个文件下 d:/test/abc.jpg</span></span><br><span class="line">	srcFileName:=<span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	dstFileName:=<span class="string">&quot;d:/test/defggg.txt&quot;</span></span><br><span class="line">	_,err:=CopyFile(dstFileName,srcFileName)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;拷贝出错&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-统计英文、数字、空格和其他字符数量"><a href="#2-统计英文、数字、空格和其他字符数量" class="headerlink" title="2.统计英文、数字、空格和其他字符数量"></a>2.统计英文、数字、空格和其他字符数量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.打开一个文件，创建一个Reader,每读取一行，就去统计该行有多少英文、数字、空格和其他字符，然后将结果保存到一个结构体。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">type</span> CharCount <span class="keyword">struct</span>&#123;</span><br><span class="line">	ChCount <span class="type">int</span>  <span class="comment">//记录英文个数</span></span><br><span class="line">	NumCount <span class="type">int</span>  <span class="comment">//记录数字个数</span></span><br><span class="line">	SpaceCount <span class="type">int</span>  <span class="comment">//记录空格个数</span></span><br><span class="line">	OtherCount <span class="type">int</span>  <span class="comment">//记录其他字符个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个文件，创建一个Reader,没读取一行，就去统计该行有多少英文、数字、空格和其他字符，然后将结果保存到一个结构体。</span></span><br><span class="line">	file,err:=os.Open(<span class="string">&quot;d:/abc.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file error:&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取file的Reader</span></span><br><span class="line">	reader:=bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个CharCount结构体</span></span><br><span class="line">	ccStu:=CharCount&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始循环读取每一行,并计数</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		str,err:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err==io.EOF&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">		<span class="comment">//遍历字符串，进行统计</span></span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">			<span class="comment">//switch当作if判断</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;%v@,&quot;</span>,v)</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">				<span class="keyword">fallthrough</span></span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">				ccStu.ChCount++</span><br><span class="line">			<span class="keyword">case</span> v==<span class="string">&#x27; &#x27;</span> || v==<span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">				ccStu.SpaceCount++</span><br><span class="line">			<span class="keyword">case</span> v&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; v&lt;=<span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">				ccStu.NumCount++</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				ccStu.OtherCount++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;英文字母个数：%d,数字个数：%d,空格个数：%d,其他字符个数：%d&quot;</span>,ccStu.ChCount,ccStu.NumCount,ccStu.SpaceCount,ccStu.OtherCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-命令行参数"><a href="#7-命令行参数" class="headerlink" title="7.命令行参数"></a>7.命令行参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">看一个需求，我们希望能够获取到命令行输入的各种参数，该如何处理？</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">os.Args是一个string的切片，用来存储所有的命令行参数</span><br><span class="line">var Args []string</span><br><span class="line">Args保管了命令行参数，第一个是程序名。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用flag包用来解析命令行参数</span></span><br><span class="line">说明：前面的方式是比较原生的方式，对解析参数不是特别的方便，特别是带有指定参数形式的命令行</span><br><span class="line">比如：cmd&gt;main.exe -f c:/aaa.txt -p 200 -u root 这样形式的命令行，go设计者给我们提供了flag包，可以方便的解析命令行参数，而且参数顺序可以随意</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//os.Args获取命令行参数代码演示 </span></span><br><span class="line"><span class="comment">//hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;命令行的参数个数有：&quot;</span>,<span class="built_in">len</span>(os.Args))</span><br><span class="line">	<span class="comment">//遍历os.Args切片，就可以得到所有的命令行输入参数值</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;第%v个参数的值为%v\n&quot;</span>,i,v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令行输出的范例</span></span><br><span class="line"><span class="comment">//1.先将hello.go源文件编译为自定义的test.exe可执行文件</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;<span class="keyword">go</span> build -o test.exe hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.执行test.exe文件，并且带上了一些参数</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;test.exe tom d:/aaa/bbb/init.log</span><br><span class="line">命令行的参数个数有： <span class="number">3</span></span><br><span class="line">第<span class="number">0</span>个参数的值为test.exe第<span class="number">1</span>个参数的值为tom第<span class="number">2</span>个参数的值为d:/aaa/bbb/init.log</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag包解析命令行参数演示</span></span><br><span class="line"><span class="comment">//hello.go文件</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//flag包中的IntVar函数，StringVar函数</span></span><br><span class="line">	<span class="comment">//func (*FlagSet) IntVar</span></span><br><span class="line">	<span class="comment">//func (f *FlagSet) IntVar(p *int, name string, value int, usage string)</span></span><br><span class="line">	<span class="comment">//IntVar用指定的名称、默认值、使用信息注册一个int类型flag，并将flag的值保存到p指向的变量。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func (*FlagSet) StringVar</span></span><br><span class="line">	<span class="comment">//func (f *FlagSet) StringVar(p *string, name string, value string, usage string)</span></span><br><span class="line">	<span class="comment">//StringVar用指定的名称、默认值、使用信息注册一个string类型flag，并将flag的值保存到p指向的变量。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义几个变量，用于接收命令行的参数值</span></span><br><span class="line">	<span class="keyword">var</span> user <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> pwd <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> host <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> port <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&amp;user，就是接收用户命令行中输入的 -u 后面的参数值</span></span><br><span class="line">	<span class="comment">//&quot;u&quot;,就是 -u 指定参数</span></span><br><span class="line">	<span class="comment">//”“，默认值</span></span><br><span class="line">	<span class="comment">//&quot;用户名，默认为空&quot;,说明</span></span><br><span class="line">	flag.StringVar(&amp;user,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;用户名，默认为空&quot;</span>)</span><br><span class="line"></span><br><span class="line">	flag.StringVar(&amp;pwd,<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;密码，默认为空&quot;</span>)</span><br><span class="line"></span><br><span class="line">	flag.StringVar(&amp;host,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;主机名，默认为localhost&quot;</span>)</span><br><span class="line"></span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;端口号，默认为3306&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//func Parse</span></span><br><span class="line">	<span class="comment">//func Parse()</span></span><br><span class="line">	<span class="comment">//从os.Args[1:]中解析注册的flag。必须在所有flag都注册好而未访问其值时执行。未注册却使用flag -help时，会返回ErrHelp。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里有一个非常重要的操作，转换，必须调用该方法</span></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出结果</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;user=%v,pwd=%v,host=%v,port=%v&quot;</span>,user,pwd,host,port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令行中的输入</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;<span class="keyword">go</span> build -o test2.exe hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;test2.exe -u root -pwd <span class="number">123456</span> -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.5</span> -port <span class="number">3306</span></span><br><span class="line">user=root,pwd=<span class="number">123456</span>,host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.5</span>,port=<span class="number">3306</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\main&gt;test2.exe -u root -pwd <span class="number">123456</span>  -port <span class="number">33065</span></span><br><span class="line">user=root,pwd=<span class="number">123456</span>,host=localhost,port=<span class="number">33065</span></span><br></pre></td></tr></table></figure>

<h3 id="8-json基本介绍"><a href="#8-json基本介绍" class="headerlink" title="8.json基本介绍"></a>8.json基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">概述</span></span><br><span class="line">1.json(JavaScript Object Notation)是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。并有效的提升网络传输效率，通常程序在网络传输时会先将数据（结构体，map等）序列化成json字符串，到接收方得到json字符串时，在反序列化恢复成原来的数据类型（结构体，map等）。这种方式已然成为各个语言的标准。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">json数据格式说明</span></span><br><span class="line">在js语言中，一切都是对象。因此，任何的数据类型都可以通过JSON来表示，例如字符串，数字，对象，数组，map，结构体等</span><br><span class="line"></span><br><span class="line">JSON键值对是用来保存数据的一种方式</span><br><span class="line">键/值对组合中的键名写在前面并用双引号&quot;&quot;包裹，使用冒号:分割，然后紧接着值</span><br><span class="line">比如：&#123;&quot;firstName&quot;:&quot;json&quot;&#125;  &#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18,&quot;address&quot;:[&quot;北京&quot;,&quot;上海&quot;]&#125;</span><br><span class="line">[&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18,&quot;address&quot;:[&quot;北京&quot;,&quot;上海&quot;]&#125;,&#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:20,&quot;address&quot;:[&quot;广州&quot;,&quot;深圳&quot;]&#125;]</span><br><span class="line"></span><br><span class="line">json在线解析工具：https://www.json.cn/ </span><br></pre></td></tr></table></figure>

<h4 id="1-json的序列化"><a href="#1-json的序列化" class="headerlink" title="1.json的序列化"></a>1.json的序列化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">json序列化是指，将有key-value结构的数据类型（比如：结构体，map,切片）序列化成json字符串的操作</span><br><span class="line"></span><br><span class="line">注意：这是在序列化时，使用tag标签，指定后面输出的键名,利用反射机制解决</span><br><span class="line">//&quot;encoding/json&quot;包中的Marshal函数</span><br><span class="line">//func Marshal</span><br><span class="line">//func Marshal(v interface&#123;&#125;) ([]byte, error)</span><br><span class="line">//Marshal函数返回v的json编码。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化切片，map,结构体的演示</span></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Birthday <span class="type">string</span></span><br><span class="line">	Salary <span class="type">float64</span></span><br><span class="line">	Skill <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是在序列化时，使用tag标签，指定后面输出的键名,利用反射机制解决</span></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span>   </span><br><span class="line">	Age <span class="type">int</span>	<span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span> <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Salary <span class="type">float64</span> <span class="string">`json:&quot;salary&quot;`</span></span><br><span class="line">	Skill <span class="type">string</span> <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//演示</span></span><br><span class="line">	monster:=Monster&#123;<span class="string">&quot;牛魔王&quot;</span>,<span class="number">500</span>,<span class="string">&quot;1000-02-01&quot;</span>,<span class="number">8000.0</span>,<span class="string">&quot;牛魔拳&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将monster序列化</span></span><br><span class="line">	data,err:=json.Marshal(&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;序列化之后的结果&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义一个map</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用map之前先make</span></span><br><span class="line">	a=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	a[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;红孩儿&quot;</span></span><br><span class="line">	a[<span class="string">&quot;age&quot;</span>]=<span class="number">123</span></span><br><span class="line">	a[<span class="string">&quot;birthday&quot;</span>]=<span class="string">&quot;1997-11-26&quot;</span></span><br><span class="line">	a[<span class="string">&quot;salary&quot;</span>]=<span class="number">123.4</span></span><br><span class="line">	a[<span class="string">&quot;Skill&quot;</span>]=[<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;使枪&quot;</span>,<span class="string">&quot;滑轮&quot;</span>,<span class="string">&quot;跳舞&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将a序列化</span></span><br><span class="line">	data,err:=json.Marshal(&amp;a)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;序列化之后的结果&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示对切片类型的序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSlice</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	slice=<span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">	slice[<span class="number">0</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	slice[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;红孩儿&quot;</span></span><br><span class="line">	slice[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>]=<span class="number">5</span></span><br><span class="line">	slice[<span class="number">0</span>][<span class="string">&quot;address&quot;</span>]=<span class="string">&quot;北京&quot;</span></span><br><span class="line">	slice[<span class="number">1</span>]=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	slice[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;牛魔王&quot;</span></span><br><span class="line">	slice[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>]=<span class="number">52</span></span><br><span class="line">	slice[<span class="number">1</span>][<span class="string">&quot;address&quot;</span>]=<span class="string">&quot;上海&quot;</span></span><br><span class="line">	m3:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m3[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;孙悟空&quot;</span></span><br><span class="line">	m3[<span class="string">&quot;age&quot;</span>]=<span class="number">523</span></span><br><span class="line">	m3[<span class="string">&quot;address&quot;</span>]=[<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m3)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将slice序列化</span></span><br><span class="line">	data,err:=json.Marshal(slice)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;序列化之后的结果&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试对基本类型的序列化,对基本类型序列化意义不大</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFloat64</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num1 <span class="type">float64</span>=<span class="number">1.1</span></span><br><span class="line">	<span class="comment">//将slice序列化</span></span><br><span class="line">	data,err:=json.Marshal(num1)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;序列化之后的结果&quot;</span>,<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//测试序列化结构体</span></span><br><span class="line">	testStruct()</span><br><span class="line">	<span class="comment">//测试序列化map</span></span><br><span class="line">	testMap()</span><br><span class="line">	<span class="comment">//测试序列化slice</span></span><br><span class="line">	testSlice()</span><br><span class="line">	<span class="comment">//测试基本类型序列化</span></span><br><span class="line">	testFloat64()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;牛魔王&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">500</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1000-02-01&quot;</span>,<span class="string">&quot;salary&quot;</span>:<span class="number">8000</span>,<span class="string">&quot;skill&quot;</span>:<span class="string">&quot;牛魔拳&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;Skill&quot;</span>:[<span class="string">&quot;使枪&quot;</span>,<span class="string">&quot;滑轮&quot;</span>,<span class="string">&quot;跳舞&quot;</span>],<span class="string">&quot;age&quot;</span>:<span class="number">123</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1997-11-26&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;红孩儿&quot;</span>,<span class="string">&quot;salary&quot;</span>:<span class="number">123.4</span>&#125;</span><br><span class="line">[&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">5</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;红孩儿&quot;</span>&#125;,&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">52</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;牛魔王&quot;</span>&#125;,&#123;<span class="string">&quot;address&quot;</span>:[<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>],<span class="string">&quot;age&quot;</span>:<span class="number">523</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>&#125;]</span><br><span class="line"><span class="number">1.1</span></span><br><span class="line">[<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="2-json的反序列化"><a href="#2-json的反序列化" class="headerlink" title="2.json的反序列化"></a>2.json的反序列化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">基本介绍</span></span><br><span class="line">json的反序列化是指，将json字符串反序列化成对应的数据类型（比如结构体，map,切片）的操作</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">	1.在反序列化一个字符串时，要确保反序列化后的数据类型和原来序列化前的数据类型一致</span><br><span class="line">	2.如果json字符串时通过程序获取到的，则不需要在对字符串做转义处理</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span>   <span class="comment">//反射机制</span></span><br><span class="line">	Age <span class="type">int</span>	<span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span> <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Salary <span class="type">float64</span> <span class="string">`json:&quot;salary&quot;`</span></span><br><span class="line">	Skill <span class="type">string</span> <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试将json反序列化成结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//一般json字符串是通过读文件获取到的</span></span><br><span class="line">	str:=<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;牛魔王\&quot;,\&quot;age\&quot;:500,\&quot;birthday\&quot;:\&quot;1000-02-01\&quot;,\&quot;salary\&quot;:8000,\&quot;skill\&quot;:\&quot;牛魔拳\&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个Monster实例</span></span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	err:=json.Unmarshal([]<span class="type">byte</span>(str),&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;反序列化之后的结果&quot;</span>,monster)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str:=<span class="string">&quot;&#123;\&quot;Skill\&quot;:[\&quot;使枪\&quot;,\&quot;滑轮\&quot;,\&quot;跳舞\&quot;],\&quot;age\&quot;:123,\&quot;birthday\&quot;:\&quot;1997-11-26\&quot;,\&quot;name\&quot;:\&quot;红孩儿\&quot;,\&quot;salary\&quot;:123.4&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个map</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	err:=json.Unmarshal([]<span class="type">byte</span>(str),&amp;a)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;反序列化之后的结果&quot;</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示对切片类型的序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSlice</span><span class="params">()</span></span>&#123;</span><br><span class="line">	str:=<span class="string">&quot;[&#123;\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:5,\&quot;name\&quot;:\&quot;红孩儿\&quot;&#125;,&#123;\&quot;address\&quot;:\&quot;上海\&quot;,\&quot;age\&quot;:52,\&quot;name\&quot;:\&quot;牛魔王\&quot;&#125;,&#123;\&quot;address\&quot;:[\&quot;广州\&quot;,\&quot;深圳\&quot;],\&quot;age\&quot;:523,\&quot;name\&quot;:\&quot;孙悟空\&quot;&#125;]&quot;</span></span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err:=json.Unmarshal([]<span class="type">byte</span>(str),&amp;slice)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;反序列化之后的结果&quot;</span>,slice)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testArray</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	str:=<span class="string">&quot;[\&quot;上海\&quot;,\&quot;广州\&quot;,\&quot;深圳\&quot;]&quot;</span></span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">string</span></span><br><span class="line">	err:=json.Unmarshal([]<span class="type">byte</span>(str),&amp;arr)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败 err=%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;反序列化之后的结果&quot;</span>,arr)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//测试反序列化结构体</span></span><br><span class="line">	testStruct()</span><br><span class="line">	<span class="comment">//测试反序列化map</span></span><br><span class="line">	testMap()</span><br><span class="line">	<span class="comment">//测试反序列化slice</span></span><br><span class="line">	testSlice()</span><br><span class="line">	<span class="comment">//测试数组反序列化</span></span><br><span class="line">	testArray()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">&#123;牛魔王 <span class="number">500</span> <span class="number">1000</span><span class="number">-02</span><span class="number">-01</span> <span class="number">8000</span> 牛魔拳&#125;</span><br><span class="line"><span class="keyword">map</span>[Skill:[使枪 滑轮 跳舞] age:<span class="number">123</span> birthday:<span class="number">1997</span><span class="number">-11</span><span class="number">-26</span> name:红孩儿 salary:<span class="number">123.4</span>]</span><br><span class="line">[<span class="keyword">map</span>[address:北京 age:<span class="number">5</span> name:红孩儿] <span class="keyword">map</span>[address:上海 age:<span class="number">52</span> name:牛魔王] <span class="keyword">map</span>[address:[广州 深圳] age:<span class="number">523</span> name:孙悟空]]</span><br><span class="line">[上海 广州 深圳]</span><br></pre></td></tr></table></figure>

<h2 id="第十章：单元测试和管道，协程"><a href="#第十章：单元测试和管道，协程" class="headerlink" title="第十章：单元测试和管道，协程"></a>第十章：单元测试和管道，协程</h2><h3 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先看一个需求</span></span><br><span class="line">在工作中，我们可能需要去确认一个函数或者一个模块是否和预期的结果一致，如果一致，则说明函数正确，否则函数有错误，然后修改错误。</span><br><span class="line"></span><br><span class="line">1.传统的测试方法就是在main函数中使用，看看结果是否和预期一致</span><br><span class="line">	传统方法的缺点：</span><br><span class="line">			1.不方便，我们总需要在main函数中运行，需要在main函数中修改代码。</span><br><span class="line">			2.不利于管理。要测试多个函数都需要放在main函数中</span><br><span class="line">于是引出单元测试。testing测试框架，可以很好的解决问题</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">单元测试介绍</span></span><br><span class="line">go语言中自带有一个轻量级的测试框架testing和自带的go test命令来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，可以基于这个这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例。通过单元测试可以解决一下问题：</span><br><span class="line">	1.确保每个函数是可运行，并且运行结果是正确的</span><br><span class="line">	2.确保写出来的代码性能是好的</span><br><span class="line">	3.单元测试能及时的发现程序设计或实现的逻辑错误，，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下保持稳定。</span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门-3"><a href="#2-快速入门-3" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#快速入门</span><br><span class="line">使用go的单元测试，对addUpper和sub函数进行测试</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单元测试案例演示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  test/cal.go文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="comment">//一个被测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addUpper</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">	res:=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		res+=i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个被测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSub</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1-n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  test/cal_test.go文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个测试用例，去测试addUpper是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddUpper</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	<span class="comment">//调用</span></span><br><span class="line">	res:=addUpper(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> res!=<span class="number">45</span>&#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;addUpper(10) 执行错误，期望值=%v 实际值=%v&quot;</span>,<span class="number">55</span>,res)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果正确，输出日志</span></span><br><span class="line">	t.Logf(<span class="string">&quot;addUpper(10)执行正确&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    t.Logf(<span class="string">&quot;hello执行正确&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line"><span class="comment">// test/sub_test.go文件</span></span><br><span class="line">           </span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个测试用例，去测试addUpper是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetSub</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	<span class="comment">//调用</span></span><br><span class="line">	res:=getSub(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">if</span> res!=<span class="number">5</span>&#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;GetSub(10,5) 执行错误，期望值=%v 实际值=%v&quot;</span>,<span class="number">5</span>,res)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果正确，输出日志</span></span><br><span class="line">	t.Logf(<span class="string">&quot;GetSub(10,5)执行正确&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line"><span class="comment">//命令行的操作</span></span><br><span class="line">D:\program\goPath\src\go_code\project01\test&gt;<span class="keyword">go</span> test -v</span><br><span class="line">=== RUN   TestAddUpper</span><br><span class="line">    cal_test.<span class="keyword">go</span>:<span class="number">15</span>: hello执行正确</span><br><span class="line">--- PASS: TestAddUpper (<span class="number">0.00</span>s)</span><br><span class="line">=== RUN   TestHello</span><br><span class="line">    cal_test.<span class="keyword">go</span>:<span class="number">19</span>: addUpper(<span class="number">10</span>)执行正确</span><br><span class="line">--- PASS: TestHello (<span class="number">0.00</span>s)</span><br><span class="line">=== RUN   TestGetSub</span><br><span class="line">    sub_test.<span class="keyword">go</span>:<span class="number">13</span>: GetSub(<span class="number">10</span>,<span class="number">5</span>)执行正确</span><br><span class="line">--- PASS: TestGetSub (<span class="number">0.00</span>s)</span><br><span class="line">PASS</span><br><span class="line">ok      go_code/project01/test  <span class="number">0.361</span>s</span><br><span class="line"></span><br><span class="line">D:\program\goPath\src\go_code\project01\test&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-单元测试使用细节和注意事项"><a href="#3-单元测试使用细节和注意事项" class="headerlink" title="3.单元测试使用细节和注意事项"></a>3.单元测试使用细节和注意事项</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.测试用例文件名必须以 _test.go结尾。比如cal_test.go，其中cal不是固定的</span><br><span class="line">2.测试用例函数必须以Test开头，一般来说就是TestXxxx,其中Xxxx就是被测试的函数名，比如TestAddUpper.</span><br><span class="line">3.TestAddUpper(t *testing.T)的形参类型必须是*testing.T</span><br><span class="line">4.一个测试用例文件中，可以有多个测试用例函数，比如 TestAddUpper,TestHello</span><br><span class="line">5.运行测试用例指令</span><br><span class="line">	1.cmd&gt;go test [如果运行正确，无日志，错误时，会输出日志]</span><br><span class="line">	2.cmd&gt;go test -v [无论运行正确与否，都输出日志]</span><br><span class="line">6.当出现错误时，可以使用t.Fatalf来格式化输出错误信息，并退出程序</span><br><span class="line">7.t.Logf方法可以输出相应的日志</span><br><span class="line">8.测试用例函数，并没有放在main函数中也执行了，这就是测试用例的方便之处</span><br><span class="line">9.PASS表示测试用例运行成功，FAIL表示测试用例运行失败</span><br><span class="line">10.测试单个文件时，一定要带上被测试的原文件(cal.go)</span><br><span class="line">	go test -v cal_test.go cal.go</span><br><span class="line">11.测试单个方法.如只测试 TestAddUpper方法</span><br><span class="line">	go test -v -test.run TestAddUpper</span><br></pre></td></tr></table></figure>

<h4 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">//exer1.go文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span>		<span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="type">int</span>			<span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Skill []<span class="type">string</span>	<span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个Monster变量序列化后保存到文件中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(monster *Monster)</span></span> Store(path <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	str,err1:=json.Marshal(monster)</span><br><span class="line">	<span class="keyword">if</span> err1!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败err1: %v\n&quot;</span>,err1)</span><br><span class="line">		<span class="keyword">return</span> err1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file,err2:=os.OpenFile(path,os.O_WRONLY | os.O_APPEND | os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err2!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;openfile失败err2: %v\n&quot;</span>,err2)</span><br><span class="line">		<span class="keyword">return</span> err2</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取Writer</span></span><br><span class="line">	writer:=bufio.NewWriter(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将json字符串写入到文件中</span></span><br><span class="line">	_,err3:=writer.WriteString(<span class="type">string</span>(str)+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err3!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;writeString失败err3: %v\n&quot;</span>,err3)</span><br><span class="line">		<span class="keyword">return</span> err3</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将写入缓存的数据进行刷新</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个序列化的monster,从文件中读取，并反序列化为Monster对象,检查反序列化的名字是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(monster *Monster)</span></span> ReStore(path <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//读取文件</span></span><br><span class="line">	file,err1:=os.OpenFile(path,os.O_RDONLY,<span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err1!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;openfile失败err1: %v\n&quot;</span>,err1)</span><br><span class="line">		<span class="keyword">return</span> err1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取Reader</span></span><br><span class="line">	reader:=bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">	str,err2:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	reader.ReadLine()</span><br><span class="line">	<span class="keyword">if</span> err2!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;readString失败err3: %v\n&quot;</span>,err2)</span><br><span class="line">		<span class="keyword">return</span> err2</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err3:=json.Unmarshal([]<span class="type">byte</span>(str),monster)</span><br><span class="line">	<span class="keyword">if</span> err3!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err1: %v\n&quot;</span>,err3)</span><br><span class="line">		<span class="keyword">return</span> err3</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exer1_test.go文件</span></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStore</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	monster:=Monster&#123;</span><br><span class="line">		Name:  <span class="string">&quot;牛魔王&quot;</span>,</span><br><span class="line">		Age:   <span class="number">500</span>,</span><br><span class="line">		Skill: <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	monster.Skill[<span class="number">0</span>]=<span class="string">&quot;打牛&quot;</span></span><br><span class="line">	monster.Skill[<span class="number">1</span>]=<span class="string">&quot;喝水&quot;</span></span><br><span class="line">	err:=monster.Store(<span class="string">&quot;d:/test/defgg.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;Store方法执行失败：%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Logf(<span class="string">&quot;Store方法运行成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReStore</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	err:=monster.ReStore(<span class="string">&quot;d:/test/defgg.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;ReStore方法执行失败：%v\n&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Logf(<span class="string">&quot;Store方法运行成功，monster=%v\n&quot;</span>,monster)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-goroutine协程"><a href="#2-goroutine协程" class="headerlink" title="2.goroutine协程"></a>2.goroutine协程</h3><h4 id="1-基本介绍-3"><a href="#1-基本介绍-3" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.使用并行/并发的方式，将一个大任务分配给多个goroutine进行处理,来加快处理</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进程和线程说明</span></span><br><span class="line">1.线程就是程序在操作系统中的一侧执行过程，是系统进行资源分配和调度的基本单位。</span><br><span class="line">2.线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位。</span><br><span class="line">3.一个进程可以创建多个和销毁多个进程，同一个进程中的多个线程可以并发执行。</span><br><span class="line">4.一个程序至少有一个进程，一个进程至少有一个线程</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">并发和并行</span></span><br><span class="line">1.多线程程序在单核上运行，就是并发</span><br><span class="line">2.多线程程序在多核上运行，就是并行</span><br><span class="line"></span><br><span class="line">并发：在一个cpu上，比如有10个线程，每个线程上执行10毫秒，从人的角度看，好像这10个线程同时运行，实际上在一个时间点上只执行一个线程。</span><br><span class="line">并行：在多个cpu上，多个任务执行在多个cpu上，在一个时间上，就是有多个任务或者说多个线程在同时执行</span><br><span class="line"></span><br><span class="line">说明：并行的速度比并发块</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">go协程和go主线程</span></span><br><span class="line">1.go主线程（有程序员直接称为线程/也可理解成进程）：一个go线程上，可以起多个协程，可以这样理解，协程是轻量级的线程【编译器做优化】</span><br><span class="line">2.#go协程的特点：</span><br><span class="line">	1.有独立的栈空间</span><br><span class="line">	2.共享程序堆空间</span><br><span class="line">	3.调度由用户控制</span><br><span class="line">	4.协程是轻量级的线程</span><br></pre></td></tr></table></figure>

<h4 id="2-快速入门-4"><a href="#2-快速入门-4" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例说明：</span></span><br><span class="line">请编写一个程序，完成如下功能：</span><br><span class="line">1.在主线程（可以理解成进程）中，开启一个goroutine，该协程每隔一秒输出&quot;hello,world&quot;</span><br><span class="line">2.在主线程中也每隔一秒输出&quot;hello,golang&quot;,输出10次后，退出程序</span><br><span class="line">3.要求主线程和goroutine同时执行</span><br><span class="line">4.画出主线程和协程执行流程图</span><br><span class="line"></span><br><span class="line">下面的代码说明：</span><br><span class="line">	1.如果主线程退出了，则协程还没有执行完毕，也会退出</span><br><span class="line">	2.当然协程也可以在主协程没有退出前，就自己结束了，比如完成了自己的任务</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">快速入门小结：</span></span><br><span class="line">	1.主线程是一个物理线程，直接作用在cpu上，是重量级的，非常耗费cpu资源。</span><br><span class="line">	2.协程从主线程开始的，是轻量级的线程，是逻辑态，对资源消耗相对较小</span><br><span class="line">	3.#golang的协程机制重要的特点，可以轻松的开启上万个协程，其他编程语言的并发机制是一般基于线程的开启过多的线程，资源耗费大，这里就突显出golang在并发上的优势了.(java的多线程是内核级的，也比较消耗资源)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">//编写一个函数，每隔一秒输出&quot;hello,world&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello,world &quot;</span>+strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//test()  //这是传统的顺序执行</span></span><br><span class="line">	<span class="keyword">go</span> test()  <span class="comment">//开启了一个协程，和main线程并发交叉执行</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello,golang &quot;</span>+strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出结果</span></span><br><span class="line">hello,golang <span class="number">0</span></span><br><span class="line">hello,world <span class="number">0</span></span><br><span class="line">hello,world <span class="number">1</span></span><br><span class="line">hello,golang <span class="number">1</span></span><br><span class="line">hello,world <span class="number">2</span></span><br><span class="line">hello,golang <span class="number">2</span></span><br><span class="line">hello,world <span class="number">3</span></span><br><span class="line">hello,golang <span class="number">3</span></span><br><span class="line">hello,golang <span class="number">4</span></span><br><span class="line">hello,world <span class="number">4</span></span><br><span class="line">hello,golang <span class="number">5</span></span><br><span class="line">hello,world <span class="number">5</span></span><br><span class="line">hello,golang <span class="number">6</span></span><br><span class="line">hello,world <span class="number">6</span></span><br><span class="line">hello,golang <span class="number">7</span></span><br><span class="line">hello,world <span class="number">7</span></span><br><span class="line">hello,golang <span class="number">8</span></span><br><span class="line">hello,world <span class="number">8</span></span><br><span class="line">hello,world <span class="number">9</span></span><br><span class="line">hello,golang <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h4 id="3-goroutine协程的调度模型MPG"><a href="#3-goroutine协程的调度模型MPG" class="headerlink" title="3.goroutine协程的调度模型MPG"></a>3.goroutine协程的调度模型MPG</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">MPG模式基本介绍</span></span><br><span class="line">1.M：操作系统的主线程（是物理线程） Machine</span><br><span class="line">2.P：协程执行需要的上下文	Processor</span><br><span class="line">3.G：协程 goroutine</span><br></pre></td></tr></table></figure>

<h4 id="4-设置golang运行的cpu数"><a href="#4-设置golang运行的cpu数" class="headerlink" title="4.设置golang运行的cpu数"></a>4.设置golang运行的cpu数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了充分利用多cpu的优势，在golang程序中，设置运行的cpu数目</span><br><span class="line">1.go1.8后，默认就是让程序运行在多个核上，可以不用设置了</span><br><span class="line">2.go 1.8前，还是要设置一下，可以更高效的利用cpu</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	func NumCPU</span></span><br><span class="line"><span class="comment">	func NumCPU() int</span></span><br><span class="line"><span class="comment">	NumCPU返回本地机器的逻辑CPU个数。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpuNum:=runtime.NumCPU()</span><br><span class="line">	fmt.Println(cpuNum)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//可以自己设置使用多个CPU</span></span><br><span class="line">	runtime.GOMAXPROCS(cpuNum<span class="number">-1</span>)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-管道（channel）"><a href="#3-管道（channel）" class="headerlink" title="3.管道（channel）"></a>3.管道（channel）</h3><h4 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1.问题引入"></a>1.问题引入</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求:现在要计算1-200的各个数的阶乘，并且把各个数的阶乘放入到map中，最后显示出来，要求使用goroutine完成。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分析思路：</span></span><br><span class="line">	1.使用goroutine来完成，效率高，但是会出现并发/并行安全问题</span><br><span class="line">	2.这里就提出了不同goroutine如何通信的问题</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只用协程处理时会出现fatal error: concurrent map writes。（多个协程同时对map进行写操作，会引发并发问题）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">代码实现：</span></span><br><span class="line">	在运行某个程序时，如何知道是否存在资源竞争问题，方法就是，在编译该程序时，增加一个参数 -race即可</span><br><span class="line"><span class="meta prompt_">	cmd&gt;</span><span class="language-bash">go build -race hello.go</span></span><br><span class="line"><span class="meta prompt_">	cmd&gt;</span><span class="language-bash">hello.exe</span></span><br><span class="line">	如果存在数据竞争，就会打印WARNING: DATA RACE  ...Found 2 data race(s)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不同goroutine之间如何通讯</span></span><br><span class="line">	1.全局变量加锁同步</span><br><span class="line">	2.channel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用全局变量加锁同步改进程序</span></span><br><span class="line">	1.因为没有对全局变量m加锁，因此会出现资源争夺问题，代码会出现提示concurrent map writes</span><br><span class="line">	2.解决方案，加入互斥锁</span><br><span class="line">	3.我们数的阶乘很大，结果会越界，可以将求阶乘改成sum+=uint64(i)</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么需要channel</span></span><br><span class="line">前面使用全局变量加锁同步来解决goroutine的通讯，但不完美：</span><br><span class="line">1.主线程在等待所有goroutine全部完成的时间很难确定，我们设置的休眠时间仅仅是估算</span><br><span class="line">2.如果主线程休眠时间长了，会加长等待时间，如果等待时间短了，可能还有goroutine处于工作状态，这时也会随着主线程退出而销毁</span><br><span class="line">3.通过全局变量加锁来实现通讯，也不利于多个协程对全局变量的读写操作</span><br><span class="line">4.因此我们引入channel机制</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方法1：全局变量加锁进行解决</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	arr <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>)</span><br><span class="line">	<span class="comment">//声明一个全局的互斥锁</span></span><br><span class="line">	<span class="comment">//lock是一个全局的互斥锁</span></span><br><span class="line">	<span class="comment">//sync是包，synchornized同步</span></span><br><span class="line">	<span class="comment">//Mutex：是互斥</span></span><br><span class="line">	lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">uint64</span> =<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		sum*=<span class="type">uint64</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加锁</span></span><br><span class="line">	lock.Lock()</span><br><span class="line">	arr[n]=sum</span><br><span class="line">	<span class="comment">//解锁</span></span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		#需求:现在要计算1-200的各个数的阶乘，并且把各个数的阶乘放入到map中，最后显示出来，要求使用goroutine完成。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		#分析思路：</span></span><br><span class="line"><span class="comment">			1.使用goroutine来完成，效率高，但是会出现并发/并行安全问题</span></span><br><span class="line"><span class="comment">			2.这里就提出了不同goroutine如何通信的问题</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//go arr[i]=cal(i)  //这样写是不可以的</span></span><br><span class="line">		<span class="keyword">go</span> cal(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//休眠10秒钟等待协程的完成</span></span><br><span class="line">	time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="comment">//这里还需要加锁，虽然上面的协程在10秒钟之内能够执行完，但是主线程并不知道，</span></span><br><span class="line">	<span class="comment">//因为在输出arr的时候仍然可能会出现资源竞争的问题，所以加入互斥锁来进行解决</span></span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">for</span> i, u := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%v\n&quot;</span>,i,u)</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方法2：管道机制</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求:现在要计算1-200的各个数的阶乘，并且把各个数的阶乘放入到map中，最后显示出来，要求使用goroutine完成。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n <span class="type">int</span>,mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">uint64</span>=<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		sum *= <span class="type">uint64</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	num:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>)</span><br><span class="line">	num[n]=sum</span><br><span class="line">	mapChan&lt;-num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span></span><br><span class="line">	mapChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>,<span class="number">200</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> cal(i,mapChan)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		num:=<span class="built_in">len</span>(mapChan)</span><br><span class="line">		<span class="keyword">if</span> num==<span class="number">20</span>&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(mapChan)</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> mapChan &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-基本介绍"><a href="#2-基本介绍" class="headerlink" title="2.基本介绍"></a>2.基本介绍</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">channel介绍</span></span><br><span class="line">1.channel本质就是一个数据结构-队列</span><br><span class="line">2.数据是先进先出</span><br><span class="line">3.线程安全，多goroutine访问时，不需要加锁，就是说channel本身就是线程安全的</span><br><span class="line">4.channel是由类型的，一个string的channel只能存放string类型数据</span><br></pre></td></tr></table></figure>

<h4 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3.快速入门"></a>3.快速入门</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义/声明channel</span></span><br><span class="line">var 变量名 chan 数据类型</span><br><span class="line">举例：</span><br><span class="line">var intChan chan int (intChan用于存放int数据)</span><br><span class="line">var mapChan chan map[int]string (mapChan用于存放map[int]string类型)</span><br><span class="line">var perChan chan Person</span><br><span class="line">var perChan2 chan *Person</span><br><span class="line">说明：</span><br><span class="line">	1.channel是引用类型</span><br><span class="line">	2.channel必须初始化才能写入数据，即make后才能使用</span><br><span class="line">	3.管道是有类型，intChan只能写入整数int</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">初始化管道：使用make进行初始化</span></span><br><span class="line">	intChan=make(chan int,3) //其中3就是指定管道的容量，初始化后就不可改变</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向channel中写入/取出数据</span></span><br><span class="line">	写数据</span><br><span class="line">	intChan &lt;- 10</span><br><span class="line">	num:=200</span><br><span class="line">	intChan&lt;-num</span><br><span class="line">	取数据</span><br><span class="line">	var num2 int</span><br><span class="line">	num2 =&lt;-intChan</span><br><span class="line">	&lt;-intChan  //也可以这样取，没有接收</span><br><span class="line">	</span><br><span class="line">	说明：在管道已满或者为空的情况下，继续存放数据或者取出数据时，就会报告-deadlock</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示 管道的初始化，写入（存取数据）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.创建一个可以存放3个int类型的管道</span></span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	intChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.看看intChan是什么</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;intChan的类型是%T,值是%v\n&quot;</span>,intChan,intChan)  <span class="comment">//intChan的类型是chan int,值是0xc000076080</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.向管道写入数据</span></span><br><span class="line">	intChan &lt;- <span class="number">10</span></span><br><span class="line">	num:=<span class="number">200</span></span><br><span class="line">	intChan&lt;-num</span><br><span class="line">	intChan&lt;-num+<span class="number">1</span></span><br><span class="line">	<span class="comment">//intChan&lt;-num+1    //当我们给管道写入数据时，不能超出其容量，容量就是make时给出的size大小，一经给出大小就固定了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.看看管道的长度和cap(容量)</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;intChan的长度len=%d,容量cap=%d\n&quot;</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))  <span class="comment">//intChan的长度len=2,容量cap=3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.从管道中取数据</span></span><br><span class="line">	<span class="keyword">var</span> num2 <span class="type">int</span></span><br><span class="line">	num2 =&lt;-intChan</span><br><span class="line">	num2 =&lt;-intChan</span><br><span class="line">	num2 =&lt;-intChan</span><br><span class="line">	fmt.Println(num2)  <span class="comment">//先进先出</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//6.在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报告-deadlock</span></span><br><span class="line">	<span class="comment">//num2 =&lt;-intChan  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-channel的遍历和关闭"><a href="#4-channel的遍历和关闭" class="headerlink" title="4.channel的遍历和关闭"></a>4.channel的遍历和关闭</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">channel的关闭</span></span><br><span class="line">使用内置函数Close可以关闭channel，当channel关闭后，就不能再向channel写数据了，但是仍然可以从该channel读取数据。如果继续写入会报panic: send on closed channel</span><br><span class="line">	close(perChan)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">channel的遍历</span></span><br><span class="line">channel支持for-range的方式进行遍历，但是要注意两个细节：</span><br><span class="line">	1.在遍历时,如果channel没有关闭，则会出现deadlock的错误</span><br><span class="line">	2.在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历,遍历的过程就是不断取出数据的过程</span><br><span class="line">//关闭管道后，对管道进行遍历，如果没有关闭管道，会遍历到数据，但是最终会报deadlock错误</span><br><span class="line">for v:= range perChan &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> perChan <span class="keyword">chan</span> Person</span><br><span class="line">	perChan=<span class="built_in">make</span>(<span class="keyword">chan</span> Person,<span class="number">10</span>)</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> s=rand.Intn(<span class="number">100</span>)</span><br><span class="line">		p:=Person&#123;Name: <span class="string">&quot;hello&quot;</span>+strconv.Itoa(s),Age:s,Address: <span class="string">&quot;hello&quot;</span>+strconv.Itoa(s)&#125;</span><br><span class="line">		<span class="comment">//fmt.Println(p)</span></span><br><span class="line">		perChan&lt;-p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不要用普通的for循环进行遍历管道，因为不容易确定管道的长度，而且管道的长度是动态变化的</span></span><br><span class="line">	<span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></span><br><span class="line">	<span class="comment">//	p:= &lt;-perChan</span></span><br><span class="line">	<span class="comment">//	fmt.Println(p)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="built_in">close</span>(perChan)  <span class="comment">//关闭管道</span></span><br><span class="line">	<span class="keyword">var</span> s=rand.Intn(<span class="number">100</span>)</span><br><span class="line">	p:=Person&#123;Name: <span class="string">&quot;hello&quot;</span>+strconv.Itoa(s),Age:s,Address: <span class="string">&quot;hello&quot;</span>+strconv.Itoa(s)&#125;</span><br><span class="line">	<span class="comment">//perChan&lt;-p  //panic: send on closed channel</span></span><br><span class="line">	p=&lt;-perChan</span><br><span class="line">	fmt.Println(p)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭管道后，对管道进行遍历，如果没有关闭管道，会遍历到数据，但是最终会报deadlock错误</span></span><br><span class="line">	<span class="comment">//在使用for-range遍历管道时，只有值，而没有索引这一变量</span></span><br><span class="line">	<span class="keyword">for</span> v:= <span class="keyword">range</span> perChan &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-goroutine和channel结合案例"><a href="#5-goroutine和channel结合案例" class="headerlink" title="5.goroutine和channel结合案例"></a>5.goroutine和channel结合案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请完成goroutine和channel协同工作的案例，具体要求：</span><br><span class="line">1.开启一个writeData协程，向管道intChan中写入50个整数</span><br><span class="line">2.开启一个readData协程，从管道intChan中读取writeData写入的数据</span><br><span class="line">3.注意writeData和readData操作的是同一个管道</span><br><span class="line">4.主线程需要等待writeData和readData协程都完成后才能退出</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">		num:=rand.Intn(<span class="number">100</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;write:&quot;</span>,num)</span><br><span class="line">		intChan&lt;-num</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭管道不影响读取数据</span></span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>,boolChan <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		v,ok:=&lt;-intChan</span><br><span class="line">        <span class="comment">//当管道关闭后，并且里面还没有数据的时候，ok就会返回false.</span></span><br><span class="line">		<span class="keyword">if</span> !ok&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;read:&quot;</span>,v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//readData读取完数据后，即任务完成</span></span><br><span class="line">	boolChan&lt;-<span class="literal">true</span></span><br><span class="line">	<span class="built_in">close</span>(boolChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	intChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">50</span>)</span><br><span class="line">	<span class="keyword">var</span> boolChan <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">	boolChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(boolChan))</span><br><span class="line">	<span class="keyword">go</span> write(intChan)</span><br><span class="line">	<span class="keyword">go</span> read(intChan,boolChan)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//time.Sleep(5*time.Second)</span></span><br><span class="line">	<span class="comment">//通过新建的boolChan来决定协程是否执行结束,来取代上面的休眠函数</span></span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		_,ok:=&lt;-boolChan</span><br><span class="line">        <span class="comment">//当管道关闭后，并且里面还没有数据的时候，ok就会返回false.</span></span><br><span class="line">		<span class="keyword">if</span> !ok&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-管道的阻塞"><a href="#6-管道的阻塞" class="headerlink" title="6.管道的阻塞"></a>6.管道的阻塞</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当管道的容量小于要写进去的数据的总数时，如果没有从管道中读取数据的操作，那么就会出现阻塞而最终deadlock.原因是intChan容量是10，而要写入50个数据，#因此会阻塞直至死锁。</span><br><span class="line">2.但是当有读取的操作时，即便读操作慢于写操作，且要写进去的数据的个数大于管道的容量，程序也只会阻塞进入等待读取的状态，等读取之后就又可以重新进行写入了，#所以程序会正常执行。</span><br></pre></td></tr></table></figure>

<h4 id="7-协程和管道的应用实例3"><a href="#7-协程和管道的应用实例3" class="headerlink" title="7.协程和管道的应用实例3"></a>7.协程和管道的应用实例3</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求</span></span><br><span class="line">要求统计1-200000的数字中，哪些是素数？【测试使用8000】</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//使用协程加管道的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">200000</span>; i++ &#123;</span><br><span class="line">		intChan&lt;-i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭通道</span></span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>,resChan <span class="keyword">chan</span> <span class="type">int</span>,exitChan <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		v,ok:=&lt;-intChan</span><br><span class="line">        <span class="comment">//当管道中有数据可以取出时，v就是取出的内容，ok等于true，当没有数据可以取出时，v就是为空，ok为false.</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;  <span class="comment">//管道中取不出数据</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		b:=<span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">2</span>; j &lt;= v/<span class="number">2</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> v%j==<span class="number">0</span>&#123;</span><br><span class="line">				b=<span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//如果b为true的话，说明从intChan 中取出的数据就是素数</span></span><br><span class="line">		<span class="keyword">if</span> b&#123;</span><br><span class="line">			resChan&lt;-v</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这是判断是否从协程中取完了数据，如果是，就关闭这个resChan</span></span><br><span class="line">		<span class="comment">//if v==8000&#123;</span></span><br><span class="line">		<span class="comment">//	close(resChan)</span></span><br><span class="line">		<span class="comment">//	exitChan&lt;-true</span></span><br><span class="line">		<span class="comment">//	close(exitChan)</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;有一个取数据判断素数的协程cal因为取不到数据，退出&quot;)</span></span><br><span class="line">	<span class="comment">//这里我们还不能关闭resChan这个管道，因为有四个这样的协程，所以我们还不能关闭</span></span><br><span class="line">	<span class="comment">//向exitChan写入true</span></span><br><span class="line">	exitChan&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//要求统计1-200000的数字中，哪些是素数？[测试数据是80000]</span></span><br><span class="line">	<span class="comment">//2、3、5、7、11、13、17、19、23、29、31、37、41、43、47、53、59、61、67、71、73、79、83、89、97。”</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//传统方法</span></span><br><span class="line">	<span class="comment">/*for i := 2; i &lt; 80000; i++ &#123;</span></span><br><span class="line"><span class="comment">		b:=true</span></span><br><span class="line"><span class="comment">		for j := 2; j &lt;= i/2; j++ &#123;</span></span><br><span class="line"><span class="comment">			if i%j==0&#123;</span></span><br><span class="line"><span class="comment">				b=false</span></span><br><span class="line"><span class="comment">				break</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		if b&#123;</span></span><br><span class="line"><span class="comment">			fmt.Println(i,&quot;是素数&quot;)</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	t1:=time.Now().Unix()</span><br><span class="line">	fmt.Println(t1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="type">int</span>=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1000</span>)</span><br><span class="line">	<span class="keyword">var</span> resChan <span class="keyword">chan</span> <span class="type">int</span>=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">100000</span>)</span><br><span class="line">	<span class="comment">//开启一个协程放入1-8000的数</span></span><br><span class="line">	<span class="keyword">go</span> insert(intChan)</span><br><span class="line">	exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">4</span>)  <span class="comment">//4个，根据协程数来决定</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启4个协程从intChan中取出数据并判断是否是素数，如果是就存进resChan中</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> cal(intChan,resChan,exitChan)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for  &#123;</span></span><br><span class="line">	<span class="comment">//	v,ok:=&lt;-resChan</span></span><br><span class="line">	<span class="comment">//	if !ok&#123;</span></span><br><span class="line">	<span class="comment">//		break</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(v,&quot;是素数&quot;)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里我们主线程，进行处理</span></span><br><span class="line">	<span class="comment">//当exitChan长度为4时就关闭resChan</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//此时说明四个协程任务均已经完成，intChan中的数据也已经取完</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(exitChan)==<span class="number">4</span>&#123;</span><br><span class="line">			<span class="built_in">close</span>(resChan)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t2:=time.Now().Unix()</span><br><span class="line">	fmt.Println(t2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;使用时间：&quot;</span>,t2-t1)</span><br><span class="line">	<span class="comment">//遍历结果</span></span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		_,ok:=&lt;-resChan</span><br><span class="line">		<span class="keyword">if</span> !ok&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//fmt.Println(v,&quot;是素数&quot;)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-channel使用细节和注意事项"><a href="#8-channel使用细节和注意事项" class="headerlink" title="8.channel使用细节和注意事项"></a>8.channel使用细节和注意事项</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.channel可以声明为只读，或者只写性质</span><br><span class="line">2.channel只读和只写的最佳案例(可以防止误操作)</span><br><span class="line">	说明：形参类型为chan&lt;- int的可以接收chan&lt;- int和chan int两种类型的数据</span><br><span class="line">3.使用select可以解决从管道取数据的阻塞问题</span><br><span class="line">4.goroutine中使用recover,解决协程中出现panic,导致程序崩溃的问题。这时如果我们goroutine中使用recover来捕获panic，进行处理，这样即使这个协程发生了问题，但是这线程仍然不受影响，可以继续执行</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二点代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(chan2 <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;chan2的类型%T,值为%v\n&quot;</span>,chan2,chan2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(chan3 &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;chan3的类型%T,值为%v\n&quot;</span>,chan3,chan3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//管道可以声明为只读或者只写</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.默认情况下声明为双向的</span></span><br><span class="line">	<span class="keyword">var</span> chan1 <span class="keyword">chan</span> <span class="type">int</span>  <span class="comment">//可读可写</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.声明为只写</span></span><br><span class="line">	<span class="keyword">var</span> chan2 <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">	chan2=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line">	chan2&lt;<span class="number">-2</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;chan2的类型%T,值为%v\n&quot;</span>,chan2,chan2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.声明为只读</span></span><br><span class="line">	<span class="keyword">var</span> chan3 &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	chan3=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;chan3的类型%T,值为%v\n&quot;</span>,chan3,chan3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//形参类型为chan&lt;- int的可以接收chan&lt;- int和chan int两种类型的数据</span></span><br><span class="line">	test1(chan1)</span><br><span class="line">	test2(chan1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三点代码演示：</span></span><br><span class="line"><span class="comment">//使用select可以解决从管道取数据的阻塞问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.定义1个管道 10个数据int</span></span><br><span class="line">	intChan :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		intChan&lt;-i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.定义1个管道 5个数据string</span></span><br><span class="line">	strChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>,<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		strChan&lt;-<span class="string">&quot;hello&quot;</span>+fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//传统的方法在遍历管道时，如果不关闭会阻塞而导致 deadlock</span></span><br><span class="line">	<span class="comment">//问题：在实际开发中我们不好确定何时去关闭管道</span></span><br><span class="line">	<span class="comment">//可以使用select进行解决</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">//注意：这里，如果intChan一直没有关闭，不会一直阻塞而deadlock</span></span><br><span class="line">		<span class="comment">//，而是会自动到下一个case匹配</span></span><br><span class="line">			<span class="keyword">case</span> v:=&lt;-intChan:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;取得数据%v\n&quot;</span>,v)</span><br><span class="line">			<span class="keyword">case</span> v:=&lt;-strChan:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;取得str数据%v\n&quot;</span>,v)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">&quot;都取不到了，不玩了，程序员可以加入&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第四点演示4.goroutine中使用recover,解决协程中出现panic,导致程序崩溃的问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//这里我们可以使用错误处理机制defer+recover</span></span><br><span class="line">	<span class="comment">//注意这里面的defer函数要写在发生错误之前，否则不起作用</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//捕获test抛出的异常</span></span><br><span class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;test发生异常,err=&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义了一个map</span></span><br><span class="line">	<span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">	myMap[<span class="number">0</span>]=<span class="string">&quot;golang&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//4.goroutine中使用recover,解决协程中出现panic,导致程序崩溃的问题</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> sayHello()</span><br><span class="line">	<span class="keyword">go</span> test()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;main ok=&quot;</span>,i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十一章：反射机制"><a href="#第十一章：反射机制" class="headerlink" title="第十一章：反射机制"></a>第十一章：反射机制</h2><h3 id="1-引出问题"><a href="#1-引出问题" class="headerlink" title="1.引出问题"></a>1.引出问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在进行json序列化和反序列化的时候，对于结构体数据的字段名使用tag进行处理时，就需要用到反射。</span><br><span class="line">2.使用反射机制，编写函数适配器</span><br></pre></td></tr></table></figure>

<h3 id="2-基本介绍-1"><a href="#2-基本介绍-1" class="headerlink" title="2.基本介绍"></a>2.基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">介绍</span></span><br><span class="line">1.反射可以在运行时动态获取变量的各种信息，比如变量的类型（type）,类别（kind）</span><br><span class="line">2.如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段，方法）</span><br><span class="line">3.通过反射，可以修改变量的值，可以调用关联的方法</span><br><span class="line">4.使用反射，需要import (&quot;reflect&quot;)</span><br><span class="line"></span><br><span class="line">package reflect</span><br><span class="line">import &quot;reflect&quot;</span><br><span class="line">reflect包实现了运行时反射，允许程序操作任意类型的对象。典型用法是用静态类型interface&#123;&#125;保存一个值，通过调用TypeOf获取其动态类型信息，该函数返回一个Type类型值。调用ValueOf函数返回一个Value类型值，该值代表运行时的数据。Zero接受一个Type类型参数并返回一个代表该类型零值的Value类型值。</span><br><span class="line"></span><br><span class="line">func TypeOf</span><br><span class="line">func TypeOf(i interface&#123;&#125;) Type</span><br><span class="line">TypeOf返回接口中保存的值的类型，TypeOf(nil)会返回nil。</span><br><span class="line"></span><br><span class="line">func ValueOf</span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value</span><br><span class="line">ValueOf返回一个初始化为i接口保管的具体值的Value，ValueOf(nil)返回Value零值。</span><br><span class="line"></span><br><span class="line">func (Value) Interface</span><br><span class="line">func (v Value) Interface() (i interface&#123;&#125;)</span><br><span class="line">本方法返回v当前持有的值（表示为/保管在interface&#123;&#125;类型），等价于：</span><br><span class="line">var i interface&#123;&#125; = (v&#x27;s underlying value)</span><br><span class="line">如果v是通过访问非导出结构体字段获取的，会导致panic。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反射重要的函数和概念</span></span><br><span class="line">1.reflect.TypeOf(变量名)，获取变量的类型，返回reflect.Type类型，这是一个接口</span><br><span class="line">2.reflect.ValueOf(变量名)，获取变量的值，返回reflect.Value类型，这时一个结构体类型，通过reflect.Value,可以获取带关于该变量的很多信息</span><br><span class="line">3.变量，interface&#123;&#125;和reflect.Value是可以相互转换的，这点在实际开发中，会经常使用到</span><br><span class="line">	变量var num 10 --》 b interface&#123;&#125;  可以通过函数传参实现</span><br><span class="line">	b interface&#123;&#125; --》 reflect.Value  rVal:=reflect.ValueOf(b)</span><br><span class="line">    reflect.Value --》 c interface&#123;&#125;  c:=rVal.Interface()</span><br><span class="line">    interface&#123;&#125;   --&gt; 原来的变量类型int  使用类型断言 v:=c.(int)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三点代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//需求1.</span></span><br><span class="line">	<span class="comment">//	请编写一个案例，演示对（基本数据类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span></span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">	<span class="comment">//将变量转换为interface&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;=num</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将interface&#123;&#125;转换为reflect.Value</span></span><br><span class="line">	<span class="keyword">var</span> rv reflect.Value =reflect.ValueOf(i)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将reflect.Value类型转换为interface&#123;&#125;类型</span></span><br><span class="line">	<span class="keyword">var</span> ii <span class="keyword">interface</span>&#123;&#125;=rv.Interface()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将interface&#123;&#125;类型转换为原来的变量的类型</span></span><br><span class="line">	<span class="keyword">var</span> num2 <span class="type">int</span>=ii.(<span class="type">int</span>)</span><br><span class="line">	fmt.Println(num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-反射的快速入门"><a href="#3-反射的快速入门" class="headerlink" title="3.反射的快速入门"></a>3.反射的快速入门</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求1.</span></span><br><span class="line">请编写一个案例，演示对（基本数据类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求2.</span></span><br><span class="line">请编写一个案例，演示对（结构体类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求1.</span></span><br><span class="line"><span class="comment">//	请编写一个案例，演示对（基本数据类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//专门演示反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	<span class="comment">//通过反射获取的传入的变量的type,kind,值</span></span><br><span class="line">	<span class="comment">//1.先获取到reflect.Type</span></span><br><span class="line">	<span class="keyword">var</span> rType reflect.Type=reflect.TypeOf(b)</span><br><span class="line">	fmt.Println(<span class="string">&quot;rType=&quot;</span>,rType)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.获取到reflect.Value</span></span><br><span class="line">	<span class="keyword">var</span> rValue reflect.Value=reflect.ValueOf(b)</span><br><span class="line">	num:= <span class="number">2</span>+rValue.Int()  <span class="comment">//将reflect.Value值转换为int64类型值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;num=&quot;</span>,num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;rValue类型=%T,值=%v\n&quot;</span>,rValue,rValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面我们将rValue转成interface&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> iV <span class="keyword">interface</span>&#123;&#125;=rValue.Interface()</span><br><span class="line">    <span class="comment">//var num3 int=iV //会报错，运行的时候虽然这个iV是int类型，但是编译的时候并不知道</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;iV类型=%T,值=%v\n&quot;</span>,iV,iV)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将interface&#123;&#125;类型通过类型断言转换为int</span></span><br><span class="line">	<span class="keyword">var</span> num2 <span class="type">int</span>=iV.(<span class="type">int</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;num2=&quot;</span>,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">	reflectTest01(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求2.</span></span><br><span class="line"><span class="comment">//请编写一个案例，演示对（结构体类型，interface&#123;&#125;,reflect.Value）进行反射的基本操作</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//专门演示反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	<span class="comment">//通过反射获取的传入的变量的type,kind,值</span></span><br><span class="line">	<span class="comment">//1.先获取到reflect.Type</span></span><br><span class="line">	<span class="keyword">var</span> rType reflect.Type=reflect.TypeOf(b)</span><br><span class="line">	fmt.Println(<span class="string">&quot;rType=&quot;</span>,rType)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.获取到reflect.Value</span></span><br><span class="line">	<span class="keyword">var</span> rValue reflect.Value=reflect.ValueOf(b)</span><br><span class="line">	<span class="comment">//num:= 2+rValue.Int()  //将reflect.Value值转换为int64类型值</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;num=&quot;,num)</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;rValue类型=%T,值=%v\n&quot;</span>,rValue,rValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面我们将rValue转成interface&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> iV <span class="keyword">interface</span>&#123;&#125;=rValue.Interface()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;iV类型=%T,值=%v\n&quot;</span>,iV,iV)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将interface&#123;&#125;类型通过类型断言转换为Student</span></span><br><span class="line">	stu2,ok:=iV.(Student)</span><br><span class="line">	<span class="keyword">if</span> ok&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;stu2=&quot;</span>,stu2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> stu Student=Student&#123;Name:<span class="string">&quot;hello&quot;</span>,Age: <span class="number">15</span>&#125;</span><br><span class="line">	reflectTest01(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-反射的注意事项和使用细节"><a href="#4-反射的注意事项和使用细节" class="headerlink" title="4.反射的注意事项和使用细节"></a>4.反射的注意事项和使用细节</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.reflect.Value.Kind,获取变量的类别，返回的是一个常量。【看手册】</span><br><span class="line">2.Type是类型，Kind是类别，Type和Kind可能是相同的，也可能是不同的</span><br><span class="line">	比如：var num int=10  num的Type是int,kind也是int</span><br><span class="line">	比如：var stu Student num的Type是包名.Student,Kind是struct</span><br><span class="line">3.通过反射可以让变量、interface&#123;&#125;,reflect.Value相互转换</span><br><span class="line">4.使用反射的方式来获取变量的值（并返回对应的类型），要求数据类型匹配，比如x是int,那么就应该使用reflect.Value(x).Int(),而不能用其他的，否则报panic</span><br><span class="line">5.通过反射来修改变量，注意当使用SetXxxx方法来设置需要通过对应的指针类型来完成，这样才能改变传入的变量的值，同时需要使用到reflect.Value.Elem()方法</span><br><span class="line"></span><br><span class="line">6.reflect.Value.Elem()方法</span><br><span class="line">func (Value) Elem</span><br><span class="line">func (v Value) Elem() Value</span><br><span class="line">Elem返回v持有的接口保管的值的Value封装，或者v持有的指针指向的值的Value封装。如果v的Kind不是Interface或Ptr会panic；如果v持有的值为nil，会返回Value零值。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.代码演示</span></span><br><span class="line"><span class="comment">//通过反射，修改基本类型int,结构体类型Student的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	rValue:=reflect.ValueOf(b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;rValue的类型是：%T,值是：%v\n&quot;</span>,rValue,rValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面语句执行panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">	<span class="comment">//rValue.SetInt(20)  </span></span><br><span class="line">    <span class="comment">//注意即便这个rValue的类型就是int，执行上面这条语句也还是会报错，依然需要使用下面这种方式，虽然这样不报错但不会修改main函数里面的值，所以还是需要传入&amp;stu</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行成功  rValue.Elem()的作用类似于是取到*rValue ,但是*rValue这个操作是不可行的，所以有了这个函数</span></span><br><span class="line">	rValue.Elem().SetInt(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//var stu Student=Student&#123;Name:&quot;hello&quot;,Age: 15&#125;</span></span><br><span class="line">	<span class="keyword">var</span> stu <span class="type">int</span>=<span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;反射前：&quot;</span>,stu)</span><br><span class="line">	reflectTest01(&amp;stu)</span><br><span class="line">	fmt.Println(<span class="string">&quot;反射后：&quot;</span>,stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-反射的最佳实践"><a href="#5-反射的最佳实践" class="headerlink" title="5.反射的最佳实践"></a>5.反射的最佳实践</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践1</span></span><br><span class="line">使用反射来遍历结构体的字段，调用结构体的方法，并获取结构体标签的值</span><br><span class="line"></span><br><span class="line">func (Value) Call</span><br><span class="line">func (v Value) Call(in []Value) []Value</span><br><span class="line">Call方法使用输入的参数in调用v持有的函数。例如，如果len(in) == 3，v.Call(in)代表调用v(in[0], in[1], in[2])（其中Value值表示其持有值）。如果v的Kind不是Func会panic。它返回函数所有输出结果的Value封装的切片。和go代码一样，每一个输入实参的持有值都必须可以直接赋值给函数对应输入参数的类型。如果v持有值是可变参数函数，Call方法会自行创建一个代表可变参数的切片，将对应可变参数的值都拷贝到里面。</span><br><span class="line"></span><br><span class="line">func (Value) Method</span><br><span class="line">func (v Value) Method(i int) Value</span><br><span class="line">返回v持有值类型的第i个方法的已绑定（到v的持有值的）状态的函数形式的Value封装。返回值调用Call方法时不应包含接收者；返回值持有的函数总是使用v的持有者作为接收者（即第一个参数）。如果i出界，或者v的持有值是接口类型的零值（nil），会panic。</span><br><span class="line"></span><br><span class="line">func (Value) Field</span><br><span class="line">func (v Value) Field(i int) Value</span><br><span class="line">返回结构体的第i个字段（的Value封装）。如果v的Kind不是Struct或i出界会panic</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">值得注意的是Field()方法必须中v的kind有这个要求，v的Kind不是Struct或i出界会panic，所以遇到结构体的指针类型时需要使用Elem()方法返回，而Method()则没有这个要求</span></span><br><span class="line"></span><br><span class="line">func (Value) MethodByName</span><br><span class="line">func (v Value) MethodByName(name string) Value</span><br><span class="line">返回v的名为name的方法的已绑定（到v的持有值的）状态的函数形式的Value封装。返回值调用Call方法时不应包含接收者；返回值持有的函数总是使用v的持有者作为接收者（即第一个参数）。如果未找到该方法，会返回一个Value零值。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.实践1代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="type">int</span> <span class="string">`json:&quot;monster_age&quot;`</span></span><br><span class="line">	Score <span class="type">float32</span></span><br><span class="line">	Sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Print()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> GetSum(n1,n2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Set(name <span class="type">string</span>,age <span class="type">int</span>,score <span class="type">float32</span>,sex <span class="type">string</span>)  &#123;</span><br><span class="line">	s.Name=name</span><br><span class="line">	s.Age=age</span><br><span class="line">	s.Score=score</span><br><span class="line">	s.Sex=sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStruct</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	rType:=reflect.TypeOf(a)</span><br><span class="line">	rValue:=reflect.ValueOf(a)</span><br><span class="line">	kind:=rValue.Kind()</span><br><span class="line">	<span class="keyword">if</span> kind!=reflect.Struct&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;期待结构体类型&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取得这个类型的字段个数</span></span><br><span class="line">	num:=rValue.NumField()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d fields\n&quot;</span>,num)</span><br><span class="line">	<span class="comment">//遍历结构体的所有字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Field %d :值为：%v\n&quot;</span>,i,rValue.Field(i))</span><br><span class="line">		<span class="comment">//获取到struct标签，注意需要通过reflect.Type来获取tag标签的值</span></span><br><span class="line">		tagVal:=rType.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> tagVal!=<span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Field %d:tag为%v\n&quot;</span>,i,tagVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取和这个类型绑定的方法个数</span></span><br><span class="line">	numOfMethod:=rValue.NumMethod()  <span class="comment">//获取方法时，是使用方法名的字典顺序来排的</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d methods&quot;</span>,numOfMethod)</span><br><span class="line">	rValue.Method(<span class="number">1</span>).Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用结构体的第1个方法Method[0]</span></span><br><span class="line">	<span class="keyword">var</span> params []reflect.Value</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">40</span>))</span><br><span class="line">	res:=rValue.Method(<span class="number">0</span>).Call(params)  <span class="comment">//传入的参数是params</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>,res[<span class="number">0</span>].Int()) <span class="comment">//返回结果，返回的结果res是[]reflect.value切片</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a Monster=Monster&#123;Name:<span class="string">&quot;黄鼠狼精&quot;</span>,Age:<span class="number">300</span>,Score:<span class="number">32.0</span>&#125;</span><br><span class="line">	TestStruct(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践2</span></span><br><span class="line">2.使用反射的方式来获取结构体的tag标签,遍历字段的值，修改字段值，调用结构体方法（要求：通过传递地址的方式完成，在前面案例上修改即可）</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实践2代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="type">int</span> <span class="string">`json:&quot;monster_age&quot;`</span></span><br><span class="line">	Score <span class="type">float32</span></span><br><span class="line">	Sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Print()  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> GetSum(n1,n2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span></span> Set(name <span class="type">string</span>,age <span class="type">int</span>,score <span class="type">float32</span>,sex <span class="type">string</span>)  &#123;</span><br><span class="line">	s.Name=name</span><br><span class="line">	s.Age=age</span><br><span class="line">	s.Score=score</span><br><span class="line">	s.Sex=sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStruct</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	rType:=reflect.TypeOf(a)</span><br><span class="line">	rValue:=reflect.ValueOf(a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;rValue的类型%T,值=%v,kind=%v\n&quot;</span>,rValue,rValue,rValue.Kind())</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	func (v Value) Kind() Kind</span></span><br><span class="line"><span class="comment">	Kind返回v持有的值的分类，如果v是Value零值，返回值为Invalid</span></span><br><span class="line"><span class="comment">	因为此时rValue是指向结构体Monster的指针，直接用rValue.Kind()则得到的是指针ptr类别，因此要想获得指针rValue指向的值struct类别，所以需要用到rValue.Elem()。至于后面的rValue.Elem().NumField()，rValue.Elem().Field(0).SetString(&quot;白象精&quot;)，rType.Elem().Field(i).Tag.Get(&quot;json&quot;)都是一个道理</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    </span><br><span class="line">    kind:=rValue.Elem().Kind()</span><br><span class="line">	<span class="keyword">if</span> kind!=reflect.Struct&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;期待结构体类型&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取得这个类型的字段个数</span></span><br><span class="line">	num:=rValue.Elem().NumField()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d fields\n&quot;</span>,num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改字段的值</span></span><br><span class="line">	rValue.Elem().Field(<span class="number">0</span>).SetString(<span class="string">&quot;白象精&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历结构体的所有字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Field %d :值为：%v\n&quot;</span>,<span class="number">0</span>,rValue.Elem().Field(<span class="number">0</span>))</span><br><span class="line">		<span class="comment">//获取到struct标签，注意需要通过reflect.Type来获取tag标签的值</span></span><br><span class="line">		tagVal:=rType.Elem().Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> tagVal!=<span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Field %d:tag为%v\n&quot;</span>,i,tagVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取和这个类型绑定的方法个数</span></span><br><span class="line">	numOfMethod:=rValue.NumMethod()  <span class="comment">//获取方法时，是使用方法名的字典顺序来排的</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d methods\n&quot;</span>,numOfMethod)</span><br><span class="line">	rValue.Method(<span class="number">1</span>).Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用结构体的第1个方法Method[0]</span></span><br><span class="line">	<span class="keyword">var</span> params []reflect.Value</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">40</span>))</span><br><span class="line">	res:=rValue.Method(<span class="number">0</span>).Call(params)  <span class="comment">//传入的参数是params</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>,res[<span class="number">0</span>].Int()) <span class="comment">//返回结果，返回的结果res是[]reflect.value切片</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a Monster=Monster&#123;Name:<span class="string">&quot;黄鼠狼精&quot;</span>,Age:<span class="number">300</span>,Score:<span class="number">32.0</span>&#125;</span><br><span class="line">	<span class="comment">//修改前</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;修改前：&quot;</span>,a)</span><br><span class="line">    <span class="comment">//要修改字段值时，就需要传递地址进去</span></span><br><span class="line">	TestStruct(&amp;a)</span><br><span class="line">	<span class="comment">//修改后</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;修改后：&quot;</span>,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践3</span></span><br><span class="line">定义了两个函数test1和test2，定义一个适配器函数用作统一处理接口</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实践3代码</span></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectFunc</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	var call1 func(v1 int, v2 int) = func(v1 int,v2 int) &#123;</span></span><br><span class="line"><span class="comment">										t.Log(v1,&quot; &quot;,v2)</span></span><br><span class="line"><span class="comment">									  &#125;</span></span><br><span class="line"><span class="comment">	call1是一个函数类型的变量</span></span><br><span class="line"><span class="comment">	调用就是call1(1,2)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//函数类型的变量</span></span><br><span class="line">	call1:= <span class="function"><span class="keyword">func</span><span class="params">(v1 <span class="type">int</span>,v2 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		t.Log(v1,<span class="string">&quot; &quot;</span>,v2)</span><br><span class="line">	&#125;</span><br><span class="line">	call2:= <span class="function"><span class="keyword">func</span><span class="params">(v1 <span class="type">int</span>,v2 <span class="type">int</span>,s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		t.Log(v1,<span class="string">&quot; &quot;</span>,v2,<span class="string">&quot; &quot;</span>,s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		function reflect.Value</span><br><span class="line">		intValue []reflect.Value</span><br><span class="line">		n <span class="type">int</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统一适配器函数处理接口</span></span><br><span class="line">	bridge:= <span class="function"><span class="keyword">func</span><span class="params">(call <span class="keyword">interface</span>&#123;&#125;,args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		<span class="comment">//n是指该函数有多少个形参</span></span><br><span class="line">		n=<span class="built_in">len</span>(args)</span><br><span class="line">		<span class="comment">//function是指函数名</span></span><br><span class="line">		function=reflect.ValueOf(call)</span><br><span class="line">		<span class="comment">//intValue是指传入的各个形式参数的值</span></span><br><span class="line">		intValue=<span class="built_in">make</span>([]reflect.Value,n,n)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">			<span class="comment">//将每一个传入的参数转为reflect.Value</span></span><br><span class="line">			intValue[i]=reflect.ValueOf(args[i])</span><br><span class="line">		&#125;</span><br><span class="line">		function.Call(intValue)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bridge(call1,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">	bridge(call2,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;string&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践4：使用反射操作任意类型的结构体</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实践4代码</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">	UserId <span class="type">string</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectStruct</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span>(</span><br><span class="line">		model *User</span><br><span class="line">		rValue reflect.Value</span><br><span class="line">	)</span><br><span class="line">	model=&amp;User&#123;&#125;</span><br><span class="line">	rValue=reflect.ValueOf(model)</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf&quot;</span>,rValue.Kind().String())</span><br><span class="line">	rValue=rValue.Elem()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf&quot;</span>,rValue.Kind().String())</span><br><span class="line">	rValue.FieldByName(<span class="string">&quot;UserId&quot;</span>).SetString(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">	rValue.FieldByName(<span class="string">&quot;Name&quot;</span>).SetString(<span class="string">&quot;nickname&quot;</span>)</span><br><span class="line">	t.Log(<span class="string">&quot;model&quot;</span>,*model)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实践5</span></span><br><span class="line">使用反射创建并操作结构体</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实践5代码</span></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">	UserId <span class="type">string</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectStruct</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span>(</span><br><span class="line">		model *User</span><br><span class="line">		rType reflect.Type</span><br><span class="line">		elem reflect.Value</span><br><span class="line">	)</span><br><span class="line">	model=&amp;User&#123;&#125;</span><br><span class="line">	rType=reflect.TypeOf(model)</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.TypeOf&quot;</span>,rType.Kind().String())</span><br><span class="line">	rType=rType.Elem()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.TypeOf.Elem&quot;</span>,rType.Kind().String())</span><br><span class="line"></span><br><span class="line">	elem=reflect.New(rType)  <span class="comment">//New返回一个Value类型值，该值持有一个指向类型为rType的新申请的零值的指针</span></span><br><span class="line">	t.Log(<span class="string">&quot;reflect.New&quot;</span>,elem.Kind().String())  <span class="comment">//ptr</span></span><br><span class="line">	t.Log(<span class="string">&quot;reflect.New.Elem&quot;</span>,elem.Elem().Kind().String())  <span class="comment">//struct</span></span><br><span class="line"> 	<span class="comment">//model就是创建的user结构体变量（实例）</span></span><br><span class="line">	model=elem.Interface().(*User)  <span class="comment">//model是*User,他的指向和elem是一样的</span></span><br><span class="line">	elem=elem.Elem() <span class="comment">//取得elem指向的值</span></span><br><span class="line">	elem.FieldByName(<span class="string">&quot;UserId&quot;</span>).SetString(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">	elem.FieldByName(<span class="string">&quot;Name&quot;</span>).SetString(<span class="string">&quot;nickname&quot;</span>)</span><br><span class="line">	t.Log(<span class="string">&quot;elem&quot;</span>,elem)</span><br><span class="line">	t.Log(<span class="string">&quot;model&quot;</span>,*model)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-练习"><a href="#6-练习" class="headerlink" title="6.练习"></a>6.练习</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cal <span class="keyword">struct</span>&#123;</span><br><span class="line">	Num1 <span class="type">int</span></span><br><span class="line">	Num2 <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cal)</span></span> GetSub2(name <span class="type">string</span>)  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v 完成了减法运行，%v-%v=%v&quot;</span>,name,c.Num1,c.Num2,c.Num1-c.Num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetSub2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Cal=Cal&#123;<span class="number">8</span>,<span class="number">3</span>&#125;</span><br><span class="line">	rType:=reflect.TypeOf(c)   <span class="comment">//获取c的类型</span></span><br><span class="line">	t.Log(<span class="string">&quot;reflect.TypeOf&quot;</span>,rType)</span><br><span class="line">	rValue:=reflect.ValueOf(c) <span class="comment">//获取c的值类型</span></span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf&quot;</span>,rValue)</span><br><span class="line">	kind:=rValue.Kind()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf.Kind&quot;</span>,kind)</span><br><span class="line"></span><br><span class="line">	n1:=rValue.FieldByName(<span class="string">&quot;Num1&quot;</span>).Int()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf.FieldByName.Int&quot;</span>,n1)</span><br><span class="line">	n2:=rValue.FieldByName(<span class="string">&quot;Num2&quot;</span>).Int()</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf.FieldByName.Int&quot;</span>,n2)</span><br><span class="line"></span><br><span class="line">	function:=rValue.MethodByName(<span class="string">&quot;GetSub2&quot;</span>)</span><br><span class="line">	t.Log(<span class="string">&quot;reflect.ValueOf.MethodByName&quot;</span>,function)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	intValue:=<span class="built_in">make</span>([]reflect.Value,<span class="number">1</span>)</span><br><span class="line">	intValue[<span class="number">0</span>]=reflect.ValueOf(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">	function.Call(intValue)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十二章：tcp编程"><a href="#第十二章：tcp编程" class="headerlink" title="第十二章：tcp编程"></a>第十二章：tcp编程</h2><h3 id="1-网络编程基本介绍"><a href="#1-网络编程基本介绍" class="headerlink" title="1.网络编程基本介绍"></a>1.网络编程基本介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.golang的主要设计目标就是面向大规模后端服务程序，网络通信这块是服务端程序必不可少也是至关重要的一部分</span><br><span class="line"></span><br><span class="line">网络编程主要有两种：</span><br><span class="line">1.TCP socket编程，是网络编程的主流，基于tcp/ip协议</span><br><span class="line">2.b/s结构的https编程，使用浏览器去访问服务器时，使用的就是http协议，而http底层依旧是tcp socket实现的</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">cmd&gt;</span><span class="language-bash">tracert www.baidu.com  //跟踪路由</span></span><br><span class="line"><span class="meta prompt_">cmd&gt;</span><span class="language-bash">netstat -an  //可以查看本机有哪些端口被监听</span></span><br><span class="line"><span class="meta prompt_">cmd&gt;</span><span class="language-bash">netstat -anb //来产看监听端口的pid,再结合任务管理器关闭不安全的端口</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">cmd&gt;</span><span class="language-bash">telnet 127.0.0.1 8888  //来查看这个地址的端口号是否处于等待监听状态  进入之后，可以使用ctrl+]退出</span></span><br><span class="line">客户端的端口是随机给的</span><br></pre></td></tr></table></figure>

<h3 id="2-快速入门-5"><a href="#2-快速入门-5" class="headerlink" title="2.快速入门"></a>2.快速入门</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">服务器的处理流程</span></span><br><span class="line">1.监听端口</span><br><span class="line">2.接收客户端的tcp连接，建立客户端和服务器端的链接</span><br><span class="line">3.创建goroutine,处理该链接的请求（客户端通常会通过链接请求发送包）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端的处理流程</span></span><br><span class="line">1.建立和服务端的链接</span><br><span class="line">2.发送请求数据，接收服务器端返回的结果数据</span><br><span class="line">3.关闭链接</span><br><span class="line"></span><br><span class="line">func Listen ¶</span><br><span class="line">func Listen(net, laddr string) (Listener, error)</span><br><span class="line">返回在一个本地网络地址laddr上监听的Listener。网络类型参数net必须是面向流的网络：</span><br><span class="line">&quot;tcp&quot;、&quot;tcp4&quot;、&quot;tcp6&quot;、&quot;unix&quot;或&quot;unixpacket&quot;。参见Dial函数获取laddr的语法。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端代码 tcp_socket/server/main/server.go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	服务器端功能：</span></span><br><span class="line"><span class="comment">		编写一个服务器端程序，在8888端口监听</span></span><br><span class="line"><span class="comment">		可以和多个客户端创建链接</span></span><br><span class="line"><span class="comment">		链接成功后，客户端可以发送数据，服务器端接收数据，并显示在终端上</span></span><br><span class="line"><span class="comment">		先使用telnet来测试，然后编写客户端程序来测试</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	客户端功能：</span></span><br><span class="line"><span class="comment">		编写一个客户端程序，能链接到服务器端的8888端口</span></span><br><span class="line"><span class="comment">		客户端可以发送多行数据，然后就退出</span></span><br><span class="line"><span class="comment">	功能扩展：</span></span><br><span class="line"><span class="comment">		能通过终端输入数据（输入一行发送一行），并发送给服务器端</span></span><br><span class="line"><span class="comment">		在终端输入exit,表示退出程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">func Listen ¶</span></span><br><span class="line"><span class="comment">func Listen(net, laddr string) (Listener, error)</span></span><br><span class="line"><span class="comment">返回在一个本地网络地址laddr上监听的Listener。网络类型参数net必须是面向流的网络：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;tcp&quot;、&quot;tcp4&quot;、&quot;tcp6&quot;、&quot;unix&quot;或&quot;unixpacket&quot;。参见Dial函数获取laddr的语法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line">	<span class="comment">//我们循环接收客户端发来的数据</span></span><br><span class="line">	<span class="keyword">defer</span> conn.Close() <span class="comment">//延迟关闭conn</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环读取</span></span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="comment">//创建一个新的切片</span></span><br><span class="line">		buf:=<span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">1024</span>)</span><br><span class="line">		<span class="comment">//conn.Read(buf)</span></span><br><span class="line">		<span class="comment">//1.等待客户端通过conn发送信息</span></span><br><span class="line">		<span class="comment">//2.如果客户端没有write（发送）信息，那么协程就阻塞在这里了</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;服务器在等待客户端%v的发送信息\n&quot;</span>,conn.RemoteAddr().String())</span><br><span class="line">		n,err:=conn.Read(buf)  <span class="comment">//从conn读取</span></span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端退出&quot;</span>,err)</span><br><span class="line">			<span class="keyword">return</span>  <span class="comment">//重要的</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.显示客户端发送的内容到服务器的终端</span></span><br><span class="line">		fmt.Print(<span class="type">string</span>(buf[:n]))</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;服务器开始监听...&quot;</span>)</span><br><span class="line">	<span class="comment">//net.Listen(&quot;tcp&quot;,&quot;0.0.0.0:8888&quot;)</span></span><br><span class="line">	<span class="comment">//1.tcp表示使用网络协议tcp</span></span><br><span class="line">	<span class="comment">//2.0.0.0.0:8888表示监听本地地址（0.0.0.0）的8888端口号</span></span><br><span class="line">	listen,err:=net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;0.0.0.0:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;监听失败 err:&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;listen 类型=%T,值=%v\n&quot;,listen,listen)</span></span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;listen.Addr 类型=%T,值=%v\n&quot;,listen.Addr(),listen.Addr())</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> listen.Close()  <span class="comment">//延时关闭listen</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环等待客户端来连接我</span></span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="comment">//等待客户端链接</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;等待客户端链接&quot;</span>)</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// handle error</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;Accept err=&quot;</span>,err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Accept() 成功 conn=%v 客户端ip=%v &quot;</span>,conn,conn.RemoteAddr().String())</span><br><span class="line"></span><br><span class="line">		<span class="comment">//启动一个协程来为客户端服务</span></span><br><span class="line">		<span class="keyword">go</span> process(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端代码  tcp_socket/client/main/client.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//客户端发送请求</span></span><br><span class="line">	<span class="comment">//conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8888&quot;)</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;192.168.80.1:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// handle error</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;client dial err:&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;conn 成功&quot;,conn)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//功能1：客户端可以发送单行数据，然后退出</span></span><br><span class="line">	reader:=bufio.NewReader(os.Stdin)  <span class="comment">//os.Stdin 代表标准输入【终端】</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//status, err := bufio.NewReader(conn).ReadString(&#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2：从终端一行一行的读取用户输入，并准备发送给服务器，当输入exit时就退出客户端</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="comment">//2.1.从终端输入一行数据</span></span><br><span class="line">		line,err:=reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;readString err:&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.2.判断输入的字符是不是exit,如果是exit就退出客户端，如果不是就发送给服务器端，而且继续输入</span></span><br><span class="line">		<span class="keyword">if</span> <span class="string">&quot;exit&quot;</span>==strings.TrimRight(line,<span class="string">&quot;\n&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.再将line发送给服务器</span></span><br><span class="line">		n,err:=conn.Write([]<span class="type">byte</span>(line))</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;conn write err:&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;客户端发送了%d个字节&quot;</span>,n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十三章：经典项目：海量用户通讯系统"><a href="#第十三章：经典项目：海量用户通讯系统" class="headerlink" title="第十三章：经典项目：海量用户通讯系统"></a>第十三章：经典项目：海量用户通讯系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需求分析</span></span><br><span class="line">	1.用户注册</span><br><span class="line">	2.用户登录</span><br><span class="line">	3.显示在线用户列表</span><br><span class="line">	4.群聊（广播）</span><br><span class="line">	5.点对点聊天</span><br><span class="line">	6.离线留言</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-golang操作redis"><a href="#1-golang操作redis" class="headerlink" title="1.golang操作redis"></a>1.golang操作redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装第三方开源Redis库</span><br><span class="line">1.使用第三方开源的redis库：github.com/garyburd/redigo/redis</span><br><span class="line">2.在使用Redis前，先安装第三方Redis库，在GOPATH路径下执行安装指令：</span><br><span class="line">	D:\program\goPath&gt;go get github.com/garyburd/redigo/redis</span><br><span class="line">3.安装成功后，可以看到如下包</span><br><span class="line"></span><br><span class="line">特别说明：在安装Redis库前，确保已经安装并配置了Git,因为是从github下载安装Redis库的，需要使用到Git,如果没有安装配置过Git.</span><br></pre></td></tr></table></figure>

<h2 id="第一十四章：并发编程"><a href="#第一十四章：并发编程" class="headerlink" title="第一十四章：并发编程"></a>第一十四章：并发编程</h2><h3 id="1-关于WaitGroup-的用法"><a href="#1-关于WaitGroup-的用法" class="headerlink" title="1.关于WaitGroup()的用法"></a>1.关于WaitGroup()的用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMutex</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, f *fetchState)</span></span> &#123;</span><br><span class="line">	f.mu.Lock()</span><br><span class="line">	already := f.fetched[url]</span><br><span class="line">	f.fetched[url] = <span class="literal">true</span></span><br><span class="line">	f.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> already &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> done sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		done.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">//u2 := u</span></span><br><span class="line">		<span class="comment">//go func() &#123;</span></span><br><span class="line">		<span class="comment">// defer done.Done()</span></span><br><span class="line">		<span class="comment">// ConcurrentMutex(u2, fetcher, f)</span></span><br><span class="line">		<span class="comment">//&#125;()</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> done.Done()</span><br><span class="line">			ConcurrentMutex(u, fetcher, f)</span><br><span class="line">		&#125;(u)</span><br><span class="line">	&#125;</span><br><span class="line">	done.Wait()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关于爬虫程序的三种解法"><a href="#2-关于爬虫程序的三种解法" class="headerlink" title="2.关于爬虫程序的三种解法"></a>2.关于爬虫程序的三种解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Several solutions to the crawler exercise from the Go tutorial</span></span><br><span class="line"><span class="comment">// https://tour.golang.org/concurrency/10</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性的爬虫程序的方式</span></span><br><span class="line"><span class="comment">// Serial crawler</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serial</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, fetched <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fetched[url] &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fetched[url] = <span class="literal">true</span></span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		Serial(u, fetcher, fetched)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用共享状态以及mutex锁的方式</span></span><br><span class="line"><span class="comment">// Concurrent crawler with shared state and Mutex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fetchState <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	fetched <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMutex</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, f *fetchState)</span></span> &#123;</span><br><span class="line">	f.mu.Lock()</span><br><span class="line">	already := f.fetched[url]</span><br><span class="line">	f.fetched[url] = <span class="literal">true</span></span><br><span class="line">	f.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> already &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> done sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		done.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">//u2 := u</span></span><br><span class="line">		<span class="comment">//go func() &#123;</span></span><br><span class="line">		<span class="comment">// defer done.Done()</span></span><br><span class="line">		<span class="comment">// ConcurrentMutex(u2, fetcher, f)</span></span><br><span class="line">		<span class="comment">//&#125;()</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> done.Done()</span><br><span class="line">			ConcurrentMutex(u, fetcher, f)</span><br><span class="line">		&#125;(u)</span><br><span class="line">	&#125;</span><br><span class="line">	done.Wait()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeState</span><span class="params">()</span></span> *fetchState &#123;</span><br><span class="line">	f := &amp;fetchState&#123;&#125;</span><br><span class="line">	f.fetched = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用channel的方式</span></span><br><span class="line"><span class="comment">// Concurrent crawler with channels</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(url <span class="type">string</span>, ch <span class="keyword">chan</span> []<span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ch &lt;- urls</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coordinator</span><span class="params">(ch <span class="keyword">chan</span> []<span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	n := <span class="number">1</span></span><br><span class="line">	fetched := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> urls := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">			<span class="keyword">if</span> fetched[u] == <span class="literal">false</span> &#123;</span><br><span class="line">				fetched[u] = <span class="literal">true</span></span><br><span class="line">				n += <span class="number">1</span></span><br><span class="line">				<span class="keyword">go</span> worker(u, ch, fetcher)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentChannel</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- []<span class="type">string</span>&#123;url&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	coordinator(ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;=== Serial===\n&quot;</span>)</span><br><span class="line">	Serial(<span class="string">&quot;http://golang.org/&quot;</span>, fetcher, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;=== ConcurrentMutex ===\n&quot;</span>)</span><br><span class="line">	ConcurrentMutex(<span class="string">&quot;http://golang.org/&quot;</span>, fetcher, makeState())</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;=== ConcurrentChannel ===\n&quot;</span>)</span><br><span class="line">	ConcurrentChannel(<span class="string">&quot;http://golang.org/&quot;</span>, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Fetcher</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Fetch returns a slice of URLs found on the page.</span></span><br><span class="line">	Fetch(url <span class="type">string</span>) (urls []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher is Fetcher that returns canned results.</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="type">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	body <span class="type">string</span></span><br><span class="line">	urls []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span></span> Fetch(url <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;found:   %s\n&quot;</span>, url)</span><br><span class="line">		<span class="keyword">return</span> res.urls, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;missing: %s\n&quot;</span>, url)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher is a populated fakeFetcher.</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line">	<span class="string">&quot;http://golang.org/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;The Go Programming Language&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/cmd/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;http://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Packages&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;http://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/cmd/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/fmt/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/os/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;http://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Package fmt&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;http://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;http://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Package os&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;http://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;http://golang.org/pkg/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-关于rpc的简单使用"><a href="#3-关于rpc的简单使用" class="headerlink" title="3.关于rpc的简单使用"></a>3.关于rpc的简单使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Common RPC request/reply definitions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	OK       = <span class="string">&quot;OK&quot;</span></span><br><span class="line">	ErrNoKey = <span class="string">&quot;ErrNoKey&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Err <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="type">string</span></span><br><span class="line">	Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Err Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Err   Err</span><br><span class="line">	Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">()</span></span> *rpc.Client &#123;</span><br><span class="line">	<span class="comment">//客户端来进行与服务端进行连接</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;客户端来连服务端了&quot;</span>)</span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;客户端连接成功&quot;</span>,client)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	client := connect()</span><br><span class="line">	args := GetArgs&#123;<span class="string">&quot;subject&quot;</span>&#125;</span><br><span class="line">	reply := GetReply&#123;&#125;</span><br><span class="line">	err := client.Call(<span class="string">&quot;KV.Get&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	client.Close()</span><br><span class="line">	<span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(key <span class="type">string</span>, val <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;已经开始执行put()方法了&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	client := connect()</span><br><span class="line">	args := PutArgs&#123;<span class="string">&quot;subject&quot;</span>, <span class="string">&quot;6.824&quot;</span>&#125;</span><br><span class="line">	reply := PutReply&#123;&#125;</span><br><span class="line">	<span class="comment">//KV是服务端注册的一个对象，使它作为一个服务被暴露</span></span><br><span class="line">	err := client.Call(<span class="string">&quot;KV.Put&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;已经内部转向去调用KV.Put方法了&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	client.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Server</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KV <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   sync.Mutex</span><br><span class="line">	data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	kv := <span class="built_in">new</span>(KV)</span><br><span class="line">	kv.data = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">	rpcs := rpc.NewServer()</span><br><span class="line">	rpcs.Register(kv)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	l, e := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;是否已经开始监听&quot;</span>)</span><br><span class="line">			<span class="comment">//注意这里的Accept()方法是一个阻塞式方法，这是在开启的一个线程中执行，一直在等待客户端的连接，</span></span><br><span class="line">			<span class="comment">//但是如果main线程结束了，此处就也会结束。当有客户端来连接时，此时就会拿到Conn对象，从而停止了阻塞。</span></span><br><span class="line">			<span class="comment">//我们还应该注意到这个监听代码是在一个无限循环for中，所以如果在没有客户端连接错误，跳出break或者main线程结束外。</span></span><br><span class="line">			<span class="comment">//该线程将一直处于等待监听的状态。注意这里必须是用开启的线程的方式来处于等待，如果是用main线程，程序将无法再继续执行下去</span></span><br><span class="line">			conn, err := l.Accept()</span><br><span class="line">			fmt.Println(<span class="string">&quot;l已经监听到&quot;</span>,conn.LocalAddr())</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">go</span> rpcs.ServeConn(conn)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		l.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KV)</span></span> Get(args *GetArgs, reply *GetReply) <span class="type">error</span> &#123;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	val, ok := kv.data[args.Key]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		reply.Err = OK</span><br><span class="line">		reply.Value = val</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reply.Err = ErrNoKey</span><br><span class="line">		reply.Value = <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KV)</span></span> Put(args *PutArgs, reply *PutReply) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;进入了Put()方法了&quot;</span>)</span><br><span class="line"></span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	kv.data[args.Key] = args.Value</span><br><span class="line">	reply.Err = OK</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server()</span><br><span class="line">	<span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line">	put(<span class="string">&quot;subject&quot;</span>, <span class="string">&quot;6.824&quot;</span>)</span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;Put(subject, 6.824) done\n&quot;)</span></span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;get(subject) -&gt; %s\n&quot;, get(&quot;subject&quot;))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://kdhello07.github.io/2022/05/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" data-id="clrv2tqxi00064hku3dg200yt" data-title="Go语言学习" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/">技术工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 13.33px;">Go</a> <a href="/tags/Hexo/" style="font-size: 13.33px;">Hexo</a> <a href="/tags/JVM/" style="font-size: 13.33px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 13.33px;">个人</a> <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 13.33px;">云原生</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 13.33px;">并发</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 13.33px;">快捷键</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13.33px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 16.67px;">数据库</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/27/hello-world/">Hexo使用技巧</a>
          </li>
        
          <li>
            <a href="/2024/01/27/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Mac使用技巧</a>
          </li>
        
          <li>
            <a href="/2022/12/27/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Java语言学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/">Java虚拟机学习</a>
          </li>
        
          <li>
            <a href="/2022/10/27/leetcode%E7%AC%94%E8%AE%B0/">LeetCode刷题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Kevin he<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>